
using System.Numerics;
using System.Reflection;
using AltV.Net.Shared.Utils;
using System.Runtime.InteropServices;

namespace AltV.Net.Client
{
	public unsafe interface INatives
	{
		/// <summary>
		/// Pauses execution of the current script, please note this behavior is only seen when called from one of the game script files(ysc). In order to wait an asi script use "static void WAIT(DWORD time);" found in main.h
		/// </summary>
		void Wait(int ms);
		/// <summary>
		/// Examples:
		/// g_384A = SYSTEM::START_NEW_SCRIPT("cellphone_flashhand", 1424);
		/// l_10D = SYSTEM::START_NEW_SCRIPT("taxiService", 1828);
		/// SYSTEM::START_NEW_SCRIPT("AM_MP_YACHT", 5000);
		/// SYSTEM::START_NEW_SCRIPT("emergencycall", 512);
		/// SYSTEM::START_NEW_SCRIPT("emergencycall", 512);
		/// SYSTEM::START_NEW_SCRIPT("FM_maintain_cloud_header_data", 1424);
		/// SYSTEM::START_NEW_SCRIPT("FM_Mission_Controller", 31000);
		/// SYSTEM::START_NEW_SCRIPT("tennis_family", 3650);
		/// See NativeDB for reference: http://natives.altv.mp/#/0xE81651AD79516E48
		/// </summary>
		/// <returns>        return 1;</returns>
		int StartNewScript(string scriptName, int stackSize);
		/// <summary>
		/// return : script thread id, 0 if failed
		/// Pass pointer to struct of args in p1, size of struct goes into p2
		/// </summary>
		int StartNewScriptWithArgs(string scriptName, ref int args, int argCount, int stackSize);
		int StartNewScriptWithNameHash(int scriptHash, int stackSize);
		/// <summary>
		/// </summary>
		int StartNewScriptWithNameHashAndArgs(int scriptHash, ref int args, int argCount, int stackSize);
		/// <summary>
		/// Counts up. Every 1000 is 1 real-time second. Use SETTIMERA(int value) to set the timer (e.g.: SETTIMERA(0)).
		/// </summary>
		int Timera();
		int Timerb();
		void Settimera(int value);
		void Settimerb(int value);
		/// <summary>
		/// Gets the current frame time.
		/// </summary>
		float Timestep();
		float Sin(float value);
		float Cos(float value);
		float Sqrt(float value);
		float Pow(float @base, float exponent);
		float Log10(float value);
		/// <summary>
		/// Calculates the magnitude of a vector.
		/// </summary>
		float Vmag(float x, float y, float z);
		/// <summary>
		/// Calculates the magnitude of a vector but does not perform Sqrt operations. (Its way faster)
		/// </summary>
		float Vmag2(float x, float y, float z);
		/// <summary>
		/// Calculates distance between vectors.
		/// </summary>
		float Vdist(float x1, float y1, float z1, float x2, float y2, float z2);
		/// <summary>
		/// Calculates distance between vectors but does not perform Sqrt operations. (Its way faster)
		/// </summary>
		float Vdist2(float x1, float y1, float z1, float x2, float y2, float z2);
		int ShiftLeft(int value, int bitShift);
		int ShiftRight(int value, int bitShift);
		int Floor(float value);
		/// <summary>
		/// I'm guessing this rounds a float value up to the next whole number, and FLOOR rounds it down
		/// </summary>
		int Ceil(float value);
		int Round(float value);
		float ToFloat(int value);
		/// <summary>
		/// 0 = high
		/// 1 = normal
		/// 2 = low
		/// </summary>
		void SetThreadPriority(int priority);
		bool AppDataValid();
		int AppGetInt(string property);
		float AppGetFloat(string property);
		string AppGetString(string property);
		void AppSetInt(string property, int value);
		void AppSetFloat(string property, float value);
		void AppSetString(string property, string value);
		/// <summary>
		/// Called in the gamescripts like:
		/// APP::APP_SET_APP("car");
		/// APP::APP_SET_APP("dog");
		/// </summary>
		void AppSetApp(string appName);
		void AppSetBlock(string blockName);
		void AppClearBlock();
		void AppCloseApp();
		void AppCloseBlock();
		bool AppHasLinkedSocialClubAccount();
		bool AppHasSyncedData(string appName);
		void AppSaveData();
		int AppGetDeletedFileStatus();
		bool AppDeleteAppData(string appName);
		/// <summary>
		/// NOTE: Debugging functions are not present in the retail version of the game.
		/// </summary>
		void SetDebugLinesAndSpheresDrawingActive(bool enabled);
		void DrawDebugLine(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9);
		/// <summary>
		/// NOTE: Debugging functions are not present in the retail version of the game.
		/// </summary>
		void DrawDebugLineWithTwoColours(float x1, float y1, float z1, float x2, float y2, float z2, int r1, int g1, int b1, int r2, int g2, int b2, int alpha1, int alpha2);
		/// <summary>
		/// NOTE: Debugging functions are not present in the retail version of the game.
		/// </summary>
		void DrawDebugSphere(float x, float y, float z, float radius, int red, int green, int blue, int alpha);
		void DrawDebugBox(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9);
		/// <summary>
		/// NOTE: Debugging functions are not present in the retail version of the game.
		/// </summary>
		void DrawDebugCross(float x, float y, float z, float size, int red, int green, int blue, int alpha);
		/// <summary>
		/// NOTE: Debugging functions are not present in the retail version of the game.
		/// </summary>
		void DrawDebugText(string text, float x, float y, float z, int red, int green, int blue, int alpha);
		/// <summary>
		/// NOTE: Debugging functions are not present in the retail version of the game.
		/// </summary>
		void DrawDebugText2d(string text, float x, float y, float z, int red, int green, int blue, int alpha);
		/// <summary>
		/// Draws a depth-tested line from one point to another.
		/// ----------------
		/// I recommend using a predefined function to call this.
		/// [VB.NET]
		/// Public Sub DrawLine(from As Vector3, [to] As Vector3, col As Color)
		/// [Function].Call(Hash.DRAW_LINE, from.X, from.Y, from.Z, [to].X, [to].Y, [to].Z, col.R, col.G, col.B, col.A)
		/// End Sub
		/// [C#]
		/// public void DrawLine(Vector3 from, Vector3 to, Color col)
		/// See NativeDB for reference: http://natives.altv.mp/#/0x6B7256074AE34680
		/// </summary>
		/// <param name="x1">Coordinates for the first point</param>
		/// <param name="y1">Coordinates for the first point</param>
		/// <param name="x2">Coordinates for the second point</param>
		/// <param name="y2">Coordinates for the second point</param>
		/// <param name="red">Color with RGBA-Values</param>
		/// <param name="green">Color with RGBA-Values</param>
		/// <param name="blue">Color with RGBA-Values</param>
		void DrawLine(float x1, float y1, float z1, float x2, float y2, float z2, int red, int green, int blue, int alpha);
		/// <summary>
		/// x/y/z - Location of a vertex (in world coords), presumably.
		/// ----------------
		/// Keep in mind that only one side of the drawn triangle is visible: It's the side, in which the vector-product of the vectors heads to: (b-a)x(c-a) Or (b-a)x(c-b).
		/// But be aware: The function seems to work somehow differently. I have trouble having them drawn in rotated orientation. Try it yourself and if you somehow succeed, please edit this and post your solution.
		/// I recommend using a predefined function to call this.
		/// [VB.NET]
		/// Public Sub DrawPoly(a As Vector3, b As Vector3, c As Vector3, col As Color)
		/// [Function].Call(Hash.DRAW_POLY, a.X, a.Y, a.Z, b.X, b.Y, b.Z, c.X, c.Y, c.Z, col.R, col.G, col.B, col.A)
		/// End Sub
		/// See NativeDB for reference: http://natives.altv.mp/#/0xAC26716048436851
		/// </summary>
		/// <param name="x1">Coordinates for the first point</param>
		/// <param name="y1">Coordinates for the first point</param>
		/// <param name="x2">Coordinates for the second point</param>
		/// <param name="y2">Coordinates for the second point</param>
		/// <param name="x3">Coordinates for the third point</param>
		/// <param name="y3">Coordinates for the third point</param>
		/// <param name="red">Color with RGBA-Values</param>
		/// <param name="green">Color with RGBA-Values</param>
		/// <param name="blue">Color with RGBA-Values</param>
		void DrawPoly(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, int red, int green, int blue, int alpha);
		/// <summary>
		/// Used for drawling Deadline trailing lights, see deadline.ytd
		/// For UVW mapping (u,v,w parameters), reference your favourite internet resource for more details.
		/// </summary>
		/// <param name="u1">through p23 are values that appear to be related to illiumation, scaling, and rotation; more testing required.</param>
		void DrawSpritePoly(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, int red, int green, int blue, int alpha, string textureDict, string textureName, float u1, float v1, float w1, float u2, float v2, float w2, float u3, float v3, float w3);
		/// <summary>
		/// Used for drawling Deadline trailing lights, see deadline.ytd
		/// For UVW mapping (u,v,w parameters), reference your favourite internet resource for more details.
		/// </summary>
		/// <param name="y1">casted internally.</param>
		void DrawSpritePoly2(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float red1, float green1, float blue1, int alpha1, float red2, float green2, float blue2, int alpha2, float red3, float green3, float blue3, int alpha3, string textureDict, string textureName, float u1, float v1, float w1, float u2, float v2, float w2, float u3, float v3, float w3);
		/// <summary>
		/// Draw's a 3D Box between the two x,y,z coords.
		/// --------------
		/// Keep in mind that the edges of the box do only align to the worlds base-vectors. Therefore something like rotation cannot be applied. That means this function is pretty much useless, unless you want a static unicolor box somewhere.
		/// I recommend using a predefined function to call this.
		/// [VB.NET]
		/// Public Sub DrawBox(a As Vector3, b As Vector3, col As Color)
		/// [Function].Call(Hash.DRAW_BOX,a.X, a.Y, a.Z,b.X, b.Y, b.Z,col.R, col.G, col.B, col.A)
		/// End Sub
		/// [C#]
		/// See NativeDB for reference: http://natives.altv.mp/#/0xD3A9971CADAC7252
		/// </summary>
		/// <param name="y1">start pos</param>
		/// <param name="x2">end pos</param>
		/// <param name="y2">end pos</param>
		void DrawBox(float x1, float y1, float z1, float x2, float y2, float z2, int red, int green, int blue, int alpha);
		void SetBackfaceculling(bool toggle);
		void _0xC5C8F970D4EDFF71(int p0);
		int BeginTakeMissionCreatorPhoto();
		int GetStatusOfTakeMissionCreatorPhoto();
		void FreeMemoryForMissionCreatorPhoto();
		/// <summary>
		/// </summary>
		bool LoadMissionCreatorPhoto(ref int p0, int p1, int p2, int p3);
		/// <summary>
		/// </summary>
		int GetStatusOfLoadMissionCreatorPhoto(ref int p0);
		int _0x7FA5D82B8F58EC06();
		int _0x5B0316762AFD4A64();
		void _0x346EF3ECAAAB149E();
		bool BeginTakeHighQualityPhoto();
		int GetStatusOfTakeHighQualityPhoto();
		void FreeMemoryForHighQualityPhoto();
		void _0x1BBC135A4D25EDDE(bool p0);
		void _0xF3F776ADA161E47D(int p0, int p1);
		/// <summary>
		/// 1 match in 1 script. cellphone_controller.
		/// </summary>
		/// <param name="unused">is -1 in scripts.</param>
		bool SaveHighQualityPhoto(int unused);
		int GetStatusOfSaveHighQualityPhoto();
		bool _0x759650634F07B6B4(int p0);
		int _0xCB82A0BF0E3E3265(int p0);
		void FreeMemoryForLowQualityPhoto();
		void DrawLowQualityPhotoToPhone(bool p0, bool p1);
		int GetMaximumNumberOfPhotos();
		int GetMaximumNumberOfCloudPhotos();
		int GetCurrentNumberOfCloudPhotos();
		/// <summary>
		/// 2 matches across 2 scripts. Only showed in appcamera & appmedia. Both were 0.
		/// </summary>
		int _0x2A893980E96B659A(int p0);
		/// <summary>
		/// 3 matches across 3 scripts. First 2 were 0, 3rd was 1. Possibly a bool.
		/// appcamera, appmedia, and cellphone_controller.
		/// </summary>
		int GetStatusOfSortedListOperation(int p0);
		void _0x4AF92ACD3141D96C();
		/// <summary>
		/// </summary>
		/// <returns>This function is hard-coded to always return 0.</returns>
		int _0xE791DF1F73ED2C8B(int p0);
		/// <summary>
		/// </summary>
		/// <returns>This function is hard-coded to always return 0.</returns>
		int _0xEC72C258667BE5EA(int p0);
		/// <summary>
		/// GET_L*
		/// </summary>
		/// <returns>Hardcoded to always return 2.</returns>
		int ReturnTwo(int p0);
		void DrawLightWithRangeAndShadow(float x, float y, float z, int r, int g, int b, float range, float intensity, float shadow);
		void DrawLightWithRange(float posX, float posY, float posZ, int colorR, int colorG, int colorB, float range, float intensity);
		/// <summary>
		/// Parameters:
		/// roundness - "smoothness" of the circle edge
		/// Example in C# (spotlight aims at the closest vehicle):
		/// Vector3 myPos = Game.Player.Character.Position;
		/// Vehicle nearest = World.GetClosestVehicle(myPos , 1000f);
		/// Vector3 destinationCoords = nearest.Position;
		/// Vector3 dirVector = destinationCoords - myPos;
		/// dirVector.Normalize();
		/// Function.Call(Hash.DRAW_SPOT_LIGHT, pos.X, pos.Y, pos.Z, dirVector.X, dirVector.Y, dirVector.Z, 255, 255, 255, 100.0f, 1f, 0.0f, 13.0f, 1f);
		/// </summary>
		/// <param name="posX">- coordinate where the spotlight is located</param>
		/// <param name="posY">- coordinate where the spotlight is located</param>
		/// <param name="posZ">- coordinate where the spotlight is located</param>
		/// <param name="dirX">- the direction vector the spotlight should aim at from its current position</param>
		/// <param name="dirY">- the direction vector the spotlight should aim at from its current position</param>
		/// <param name="dirZ">- the direction vector the spotlight should aim at from its current position</param>
		/// <param name="colorR">color of the spotlight</param>
		/// <param name="colorG">color of the spotlight</param>
		/// <param name="distance">- the maximum distance the light can reach</param>
		/// <param name="brightness">- the brightness of the light</param>
		/// <param name="radius">- the radius size of the spotlight</param>
		/// <param name="falloff">- the falloff size of the light's edge (example: www.i.imgur.com/DemAWeO.jpg)</param>
		void DrawSpotLight(float posX, float posY, float posZ, float dirX, float dirY, float dirZ, int colorR, int colorG, int colorB, float distance, float brightness, float hardness, float radius, float falloff);
		void DrawSpotLightWithShadow(float posX, float posY, float posZ, float dirX, float dirY, float dirZ, int colorR, int colorG, int colorB, float distance, float brightness, float roundness, float radius, float falloff, int shadowId);
		void FadeUpPedLight(float p0);
		void UpdateLightsOnEntity(int entity);
		void _0x9641588DAB93B4B5(int p0);
		int _0x393BD2275CEB7793();
		/// <summary>
		/// enum MarkerTypes
		/// {
		/// MarkerTypeUpsideDownCone = 0,
		/// MarkerTypeVerticalCylinder = 1,
		/// MarkerTypeThickChevronUp = 2,
		/// MarkerTypeThinChevronUp = 3,
		/// MarkerTypeCheckeredFlagRect = 4,
		/// MarkerTypeCheckeredFlagCircle = 5,
		/// MarkerTypeVerticleCircle = 6,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x28477EC23D892089
		/// </summary>
		/// <param name="faceCamera">- Rotates only the y-axis (the heading) towards the camera</param>
		/// <param name="p19">- no effect, default value in script is 2</param>
		/// <param name="rotate">- Rotates only on the y-axis (the heading)</param>
		/// <param name="textureDict">- Name of texture dictionary to load texture from (e.g. "GolfPutting")</param>
		/// <param name="textureName">- Name of texture inside dictionary to load (e.g. "PuttingMarker")</param>
		/// <param name="drawOnEnts">- Draws the marker onto any entities that intersect it</param>
		void DrawMarker(int type, float posX, float posY, float posZ, float dirX, float dirY, float dirZ, float rotX, float rotY, float rotZ, float scaleX, float scaleY, float scaleZ, int red, int green, int blue, int alpha, bool bobUpAndDown, bool faceCamera, int p19, bool rotate, string textureDict, string textureName, bool drawOnEnts);
		void DrawMarker2(int type, float posX, float posY, float posZ, float dirX, float dirY, float dirZ, float rotX, float rotY, float rotZ, float scaleX, float scaleY, float scaleZ, int red, int green, int blue, int alpha, bool bobUpAndDown, bool faceCamera, int p19, bool rotate, string textureDict, string textureName, bool drawOnEnts, bool p24, bool p25);
		/// <summary>
		/// Draws a 3D sphere, typically seen in the GTA:O freemode event "Penned In".
		/// Example https://imgur.com/nCbtS4H
		/// </summary>
		void DrawSphere(float x, float y, float z, float radius, int red, int green, int blue, float alpha);
		/// <summary>
		/// 20/03/17 : Attention, checkpoints are already handled by the game itself, so you must not loop it like markers.
		/// Parameters:
		/// pos2 - The position of the next checkpoint to point to.
		/// radius - The radius of the checkpoint.
		/// Checkpoint types:
		/// 0-4---------Cylinder: 1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker
		/// 5-9---------Cylinder: 1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker
		/// 10-14-------Ring: 1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker
		/// 15-19-------1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker
		/// See NativeDB for reference: http://natives.altv.mp/#/0x0134F0835AB6BFCB
		/// </summary>
		/// <param name="type">- The type of checkpoint to create. See below for a list of checkpoint types.</param>
		/// <param name="posX1">- The position of the checkpoint.</param>
		/// <param name="red">Special parameter, see below for details. Usually set to 0 in the scripts.</param>
		/// <param name="green">- The color of the checkpoint.</param>
		/// <param name="blue">- The color of the checkpoint.</param>
		/// <param name="reserved">- Special parameter, see below for details. Usually set to 0 in the scripts.</param>
		/// <returns>Creates a checkpoint. Returns the handle of the checkpoint.</returns>
		int CreateCheckpoint(int type, float posX1, float posY1, float posZ1, float posX2, float posY2, float posZ2, float diameter, int red, int green, int blue, int alpha, int reserved);
		/// <summary>
		/// offroad_races.c4, line ~67407:
		/// a_3._f7 = GRAPHICS::CREATE_CHECKPOINT(v_D, v_A, a_4, a_7, v_E, v_F, v_10, sub_62b2(v_A, 220, 255), 0);
		/// HUD::GET_HUD_COLOUR(134, &v_E, &v_F, &v_10, &v_11);
		/// GRAPHICS::_SET_CHECKPOINT_ICON_RGBA(a_3._f7, v_E, v_F, v_10, sub_62b2(v_A, 70, 210));
		/// GRAPHICS::_4B5B4DA5D79F1943(a_3._f7, 0.95);
		/// GRAPHICS::SET_CHECKPOINT_CYLINDER_HEIGHT(a_3._f7, 4.0, 4.0, 100.0);
		/// </summary>
		/// <param name="checkpoint">- Scale? Looks to be a normalized value (0.0 - 1.0)</param>
		/// <param name="p0">- Scale? Looks to be a normalized value (0.0 - 1.0)</param>
		void SetCheckpointScale(int checkpoint, float p0);
		void SetCheckpointIconScale(int checkpoint, float scale);
		/// <summary>
		/// Sets the cylinder height of the checkpoint.
		/// Parameters:
		/// </summary>
		/// <param name="nearHeight">- The height of the checkpoint when inside of the radius.</param>
		/// <param name="farHeight">- The height of the checkpoint when outside of the radius.</param>
		/// <param name="radius">- The radius of the checkpoint.</param>
		void SetCheckpointCylinderHeight(int checkpoint, float nearHeight, float farHeight, float radius);
		/// <summary>
		/// Sets the checkpoint color.
		/// </summary>
		void SetCheckpointRgba(int checkpoint, int red, int green, int blue, int alpha);
		/// <summary>
		/// Sets the checkpoint icon color.
		/// </summary>
		void SetCheckpointRgba2(int checkpoint, int red, int green, int blue, int alpha);
		/// <summary>
		/// This does not move an existing checkpoint... so wtf.
		/// </summary>
		void _0xF51D36185993515D(int checkpoint, float posX, float posY, float posZ, float unkX, float unkY, float unkZ);
		/// <summary>
		/// SET_CHECKPOINT_*
		/// </summary>
		void _0xFCF6788FC4860CD4(int checkpoint);
		/// <summary>
		/// Unknown. Called after creating a checkpoint (type: 51) in the creators.
		/// </summary>
		void _0x615D3925E87A3B26(int checkpoint);
		void _0xDB1EA9411C8911EC(int p0);
		void _0x3C788E7F6438754D(int p0, int p1, int p2, int p3);
		void DeleteCheckpoint(int checkpoint);
		void DontRenderInGameUi(bool p0);
		void ForceRenderInGameUi(bool toggle);
		/// <summary>
		/// This function can requests texture dictonaries from following RPFs:
		/// scaleform_generic.rpf
		/// scaleform_minigames.rpf
		/// scaleform_minimap.rpf
		/// scaleform_web.rpf
		/// last param isnt a toggle
		/// </summary>
		void RequestStreamedTextureDict(string textureDict, bool p1);
		bool HasStreamedTextureDictLoaded(string textureDict);
		void SetStreamedTextureDictAsNoLongerNeeded(string textureDict);
		/// <summary>
		/// Draws a rectangle on the screen.
		/// The total number of rectangles to be drawn in one frame is apparently limited to 399.
		/// </summary>
		/// <param name="x">The relative X point of the center of the rectangle. (0.0-1.0, 0.0 is the left edge of the screen, 1.0 is the right edge of the screen)</param>
		/// <param name="y">The relative Y point of the center of the rectangle. (0.0-1.0, 0.0 is the top edge of the screen, 1.0 is the bottom edge of the screen)</param>
		/// <param name="width">The relative width of the rectangle. (0.0-1.0, 1.0 means the whole screen width)</param>
		/// <param name="height">The relative height of the rectangle. (0.0-1.0, 1.0 means the whole screen height)</param>
		/// <param name="r">Red part of the color. (0-255)</param>
		/// <param name="g">Green part of the color. (0-255)</param>
		/// <param name="b">Blue part of the color. (0-255)</param>
		/// <param name="a">Alpha part of the color. (0-255, 0 means totally transparent, 255 means totally opaque)</param>
		void DrawRect(float x, float y, float width, float height, int r, int g, int b, int a, bool p8);
		/// <summary>
		/// Sets a flag defining whether or not script draw commands should continue being drawn behind the pause menu. This is usually used for TV channels and other draw commands that are used with a world render target.
		/// </summary>
		void SetScriptGfxDrawBehindPausemenu(bool toggle);
		/// <summary>
		/// Sets the draw order for script draw commands.
		/// Examples from decompiled scripts:
		/// GRAPHICS::SET_SCRIPT_GFX_DRAW_ORDER(7);
		/// GRAPHICS::DRAW_RECT(0.5, 0.5, 3.0, 3.0, v_4, v_5, v_6, a_0._f172, 0);
		/// GRAPHICS::SET_SCRIPT_GFX_DRAW_ORDER(1);
		/// GRAPHICS::DRAW_RECT(0.5, 0.5, 1.5, 1.5, 0, 0, 0, 255, 0);
		/// </summary>
		void SetScriptGfxDrawOrder(int drawOrder);
		/// <summary>
		/// This function anchors script draws to a side of the safe zone. This needs to be called to make the interface independent of the player's safe zone configuration.
		/// These values are equivalent to alignX and alignY in common:/data/ui/frontend.xml, which can be used as a baseline for default alignment.
		/// Using any other value (including 0) will result in the safe zone not being taken into account for this draw. The canonical value for this is 'I' (73).
		/// For example, you can use SET_SCRIPT_GFX_ALIGN(0, 84) to only scale on the Y axis (to the top), but not change the X axis.
		/// To reset the value, use RESET_SCRIPT_GFX_ALIGN.
		/// </summary>
		/// <param name="horizontalAlign">The horizontal alignment. This can be 67 ('C'), 76 ('L'), or 82 ('R').</param>
		/// <param name="verticalAlign">The vertical alignment. This can be 67 ('C'), 66 ('B'), or 84 ('T').</param>
		void SetScriptGfxAlign(int horizontalAlign, int verticalAlign);
		/// <summary>
		/// This function resets the alignment set using SET_SCRIPT_GFX_ALIGN and SET_SCRIPT_GFX_ALIGN_PARAMS to the default values ('I', 'I'; 0, 0, 0, 0).
		/// This should be used after having used the aforementioned functions in order to not affect any other scripts attempting to draw.
		/// </summary>
		void ResetScriptGfxAlign();
		/// <summary>
		/// Sets the draw offset/calculated size for SET_SCRIPT_GFX_ALIGN. If using any alignment other than left/top, the game expects the width/height to be configured using this native in order to get a proper starting position for the draw command.
		/// </summary>
		void SetScriptGfxAlignParams(float x, float y, float w, float h);
		/// <summary>
		/// Calculates the effective X/Y fractions when applying the values set by SET_SCRIPT_GFX_ALIGN and SET_SCRIPT_GFX_ALIGN_PARAMS
		/// </summary>
		void GetScriptGfxPosition(float x, float y, ref float calculatedX, ref float calculatedY);
		float GetSafeZoneSize();
		/// <summary>
		/// Draws a 2D sprite on the screen.
		/// Parameters:
		/// scaleX/Y - Texture scaling. Negative values can be used to flip the texture on that axis. (0.5 = half)
		/// </summary>
		/// <param name="textureDict">- Name of texture dictionary to load texture from (e.g. "CommonMenu", "MPWeaponsCommon", etc.)</param>
		/// <param name="textureName">- Name of texture to load from texture dictionary (e.g. "last_team_standing_icon", "tennis_icon", etc.)</param>
		/// <param name="screenX">Screen offset (0.5 = center)</param>
		/// <param name="heading">- Texture rotation in degrees (default = 0.0) positive is clockwise, measured in degrees</param>
		/// <param name="red">Sprite color (default = 255/255/255)</param>
		/// <param name="green">Sprite color (default = 255/255/255)</param>
		/// <param name="alpha">- opacity level</param>
		void DrawSprite(string textureDict, string textureName, float screenX, float screenY, float width, float height, float heading, int red, int green, int blue, int alpha, bool p11);
		/// <summary>
		/// Used in arcade games and Beam hack minigame in Doomsday Heist. I will most certainly dive into this to try replicate arcade games.
		/// </summary>
		/// <param name="x">position must be between 0.0 and 1.0 (1.0 being the most right side of the screen)</param>
		/// <param name="y">position must be between 0.0 and 1.0 (1.0 being the most bottom side of the screen)</param>
		/// <param name="width">0.0 - 1.0 is the reasonable amount generally</param>
		/// <param name="height">0.0 - 1.0 is the reasonable amount generally</param>
		/// <param name="p6">almost always 0.0</param>
		/// <param name="p11">seems to be unknown but almost always 0 int</param>
		void _0x2D3B147AFAD49DE0(string textureDict, string textureName, float x, float y, float width, float height, float p6, int red, int green, int blue, int alpha, int p11);
		/// <summary>
		/// Similar to _DRAW_SPRITE, but seems to be some kind of "interactive" sprite, at least used by render targets.
		/// These seem to be the only dicts ever requested by this native:
		/// prop_screen_biker_laptop
		/// Prop_Screen_GR_Disruption
		/// Prop_Screen_TaleOfUs
		/// prop_screen_nightclub
		/// Prop_Screen_IE_Adhawk
		/// prop_screen_sm_free_trade_shipping
		/// prop_screen_hacker_truck
		/// See NativeDB for reference: http://natives.altv.mp/#/0x2BC54A8188768488
		/// </summary>
		void DrawInteractiveSprite(string textureDict, string textureName, float screenX, float screenY, float width, float height, float heading, int red, int green, int blue, int alpha);
		/// <summary>
		/// Similar to DRAW_SPRITE, but allows to specify the texture coordinates used to draw the sprite.
		/// </summary>
		/// <param name="u1">texture coordinates for the top</param>
		/// <param name="u2">texture coordinates for the bottom</param>
		void DrawSpriteUv(string textureDict, string textureName, float x, float y, float width, float height, float u1, float v1, float u2, float v2, float heading, int red, int green, int blue, int alpha);
		/// <summary>
		/// Example:
		/// GRAPHICS::ADD_ENTITY_ICON(a_0, "MP_Arrow");
		/// I tried this and nothing happened...
		/// </summary>
		int AddEntityIcon(int entity, string icon);
		void SetEntityIconVisibility(int entity, bool toggle);
		void SetEntityIconColor(int entity, int red, int green, int blue, int alpha);
		/// <summary>
		/// Sets the on-screen drawing origin for draw-functions (which is normally x=0,y=0 in the upper left corner of the screen) to a world coordinate.
		/// From now on, the screen coordinate which displays the given world coordinate on the screen is seen as x=0,y=0.
		/// Example in C#:
		/// Vector3 boneCoord = somePed.GetBoneCoord(Bone.SKEL_Head);
		/// Function.Call(Hash.SET_DRAW_ORIGIN, boneCoord.X, boneCoord.Y, boneCoord.Z, 0);
		/// Function.Call(Hash.DRAW_SPRITE, "helicopterhud", "hud_corner", -0.01, -0.015, 0.013, 0.013, 0.0, 255, 0, 0, 200);
		/// Function.Call(Hash.DRAW_SPRITE, "helicopterhud", "hud_corner", 0.01, -0.015, 0.013, 0.013, 90.0, 255, 0, 0, 200);
		/// Function.Call(Hash.DRAW_SPRITE, "helicopterhud", "hud_corner", -0.01, 0.015, 0.013, 0.013, 270.0, 255, 0, 0, 200);
		/// Function.Call(Hash.DRAW_SPRITE, "helicopterhud", "hud_corner", 0.01, 0.015, 0.013, 0.013, 180.0, 255, 0, 0, 200);
		/// See NativeDB for reference: http://natives.altv.mp/#/0xAA0008F3BBB8F416
		/// </summary>
		void SetDrawOrigin(float x, float y, float z, int p3);
		/// <summary>
		/// Resets the screen's draw-origin which was changed by the function GRAPHICS::SET_DRAW_ORIGIN(...) back to x=0,y=0.
		/// See GRAPHICS::SET_DRAW_ORIGIN(...) for further information.
		/// </summary>
		void ClearDrawOrigin();
		int SetBinkMovie(string name);
		void PlayBinkMovie(int binkMovie);
		void StopBinkMovie(int binkMovie);
		void ReleaseBinkMovie(int binkMovie);
		void DrawBinkMovie(int binkMovie, float p1, float p2, float p3, float p4, float p5, int r, int g, int b, int a);
		/// <summary>
		/// In percentage: 0.0 - 100.0
		/// </summary>
		void SetBinkMovieTime(int binkMovie, float progress);
		/// <summary>
		/// In percentage: 0.0 - 100.0
		/// </summary>
		float GetBinkMovieTime(int binkMovie);
		/// <summary>
		/// </summary>
		/// <param name="binkMovie">Is return value from _SET_BINK_MOVIE. Has something to do with bink volume? (audRequestedSettings::SetVolumeCurveScale)</param>
		/// <returns>binkMovie: Is return value from _SET_BINK_MOVIE. Has something to do with bink volume? (audRequestedSettings::SetVolumeCurveScale)</returns>
		void SetBinkMovieVolume(int binkMovie, float value);
		/// <summary>
		/// Might be more appropriate in AUDIO?
		/// </summary>
		void AttachTvAudioToEntity(int entity);
		void SetBinkMovieUnk2(int binkMovie, bool p1);
		/// <summary>
		/// Probably changes tvs from being a 3d audio to being "global" audio
		/// </summary>
		void SetTvAudioFrontend(bool toggle);
		void SetBinkShouldSkip(int binkMovie, bool bShouldSkip);
		int LoadMovieMeshSet(string movieMeshSetName);
		void ReleaseMovieMeshSet(int movieMeshSet);
		int QueryMovieMeshSetState(int p0);
		/// <summary>
		/// int screenresx,screenresy;
		/// GET_SCREEN_RESOLUTION(&screenresx,&screenresy);
		/// </summary>
		void GetScreenResolution(ref int x, ref int y);
		/// <summary>
		/// Returns current screen resolution.
		/// </summary>
		void GetActiveScreenResolution(ref int x, ref int y);
		float GetAspectRatio(bool b);
		int _0xB2EBE8CBC58B90E9();
		/// <summary>
		/// Setting Aspect Ratio Manually in game will return:
		/// false - for Narrow format Aspect Ratios (3:2, 4:3, 5:4, etc. )
		/// true - for Wide format Aspect Ratios (5:3, 16:9, 16:10, etc. )
		/// </summary>
		/// <returns>Setting Aspect Ratio to "Auto" in game will return "false" or "true" based on the actual set Resolution Ratio.</returns>
		bool GetIsWidescreen();
		/// <summary>
		/// false = Any resolution < 1280x720
		/// true = Any resolution >= 1280x720
		/// </summary>
		bool GetIsHidef();
		/// <summary>
		/// AD*
		/// </summary>
		void _0xEFABC7722293DA7C();
		/// <summary>
		/// Enables Night Vision.
		/// Example:
		/// C#: Function.Call(Hash.SET_NIGHTVISION, true);
		/// C++: GRAPHICS::SET_NIGHTVISION(true);
		/// BOOL toggle:
		/// true = turns night vision on for your player.
		/// false = turns night vision off for your player.
		/// </summary>
		void SetNightvision(bool toggle);
		bool GetRequestingnightvision();
		bool GetUsingnightvision();
		void _0xEF398BEEE4EF45F9(bool p0);
		void _0x814AF7DCAACC597B(int p0);
		void _0x43FA7CBE20DAB219(int p0);
		void SetNoiseoveride(bool toggle);
		void SetNoisinessoveride(float value);
		/// <summary>
		/// Convert a world coordinate into its relative screen coordinate.  (WorldToScreen)
		/// For .NET users...
		/// VB:
		/// Public Shared Function World3DToScreen2d(pos as vector3) As Vector2
		/// Dim x2dp, y2dp As New Native.OutputArgument
		/// Native.Function.Call(Of Boolean)(Native.Hash.GET_SCREEN_COORD_FROM_WORLD_COORD , pos.x, pos.y, pos.z, x2dp, y2dp)
		/// Return New Vector2(x2dp.GetResult(Of Single), y2dp.GetResult(Of Single))
		/// End Function
		/// C#:
		/// See NativeDB for reference: http://natives.altv.mp/#/0x34E82F05DF2974F5
		/// </summary>
		/// <returns>Returns a boolean; whether or not the operation was successful. It will return false if the coordinates given are not visible to the rendering camera.</returns>
		bool GetScreenCoordFromWorldCoord(float worldX, float worldY, float worldZ, ref float screenX, ref float screenY);
		/// <summary>
		/// Returns the texture resolution of the passed texture dict+name.
		/// Note: Most texture resolutions are doubled compared to the console version of the game.
		/// </summary>
		Vector3 GetTextureResolution(string textureDict, string textureName);
		/// <summary>
		/// Overriding ped badge texture to a passed texture. It's synced between players (even custom textures!), don't forget to request used dict on *all* clients to make it sync properly. Can be removed by passing empty strings.
		/// </summary>
		bool OverridePedBadgeTexture(int ped, string txd, string txn);
		void _0xE2892E7E55D7073A(float p0);
		/// <summary>
		/// Purpose of p0 and p1 unknown.
		/// </summary>
		void SetFlash(float p0, float p1, float fadeIn, float duration, float fadeOut);
		void DisableOcclusionThisFrame();
		/// <summary>
		/// Does not affect weapons, particles, fire/explosions, flashlights or the sun.
		/// When set to true, all emissive textures (including ped components that have light effects), street lights, building lights, vehicle lights, etc will all be turned off.
		/// Used in Humane Labs Heist for EMP.
		/// </summary>
		/// <param name="state">True turns off all artificial light sources in the map: buildings, street lights, car lights, etc. False turns them back on.</param>
		void SetArtificialLightsState(bool state);
		/// <summary>
		/// If "blackout" is enabled, this native allows you to ignore "blackout" for vehicles.
		/// </summary>
		void SetArtificialLightsStateAffectsVehicles(bool toggle);
		void _0xC35A6D07C93802B2();
		/// <summary>
		/// Creates a tracked point, useful for checking the visibility of a 3D point on screen.
		/// </summary>
		int CreateTrackedPoint();
		void SetTrackedPointInfo(int point, float x, float y, float z, float radius);
		bool IsTrackedPointVisible(int point);
		void DestroyTrackedPoint(int point);
		/// <summary>
		/// </summary>
		/// <returns>This function is hard-coded to always return 0.</returns>
		int _0xBE197EAA669238F4(int p0, int p1, int p2, int p3);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void _0x61F95E5BB3E0A8C6(int p0);
		void _0xAE51BC858F32BA66(int p0, float p1, float p2, float p3, float p4);
		void _0x649C97D52332341A(int p0);
		int _0x2C42340F916C5930(int p0);
		void _0x14FC5833464340A8();
		void _0x0218BA067D249DEA();
		void _0x1612C45F9E3E0D44();
		void _0x5DEBD9C4DC995692();
		void _0xAAE9BE70EC7C69AB(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7);
		/// <summary>
		/// Wraps 0xAAE9BE70EC7C69AB with FLT_MAX as p7, Jenkins: 0x73E96210?
		/// </summary>
		void GrassLodShrinkScriptAreas(float x, float y, float z, float radius, float p4, float p5, float p6);
		void GrassLodResetScriptAreas();
		void CascadeShadowsInitSession();
		void CascadeShadowsSetCascadeBounds(int p0, bool p1, float p2, float p3, float p4, float p5, bool p6, float p7);
		void CascadeShadowsSetCascadeBoundsScale(float p0);
		void CascadeShadowsSetEntityTrackerScale(float p0);
		void _0x36F6626459D91457(float p0);
		void _0x259BA6D4E6F808F1(int p0);
		/// <summary>
		/// When this is set to ON, shadows only draw as you get nearer.
		/// When OFF, they draw from a further distance.
		/// </summary>
		void CascadeShadowsEnableEntityTracker(bool toggle);
		void _0x25FC3E33A31AD0C9(bool p0);
		/// <summary>
		/// Possible values:
		/// "CSM_ST_POINT"
		/// "CSM_ST_LINEAR"
		/// "CSM_ST_TWOTAP"
		/// "CSM_ST_BOX3x3"
		/// "CSM_ST_BOX4x4"
		/// "CSM_ST_DITHER2_LINEAR"
		/// "CSM_ST_CUBIC"
		/// "CSM_ST_DITHER4"
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB11D94BC55F41932
		/// </summary>
		void CascadeShadowsSetShadowSampleType(string type);
		void CascadeShadowsClearShadowSampleType();
		void CascadeShadowsSetAircraftMode(bool p0);
		void CascadeShadowsSetDynamicDepthMode(bool p0);
		void CascadeShadowsSetDynamicDepthValue(float p0);
		void _0x0AE73D8DF3A762B2(bool p0);
		void _0xCA465D9CC0D231BA(int p0);
		void GolfTrailSetEnabled(bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="p8">seems to always be false.</param>
		void GolfTrailSetPath(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, bool p8);
		void GolfTrailSetRadius(float p0, float p1, float p2);
		void GolfTrailSetColour(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11);
		void GolfTrailSetTessellation(int p0, int p1);
		/// <summary>
		/// GOLF_TRAIL_SET_*
		/// </summary>
		void _0xC0416B061F2B7E5E(bool p0);
		/// <summary>
		/// 12 matches across 4 scripts. All 4 scripts were job creators.
		/// Tested but noticed nothing.
		/// </summary>
		/// <param name="type">ranged from 0 - 2.</param>
		/// <param name="p4">was always 0.2f. Likely scale.</param>
		/// <param name="alpha">p8 is RGBA, the graphic is always yellow (255, 255, 0, 255).</param>
		void GolfTrailSetFixedControlPoint(int type, float xPos, float yPos, float zPos, float p4, int red, int green, int blue, int alpha);
		/// <summary>
		/// Only appeared in Golf & Golf_mp. Parameters were all ptrs
		/// </summary>
		void GolfTrailSetShaderParams(float p0, float p1, float p2, float p3, float p4);
		void GolfTrailSetFacing(bool p0);
		float GolfTrailGetMaxHeight();
		Vector3 GolfTrailGetVisualControlPoint(int p0);
		/// <summary>
		/// Toggles Heatvision on/off.
		/// </summary>
		void SetSeethrough(bool toggle);
		bool GetUsingseethrough();
		void SeethroughReset();
		void SeethroughSetFadeStartDistance(float distance);
		void SeethroughSetFadeEndDistance(float distance);
		float SeethroughGetMaxThickness();
		/// <summary>
		/// 0.0 = you will not be able to see people behind the walls. 50.0 and more = you will see everyone through the walls. More value is "better" view. See https://gfycat.com/FirmFlippantGourami
		/// min: 1.0
		/// max: 10000.0
		/// </summary>
		void SeethroughSetMaxThickness(float thickness);
		void SeethroughSetNoiseAmountMin(float amount);
		void SeethroughSetNoiseAmountMax(float amount);
		void SeethroughSetHiLightIntensity(float intensity);
		void SeethroughSetHiLightNoise(float noise);
		/// <summary>
		/// min: 0.0
		/// max: 0.75
		/// </summary>
		void SeethroughSetHeatscale(int index, float heatScale);
		void SeethroughSetColorNear(int red, int green, int blue);
		/// <summary>
		/// Setter for 0xE59343E9E96529E7
		/// SET_M*
		/// </summary>
		void _0xB3C641F3630BF6DA(float p0);
		/// <summary>
		/// Getter for 0xB3C641F3630BF6DA
		/// GET_M*
		/// </summary>
		float _0xE59343E9E96529E7();
		/// <summary>
		/// SET_F*
		/// </summary>
		void _0x6A51F78772175A51(bool toggle);
		void TogglePlayerDamageOverlay(bool toggle);
		/// <summary>
		/// Sets an unknown value related to timecycles.
		/// </summary>
		void _0xE3E2C1B4C59DBC77(int unk);
		/// <summary>
		/// time in ms to transition to fully blurred screen
		/// </summary>
		bool TriggerScreenblurFadeIn(float transitionTime);
		/// <summary>
		/// time in ms to transition from fully blurred to normal
		/// </summary>
		bool TriggerScreenblurFadeOut(float transitionTime);
		void DisableScreenblurFade();
		float GetScreenblurFadeCurrentTime();
		/// <summary>
		/// Returns whether screen transition to blur/from blur is running.
		/// </summary>
		bool IsScreenblurFadeRunning();
		void TogglePausedRenderphases(bool toggle);
		bool GetTogglePausedRenderphasesStatus();
		void ResetPausedRenderphases();
		void _0x851CD923176EBA7C();
		/// <summary>
		/// Every p2 - p5 occurrence was 0f.
		/// </summary>
		void SetHidofEnvBlurParams(bool p0, bool p1, float nearplaneOut, float nearplaneIn, float farplaneOut, float farplaneIn);
		void _0xB569F41F3E7E83A4(int p0);
		bool _0x7AC24EAB6D74118D(bool p0);
		int _0xBCEDB009461DA156();
		bool _0x27FEB5254759CDE3(string textureDict, bool p1);
		/// <summary>
		/// GRAPHICS::START_PARTICLE_FX_NON_LOOPED_AT_COORD("scr_paleto_roof_impact", -140.8576f, 6420.789f, 41.1391f, 0f, 0f, 267.3957f, 0x3F800000, 0, 0, 0);
		/// Axis - Invert Axis Flags
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// -------------------------------------------------------------------
		/// C#
		/// Function.Call<int>(Hash.START_PARTICLE_FX_NON_LOOPED_AT_COORD, = you are calling this function.
		/// char *effectname = This is an in-game effect name, for e.g. "scr_fbi4_trucks_crash" is used to give the effects when truck crashes etc
		/// float x, y, z pos = this one is Simple, you just have to declare, where do you want this effect to take place at, so declare the ordinates
		/// float scale = is declare the scale of the effect, this may vary as per the effects for e.g 1.0f
		/// See NativeDB for reference: http://natives.altv.mp/#/0x25129531F77B9ED3
		/// </summary>
		/// <param name="xRot">Again simple? just mention the value in case if you want the effect to rotate.</param>
		/// <param name="yRot">Again simple? just mention the value in case if you want the effect to rotate.</param>
		/// <param name="xAxis">To bool the axis values.</param>
		/// <param name="yAxis">To bool the axis values.</param>
		int StartParticleFxNonLoopedAtCoord(string effectName, float xPos, float yPos, float zPos, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis);
		/// <summary>
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		bool StartNetworkedParticleFxNonLoopedAtCoord(string effectName, float xPos, float yPos, float zPos, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis, bool p11);
		/// <summary>
		/// GRAPHICS::START_PARTICLE_FX_NON_LOOPED_ON_PED_BONE("scr_sh_bong_smoke", PLAYER::PLAYER_PED_ID(), -0.025f, 0.13f, 0f, 0f, 0f, 0f, 31086, 0x3F800000, 0, 0, 0);
		/// Axis - Invert Axis Flags
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		bool StartParticleFxNonLoopedOnPedBone(string effectName, int ped, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, int boneIndex, float scale, bool axisX, bool axisY, bool axisZ);
		/// <summary>
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		bool StartNetworkedParticleFxNonLoopedOnPedBone(string effectName, int ped, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, int boneIndex, float scale, bool axisX, bool axisY, bool axisZ);
		/// <summary>
		/// Starts a particle effect on an entity for example your player.
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// Example:
		/// C#:
		/// Internally this calls the same function as GRAPHICS::START_PARTICLE_FX_NON_LOOPED_ON_PED_BONE
		/// however it uses -1 for the specified bone index, so it should be possible to start a non looped fx on an entity bone using that native
		/// -can confirm START_PARTICLE_FX_NON_LOOPED_ON_PED_BONE does NOT work on vehicle bones.
		/// </summary>
		/// <param name="entity">0.5, 0.0, 0.0, 0.0, 1.0, false, false, false);</param>
		bool StartParticleFxNonLoopedOnEntity(string effectName, int entity, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, float scale, bool axisX, bool axisY, bool axisZ);
		/// <summary>
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		bool StartNetworkedParticleFxNonLoopedOnEntity(string effectName, int entity, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, float scale, bool axisX, bool axisY, bool axisZ);
		bool StartNetworkedParticleFxNonLoopedOnEntityBone(string effectName, int entity, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, int boneIndex, float scale, bool axisX, bool axisY, bool axisZ);
		/// <summary>
		/// only works on some fx's, not networked
		/// </summary>
		void SetParticleFxNonLoopedColour(float r, float g, float b);
		/// <summary>
		/// Usage example for C#:
		/// Function.Call(Hash.SET_PARTICLE_FX_NON_LOOPED_ALPHA, new InputArgument[] { 0.1f });
		/// Note: the argument alpha ranges from 0.0f-1.0f !
		/// </summary>
		void SetParticleFxNonLoopedAlpha(float alpha);
		/// <summary>
		/// Used only once in the scripts (taxi_clowncar)
		/// SET_PARTICLE_FX_*
		/// </summary>
		void _0x8CDE909A0370BB3A(bool toggle);
		/// <summary>
		/// GRAPHICS::START_PARTICLE_FX_LOOPED_AT_COORD("scr_fbi_falling_debris", 93.7743f, -749.4572f, 70.86904f, 0f, 0f, 0f, 0x3F800000, 0, 0, 0, 0)
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		/// <param name="p11">seems to be always 0</param>
		int StartParticleFxLoopedAtCoord(string effectName, float x, float y, float z, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis, bool p11);
		/// <summary>
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		int StartParticleFxLoopedOnPedBone(string effectName, int ped, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, int boneIndex, float scale, bool xAxis, bool yAxis, bool zAxis);
		/// <summary>
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		int StartParticleFxLoopedOnEntity(string effectName, int entity, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis);
		/// <summary>
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		int StartParticleFxLoopedOnEntityBone(string effectName, int entity, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, int boneIndex, float scale, bool xAxis, bool yAxis, bool zAxis);
		/// <summary>
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		int StartNetworkedParticleFxLoopedOnEntity(string effectName, int entity, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, float scale, bool xAxis, bool yAxis, bool zAxis, int p12, int p13, int p14, int p15);
		/// <summary>
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		int StartNetworkedParticleFxLoopedOnEntityBone(string effectName, int entity, float xOffset, float yOffset, float zOffset, float xRot, float yRot, float zRot, int boneIndex, float scale, bool xAxis, bool yAxis, bool zAxis, int p13, int p14, int p15, int p16);
		/// <summary>
		/// </summary>
		/// <param name="p1">is always 0 in the native scripts</param>
		void StopParticleFxLooped(int ptfxHandle, bool p1);
		void RemoveParticleFx(int ptfxHandle, bool p1);
		void RemoveParticleFxFromEntity(int entity);
		void RemoveParticleFxInRange(float X, float Y, float Z, float radius);
		void _0xBA0127DA25FD54C9(int p0, int p1);
		bool DoesParticleFxLoopedExist(int ptfxHandle);
		void SetParticleFxLoopedOffsets(int ptfxHandle, float x, float y, float z, float rotX, float rotY, float rotZ);
		void SetParticleFxLoopedEvolution(int ptfxHandle, string propertyName, float amount, bool noNetwork);
		/// <summary>
		/// only works on some fx's
		/// </summary>
		/// <param name="p4">= 0</param>
		void SetParticleFxLoopedColour(int ptfxHandle, float r, float g, float b, bool p4);
		void SetParticleFxLoopedAlpha(int ptfxHandle, float alpha);
		void SetParticleFxLoopedScale(int ptfxHandle, float scale);
		void SetParticleFxLoopedFarClipDist(int ptfxHandle, float range);
		void SetParticleFxCamInsideVehicle(bool p0);
		void SetParticleFxCamInsideNonplayerVehicle(int vehicle, bool p1);
		void SetParticleFxShootoutBoat(int p0);
		void _0x2A251AA48B2B46DB();
		void _0x908311265D42A820(int p0);
		void _0xCFD16F0DB5A3535C(bool toggle);
		/// <summary>
		/// DISABLE_*
		/// </summary>
		void _0x5F6DF3D92271E8A1(bool toggle);
		void _0x2B40A97646381508(int p0);
		/// <summary>
		/// Creates cartoon effect when Michel smokes the weed
		/// </summary>
		void EnableClownBloodVfx(bool toggle);
		/// <summary>
		/// Creates a motion-blur sort of effect, this native does not seem to work, however by using the `START_SCREEN_EFFECT` native with `DrugsMichaelAliensFight` as the effect parameter, you should be able to get the effect.
		/// </summary>
		void EnableAlienBloodVfx(bool toggle);
		void SetParticleFxBulletImpactScale(float scale);
		void _0xBB90E12CAC1DAB25(float p0);
		void _0xCA4AE345A153D573(bool p0);
		void _0x54E22EA2C1956A8D(float p0);
		void _0x949F397A288B28B3(float p0);
		/// <summary>
		/// SET_PARTICLE_FX_*
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		void _0xBA3D194057C79A7B(string p0);
		void _0x5DBF05DB5926D089(int p0);
		/// <summary>
		/// FORCE_*
		/// </summary>
		void _0x9B079E5221D984D3(bool p0);
		/// <summary>
		/// From the b678d decompiled scripts:
		/// GRAPHICS::_SET_PTFX_ASSET_NEXT_CALL("FM_Mission_Controler");
		/// GRAPHICS::_SET_PTFX_ASSET_NEXT_CALL("scr_apartment_mp");
		/// GRAPHICS::_SET_PTFX_ASSET_NEXT_CALL("scr_indep_fireworks");
		/// GRAPHICS::_SET_PTFX_ASSET_NEXT_CALL("scr_mp_cig_plane");
		/// GRAPHICS::_SET_PTFX_ASSET_NEXT_CALL("scr_mp_creator");
		/// GRAPHICS::_SET_PTFX_ASSET_NEXT_CALL("scr_ornate_heist");
		/// GRAPHICS::_SET_PTFX_ASSET_NEXT_CALL("scr_prison_break_heist_station");
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		void UseParticleFxAsset(string name);
		/// <summary>
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		void SetParticleFxOverride(string oldAsset, string newAsset);
		/// <summary>
		/// Resets the effect of SET_PARTICLE_FX_OVERRIDE
		/// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
		/// </summary>
		void ResetParticleFxOverride(string name);
		void _0xA46B73FAA3460AE1(bool p0);
		void _0xF78B803082D4386F(float p0);
		void WashDecalsInRange(int p0, int p1, int p2, int p3, int p4);
		void WashDecalsFromVehicle(int vehicle, float p1);
		/// <summary>
		/// Fades nearby decals within the range specified
		/// </summary>
		void FadeDecalsInRange(int p0, int p1, int p2, int p3, int p4);
		/// <summary>
		/// Removes all decals in range from a position, it includes the bullet holes, blood pools, petrol...
		/// </summary>
		void RemoveDecalsInRange(float x, float y, float z, float range);
		void RemoveDecalsFromObject(int obj);
		void RemoveDecalsFromObjectFacing(int obj, float x, float y, float z);
		void RemoveDecalsFromVehicle(int vehicle);
		/// <summary>
		/// decal types:
		/// public enum DecalTypes
		/// {
		/// splatters_blood = 1010,
		/// splatters_blood_dir = 1015,
		/// splatters_blood_mist = 1017,
		/// splatters_mud = 1020,
		/// splatters_paint = 1030,
		/// splatters_water = 1040,
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB302244A1839BDAD
		/// </summary>
		int AddDecal(int decalType, float posX, float posY, float posZ, float p4, float p5, float p6, float p7, float p8, float p9, float width, float height, float rCoef, float gCoef, float bCoef, float opacity, float timeout, bool p17, bool p18, bool p19);
		int AddPetrolDecal(float x, float y, float z, float groundLvl, float width, float transparency);
		void StartPetrolTrailDecals(float p0);
		void AddPetrolTrailDecalInfo(float x, float y, float z, float p3);
		void EndPetrolTrailDecals();
		void RemoveDecal(int decal);
		bool IsDecalAlive(int decal);
		float GetDecalWashLevel(int decal);
		void _0xD9454B5752C857DC();
		void _0x27CFB1B1E078CB2D();
		void SetDisableDecalRenderingThisFrame();
		bool GetIsPetrolDecalInRange(float xCoord, float yCoord, float zCoord, float radius);
		void PatchDecalDiffuseMap(int decalType, string textureDict, string textureName);
		void UnpatchDecalDiffuseMap(int decalType);
		void MoveVehicleDecals(int p0, int p1);
		/// <summary>
		/// </summary>
		/// <param name="boneIndex">is always chassis_dummy in the scripts. The x/y/z params are location relative to the chassis bone.</param>
		bool AddVehicleCrewEmblem(int vehicle, int ped, int boneIndex, float x1, float x2, float x3, float y1, float y2, float y3, float z1, float z2, float z3, float scale, int p13, int alpha);
		int _0x82ACC484FFA3B05F(int p0);
		void RemoveVehicleCrewEmblem(int vehicle, int p1);
		int GetVehicleCrewEmblemRequestState(int vehicle, int p1);
		bool DoesVehicleHaveCrewEmblem(int vehicle, int p1);
		void _0x0E4299C549F0D1F1(bool toggle);
		/// <summary>
		/// DISABLE_S*
		/// </summary>
		void _0x02369D5C8A51FDCF(bool toggle);
		void _0x46D1A61A21F566FC(float p0);
		void OverrideInteriorSmokeName(string name);
		void OverrideInteriorSmokeLevel(float level);
		void OverrideInteriorSmokeEnd();
		/// <summary>
		/// Used with 'NG_filmnoir_BW{01,02}' timecycles and the "NOIR_FILTER_SOUNDS" audioref.
		/// </summary>
		void RegisterNoirScreenEffectThisFrame();
		void DisableVehicleDistantlights(bool toggle);
		void _0x03300B57FCAC6DDB(bool p0);
		/// <summary>
		/// REQUEST_*
		/// </summary>
		void _0x98EDF76A7271E4F2();
		/// <summary>
		/// Forces footstep tracks on all surfaces.
		/// USE_/USING_*
		/// </summary>
		void SetForcePedFootstepsTracks(bool toggle);
		/// <summary>
		/// Forces vehicle trails on all surfaces.
		/// USE_/USING_*
		/// </summary>
		void SetForceVehicleTrails(bool toggle);
		void DisableScriptAmbientEffects(int p0);
		/// <summary>
		/// Only one match in the scripts:
		/// GRAPHICS::PRESET_INTERIOR_AMBIENT_CACHE("int_carrier_hanger");
		/// </summary>
		void PresetInteriorAmbientCache(string timecycleModifierName);
		/// <summary>
		/// Loads the specified timecycle modifier. Modifiers are defined separately in another file (e.g. "timecycle_mods_1.xml")
		/// Parameters:
		/// Full list of timecycle modifiers by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/timecycleModifiers.json
		/// </summary>
		/// <param name="modifierName">- The modifier to load (e.g. "V_FIB_IT3", "scanline_cam", etc.)</param>
		void SetTimecycleModifier(string modifierName);
		void SetTimecycleModifierStrength(float strength);
		/// <summary>
		/// Full list of timecycle modifiers by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/timecycleModifiers.json
		/// </summary>
		void SetTransitionTimecycleModifier(string modifierName, float transition);
		/// <summary>
		/// SET_TRA*
		/// </summary>
		void _0x1CBA05AE7BD7EE05(float p0);
		void ClearTimecycleModifier();
		/// <summary>
		/// Only use for this in the PC scripts is:
		/// if (GRAPHICS::GET_TIMECYCLE_MODIFIER_INDEX() != -1)
		/// For a full list, see here: pastebin.com/cnk7FTF2
		/// </summary>
		int GetTimecycleModifierIndex();
		int GetTimecycleTransitionModifierIndex();
		int _0x98D18905BF723B99();
		void PushTimecycleModifier();
		void PopTimecycleModifier();
		void SetCurrentPlayerTcmodifier(string modifierName);
		void SetPlayerTcmodifierTransition(float value);
		void SetNextPlayerTcmodifier(string modifierName);
		void AddTcmodifierOverride(string modifierName1, string modifierName2);
		void RemoveTcmodifierOverride(string p0);
		/// <summary>
		/// Full list of timecycle modifiers by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/timecycleModifiers.json
		/// </summary>
		void SetExtraTimecycleModifier(string modifierName);
		/// <summary>
		/// Clears the secondary timecycle modifier usually set with _SET_EXTRA_TIMECYCLE_MODIFIER
		/// </summary>
		void ClearExtraTimecycleModifier();
		/// <summary>
		/// See _0xFDF3D97C674AFB66 for use, works the same just for the secondary timecycle modifier.
		/// Returns an integer representing the Timecycle modifier
		/// </summary>
		int GetExtraTimecycleModifierIndex();
		/// <summary>
		/// ENABLE_*
		/// The same as SET_TIMECYCLE_MODIFIER_STRENGTH but for the secondary timecycle modifier.
		/// </summary>
		void SetExtraTimecycleModifierStrength(float strength);
		/// <summary>
		/// Resets the extra timecycle modifier strength normally set with 0x2C328AF17210F009
		/// </summary>
		void ResetExtraTimecycleModifierStrength();
		int RequestScaleformMovie(string scaleformName);
		int RequestScaleformMovieInstance(string scaleformName);
		/// <summary>
		/// Similar to REQUEST_SCALEFORM_MOVIE, but seems to be some kind of "interactive" scaleform movie?
		/// These seem to be the only scaleforms ever requested by this native:
		/// "breaking_news"
		/// "desktop_pc"
		/// "ECG_MONITOR"
		/// "Hacking_PC"
		/// "TEETH_PULLING"
		/// Note: Unless this hash is out-of-order, this native is next-gen only.
		/// </summary>
		int RequestScaleformMovieInteractive(string scaleformName);
		bool HasScaleformMovieLoaded(int scaleformHandle);
		/// <summary>
		/// SET_???
		/// </summary>
		/// <param name="val">is 1-20 (0 will return false)</param>
		/// <returns>val is 1-20 (0 will return false)</returns>
		bool _0x2FCB133CA50A49EB(int val);
		/// <summary>
		/// </summary>
		/// <param name="val">is 1-20. Return is related to INSTRUCTIONAL_BUTTONS, COLOUR_SWITCHER_02, etc?</param>
		/// <returns>val is 1-20. Return is related to INSTRUCTIONAL_BUTTONS, COLOUR_SWITCHER_02, etc?</returns>
		bool _0x86255B1FC929E33E(int val);
		/// <summary>
		/// Only values used in the scripts are:
		/// "heist_mp"
		/// "heistmap_mp"
		/// "instructional_buttons"
		/// "heist_pre"
		/// </summary>
		bool HasScaleformMovieFilenameLoaded(string scaleformName);
		bool HasScaleformContainerMovieLoadedIntoParent(int scaleformHandle);
		/// <summary>
		/// </summary>
		void SetScaleformMovieAsNoLongerNeeded(ref int scaleformHandle);
		void SetScaleformMovieToUseSystemTime(int scaleform, bool toggle);
		void _0x32F34FF7F617643B(int p0, int p1);
		/// <summary>
		/// This native is used in some casino scripts to fit the scaleform in the rendertarget.
		/// </summary>
		void SetScaleformFitRendertarget(int scaleformHandle, bool toggle);
		void DrawScaleformMovie(int scaleformHandle, float x, float y, float width, float height, int red, int green, int blue, int alpha, int unk);
		/// <summary>
		/// </summary>
		/// <param name="unk">is not used so no need</param>
		void DrawScaleformMovieFullscreen(int scaleform, int red, int green, int blue, int alpha, int unk);
		void DrawScaleformMovieFullscreenMasked(int scaleform1, int scaleform2, int red, int green, int blue, int alpha);
		void DrawScaleformMovie3d(int scaleform, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float p7, float p8, float p9, float scaleX, float scaleY, float scaleZ, int p13);
		void DrawScaleformMovie3dSolid(int scaleform, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float p7, float p8, float p9, float scaleX, float scaleY, float scaleZ, int p13);
		/// <summary>
		/// Calls the Scaleform function.
		/// </summary>
		void CallScaleformMovieMethod(int scaleform, string method);
		/// <summary>
		/// Calls the Scaleform function and passes the parameters as floats.
		/// The number of parameters passed to the function varies, so the end of the parameter list is represented by -1.0.
		/// </summary>
		void CallScaleformMovieMethodWithNumber(int scaleform, string methodName, float param1, float param2, float param3, float param4, float param5);
		/// <summary>
		/// Calls the Scaleform function and passes the parameters as strings.
		/// The number of parameters passed to the function varies, so the end of the parameter list is represented by 0 (NULL).
		/// </summary>
		void CallScaleformMovieMethodWithString(int scaleform, string methodName, string param1, string param2, string param3, string param4, string param5);
		/// <summary>
		/// Calls the Scaleform function and passes both float and string parameters (in their respective order).
		/// The number of parameters passed to the function varies, so the end of the float parameters is represented by -1.0, and the end of the string parameters is represented by 0 (NULL).
		/// NOTE: The order of parameters in the function prototype is important! All float parameters must come first, followed by the string parameters.
		/// Examples:
		/// // function MY_FUNCTION(floatParam1, floatParam2, stringParam)
		/// // function MY_FUNCTION_2(floatParam, stringParam1, stringParam2)
		/// GRAPHICS::_CALL_SCALEFORM_MOVIE_FUNCTION_MIXED_PARAMS(scaleform, "MY_FUNCTION_2", 10.0, -1.0, -1.0, -1.0, -1.0, "String param #1", "String param #2", 0, 0, 0);
		/// </summary>
		void CallScaleformMovieMethodWithNumberAndString(int scaleform, string methodName, float floatParam1, float floatParam2, float floatParam3, float floatParam4, float floatParam5, string stringParam1, string stringParam2, string stringParam3, string stringParam4, string stringParam5);
		/// <summary>
		/// Pushes a function from the Hud component Scaleform onto the stack. Same behavior as GRAPHICS::BEGIN_SCALEFORM_MOVIE_METHOD, just a hud component id instead of a Scaleform.
		/// Known components:
		/// 19 - MP_RANK_BAR
		/// 20 - HUD_DIRECTOR_MODE
		/// This native requires more research - all information can be found inside of 'hud.gfx'. Using a decompiler, the different components are located under "scripts\__Packages\com\rockstargames\gtav\hud\hudComponents" and "scripts\__Packages\com\rockstargames\gtav\Multiplayer".
		/// </summary>
		bool BeginScaleformScriptHudMovieMethod(int hudComponent, string methodName);
		/// <summary>
		/// Push a function from the Scaleform onto the stack
		/// </summary>
		bool BeginScaleformMovieMethod(int scaleform, string methodName);
		/// <summary>
		/// Starts frontend (pause menu) scaleform movie methods.
		/// This can be used when you want to make custom frontend menus, and customize things like images or text in the menus etc.
		/// Use `BEGIN_SCALEFORM_MOVIE_METHOD_ON_FRONTEND_HEADER` for header scaleform functions.
		/// </summary>
		bool BeginScaleformMovieMethodOnFrontend(string methodName);
		/// <summary>
		/// Starts frontend (pause menu) scaleform movie methods for header options.
		/// Use `BEGIN_SCALEFORM_MOVIE_METHOD_ON_FRONTEND` to customize the content inside the frontend menus.
		/// </summary>
		bool BeginScaleformMovieMethodOnFrontendHeader(string methodName);
		/// <summary>
		/// Pops and calls the Scaleform function on the stack
		/// </summary>
		void EndScaleformMovieMethod();
		int EndScaleformMovieMethodReturnValue();
		/// <summary>
		/// Returns true if the return value of a scaleform function is ready to be collected (using GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_STRING or GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_INT).
		/// </summary>
		/// <param name="methodReturn">The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE</param>
		/// <returns>methodReturn: The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE</returns>
		bool IsScaleformMovieMethodReturnValueReady(int methodReturn);
		/// <summary>
		/// Used to get a return value from a scaleform function. Returns an int in the same way GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_STRING returns a string.
		/// </summary>
		/// <param name="methodReturn">The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE</param>
		/// <returns>methodReturn: The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE</returns>
		int GetScaleformMovieMethodReturnValueInt(int methodReturn);
		/// <summary>
		/// </summary>
		/// <param name="methodReturn">The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE</param>
		/// <returns>methodReturn: The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE</returns>
		bool GetScaleformMovieMethodReturnValueBool(int methodReturn);
		/// <summary>
		/// Used to get a return value from a scaleform function. Returns a string in the same way GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_INT returns an int.
		/// </summary>
		/// <param name="methodReturn">The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE</param>
		/// <returns>methodReturn: The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE</returns>
		string GetScaleformMovieMethodReturnValueString(int methodReturn);
		/// <summary>
		/// Pushes an integer for the Scaleform function onto the stack.
		/// </summary>
		void ScaleformMovieMethodAddParamInt(int value);
		/// <summary>
		/// Pushes a float for the Scaleform function onto the stack.
		/// </summary>
		void ScaleformMovieMethodAddParamFloat(float value);
		/// <summary>
		/// Pushes a boolean for the Scaleform function onto the stack.
		/// </summary>
		void ScaleformMovieMethodAddParamBool(bool value);
		/// <summary>
		/// Called prior to adding a text component to the UI. After doing so, GRAPHICS::END_TEXT_COMMAND_SCALEFORM_STRING is called.
		/// Examples:
		/// GRAPHICS::BEGIN_TEXT_COMMAND_SCALEFORM_STRING("NUMBER");
		/// HUD::ADD_TEXT_COMPONENT_INTEGER(MISC::ABSI(a_1));
		/// GRAPHICS::END_TEXT_COMMAND_SCALEFORM_STRING();
		/// GRAPHICS::BEGIN_TEXT_COMMAND_SCALEFORM_STRING("STRING");
		/// HUD::_ADD_TEXT_COMPONENT_STRING(a_2);
		/// GRAPHICS::END_TEXT_COMMAND_SCALEFORM_STRING();
		/// GRAPHICS::BEGIN_TEXT_COMMAND_SCALEFORM_STRING("STRTNM2");
		/// See NativeDB for reference: http://natives.altv.mp/#/0x80338406F3475E55
		/// </summary>
		void BeginTextCommandScaleformString(string componentType);
		void EndTextCommandScaleformString();
		/// <summary>
		/// Same as END_TEXT_COMMAND_SCALEFORM_STRING but does not perform HTML conversion for text tokens.
		/// </summary>
		void EndTextCommandScaleformString2();
		/// <summary>
		/// Same as SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING
		/// Both SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING / _SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING_2 works, but _SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING_2 is usually used for "name" (organisation, players..).
		/// </summary>
		void ScaleformMovieMethodAddParamTextureNameString2(string @string);
		void ScaleformMovieMethodAddParamTextureNameString(string @string);
		void ScaleformMovieMethodAddParamPlayerNameString(string @string);
		bool DoesLatestBriefStringExist(int p0);
		void ScaleformMovieMethodAddParamLatestBriefString(int value);
		void RequestScaleformScriptHudMovie(int hudComponent);
		bool HasScaleformScriptHudMovieLoaded(int hudComponent);
		void RemoveScaleformScriptHudMovie(int hudComponent);
		bool _0xD1C7CB175E012964(int scaleformHandle);
		void SetTvChannel(int channel);
		int GetTvChannel();
		void SetTvVolume(float volume);
		float GetTvVolume();
		/// <summary>
		/// All calls to this native are preceded by calls to GRAPHICS::_0x61BB1D9B3A95D802 and GRAPHICS::_0xC6372ECD45D73BCD, respectively.
		/// "act_cinema.ysc", line 1483:
		/// HUD::SET_HUD_COMPONENT_POSITION(15, 0.0, -0.0375);
		/// HUD::SET_TEXT_RENDER_ID(l_AE);
		/// GRAPHICS::_0x61BB1D9B3A95D802(4);
		/// GRAPHICS::_0xC6372ECD45D73BCD(1);
		/// if (GRAPHICS::_0x0AD973CA1E077B60(${movie_arthouse})) {
		/// GRAPHICS::DRAW_TV_CHANNEL(0.5, 0.5, 0.7375, 1.0, 0.0, 255, 255, 255, 255);
		/// } else {
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFDDC2B4ED3C69DF0
		/// </summary>
		void DrawTvChannel(float xPos, float yPos, float xScale, float yScale, float rotation, int red, int green, int blue, int alpha);
		/// <summary>
		/// Loads specified video sequence into the TV Channel
		/// TV_Channel ranges from 0-2
		/// VideoSequence can be any of the following:
		/// "PL_STD_CNT" CNT Standard Channel
		/// "PL_STD_WZL" Weazel Standard Channel
		/// "PL_LO_CNT"
		/// "PL_LO_WZL"
		/// "PL_SP_WORKOUT"
		/// "PL_SP_INV" - Jay Norris Assassination Mission Fail
		/// See NativeDB for reference: http://natives.altv.mp/#/0xF7B38B8305F1FE8B
		/// </summary>
		void SetTvChannelPlaylist(int tvChannel, string playlistName, bool restart);
		void SetTvChannelPlaylistAtHour(int tvChannel, string playlistName, int hour);
		void ClearTvChannelPlaylist(int tvChannel);
		bool IsPlaylistUnk(int tvChannel, int p1);
		/// <summary>
		/// IS_*
		/// </summary>
		bool IsTvPlaylistItemPlaying(int videoCliphash);
		void EnableMovieKeyframeWait(bool toggle);
		/// <summary>
		/// SET_TV_???
		/// </summary>
		void _0xD1C55B110E4DF534(int p0);
		/// <summary>
		/// GET_CURRENT_*
		/// </summary>
		int _0x30432A0118736E00();
		void EnableMovieSubtitles(bool toggle);
		bool Ui3dsceneIsAvailable();
		/// <summary>
		/// All presets can be found in common\data\ui\uiscenes.meta
		/// </summary>
		bool Ui3dscenePushPreset(string presetName);
		/// <summary>
		/// It's called after 0xD3A10FC7FD8D98CD and 0xF1CEA8A4198D8E9A
		/// All presets can be found in common\data\ui\uiscenes.meta
		/// UI3DSCENE_*
		/// </summary>
		/// <param name="presetName">was always "CELEBRATION_WINNER"</param>
		bool _0x98C4FE6EC34154CA(string presetName, int ped, int p2, float posX, float posY, float posZ);
		/// <summary>
		/// UI3DSCENE_*
		/// </summary>
		void _0x7A42B2E236E71415();
		/// <summary>
		/// UI3DSCENE_*
		/// </summary>
		void _0x108BE26959A9D9BB(bool toggle);
		/// <summary>
		/// This native enables/disables the gold putting grid display (https://i.imgur.com/TC6cku6.png).
		/// This requires these two natives to be called as well to configure the grid: `0x1c4fc5752bcd8e48` and `0x5ce62918f8d703c7`.
		/// </summary>
		void TerraingridActivate(bool toggle);
		/// <summary>
		/// This native is used along with these two natives: `0xa356990e161c9e65` and `0x5ce62918f8d703c7`.
		/// This native configures the location, size, rotation, normal height, and the difference ratio between min, normal and max.
		/// All those natives combined they will output something like this: https://i.imgur.com/TC6cku6.png
		/// </summary>
		void TerraingridSetParams(float x, float y, float z, float p3, float rotation, float p5, float width, float height, float p8, float scale, float glowIntensity, float normalHeight, float heightDiff);
		/// <summary>
		/// This native is used along with these two natives: `0xa356990e161c9e65` and `0x1c4fc5752bcd8e48`.
		/// This native sets the colors for the golf putting grid. the 'min...' values are for the lower areas that the grid covers, the 'max...' values are for the higher areas that the grid covers, all remaining values are for the 'normal' ground height.
		/// All those natives combined they will output something like this: https://i.imgur.com/TC6cku6.png
		/// </summary>
		void TerraingridSetColours(int lowR, int lowG, int lowB, int lowAlpha, int r, int g, int b, int alpha, int highR, int highG, int highB, int highAlpha);
		/// <summary>
		/// if loop is true, the effect won't stop until you call ANIMPOSTFX_STOP on it. (only loopable effects)
		/// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
		/// </summary>
		/// <param name="duration">- is how long to play the effect for in milliseconds. If 0, it plays the default length</param>
		void AnimpostfxPlay(string effectName, int duration, bool looped);
		/// <summary>
		/// See ANIMPOSTFX_PLAY
		/// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
		/// </summary>
		void AnimpostfxStop(string effectName);
		/// <summary>
		/// See ANIMPOSTFX_PLAY
		/// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
		/// </summary>
		float AnimpostfxGetUnk(string effectName);
		/// <summary>
		/// Returns whether the specified effect is active.
		/// See ANIMPOSTFX_PLAY
		/// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
		/// </summary>
		bool AnimpostfxIsRunning(string effectName);
		/// <summary>
		/// Stops ALL currently playing effects.
		/// </summary>
		void AnimpostfxStopAll();
		/// <summary>
		/// Stops the effect and sets a value (bool) in its data (+0x199) to false.
		/// See ANIMPOSTFX_PLAY
		/// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
		/// </summary>
		void AnimpostfxStopAndDoUnk(string effectName);
		/// <summary>
		/// All found occurrences in b617d, sorted alphabetically and identical lines removed: pastebin.com/RFb4GTny
		/// AUDIO::PLAY_PED_RINGTONE("Remote_Ring", PLAYER::PLAYER_PED_ID(), 1);
		/// AUDIO::PLAY_PED_RINGTONE("Dial_and_Remote_Ring", PLAYER::PLAYER_PED_ID(), 1);
		/// </summary>
		void PlayPedRingtone(string ringtoneName, int ped, bool p2);
		bool IsPedRingtonePlaying(int ped);
		void StopPedRingtone(int ped);
		bool IsMobilePhoneCallOngoing();
		/// <summary>
		/// IS_MOBILE_PHONE_*
		/// </summary>
		bool _0xC8B1B2425604CDD0();
		void CreateNewScriptedConversation();
		/// <summary>
		/// NOTE: ones that are -1, 0 - 35 are determined by a function where it gets a TextLabel from a global then runs,
		/// </summary>
		/// <param name="index">is -1, 0 - 35</param>
		/// <param name="p1">is a char or string (whatever you wanna call it)</param>
		/// <param name="p2">is Global 10597 + i * 6. 'i' is a while(i < 70) loop</param>
		/// <param name="p3">is again -1, 0 - 35</param>
		/// <param name="p4">is again -1, 0 - 35</param>
		/// <param name="p5">is either 0 or 1 (bool ?)</param>
		/// <param name="p6">is either 0 or 1 (The func to determine this is bool)</param>
		/// <param name="p7">is either 0 or 1 (The func to determine this is bool)</param>
		/// <param name="p8">is either 0 or 1 (The func to determine this is bool)</param>
		/// <param name="p9">is 0 - 3 (Determined by func_60 in dialogue_handler.c)</param>
		/// <param name="p10">is either 0 or 1 (The func to determine this is bool)</param>
		/// <param name="p11">is either 0 or 1 (The func to determine this is bool)</param>
		/// <param name="p12">is unknown as in TU27 X360 scripts it only goes to p11.</param>
		/// <returns>_GET_TEXT_SUBSTRING and depending on what the result is it goes in check order of 0 - 9 then A - Z then z (lowercase). So it will then return 0 - 35 or -1 if it's 'z'. The func to handle that ^^ is func_67 in dialog_handler.c atleast in TU27 Xbox360 scripts.</returns>
		void AddLineToConversation(int index, string p1, string p2, int p3, int p4, bool p5, bool p6, bool p7, bool p8, int p9, bool p10, bool p11, bool p12);
		/// <summary>
		/// 4 calls in the b617d scripts. The only one with p0 and p2 in clear text:
		/// AUDIO::ADD_PED_TO_CONVERSATION(5, l_AF, "DINAPOLI");
		/// =================================================
		/// One of the 2 calls in dialogue_handler.c p0 is in a while-loop, and so is determined to also possibly be 0 - 15.
		/// </summary>
		void AddPedToConversation(int index, int ped, string p2);
		void _0x33E3C6C6F2F0B506(int p0, float p1, float p2, float p3);
		void _0x892B6AB8F33606F5(int p0, int entity);
		/// <summary>
		/// If this is the correct name, what microphone? I know your TV isn't going to reach out and adjust your headset so..
		/// </summary>
		void SetMicrophonePosition(bool p0, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3);
		void _0x0B568201DD99F0EB(bool p0);
		void _0x61631F5DF50D1C34(bool p0);
		void StartScriptPhoneConversation(bool p0, bool p1);
		void PreloadScriptPhoneConversation(bool p0, bool p1);
		void StartScriptConversation(bool p0, bool p1, bool p2, bool p3);
		void PreloadScriptConversation(bool p0, bool p1, bool p2, bool p3);
		void StartPreloadedConversation();
		bool GetIsPreloadedConversationReady();
		bool IsScriptedConversationOngoing();
		bool IsScriptedConversationLoaded();
		int GetCurrentScriptedConversationLine();
		void PauseScriptedConversation(bool p0);
		void RestartScriptedConversation();
		int StopScriptedConversation(bool p0);
		void SkipToNextScriptedConversationLine();
		/// <summary>
		/// </summary>
		void InterruptConversation(int p0, ref int p1, ref int p2);
		/// <summary>
		/// One call found in the b617d scripts:
		/// AUDIO::_8A694D7A68F8DC38(NETWORK::NET_TO_PED(l_3989._f26F[01]), "CONV_INTERRUPT_QUIT_IT", "LESTER");
		/// </summary>
		void InterruptConversationAndPause(int ped, string p1, string p2);
		/// <summary>
		/// </summary>
		int _0xAA19F5572C38B564(ref int p0);
		void _0xB542DE8C3D1CB210(bool p0);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void RegisterScriptWithAudio(int p0);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void UnregisterScriptWithAudio();
		/// <summary>
		/// All occurrences and usages found in b617d: pastebin.com/NzZZ2Tmm
		/// </summary>
		bool RequestMissionAudioBank(string p0, bool p1, int p2);
		/// <summary>
		/// All occurrences and usages found in b617d, sorted alphabetically and identical lines removed: pastebin.com/XZ1tmGEz
		/// </summary>
		bool RequestAmbientAudioBank(string p0, bool p1, int p2);
		/// <summary>
		/// All occurrences and usages found in b617d, sorted alphabetically and identical lines removed: pastebin.com/AkmDAVn6
		/// </summary>
		bool RequestScriptAudioBank(string p0, bool p1, int p2);
		int _0x40763EA7B9B783E7(int p0, int p1, int p2);
		int HintAmbientAudioBank(int p0, int p1, int p2);
		int HintScriptAudioBank(int p0, int p1, int p2);
		void ReleaseMissionAudioBank();
		void ReleaseAmbientAudioBank();
		void ReleaseNamedScriptAudioBank(string audioBank);
		void ReleaseScriptAudioBank();
		void _0x19AF7ED9B9D23058();
		void _0x9AC92EED5E4793AB();
		void _0x11579D940949C49E(int p0);
		int GetSoundId();
		void ReleaseSoundId(int soundId);
		/// <summary>
		/// All found occurrences in b617d, sorted alphabetically and identical lines removed: pastebin.com/A8Ny8AHZ
		/// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
		/// </summary>
		void PlaySound(int soundId, string audioName, string audioRef, bool p3, int p4, bool p5);
		/// <summary>
		/// List: https://pastebin.com/DCeRiaLJ
		/// All occurrences as of Cayo Perico Heist DLC (b2189), sorted alphabetically and identical lines removed: https://git.io/JtLxM
		/// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
		/// </summary>
		void PlaySoundFrontend(int soundId, string audioName, string audioRef, bool p3);
		/// <summary>
		/// Only call found in the b617d scripts:
		/// AUDIO::PLAY_DEFERRED_SOUND_FRONTEND("BACK", "HUD_FREEMODE_SOUNDSET");
		/// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
		/// </summary>
		void PlayDeferredSoundFrontend(string soundName, string soundsetName);
		/// <summary>
		/// All found occurrences in b617d, sorted alphabetically and identical lines removed: pastebin.com/f2A7vTj0
		/// No changes made in b678d.
		/// gtaforums.com/topic/795622-audio-for-mods
		/// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
		/// </summary>
		void PlaySoundFromEntity(int soundId, string audioName, int entity, string audioRef, bool isNetwork, int p5);
		void _0x5B9853296731E88D(int p0, int p1, int p2, int p3, int p4, int p5);
		/// <summary>
		/// All found occurrences in b617d, sorted alphabetically and identical lines removed: pastebin.com/eeFc5DiW
		/// gtaforums.com/topic/795622-audio-for-mods
		/// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
		/// </summary>
		void PlaySoundFromCoord(int soundId, string audioName, float x, float y, float z, string audioRef, bool isNetwork, int range, bool p8);
		void _0x7EC3C679D0E7E46B(int p0, int p1, int p2, int p3);
		void StopSound(int soundId);
		/// <summary>
		/// Could this be used alongside either,
		/// SET_NETWORK_ID_EXISTS_ON_ALL_MACHINES or _SET_NETWORK_ID_SYNC_TO_PLAYER to make it so other players can hear the sound while online? It'd be a bit troll-fun to be able to play the Zancudo UFO creepy sounds globally.
		/// </summary>
		int GetNetworkIdFromSoundId(int soundId);
		int GetSoundIdFromNetworkId(int netId);
		/// <summary>
		/// </summary>
		void SetVariableOnSound(int soundId, ref int p1, float p2);
		/// <summary>
		/// From the scripts, p0:
		/// "ArmWrestlingIntensity",
		/// "INOUT",
		/// "Monkey_Stream",
		/// "ZoomLevel"
		/// </summary>
		void SetVariableOnStream(string p0, float p1);
		/// <summary>
		/// </summary>
		void OverrideUnderwaterStream(ref int p0, bool p1);
		/// <summary>
		/// AUDIO::SET_VARIABLE_ON_UNDER_WATER_STREAM("inTunnel", 1.0);
		/// AUDIO::SET_VARIABLE_ON_UNDER_WATER_STREAM("inTunnel", 0.0);
		/// </summary>
		void SetVariableOnUnderWaterStream(string unkVariableName, float value);
		bool HasSoundFinished(int soundId);
		/// <summary>
		/// Plays ambient speech. See also _0x444180DB.
		/// SPEECH_PARAMS_STANDARD
		/// SPEECH_PARAMS_ALLOW_REPEAT
		/// SPEECH_PARAMS_BEAT
		/// SPEECH_PARAMS_FORCE
		/// SPEECH_PARAMS_FORCE_FRONTEND
		/// SPEECH_PARAMS_FORCE_NO_REPEAT_FRONTEND
		/// SPEECH_PARAMS_FORCE_NORMAL
		/// SPEECH_PARAMS_FORCE_NORMAL_CLEAR
		/// See NativeDB for reference: http://natives.altv.mp/#/0x8E04FEDD28D42462
		/// </summary>
		/// <param name="ped">The ped to play the ambient speech.</param>
		/// <param name="speechName">Name of the speech to play, eg. "GENERIC_HI".</param>
		/// <param name="speechParam">Can be one of the following:</param>
		void PlayPedAmbientSpeechNative(int ped, string speechName, string speechParam, int p3);
		/// <summary>
		/// Plays ambient speech. See also _0x5C57B85D.
		/// See PLAY_PED_AMBIENT_SPEECH_NATIVE for parameter specifications.
		/// Full list of speeches and voices names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/speeches.json
		/// </summary>
		void PlayPedAmbientSpeechAndCloneNative(int ped, string speechName, string speechParam, int p3);
		/// <summary>
		/// This is the same as PLAY_PED_AMBIENT_SPEECH_NATIVE and PLAY_PED_AMBIENT_SPEECH_AND_CLONE_NATIVE but it will allow you to play a speech file from a specific voice file. It works on players and all peds, even animals.
		/// EX (C#):
		/// GTA.Native.Function.Call(Hash._0x3523634255FC3318, Game.Player.Character, "GENERIC_INSULT_HIGH", "s_m_y_sheriff_01_white_full_01", "SPEECH_PARAMS_FORCE_SHOUTED", 0);
		/// The first param is the ped you want to play it on, the second is the speech name, the third is the voice name, the fourth is the speech param, and the last param is usually always 0.
		/// Full list of speeches and voices names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/speeches.json
		/// </summary>
		void PlayPedAmbientSpeechWithVoiceNative(int ped, string speechName, string voiceName, string speechParam, bool p4);
		/// <summary>
		/// Full list of speeches and voices names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/speeches.json
		/// </summary>
		void PlayAmbientSpeechFromPositionNative(string speechName, string voiceName, float x, float y, float z, string speechParam);
		/// <summary>
		/// This native enables the audio flag "TrevorRageIsOverridden" and sets the voice effect to `voiceEffect`
		/// </summary>
		void OverrideTrevorRage(string voiceEffect);
		void ResetTrevorRage();
		void SetPlayerAngry(int ped, bool toggle);
		/// <summary>
		/// Last 2 parameters always seem to be 0.
		/// EX: Function.Call(Hash.PLAY_PAIN, TestPed, 6, 0, 0);
		/// Known Pain IDs
		/// ________________________
		/// 1 - Doesn't seem to do anything. Does NOT crash the game like previously said. (Latest patch)
		/// 6 - Scream (Short)
		/// 7 - Scared Scream (Kinda Long)
		/// 8 - On Fire
		/// </summary>
		void PlayPain(int ped, int painID, int p1, int p3);
		void ReleaseWeaponAudio();
		void ActivateAudioSlowmoMode(string p0);
		void DeactivateAudioSlowmoMode(string p0);
		/// <summary>
		/// Audio List
		/// gtaforums.com/topic/795622-audio-for-mods/
		/// All found occurrences in b617d, sorted alphabetically and identical lines removed: pastebin.com/FTeAj4yZ
		/// Yes
		/// </summary>
		void SetAmbientVoiceName(int ped, string name);
		void SetAmbientVoiceNameHash(int ped, int hash);
		int GetAmbientVoiceNameHash(int ped);
		/// <summary>
		/// Assigns some ambient voice to the ped.
		/// </summary>
		void SetPedScream(int ped);
		void _0x1B7ABE26CBCBF8C7(int ped, int p1, int p2);
		/// <summary>
		/// From the scripts:
		/// AUDIO::_SET_PED_VOICE_GROUP(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("PAIGE_PVG"));
		/// AUDIO::_SET_PED_VOICE_GROUP(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("TALINA_PVG"));
		/// AUDIO::_SET_PED_VOICE_GROUP(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("FEMALE_LOST_BLACK_PVG"));
		/// AUDIO::_SET_PED_VOICE_GROUP(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("FEMALE_LOST_WHITE_PVG"));
		/// </summary>
		void SetPedVoiceGroup(int ped, int voiceGroupHash);
		void SetPedAudioGender(int ped, bool p1);
		void StopCurrentPlayingSpeech(int ped);
		void StopCurrentPlayingAmbientSpeech(int ped);
		bool IsAmbientSpeechPlaying(int ped);
		bool IsScriptedSpeechPlaying(int p0);
		bool IsAnySpeechPlaying(int ped);
		int _0x30CA2EF91D15ADF8();
		/// <summary>
		/// Checks if the ped can play the speech or has the speech file, last parameter is usually 0
		/// DOES_C*
		/// </summary>
		bool CanPedSpeak(int ped, string speechName, bool unk);
		bool IsPedInCurrentConversation(int ped);
		/// <summary>
		/// Sets the ped drunk sounds.  Only works with PLAYER_PED_ID
		/// ====================================================
		/// As mentioned above, this only sets the drunk sound to ped/player.
		/// To give the Ped a drunk effect with drunk walking animation try using SET_PED_MOVEMENT_CLIPSET
		/// Below is an example
		/// if (!Function.Call<bool>(Hash.HAS_ANIM_SET_LOADED, "move_m@drunk@verydrunk"))
		/// {
		/// Function.Call(Hash.REQUEST_ANIM_SET, "move_m@drunk@verydrunk");
		/// }
		/// See NativeDB for reference: http://natives.altv.mp/#/0x95D2D383D5396B8A
		/// </summary>
		void SetPedIsDrunk(int ped, bool toggle);
		/// <summary>
		/// Plays sounds from a ped with chop model. For example it used to play bark or sniff sounds. p1 is always 3 or 4294967295 in decompiled scripts. By a quick disassembling I can assume that this arg is unused.
		/// This native is works only when you call it on the ped with right model (ac_chop only ?)
		/// Speech Name can be: CHOP_SNIFF_SEQ CHOP_WHINE CHOP_LICKS_MOUTH CHOP_PANT bark GROWL SNARL BARK_SEQ
		/// </summary>
		void PlayAnimalVocalization(int pedHandle, int p1, string speechName);
		bool IsAnimalVocalizationPlaying(int pedHandle);
		/// <summary>
		/// </summary>
		/// <param name="mood">can be 0 or 1 (it's not a boolean value!). Effects audio of the animal.</param>
		void SetAnimalMood(int animal, int mood);
		bool IsMobilePhoneRadioActive();
		void SetMobilePhoneRadioState(bool state);
		/// <summary>
		/// Returns 255 (radio off index) if the function fails.
		/// </summary>
		int GetPlayerRadioStationIndex();
		/// <summary>
		/// Returns active radio station name
		/// </summary>
		string GetPlayerRadioStationName();
		/// <summary>
		/// Converts radio station index to string. Use HUD::_GET_LABEL_TEXT to get the user-readable text.
		/// </summary>
		string GetRadioStationName(int radioStation);
		int GetPlayerRadioStationGenre();
		bool IsRadioRetuning();
		bool IsRadioFadedOut();
		/// <summary>
		/// Tune Forward... ?
		/// SET_RADIO_*
		/// </summary>
		void _0xFF266D1D0EB1195D();
		/// <summary>
		/// Tune Backwards... ?
		/// SET_RADIO_*
		/// </summary>
		void _0xDD6BCF9E94425DF9();
		/// <summary>
		/// List of radio stations that are in the wheel, in clockwise order, as of LS Tuners DLC: https://git.io/J8a3k
		/// An older list including hidden radio stations: https://pastebin.com/Kj9t38KF
		/// </summary>
		void SetRadioToStationName(string stationName);
		/// <summary>
		/// List of radio stations that are in the wheel, in clockwise order, as of LS Tuners DLC: https://git.io/J8a3k
		/// An older list including hidden radio stations: https://pastebin.com/Kj9t38KF
		/// </summary>
		void SetVehRadioStation(int vehicle, string radioStation);
		void SetVehHasRadioOverride(int vehicle);
		/// <summary>
		/// IS_VEHICLE_*
		/// </summary>
		bool IsVehicleRadioEnabled(int vehicle);
		/// <summary>
		/// SET_VEH*
		/// </summary>
		void _0xC1805D05E6D4FE10(int vehicle);
		/// <summary>
		/// Full list of static emitters by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/staticEmitters.json
		/// </summary>
		void SetEmitterRadioStation(string emitterName, string radioStation);
		/// <summary>
		/// Example:
		/// AUDIO::SET_STATIC_EMITTER_ENABLED((Any*)"LOS_SANTOS_VANILLA_UNICORN_01_STAGE", false);    AUDIO::SET_STATIC_EMITTER_ENABLED((Any*)"LOS_SANTOS_VANILLA_UNICORN_02_MAIN_ROOM", false);    AUDIO::SET_STATIC_EMITTER_ENABLED((Any*)"LOS_SANTOS_VANILLA_UNICORN_03_BACK_ROOM", false);
		/// This turns off surrounding sounds not connected directly to peds.
		/// Full list of static emitters by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/staticEmitters.json
		/// </summary>
		void SetStaticEmitterEnabled(string emitterName, bool toggle);
		/// <summary>
		/// L* (LINK_*?)
		/// Full list of static emitters by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/staticEmitters.json
		/// </summary>
		void LinkStaticEmitterToEntity(string emitterName, int entity);
		/// <summary>
		/// Sets radio station by index.
		/// </summary>
		void SetRadioToStationIndex(int radioStation);
		void SetFrontendRadioActive(bool active);
		/// <summary>
		/// I see this as a native that would of been used back in GTA III when you finally unlocked the bridge to the next island and such.
		/// </summary>
		void UnlockMissionNewsStory(int newsStory);
		bool IsMissionNewsStoryUnlocked(int newsStory);
		int GetAudibleMusicTrackTextId();
		void PlayEndCreditsMusic(bool play);
		void SkipRadioForward();
		void FreezeRadioStation(string radioStation);
		void UnfreezeRadioStation(string radioStation);
		void SetRadioAutoUnfreeze(bool toggle);
		void SetInitialPlayerStation(string radioStation);
		void SetUserRadioControlEnabled(bool toggle);
		/// <summary>
		/// Only found this one in the decompiled scripts:
		/// AUDIO::SET_RADIO_TRACK("RADIO_03_HIPHOP_NEW", "ARM1_RADIO_STARTS");
		/// </summary>
		void SetRadioTrack(string radioStation, string radioTrack);
		void SetRadioTrackMix(string radioStationName, string mixName, int p2);
		void _0x55ECF4D13D9903B0(int p0, int p1, int p2, int p3);
		void SetVehicleRadioLoud(int vehicle, bool toggle);
		bool IsVehicleRadioLoud(int vehicle);
		void SetMobileRadioEnabledDuringGameplay(bool toggle);
		bool DoesPlayerVehHaveRadio();
		bool IsPlayerVehRadioEnable();
		/// <summary>
		/// can't seem to enable radio on cop cars etc
		/// </summary>
		void SetVehicleRadioEnabled(int vehicle, bool toggle);
		void _0xDA07819E452FFE8F(int p0);
		/// <summary>
		/// Examples:
		/// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "END_CREDITS_KILL_MICHAEL", 1);
		/// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "END_CREDITS_KILL_MICHAEL", 1);
		/// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "END_CREDITS_KILL_TREVOR", 1);
		/// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "END_CREDITS_SAVE_MICHAEL_TREVOR", 1);
		/// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "OFF_ROAD_RADIO_ROCK_LIST", 1);
		/// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_06_COUNTRY", "MAGDEMO2_RADIO_DINGHY", 1);
		/// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_16_SILVERLAKE", "SEA_RACE_RADIO_PLAYLIST", 1);
		/// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "OFF_ROAD_RADIO_ROCK_LIST", 1);
		/// </summary>
		void SetCustomRadioTrackList(string radioStation, string trackListName, bool p2);
		/// <summary>
		/// 3 calls in the b617d scripts, removed duplicate.
		/// AUDIO::CLEAR_CUSTOM_RADIO_TRACK_LIST("RADIO_16_SILVERLAKE");
		/// AUDIO::CLEAR_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK");
		/// </summary>
		void ClearCustomRadioTrackList(string radioStation);
		int GetNumUnlockedRadioStations();
		int FindRadioStationIndex(int stationNameHash);
		/// <summary>
		/// 6 calls in the b617d scripts, removed identical lines:
		/// AUDIO::SET_RADIO_STATION_MUSIC_ONLY("RADIO_01_CLASS_ROCK", 1);
		/// AUDIO::SET_RADIO_STATION_MUSIC_ONLY(AUDIO::GET_RADIO_STATION_NAME(10), 0);
		/// AUDIO::SET_RADIO_STATION_MUSIC_ONLY(AUDIO::GET_RADIO_STATION_NAME(10), 1);
		/// </summary>
		void SetRadioStationMusicOnly(string radioStation, bool toggle);
		void SetRadioFrontendFadeTime(float fadeTime);
		/// <summary>
		/// AUDIO::UNLOCK_RADIO_STATION_TRACK_LIST("RADIO_16_SILVERLAKE", "MIRRORPARK_LOCKED");
		/// </summary>
		void UnlockRadioStationTrackList(string radioStation, string trackListName);
		void LockRadioStationTrackList(string radioStation, string trackListName);
		/// <summary>
		/// Just a nullsub (i.e. does absolutely nothing) since build 1604.
		/// </summary>
		void UpdateLsur(bool enableMixes);
		/// <summary>
		/// Disables the radio station (hides it from the radio wheel).
		/// </summary>
		void LockRadioStation(string radioStationName, bool toggle);
		/// <summary>
		/// Doesn't have an effect in Story Mode.
		/// </summary>
		void SetRadioStationIsVisible(string radioStation, bool toggle);
		/// <summary>
		/// GET_NE*
		/// Gets values from the radio?
		/// </summary>
		bool _0xC64A06D939F826F5(ref float p0, ref float p1, ref int p2);
		void ForceRadioTrackListPosition(string radioStation, string trackListName, int milliseconds);
		/// <summary>
		/// GET_CURRENT_*
		/// </summary>
		/// <returns>Seems to return hashed radio station name?</returns>
		int GetCurrentRadioStationHash(string radioStationName);
		/// <summary>
		/// GET_CURRENT_*
		/// </summary>
		int _0x34D66BC058019CE0(string radioStationName);
		/// <summary>
		/// SET_VEHICLE_*
		/// </summary>
		void _0xF3365489E0DD50F9(int vehicle, bool toggle);
		/// <summary>
		/// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
		/// </summary>
		void SetAmbientZoneState(string zoneName, bool p1, bool p2);
		/// <summary>
		/// Still needs more research.
		/// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
		/// </summary>
		void ClearAmbientZoneState(string zoneName, bool p1);
		/// <summary>
		/// </summary>
		void SetAmbientZoneListState(ref int p0, bool p1, bool p2);
		/// <summary>
		/// </summary>
		void ClearAmbientZoneListState(ref int p0, bool p1);
		/// <summary>
		/// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
		/// </summary>
		void SetAmbientZoneStatePersistent(string ambientZone, bool p1, bool p2);
		/// <summary>
		/// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
		/// </summary>
		void SetAmbientZoneListStatePersistent(string ambientZone, bool p1, bool p2);
		/// <summary>
		/// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
		/// </summary>
		bool IsAmbientZoneEnabled(string ambientZone);
		void _0x5D2BFAAB8D956E0E();
		/// <summary>
		/// All occurrences found in b617d, sorted alphabetically and identical lines removed:
		/// AUDIO::SET_CUTSCENE_AUDIO_OVERRIDE("_AK");
		/// AUDIO::SET_CUTSCENE_AUDIO_OVERRIDE("_CUSTOM");
		/// AUDIO::SET_CUTSCENE_AUDIO_OVERRIDE("_TOOTHLESS");
		/// </summary>
		void SetCutsceneAudioOverride(string name);
		/// <summary>
		/// SET_VARIABLE_ON_*
		/// </summary>
		void SetVariableOnCutsceneAudio(string unkVariableName, float value);
		/// <summary>
		/// Plays the given police radio message.
		/// All found occurrences in b617d, sorted alphabetically and identical lines removed: pastebin.com/GBnsQ5hr
		/// </summary>
		int PlayPoliceReport(string name, float p1);
		void CancelCurrentPoliceReport();
		/// <summary>
		/// Plays the siren sound of a vehicle which is otherwise activated when fastly double-pressing the horn key.
		/// Only works on vehicles with a police siren.
		/// </summary>
		void BlipSiren(int vehicle);
		/// <summary>
		/// Overrides the vehicle's horn hash.
		/// mute - p1 seems to be an option for muting the horn
		/// </summary>
		/// <param name="vehicle">- the vehicle whose horn should be overwritten</param>
		/// <param name="hornHash">- maybe a horn id, since the function AUDIO::GET_VEHICLE_DEFAULT_HORN(veh) exists?</param>
		/// <returns>When changing this hash on a vehicle, it will not return the 'overwritten' hash. It will still always return the default horn hash (same as GET_VEHICLE_DEFAULT_HORN)</returns>
		void OverrideVehHorn(int vehicle, bool @override, int hornHash);
		/// <summary>
		/// Checks whether the horn of a vehicle is currently played.
		/// </summary>
		bool IsHornActive(int vehicle);
		/// <summary>
		/// Makes pedestrians sound their horn longer, faster and more agressive when they use their horn.
		/// </summary>
		void SetAggressiveHorns(bool toggle);
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		void _0x02E93C796ABD3A97(bool p0);
		/// <summary>
		/// SET_VEHICLE_CONVERSATIONS_PERSIST?
		/// </summary>
		void _0x58BB377BEC7CD5F4(bool p0, bool p1);
		void _0x9BD7BD55E4533183(int p0, int p1, int p2);
		bool IsStreamPlaying();
		int GetStreamPlayTime();
		/// <summary>
		/// Example:
		/// AUDIO::LOAD_STREAM("CAR_STEAL_1_PASSBY", "CAR_STEAL_1_SOUNDSET");
		/// All found occurrences in the b678d decompiled scripts: pastebin.com/3rma6w5w
		/// Stream names often ends with "_MASTER", "_SMALL" or "_STREAM". Also "_IN", "_OUT" and numbers.
		/// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
		/// </summary>
		/// <param name="soundSet">is often set to 0 in the scripts. These are common to end the soundSets: "_SOUNDS", "_SOUNDSET" and numbers.</param>
		bool LoadStream(string streamName, string soundSet);
		/// <summary>
		/// Example:
		/// AUDIO::LOAD_STREAM_WITH_START_OFFSET("STASH_TOXIN_STREAM", 2400, "FBI_05_SOUNDS");
		/// Only called a few times in the scripts.
		/// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
		/// </summary>
		bool LoadStreamWithStartOffset(string streamName, int startOffset, string soundSet);
		void PlayStreamFromPed(int ped);
		void PlayStreamFromVehicle(int vehicle);
		/// <summary>
		/// Used with AUDIO::LOAD_STREAM
		/// Example from finale_heist2b.c4:
		/// TASK::TASK_SYNCHRONIZED_SCENE(l_4C8[214], l_4C8[214]._f7, l_30A, "push_out_vault_l", 4.0, -1.5, 5, 713, 4.0, 0);
		/// PED::SET_SYNCHRONIZED_SCENE_PHASE(l_4C8[214]._f7, 0.0);
		/// PED::_2208438012482A1A(l_4C8[214], 0, 0);
		/// PED::SET_PED_COMBAT_ATTRIBUTES(l_4C8[214], 38, 1);
		/// PED::SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(l_4C8[214], 1);
		/// if (AUDIO::LOAD_STREAM("Gold_Cart_Push_Anim_01", "BIG_SCORE_3B_SOUNDS")) {
		/// AUDIO::PLAY_STREAM_FROM_OBJECT(l_36F[01]);
		/// }
		/// </summary>
		void PlayStreamFromObject(int @object);
		void PlayStreamFrontend();
		void PlayStreamFromPosition(float x, float y, float z);
		void StopStream();
		void StopPedSpeaking(int ped, bool shaking);
		/// <summary>
		/// BL*
		/// </summary>
		void _0xF8AD2EED7C47E8FE(int ped, bool p1, bool p2);
		void _0xAB6781A5F3101470(int p0, int p1);
		void DisablePedPainAudio(int ped, bool toggle);
		/// <summary>
		/// Common in the scripts:
		/// AUDIO::IS_AMBIENT_SPEECH_DISABLED(PLAYER::PLAYER_PED_ID());
		/// </summary>
		bool IsAmbientSpeechDisabled(int ped);
		void _0xA8A7D434AFB4B97B(string p0, int p1);
		void _0x2ACABED337622DF2(string p0);
		void SetSirenWithNoDriver(int vehicle, bool toggle);
		void SetSirenKeepOn(int vehicle, bool toggle);
		void TriggerSiren(int vehicle);
		/// <summary>
		/// SET_*
		/// </summary>
		void SoundVehicleHornThisFrame(int vehicle);
		void SetHornEnabled(int vehicle, bool toggle);
		void SetAudioVehiclePriority(int vehicle, int p1);
		/// <summary>
		/// SET_H*
		/// </summary>
		void _0x9D3AF56E94C9AE98(int vehicle, float p1);
		void UseSirenAsHorn(int vehicle, bool toggle);
		/// <summary>
		/// This native sets the audio of the specified vehicle to the audioName (p1).
		/// Use the audioNameHash found in vehicles.meta
		/// Example:
		/// _SET_VEHICLE_AUDIO(veh, "ADDER");
		/// The selected vehicle will now have the audio of the Adder.
		/// FORCE_VEHICLE_???
		/// </summary>
		void ForceVehicleEngineAudio(int vehicle, string audioName);
		void PreloadVehicleAudio(int vehicleModel);
		void SetVehicleStartupRevSound(int vehicle, string p1, string p2);
		void ResetVehicleStartupRevSound(int vehicle);
		void _0x97FFB4ADEED08066(int p0, int p1);
		bool IsVehicleAudiblyDamaged(int vehicle);
		void SetVehicleAudioEngineDamageFactor(int vehicle, float damageFactor);
		void SetVehicleAudioBodyDamageFactor(int vehicle, float p1);
		void EnableVehicleFanbeltDamage(int vehicle, bool toggle);
		void EnableVehicleExhaustPops(int vehicle, bool toggle);
		/// <summary>
		/// SET_VEHICLE_BOOST_ACTIVE(vehicle, 1, 0);
		/// SET_VEHICLE_BOOST_ACTIVE(vehicle, 0, 0);
		/// Will give a boost-soundeffect.
		/// </summary>
		void SetVehicleBoostActive(int vehicle, bool toggle);
		/// <summary>
		/// SET_P*
		/// </summary>
		void _0x6FDDAD856E36988A(int vehicle, bool toggle);
		void SetScriptUpdateDoorAudio(int doorHash, bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		void PlayVehicleDoorOpenSound(int vehicle, int doorId);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		void PlayVehicleDoorCloseSound(int vehicle, int doorId);
		/// <summary>
		/// Works for planes only.
		/// </summary>
		void EnableStallWarningSounds(int vehicle, bool toggle);
		bool IsGameInControlOfMusic();
		void SetGpsActive(bool active);
		/// <summary>
		/// Called 38 times in the scripts. There are 5 different audioNames used.
		/// One unknown removed below.
		/// AUDIO::PLAY_MISSION_COMPLETE_AUDIO("DEAD");
		/// AUDIO::PLAY_MISSION_COMPLETE_AUDIO("FRANKLIN_BIG_01");
		/// AUDIO::PLAY_MISSION_COMPLETE_AUDIO("GENERIC_FAILED");
		/// AUDIO::PLAY_MISSION_COMPLETE_AUDIO("TREVOR_SMALL_01");
		/// </summary>
		void PlayMissionCompleteAudio(string audioName);
		bool IsMissionCompletePlaying();
		bool IsMissionCompleteReadyForUi();
		void BlockDeathJingle(bool toggle);
		/// <summary>
		/// Used to prepare a scene where the surrounding sound is muted or a bit changed. This does not play any sound.
		/// List of all usable scene names found in b617d. Sorted alphabetically and identical names removed: pastebin.com/MtM9N9CC
		/// </summary>
		bool StartAudioScene(string scene);
		void StopAudioScene(string scene);
		/// <summary>
		/// ??
		/// </summary>
		void StopAudioScenes();
		bool IsAudioSceneActive(string scene);
		void SetAudioSceneVariable(string scene, string unkVariable, float value);
		void SetAudioScriptCleanupTime(int time);
		/// <summary>
		/// All found occurrences in b678d:
		/// pastebin.com/ceu67jz8
		/// </summary>
		void AddEntityToAudioMixGroup(int entity, string groupName, float p2);
		void RemoveEntityFromAudioMixGroup(int entity, float p1);
		bool AudioIsScriptedMusicPlaying();
		int _0x2DD39BF3E2F9C47F();
		/// <summary>
		/// All music event names found in the b617d scripts: pastebin.com/GnYt0R3P
		/// </summary>
		bool PrepareMusicEvent(string eventName);
		/// <summary>
		/// All music event names found in the b617d scripts: pastebin.com/GnYt0R3P
		/// </summary>
		bool CancelMusicEvent(string eventName);
		/// <summary>
		/// List of all usable event names found in b617d used with this native. Sorted alphabetically and identical names removed: pastebin.com/RzDFmB1W
		/// All music event names found in the b617d scripts: pastebin.com/GnYt0R3P
		/// </summary>
		bool TriggerMusicEvent(string eventName);
		bool IsMusicOneshotPlaying();
		int GetMusicPlaytime();
		void _0x159B7318403A1CD8(int p0);
		void RecordBrokenGlass(float x, float y, float z, float radius);
		void ClearAllBrokenGlass();
		void _0x70B8EC8FC108A634(bool p0, int p1);
		void _0x149AEE66F0CB3A99(float p0, float p1);
		void _0x8BF907833BE275DE(float p0, float p1);
		void ForcePedPanicWalla();
		/// <summary>
		/// Example:
		/// bool prepareAlarm = AUDIO::PREPARE_ALARM("PORT_OF_LS_HEIST_FORT_ZANCUDO_ALARMS");
		/// </summary>
		bool PrepareAlarm(string alarmName);
		/// <summary>
		/// Example:
		/// This will start the alarm at Fort Zancudo.
		/// AUDIO::START_ALARM("PORT_OF_LS_HEIST_FORT_ZANCUDO_ALARMS", 1);
		/// First parameter (char) is the name of the alarm.
		/// Second parameter (bool) is unknown, it does not seem to make a difference if this one is 0 or 1.
		/// ----------
		/// It DOES make a difference but it has to do with the duration or something I dunno yet
		/// ----------
		/// Found in the b617d scripts:
		/// See NativeDB for reference: http://natives.altv.mp/#/0x0355EF116C4C97B2
		/// </summary>
		void StartAlarm(string alarmName, bool p2);
		/// <summary>
		/// Example:
		/// This will stop the alarm at Fort Zancudo.
		/// AUDIO::STOP_ALARM("PORT_OF_LS_HEIST_FORT_ZANCUDO_ALARMS", 1);
		/// First parameter (char) is the name of the alarm.
		/// Second parameter (bool) has to be true (1) to have any effect.
		/// </summary>
		void StopAlarm(string alarmName, bool toggle);
		void StopAllAlarms(bool stop);
		/// <summary>
		/// Example:
		/// bool playing = AUDIO::IS_ALARM_PLAYING("PORT_OF_LS_HEIST_FORT_ZANCUDO_ALARMS");
		/// </summary>
		bool IsAlarmPlaying(string alarmName);
		/// <summary>
		/// Returns hash of default vehicle horn
		/// Hash is stored in audVehicleAudioEntity
		/// </summary>
		int GetVehicleDefaultHorn(int vehicle);
		int GetVehicleDefaultHornIgnoreMods(int vehicle);
		void ResetPedAudioFlags(int ped);
		/// <summary>
		/// Enables/disables ped's "loud" footstep sound.
		/// </summary>
		void SetPedAudioFootstepLoud(int ped, bool toggle);
		/// <summary>
		/// Enables/disables ped's "quiet" footstep sound.
		/// </summary>
		void SetPedAudioFootstepQuiet(int ped, bool toggle);
		/// <summary>
		/// Sets audio flag "OverridePlayerGroundMaterial"
		/// </summary>
		void OverridePlayerGroundMaterial(int hash, bool toggle);
		/// <summary>
		/// Something like UPDATE_PED_*
		/// </summary>
		void _0xBF4DC1784BE94DFA(int ped, bool p1, int hash);
		/// <summary>
		/// Sets audio flag "OverrideMicrophoneSettings"
		/// </summary>
		void OverrideMicrophoneSettings(int hash, bool toggle);
		void FreezeMicrophone();
		/// <summary>
		/// If value is set to true, and ambient siren sound will be played.
		/// Appears to enable/disable an audio flag.
		/// </summary>
		void DistantCopCarSirens(bool value);
		void _0x43FA0DFC5DF87815(int vehicle, bool p1);
		void _0xB81CF134AEB56FFB();
		/// <summary>
		/// Possible flag names:
		/// "ActivateSwitchWheelAudio"
		/// "AllowAmbientSpeechInSlowMo"
		/// "AllowCutsceneOverScreenFade"
		/// "AllowForceRadioAfterRetune"
		/// "AllowPainAndAmbientSpeechToPlayDuringCutscene"
		/// "AllowPlayerAIOnMission"
		/// "AllowPoliceScannerWhenPlayerHasNoControl"
		/// "AllowRadioDuringSwitch"
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB9EFD5C25018725A
		/// </summary>
		void SetAudioFlag(string flagName, bool toggle);
		int PrepareSynchronizedAudioEvent(string p0, int p1);
		/// <summary>
		/// </summary>
		bool PrepareSynchronizedAudioEventForScene(int p0, ref int p1);
		bool PlaySynchronizedAudioEvent(int p0);
		bool StopSynchronizedAudioEvent(int p0);
		/// <summary>
		/// </summary>
		void _0xC8EDE9BDBCCBA6D4(ref int p0, float p1, float p2, float p3);
		/// <summary>
		/// Sets the position of the audio event to the entity's position for one frame(?)
		/// if (l_8C3 == 0) {
		/// sub_27fd1(0, -1, 1);
		/// if (PED::IS_SYNCHRONIZED_SCENE_RUNNING(l_87D)) {
		/// AUDIO::STOP_SYNCHRONIZED_AUDIO_EVENT(l_87D);
		/// }
		/// if (sub_7dd(l_A00)) {
		/// AUDIO::_950A154B8DAB6185("PAP2_IG1_POPPYSEX", l_A00);
		/// }
		/// See NativeDB for reference: http://natives.altv.mp/#/0x950A154B8DAB6185
		/// </summary>
		void SetSynchronizedAudioEventPositionThisFrame(string p0, int p1);
		/// <summary>
		/// Needs to be called every frame.
		/// Audio mode to apply this frame: https://alloc8or.re/gta5/doc/enums/audSpecialEffectMode.txt
		/// </summary>
		void SetAudioSpecialEffectMode(int mode);
		/// <summary>
		/// Found in the b617d scripts, duplicates removed:
		/// AUDIO::_044DBAD7A7FA2BE5("V_CARSHOWROOM_PS_WINDOW_UNBROKEN", "V_CARSHOWROOM_PS_WINDOW_BROKEN");
		/// AUDIO::_044DBAD7A7FA2BE5("V_CIA_PS_WINDOW_UNBROKEN", "V_CIA_PS_WINDOW_BROKEN");
		/// AUDIO::_044DBAD7A7FA2BE5("V_DLC_HEIST_APARTMENT_DOOR_CLOSED", "V_DLC_HEIST_APARTMENT_DOOR_OPEN");
		/// AUDIO::_044DBAD7A7FA2BE5("V_FINALEBANK_PS_VAULT_INTACT", "V_FINALEBANK_PS_VAULT_BLOWN");
		/// AUDIO::_044DBAD7A7FA2BE5("V_MICHAEL_PS_BATHROOM_WITH_WINDOW", "V_MICHAEL_PS_BATHROOM_WITHOUT_WINDOW");
		/// </summary>
		void SetPortalSettingsOverride(string p0, string p1);
		/// <summary>
		/// Found in the b617d scripts, duplicates removed:
		/// AUDIO::_B4BBFD9CD8B3922B("V_CARSHOWROOM_PS_WINDOW_UNBROKEN");
		/// AUDIO::_B4BBFD9CD8B3922B("V_CIA_PS_WINDOW_UNBROKEN");
		/// AUDIO::_B4BBFD9CD8B3922B("V_DLC_HEIST_APARTMENT_DOOR_CLOSED");
		/// AUDIO::_B4BBFD9CD8B3922B("V_FINALEBANK_PS_VAULT_INTACT");
		/// AUDIO::_B4BBFD9CD8B3922B("V_MICHAEL_PS_BATHROOM_WITH_WINDOW");
		/// </summary>
		void RemovePortalSettingsOverride(string p0);
		/// <summary>
		/// STOP_S[MOKE_GRENADE_EXPLOSION_SOUNDS]?
		/// </summary>
		void _0xE4E6DD5566D28C82();
		int GetMusicVolSlider();
		void RequestTennisBanks(int ped);
		void UnrequestTennisBanks();
		void _0xBEF34B1D9624D5DD(bool p0);
		void StopCutsceneAudio();
		/// <summary>
		/// HAS_*
		/// </summary>
		bool HasMultiplayerAudioDataLoaded();
		/// <summary>
		/// HAS_*
		/// </summary>
		bool HasMultiplayerAudioDataUnloaded();
		int GetVehicleDefaultHornVariation(int vehicle);
		void SetVehicleHornVariation(int vehicle, int value);
		/// <summary>
		/// BRAIN::ADD_SCRIPT_TO_RANDOM_PED("pb_prostitute", ${s_f_y_hooker_01}, 100, 0);
		/// - Nacorpio
		/// -----
		/// Hardcoded to not work in Multiplayer.
		/// </summary>
		void AddScriptToRandomPed(string name, int model, float p2, float p3);
		/// <summary>
		/// Registers a script for any object with a specific model hash.
		/// BRAIN::REGISTER_OBJECT_SCRIPT_BRAIN("ob_telescope", ${prop_telescope_01}, 100, 4.0, -1, 9);
		/// - Nacorpio
		/// </summary>
		void RegisterObjectScriptBrain(string scriptName, int modelHash, int p2, float activationRange, int p4, int p5);
		bool IsObjectWithinBrainActivationRange(int @object);
		void RegisterWorldPointScriptBrain(string scriptName, float activationRange, int p2);
		/// <summary>
		/// Gets whether the world point the calling script is registered to is within desired range of the player.
		/// </summary>
		bool IsWorldPointWithinBrainActivationRange();
		void EnableScriptBrainSet(int brainSet);
		void DisableScriptBrainSet(int brainSet);
		void _0x0B40ED49D7D6FF84();
		/// <summary>
		/// Something like flush_all_scripts
		/// Most of time comes after NETWORK_END_TUTORIAL_SESSION() or before TERMINATE_THIS_THREAD()
		/// </summary>
		void _0x4D953DF78EBF8158();
		/// <summary>
		/// Possible values:
		/// act_cinema
		/// am_mp_carwash_launch
		/// am_mp_carwash_control
		/// am_mp_property_ext
		/// chop
		/// fairgroundHub
		/// launcher_BasejumpHeli
		/// launcher_BasejumpPack
		/// See NativeDB for reference: http://natives.altv.mp/#/0x6D6840CEE8845831
		/// </summary>
		void _0x6D6840CEE8845831(string action);
		/// <summary>
		/// Looks like a cousin of above function _6D6840CEE8845831 as it was found among them. Must be similar
		/// Here are possible values of argument -
		/// "ob_tv"
		/// "launcher_Darts"
		/// </summary>
		void _0x6E91B04E08773030(string action);
		/// <summary>
		/// If you have created a script (rendering) camera, and want to go back to the
		/// character (gameplay) camera, call this native with render set to 0.
		/// Setting ease to 1 will smooth the transition.
		/// </summary>
		/// <param name="ease">- smooth transition between the camera's positions</param>
		/// <param name="easeTime">- Time in milliseconds for the transition to happen</param>
		void RenderScriptCams(bool render, bool ease, int easeTime, bool p3, bool p4, int p5);
		/// <summary>
		/// This native makes the gameplay camera zoom into first person/third person with a special effect.
		/// </summary>
		void StopRenderingScriptCamsUsingCatchUp(bool render, float p1, int p2, int p3);
		/// <summary>
		/// "DEFAULT_SCRIPTED_CAMERA"
		/// "DEFAULT_ANIMATED_CAMERA"
		/// "DEFAULT_SPLINE_CAMERA"
		/// "DEFAULT_SCRIPTED_FLY_CAMERA"
		/// "TIMED_SPLINE_CAMERA"
		/// </summary>
		int CreateCam(string camName, bool p1);
		/// <summary>
		/// ------------
		/// Camera names found in the b617d scripts:
		/// "DEFAULT_ANIMATED_CAMERA"
		/// "DEFAULT_SCRIPTED_CAMERA"
		/// "DEFAULT_SCRIPTED_FLY_CAMERA"
		/// "DEFAULT_SPLINE_CAMERA"
		/// ------------
		/// Side Note: It seems p8 is basically to represent what would be the bool p1 within CREATE_CAM native. As well as the p9 since it's always 2 in scripts seems to represent what would be the last param within SET_CAM_ROT native which normally would be 2.
		/// </summary>
		/// <param name="camName">is always set to "DEFAULT_SCRIPTED_CAMERA" in Rockstar's scripts.</param>
		int CreateCamWithParams(string camName, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float fov, bool p8, int p9);
		int CreateCamera(int camHash, bool p1);
		/// <summary>
		/// CAM::_80EC114669DAEFF4() can be used instead of p7 (Possible p7 is FOV parameter. )
		/// </summary>
		/// <param name="p8">???</param>
		/// <param name="p9">uses 2 by default</param>
		int CreateCameraWithParams(int camHash, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float fov, bool p8, int p9);
		/// <summary>
		/// BOOL param indicates whether the cam should be destroyed if it belongs to the calling script.
		/// </summary>
		void DestroyCam(int cam, bool bScriptHostCam);
		/// <summary>
		/// BOOL param indicates whether the cam should be destroyed if it belongs to the calling script.
		/// </summary>
		void DestroyAllCams(bool bScriptHostCam);
		/// <summary>
		/// Returns whether or not the passed camera handle exists.
		/// </summary>
		bool DoesCamExist(int cam);
		/// <summary>
		/// Set camera as active/inactive.
		/// </summary>
		void SetCamActive(int cam, bool active);
		/// <summary>
		/// Returns whether or not the passed camera handle is active.
		/// </summary>
		bool IsCamActive(int cam);
		bool IsCamRendering(int cam);
		int GetRenderingCam();
		Vector3 GetCamCoord(int cam);
		/// <summary>
		/// The last parameter, as in other "ROT" methods, is usually 2.
		/// </summary>
		Vector3 GetCamRot(int cam, int rotationOrder);
		float GetCamFov(int cam);
		float GetCamNearClip(int cam);
		float GetCamFarClip(int cam);
		float GetCamFarDof(int cam);
		void SetCamParams(int cam, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float fieldOfView, int p8, int p9, int p10, int p11);
		/// <summary>
		/// Sets the position of the cam.
		/// </summary>
		void SetCamCoord(int cam, float posX, float posY, float posZ);
		/// <summary>
		/// Sets the rotation of the cam.
		/// Last parameter unknown.
		/// Last parameter seems to always be set to 2.
		/// </summary>
		void SetCamRot(int cam, float rotX, float rotY, float rotZ, int rotationOrder);
		/// <summary>
		/// Sets the field of view of the cam.
		/// ---------------------------------------------
		/// Min: 1.0f
		/// Max: 130.0f
		/// </summary>
		void SetCamFov(int cam, float fieldOfView);
		void SetCamNearClip(int cam, float nearClip);
		void SetCamFarClip(int cam, float farClip);
		void _0xAABD62873FFB1A33(int p0, int p1);
		void SetCamMotionBlurStrength(int cam, float strength);
		void SetCamNearDof(int cam, float nearDOF);
		void SetCamFarDof(int cam, float farDOF);
		void SetCamDofStrength(int cam, float dofStrength);
		void SetCamDofPlanes(int cam, float p1, float p2, float p3, float p4);
		void SetCamUseShallowDofMode(int cam, bool toggle);
		void SetUseHiDof();
		void _0xF55E4046F6F831DC(int p0, float p1);
		void _0xE111A7C0D200CBC5(int p0, float p1);
		/// <summary>
		/// This native has its name defined inside its codE
		/// </summary>
		void SetCamDofFnumberOfLens(int camera, float p1);
		/// <summary>
		/// Native name labeled within its code
		/// </summary>
		void SetCamDofFocalLengthMultiplier(int camera, float multiplier);
		/// <summary>
		/// This native has a name defined inside its code
		/// </summary>
		void SetCamDofFocusDistanceBias(int camera, float p1);
		/// <summary>
		/// This native has a name defined inside its code
		/// </summary>
		void SetCamDofMaxNearInFocusDistance(int camera, float p1);
		/// <summary>
		/// This native has a name defined inside its code
		/// </summary>
		void SetCamDofMaxNearInFocusDistanceBlendLevel(int camera, float p1);
		/// <summary>
		/// Last param determines if its relative to the Entity
		/// </summary>
		void AttachCamToEntity(int cam, int entity, float xOffset, float yOffset, float zOffset, bool isRelative);
		void AttachCamToPedBone(int cam, int ped, int boneIndex, float x, float y, float z, bool heading);
		void AttachCamToPedBone2(int cam, int ped, int boneIndex, float p3, float p4, float p5, float p6, float p7, float p8, bool p9);
		void _0x202A5ED9CE01D6E7(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8);
		/// <summary>
		/// This native works with vehicles only. Bone indexes are usually given by this native GET_ENTITY_BONE_INDEX_BY_NAME.
		/// </summary>
		void AttachCamToVehicleBone(int cam, int vehicle, int boneIndex, bool relativeRotation, float rotX, float rotY, float rotZ, float offsetX, float offsetY, float offsetZ, bool fixedDirection);
		void DetachCam(int cam);
		/// <summary>
		/// The native seems to only be called once.
		/// The native is used as so,
		/// In the exile1 script.
		/// </summary>
		/// <param name="cam">:SET_CAM_INHERIT_ROLL_VEHICLE(l_544, getElem(2, &l_525, 4));</param>
		void SetCamInheritRollVehicle(int cam, bool p1);
		void PointCamAtCoord(int cam, float x, float y, float z);
		/// <summary>
		/// </summary>
		/// <param name="p5">always seems to be 1 i.e TRUE</param>
		void PointCamAtEntity(int cam, int entity, float p2, float p3, float p4, bool p5);
		/// <summary>
		/// Parameters p0-p5 seems correct. The bool p6 is unknown, but through every X360 script it's always 1. Please correct p0-p5 if any prove to be wrong.
		/// </summary>
		void PointCamAtPedBone(int cam, int ped, int boneIndex, float x, float y, float z, bool p6);
		void StopCamPointing(int cam);
		/// <summary>
		/// Allows you to aim and shoot at the direction the camera is facing.
		/// </summary>
		void SetCamAffectsAiming(int cam, bool toggle);
		/// <summary>
		/// SET_CAM_*
		/// </summary>
		void _0x661B5C8654ADD825(int cam, bool p1);
		void _0xA2767257A320FC82(int p0, bool p1);
		void _0x271017B9BA825366(int p0, bool p1);
		/// <summary>
		/// NOTE: Debugging functions are not present in the retail version of the game.
		/// </summary>
		void SetCamDebugName(int camera, string name);
		int GetDebugCamera();
		/// <summary>
		/// I filled p1-p6 (the floats) as they are as other natives with 6 floats in a row are similar and I see no other method. So if a test from anyone proves them wrong please correct.
		/// </summary>
		/// <param name="length">(length) determines the length of the spline, affects camera path and duration of transition between previous node and this one</param>
		/// <param name="p8">big values ~100 will slow down the camera movement before reaching this node</param>
		/// <param name="p9">!= 0 seems to override the rotation/pitch (bool?)</param>
		void AddCamSplineNode(int camera, float x, float y, float z, float xRot, float yRot, float zRot, int length, int p8, int p9);
		void AddCamSplineNodeUsingCameraFrame(int cam, int cam2, int p2, int p3);
		void AddCamSplineNodeUsingCamera(int cam, int cam2, int p2, int p3);
		void AddCamSplineNodeUsingGameplayFrame(int cam, int p1, int p2);
		void SetCamSplinePhase(int cam, float p1);
		/// <summary>
		/// Can use this with SET_CAM_SPLINE_PHASE to set the float it this native returns.
		/// (returns 1.0f when no nodes has been added, reached end of non existing spline)
		/// </summary>
		float GetCamSplinePhase(int cam);
		/// <summary>
		/// I'm pretty sure the parameter is the camera as usual, but I am not certain so I'm going to leave it as is.
		/// </summary>
		float GetCamSplineNodePhase(int cam);
		/// <summary>
		/// I named p1 as timeDuration as it is obvious. I'm assuming tho it is ran in ms(Milliseconds) as usual.
		/// </summary>
		void SetCamSplineDuration(int cam, int timeDuration);
		void SetCamSplineSmoothingStyle(int cam, int smoothingStyle);
		int GetCamSplineNodeIndex(int cam);
		void SetCamSplineNodeEase(int cam, int p1, int p2, float p3);
		void SetCamSplineNodeVelocityScale(int cam, int p1, float scale);
		void OverrideCamSplineVelocity(int cam, int p1, float p2, float p3);
		/// <summary>
		/// Max value for p1 is 15.
		/// </summary>
		void OverrideCamSplineMotionBlur(int cam, int p1, float p2, float p3);
		void SetCamSplineNodeExtraFlags(int cam, int p1, int flags);
		bool IsCamSplinePaused(int p0);
		/// <summary>
		/// Previous declaration void SET_CAM_ACTIVE_WITH_INTERP(Cam camTo, Cam camFrom, int duration, BOOL easeLocation, BOOL easeRotation) is completely wrong. The last two params are integers not BOOLs...
		/// </summary>
		void SetCamActiveWithInterp(int camTo, int camFrom, int duration, int easeLocation, int easeRotation);
		bool IsCamInterpolating(int cam);
		/// <summary>
		/// Possible shake types (updated b617d):
		/// DEATH_FAIL_IN_EFFECT_SHAKE
		/// DRUNK_SHAKE
		/// FAMILY5_DRUG_TRIP_SHAKE
		/// HAND_SHAKE
		/// JOLT_SHAKE
		/// LARGE_EXPLOSION_SHAKE
		/// MEDIUM_EXPLOSION_SHAKE
		/// SMALL_EXPLOSION_SHAKE
		/// See NativeDB for reference: http://natives.altv.mp/#/0x6A25241C340D3822
		/// </summary>
		void ShakeCam(int cam, string type, float amplitude);
		/// <summary>
		/// Example from michael2 script.
		/// </summary>
		/// <param name="cam">:ANIMATED_SHAKE_CAM(l_5069, "shake_cam_all@", "light", "", 1f);</param>
		void AnimatedShakeCam(int cam, string p1, string p2, string p3, float amplitude);
		bool IsCamShaking(int cam);
		void SetCamShakeAmplitude(int cam, float amplitude);
		void StopCamShaking(int cam, bool p1);
		/// <summary>
		/// CAM::SHAKE_SCRIPT_GLOBAL("HAND_SHAKE", 0.2);
		/// Full list of cam shake types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/camShakeTypesCompact.json
		/// </summary>
		void ShakeScriptGlobal(string p0, float p1);
		/// <summary>
		/// CAM::ANIMATED_SHAKE_SCRIPT_GLOBAL("SHAKE_CAM_medium", "medium", "", 0.5f);
		/// Full list of cam shake types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/camShakeTypesCompact.json
		/// </summary>
		void AnimatedShakeScriptGlobal(string p0, string p1, string p2, float p3);
		/// <summary>
		/// In drunk_controller.c4, sub_309
		/// if (CAM::IS_SCRIPT_GLOBAL_SHAKING()) {
		/// CAM::STOP_SCRIPT_GLOBAL_SHAKING(0);
		/// }
		/// </summary>
		bool IsScriptGlobalShaking();
		/// <summary>
		/// In drunk_controller.c4, sub_309
		/// if (CAM::IS_SCRIPT_GLOBAL_SHAKING()) {
		/// CAM::STOP_SCRIPT_GLOBAL_SHAKING(0);
		/// }
		/// </summary>
		void StopScriptGlobalShaking(bool p0);
		/// <summary>
		/// </summary>
		/// <param name="p1">0..16</param>
		void _0x5D96CFB59DA076A0(int vehicle, int p1, float p2);
		/// <summary>
		/// Atleast one time in a script for the zRot Rockstar uses GET_ENTITY_HEADING to help fill the parameter.
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		/// <param name="p9">is unknown at this time.</param>
		/// <param name="p10">throughout all the X360 Scripts is always 2.</param>
		bool PlayCamAnim(int cam, string animName, string animDictionary, float x, float y, float z, float xRot, float yRot, float zRot, bool p9, int p10);
		bool IsCamPlayingAnim(int cam, string animName, string animDictionary);
		void SetCamAnimCurrentPhase(int cam, float phase);
		float GetCamAnimCurrentPhase(int cam);
		/// <summary>
		/// Examples:
		/// CAM::PLAY_SYNCHRONIZED_CAM_ANIM(l_2734, NETWORK::_02C40BF885C567B6(l_2739), "PLAYER_EXIT_L_CAM", "mp_doorbell");
		/// CAM::PLAY_SYNCHRONIZED_CAM_ANIM(l_F0D[71], l_F4D[151], "ah3b_attackheli_cam2", "missheistfbi3b_helicrash");
		/// </summary>
		bool PlaySynchronizedCamAnim(int p0, int p1, string animName, string animDictionary);
		void SetFlyCamHorizontalResponse(int cam, float p1, float p2, float p3);
		void SetFlyCamVerticalSpeedMultiplier(int cam, float p1, float p2, float p3);
		void SetFlyCamMaxHeight(int cam, float height);
		void SetFlyCamCoordAndConstrain(int cam, float x, float y, float z);
		void _0xC8B5C4A79CC18B94(int cam);
		/// <summary>
		/// W*
		/// </summary>
		bool _0x5C48A1D6E3B33179(int cam);
		bool IsScreenFadedOut();
		bool IsScreenFadedIn();
		bool IsScreenFadingOut();
		bool IsScreenFadingIn();
		/// <summary>
		/// Fades the screen in.
		/// </summary>
		/// <param name="duration">The time the fade should take, in milliseconds.</param>
		void DoScreenFadeIn(int duration);
		/// <summary>
		/// Fades the screen out.
		/// </summary>
		/// <param name="duration">The time the fade should take, in milliseconds.</param>
		void DoScreenFadeOut(int duration);
		void SetWidescreenBorders(bool p0, int p1);
		/// <summary>
		/// A*
		/// </summary>
		bool _0x4879E4FE39074CDF();
		Vector3 GetGameplayCamCoord();
		/// <summary>
		/// 0-Pitch(X): -70.000092
		/// 0-Roll(Y): -0.000001
		/// 0-Yaw(Z): -43.886459
		/// 1-Pitch(X): -70.000092
		/// 1-Roll(Y): -0.000001
		/// 1-Yaw(Z): -43.886463
		/// 2-Pitch(X): -70.000092
		/// 2-Roll(Y): -0.000002
		/// 2-Yaw(Z): -43.886467
		/// </summary>
		/// <param name="rotationOrder">dosen't seem to change much, I tried it with 0, 1, 2:</param>
		Vector3 GetGameplayCamRot(int rotationOrder);
		float GetGameplayCamFov();
		/// <summary>
		/// some camera effect that is used in the drunk-cheat, and turned off (by setting it to 0.0) along with the shaking effects once the drunk cheat is disabled.
		/// </summary>
		void _0x487A82C650EB7799(float p0);
		/// <summary>
		/// some camera effect that is (also) used in the drunk-cheat, and turned off (by setting it to 0.0) along with the shaking effects once the drunk cheat is disabled. Possibly a cinematic or script-cam version of _0x487A82C650EB7799
		/// </summary>
		void _0x0225778816FDC28C(float p0);
		float GetGameplayCamRelativeHeading();
		/// <summary>
		/// Sets the camera position relative to heading in float from -360 to +360.
		/// </summary>
		/// <param name="heading">is alwyas 0 in aiming camera.</param>
		void SetGameplayCamRelativeHeading(float heading);
		float GetGameplayCamRelativePitch();
		/// <summary>
		/// This native sets the camera's pitch (rotation on the x-axis).
		/// </summary>
		void SetGameplayCamRelativePitch(float angle, float scalingFactor);
		void SetGameplayCamRelativeRotation(float roll, float pitch, float yaw);
		/// <summary>
		/// F*
		/// </summary>
		void _0x28B022A17B068A3A(float p0, float p1);
		/// <summary>
		/// Does nothing
		/// </summary>
		void SetGameplayCamRawYaw(float yaw);
		void SetGameplayCamRawPitch(float pitch);
		void _0x469F2ECDEC046337(bool p0);
		/// <summary>
		/// Possible shake types (updated b617d):
		/// DEATH_FAIL_IN_EFFECT_SHAKE
		/// DRUNK_SHAKE
		/// FAMILY5_DRUG_TRIP_SHAKE
		/// HAND_SHAKE
		/// JOLT_SHAKE
		/// LARGE_EXPLOSION_SHAKE
		/// MEDIUM_EXPLOSION_SHAKE
		/// SMALL_EXPLOSION_SHAKE
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFD55E49555E017CF
		/// </summary>
		void ShakeGameplayCam(string shakeName, float intensity);
		bool IsGameplayCamShaking();
		/// <summary>
		/// Sets the amplitude for the gameplay (i.e. 3rd or 1st) camera to shake. Used in script "drunk_controller.ysc.c4" to simulate making the player drunk.
		/// </summary>
		void SetGameplayCamShakeAmplitude(float amplitude);
		void StopGameplayCamShaking(bool p0);
		void SetGameplayCamFollowPedThisUpdate(int ped);
		/// <summary>
		/// - During busted screen.
		/// - When player is coming out from a hospital.
		/// - When player is coming out from a police station.
		/// - When player is buying gun from AmmuNation.
		/// </summary>
		/// <returns>Examples when this function will return 0 are:</returns>
		bool IsGameplayCamRendering();
		bool _0x3044240D2E0FA842();
		bool _0x705A276EBFF3133D();
		void _0xDB90C6CCA48940F1(bool p0);
		/// <summary>
		/// Shows the crosshair even if it wouldn't show normally. Only works for one frame, so make sure to call it repeatedly.
		/// DISABLE_*
		/// </summary>
		void EnableCrosshairThisFrame();
		bool IsGameplayCamLookingBehind();
		void DisableCamCollisionForEntity(int entity);
		void DisableCamCollisionForObject(int entity);
		void _0xA7092AFE81944852();
		void _0xFD3151CD37EA2245(int entity);
		/// <summary>
		/// Sets some flag on cinematic camera
		/// </summary>
		void _0xB1381B97F70C7B30();
		void _0xDD79DF9F4D26E1C9();
		bool IsSphereVisible(float x, float y, float z, float radius);
		bool IsFollowPedCamActive();
		/// <summary>
		/// From the scripts:
		/// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_ATTACHED_TO_ROPE_CAMERA", 0);
		/// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_ON_EXILE1_LADDER_CAMERA", 1500);
		/// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_SKY_DIVING_CAMERA", 0);
		/// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_SKY_DIVING_CAMERA", 3000);
		/// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_SKY_DIVING_FAMILY5_CAMERA", 0);
		/// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_SKY_DIVING_CAMERA", 0);
		/// </summary>
		bool SetFollowPedCamThisUpdate(string camName, int p1);
		void _0x271401846BD26E92(bool p0, bool p1);
		void _0xC8391C309684595A();
		/// <summary>
		/// Clamps the gameplay camera's current yaw.
		/// Eg. _CLAMP_GAMEPLAY_CAM_YAW(0.0f, 0.0f) will set the horizontal angle directly behind the player.
		/// </summary>
		/// <param name="minimum">Degrees between -180f and 180f.</param>
		/// <param name="maximum">Degrees between -180f and 180f.</param>
		void ClampGameplayCamYaw(float minimum, float maximum);
		/// <summary>
		/// Clamps the gameplay camera's current pitch.
		/// Eg. _CLAMP_GAMEPLAY_CAM_PITCH(0.0f, 0.0f) will set the vertical angle directly behind the player.
		/// </summary>
		/// <param name="minimum">Degrees between -90f and 90f.</param>
		/// <param name="maximum">Degrees between -90f and 90f.</param>
		void ClampGameplayCamPitch(float minimum, float maximum);
		/// <summary>
		/// Seems to animate the gameplay camera zoom.
		/// Eg. _ANIMATE_GAMEPLAY_CAM_ZOOM(1f, 1000f);
		/// will animate the camera zooming in from 1000 meters away.
		/// Game scripts use it like this:
		/// // Setting this to 1 prevents V key from changing zoom
		/// PLAYER::SET_PLAYER_FORCED_ZOOM(PLAYER::PLAYER_ID(), 1);
		/// // These restrict how far you can move cam up/down left/right
		/// CAM::_CLAMP_GAMEPLAY_CAM_YAW(-20f, 50f);
		/// CAM::_CLAMP_GAMEPLAY_CAM_PITCH(-60f, 0f);
		/// CAM::_ANIMATE_GAMEPLAY_CAM_ZOOM(1f, 1f);
		/// </summary>
		void AnimateGameplayCamZoom(float p0, float distance);
		void SetInVehicleCamStateThisUpdate(int p0, int p1);
		/// <summary>
		/// Disables first person camera for the current frame.
		/// Found in decompiled scripts:
		/// GRAPHICS::DRAW_DEBUG_TEXT_2D("Disabling First Person Cam", 0.5, 0.8, 0.0, 0, 0, 255, 255);
		/// CAM::_DE2EF5DA284CC8DF();
		/// </summary>
		void DisableFirstPersonCamThisFrame();
		void _0x59424BD75174C9B1();
		/// <summary>
		/// B*
		/// </summary>
		void _0x9F97DA93681F87EA();
		int GetFollowPedCamZoomLevel();
		/// <summary>
		/// Returns
		/// 0 - Third Person Close
		/// 1 - Third Person Mid
		/// 2 - Third Person Far
		/// 4 - First Person
		/// </summary>
		int GetFollowPedCamViewMode();
		/// <summary>
		/// Sets the type of Player camera:
		/// 0 - Third Person Close
		/// 1 - Third Person Mid
		/// 2 - Third Person Far
		/// 4 - First Person
		/// </summary>
		void SetFollowPedCamViewMode(int viewMode);
		bool IsFollowVehicleCamActive();
		void _0x91EF6EE6419E5B97(bool p0);
		/// <summary>
		/// SET_FOLLOW_*
		/// </summary>
		void _0x9DFE13ECDC1EC196(bool p0, bool p1);
		bool _0x79C0E43EB9B944E2(int hash);
		int GetFollowVehicleCamZoomLevel();
		void SetFollowVehicleCamZoomLevel(int zoomLevel);
		/// <summary>
		/// Returns the type of camera:
		/// 0 - Third Person Close
		/// 1 - Third Person Mid
		/// 2 - Third Person Far
		/// 4 - First Person
		/// </summary>
		int GetFollowVehicleCamViewMode();
		/// <summary>
		/// Sets the type of Player camera in vehicles:
		/// 0 - Third Person Close
		/// 1 - Third Person Mid
		/// 2 - Third Person Far
		/// 4 - First Person
		/// </summary>
		void SetFollowVehicleCamViewMode(int viewMode);
		/// <summary>
		/// </summary>
		/// <param name="context">see _GET_CAM_ACTIVE_VIEW_MODE_CONTEXT</param>
		int GetCamViewModeForContext(int context);
		/// <summary>
		/// </summary>
		/// <param name="context">see _GET_CAM_ACTIVE_VIEW_MODE_CONTEXT</param>
		void SetCamViewModeForContext(int context, int viewMode);
		/// <summary>
		/// enum Context
		/// {
		/// ON_FOOT,
		/// IN_VEHICLE,
		/// ON_BIKE,
		/// IN_BOAT,
		/// IN_AIRCRAFT,
		/// IN_SUBMARINE,
		/// IN_HELI,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x19CAFA3C87F7C2FF
		/// </summary>
		int GetCamActiveViewModeContext();
		void UseStuntCameraThisFrame();
		/// <summary>
		/// Sets gameplay camera to hash
		/// </summary>
		void SetGameplayCamHash(string camName);
		void _0x0AA27680A0BD43FA();
		void SetFollowTurretSeatCam(int seatIndex);
		bool IsAimCamActive();
		/// <summary>
		/// IS_A*
		/// </summary>
		bool IsAimCamThirdPersonActive();
		bool IsFirstPersonAimCamActive();
		void DisableAimCamThisUpdate();
		float GetFirstPersonAimCamZoomFactor();
		void SetFirstPersonAimCamZoomFactor(float zoomFactor);
		void _0xCED08CBE8EBB97C7(float p0, float p1);
		void _0x2F7F2B26DD3F18EE(float p0, float p1);
		void SetFirstPersonCamPitchRange(float p0, float p1);
		void SetFirstPersonAimCamNearClipThisUpdate(float p0);
		void SetThirdPersonAimCamNearClipThisUpdate(float p0);
		void _0x4008EDF7D6E48175(bool p0);
		void _0x380B4968D1E09E55();
		Vector3 GetFinalRenderedCamCoord();
		/// <summary>
		/// Function is called faily often by CAM::CREATE_CAM_WITH_PARAMS
		/// </summary>
		/// <param name="rotationOrder">seems to consistently be 2 across scripts</param>
		Vector3 GetFinalRenderedCamRot(int rotationOrder);
		Vector3 GetFinalRenderedInWhenFriendlyRot(int player, int rotationOrder);
		/// <summary>
		/// Gets some camera fov
		/// </summary>
		float GetFinalRenderedCamFov();
		float GetFinalRenderedInWhenFriendlyFov(int player);
		float GetFinalRenderedCamNearClip();
		float GetFinalRenderedCamFarClip();
		float GetFinalRenderedCamNearDof();
		float GetFinalRenderedCamFarDof();
		float GetFinalRenderedCamMotionBlurStrength();
		void SetGameplayCoordHint(float x, float y, float z, int duration, int blendOutDuration, int blendInDuration, int unk);
		void SetGameplayPedHint(int p0, float x1, float y1, float z1, bool p4, int p5, int p6, int p7);
		/// <summary>
		/// Focuses the camera on the specified vehicle.
		/// </summary>
		void SetGameplayVehicleHint(int vehicle, float offsetX, float offsetY, float offsetZ, bool p4, int time, int easeInTime, int easeOutTime);
		void SetGameplayObjectHint(int p0, float p1, float p2, float p3, bool p4, int p5, int p6, int p7);
		/// <summary>
		/// </summary>
		/// <param name="p6">& p7 - possibly length or time</param>
		void SetGameplayEntityHint(int entity, float xOffset, float yOffset, float zOffset, bool p4, int p5, int p6, int p7, int p8);
		bool IsGameplayHintActive();
		void StopGameplayHint(bool p0);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void _0xCCD078C2665D2973(bool p0);
		void _0x247ACBC4ABBC9D1C(bool p0);
		int _0xBF72910D0F26F025();
		void SetGameplayHintFov(float FOV);
		void SetGameplayHintFollowDistanceScalar(float value);
		void SetGameplayHintBaseOrbitPitchOffset(float value);
		void SetGameplayHintAnimOffsetx(float xOffset);
		void SetGameplayHintAnimOffsety(float yOffset);
		void SetGameplayHintAnimCloseup(bool toggle);
		void SetCinematicButtonActive(bool p0);
		bool IsCinematicCamRendering();
		/// <summary>
		/// Full list of cam shake types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/camShakeTypesCompact.json
		/// </summary>
		/// <param name="p0">argument found in the b617d scripts: "DRUNK_SHAKE"</param>
		void ShakeCinematicCam(string p0, float p1);
		bool IsCinematicCamShaking();
		void SetCinematicCamShakeAmplitude(float p0);
		void StopCinematicCamShaking(bool p0);
		void DisableVehicleFirstPersonCamThisFrame();
		void _0x62ECFCFDEE7885D6();
		/// <summary>
		/// Resets the vehicle idle camera timer. Calling this in a loop will disable the idle camera.
		/// </summary>
		void InvalidateVehicleIdleCam();
		/// <summary>
		/// Resets the idle camera timer. Calling that in a loop once every few seconds is enough to disable the idle cinematic camera.
		/// </summary>
		void InvalidateIdleCam();
		bool IsCinematicIdleCamRendering();
		bool IsInVehicleCamDisabled();
		void CreateCinematicShot(int p0, int p1, int p2, int entity);
		bool IsCinematicShotActive(int p0);
		/// <summary>
		/// Only used once in carsteal3 with p0 set to -1096069633 (CAMERA_MAN_SHOT)
		/// </summary>
		void StopCinematicShot(int p0);
		void ForceCinematicRenderingThisUpdate(bool p0);
		void _0xDC9DA9E8789F5246();
		/// <summary>
		/// Toggles the vehicle cinematic cam; requires the player ped to be in a vehicle to work.
		/// </summary>
		void SetCinematicModeActive(bool toggle);
		int _0x1F2300CB7FA7B7F6();
		int _0x17FCA7199A530203();
		int _0xD7360051C885628B();
		/// <summary>
		/// Tests some cinematic camera flags
		/// </summary>
		bool IsCinematicCamActive();
		void _0x7B8A361C1813FBEF();
		void StopCutsceneCamShaking();
		void _0x324C5AA411DA7737(int p0);
		/// <summary>
		/// Hardcoded to only work in multiplayer.
		/// </summary>
		void _0x12DED8CA53D47EA5(float p0);
		int GetFocusPedOnScreen(float p0, int p1, float p2, float p3, float p4, float p5, float p6, int p7, int p8);
		void _0x5A43C76F7FC7BA5F();
		/// <summary>
		/// if p0 is 0, effect is cancelled
		/// if p0 is 1, effect zooms in, gradually tilts cam clockwise apx 30 degrees, wobbles slowly. Motion blur is active until cancelled.
		/// if p0 is 2, effect immediately tilts cam clockwise apx 30 degrees, begins to wobble slowly, then gradually tilts cam back to normal. The wobbling will continue until the effect is cancelled.
		/// </summary>
		void SetCamEffect(int p0);
		void _0x5C41E6BABC9E2112(int p0);
		/// <summary>
		/// From b617 scripts:
		/// CAM::_21E253A7F8DA5DFB("DINGHY");
		/// CAM::_21E253A7F8DA5DFB("ISSI2");
		/// CAM::_21E253A7F8DA5DFB("SPEEDO");
		/// </summary>
		void SetGameplayCamVehicleCamera(string vehicleName);
		void SetGameplayCamVehicleCameraName(int vehicleModel);
		int _0xEAF0FA793D05C592();
		void _0x62374889A4D59F72();
		float ReplayFreeCamGetMaxRange();
		/// <summary>
		/// SET_CLOCK_TIME(12, 34, 56);
		/// </summary>
		void SetClockTime(int hour, int minute, int second);
		void PauseClock(bool toggle);
		void AdvanceClockTimeTo(int hour, int minute, int second);
		void AddToClockTime(int hours, int minutes, int seconds);
		/// <summary>
		/// Gets the current ingame hour, expressed without zeros. (09:34 will be represented as 9)
		/// </summary>
		int GetClockHours();
		/// <summary>
		/// Gets the current ingame clock minute.
		/// </summary>
		int GetClockMinutes();
		/// <summary>
		/// Gets the current ingame clock second. Note that ingame clock seconds change really fast since a day in GTA is only 48 minutes in real life.
		/// </summary>
		int GetClockSeconds();
		void SetClockDate(int day, int month, int year);
		/// <summary>
		/// Gets the current day of the week.
		/// 0: Sunday
		/// 1: Monday
		/// 2: Tuesday
		/// 3: Wednesday
		/// 4: Thursday
		/// 5: Friday
		/// 6: Saturday
		/// </summary>
		int GetClockDayOfWeek();
		int GetClockDayOfMonth();
		int GetClockMonth();
		int GetClockYear();
		int GetMillisecondsPerGameMinute();
		/// <summary>
		/// Gets system time as year, month, day, hour, minute and second.
		/// Example usage:
		/// int year;
		/// int month;
		/// int day;
		/// int hour;
		/// int minute;
		/// int second;
		/// </summary>
		void GetPosixTime(ref int year, ref int month, ref int day, ref int hour, ref int minute, ref int second);
		/// <summary>
		/// Gets current UTC time
		/// </summary>
		void GetUtcTime(ref int year, ref int month, ref int day, ref int hour, ref int minute, ref int second);
		/// <summary>
		/// Gets local system time as year, month, day, hour, minute and second.
		/// Example usage:
		/// int year;
		/// int month;
		/// int day;
		/// int hour;
		/// int minute;
		/// int second;
		/// or use std::tm struct
		/// </summary>
		void GetLocalTime(ref int year, ref int month, ref int day, ref int hour, ref int minute, ref int second);
		/// <summary>
		/// </summary>
		/// <param name="flags">Usually 8</param>
		void RequestCutscene(string cutsceneName, int flags);
		/// <summary>
		/// Example: 0x105 (bit 0, 2 and 8 set) will enable scene 1, 3 and 9.
		/// </summary>
		/// <param name="playbackFlags">Which scenes should be played.</param>
		/// <param name="flags">Usually 8</param>
		void RequestCutsceneWithPlaybackList(string cutsceneName, int playbackFlags, int flags);
		void RemoveCutscene();
		bool HasCutsceneLoaded();
		bool HasThisCutsceneLoaded(string cutsceneName);
		/// <summary>
		/// SET_SCRIPT_*
		/// Sets the cutscene's owning thread ID.
		/// </summary>
		void _0x8D9DF6ECA8768583(int threadId);
		bool CanRequestAssetsForCutsceneEntity();
		bool IsCutscenePlaybackFlagSet(int flag);
		void SetCutsceneEntityStreamingFlags(string cutsceneEntName, int p1, int p2);
		/// <summary>
		/// Simply loads the cutscene and doesn't do extra stuff that REQUEST_CUTSCENE does.
		/// </summary>
		void RequestCutFile(string cutsceneName);
		/// <summary>
		/// Simply checks if the cutscene has loaded and doesn't check via CutSceneManager as opposed to HAS_[THIS]_CUTSCENE_LOADED.
		/// </summary>
		bool HasCutFileLoaded(string cutsceneName);
		/// <summary>
		/// Simply unloads the cutscene and doesn't do extra stuff that REMOVE_CUTSCENE does.
		/// </summary>
		void RemoveCutFile(string cutsceneName);
		/// <summary>
		/// Jenkins hash probably is 0xFD8B1AC2
		/// </summary>
		int GetCutFileNumSections(string cutsceneName);
		/// <summary>
		/// </summary>
		/// <param name="flags">Usually 0.</param>
		void StartCutscene(int flags);
		/// <summary>
		/// </summary>
		/// <param name="flags">Usually 0.</param>
		void StartCutsceneAtCoords(float x, float y, float z, int flags);
		void StopCutscene(bool p0);
		void StopCutsceneImmediately();
		/// <summary>
		/// </summary>
		/// <param name="p3">could be heading. Needs more research.</param>
		void SetCutsceneOrigin(float x, float y, float z, float p3, int p4);
		void _0x011883F41211432A(float x1, float y1, float z1, float x2, float y2, float z2, int p6);
		int GetCutsceneTime();
		int GetCutsceneTotalDuration();
		/// <summary>
		/// GET_CUTSCENE_*
		/// </summary>
		int _0x971D7B15BCDBEF99();
		bool WasCutsceneSkipped();
		bool HasCutsceneFinished();
		bool IsCutsceneActive();
		bool IsCutscenePlaying();
		int GetCutsceneSectionPlaying();
		int GetEntityIndexOfCutsceneEntity(string cutsceneEntName, int modelHash);
		int _0x583DF8E3D4AFBD98();
		/// <summary>
		/// </summary>
		/// <returns>This function is hard-coded to always return 1.</returns>
		bool _0x4CEBC1ED31E8925E(string cutsceneName);
		int _0x4FCD976DA686580C(int p0);
		void RegisterEntityForCutscene(int cutscenePed, string cutsceneEntName, int p2, int modelHash, int p4);
		int GetEntityIndexOfRegisteredEntity(string cutsceneEntName, int modelHash);
		/// <summary>
		/// SET_VEHICLE_*
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		void _0x7F96F23FA9B73327(int modelHash);
		/// <summary>
		/// Only used twice in R* scripts
		/// </summary>
		void SetCutsceneTriggerArea(float p0, float p1, float p2, float p3, float p4, float p5);
		/// <summary>
		/// </summary>
		/// <param name="modelHash">(p1) was always 0 in R* scripts</param>
		bool CanSetEnterStateForRegisteredEntity(string cutsceneEntName, int modelHash);
		bool CanSetExitStateForRegisteredEntity(string cutsceneEntName, int modelHash);
		bool CanSetExitStateForCamera(bool p0);
		/// <summary>
		/// Toggles a value (bool) for cutscenes.
		/// SET_*
		/// </summary>
		void _0xC61B86C9F61EB404(bool toggle);
		void SetCutsceneFadeValues(bool p0, bool p1, bool p2, bool p3);
		void _0x20746F7B1032A3C7(bool p0, bool p1, bool p2, bool p3);
		void _0x06EE9048FD080382(bool p0);
		int _0xA0FE76168A189DDB();
		void _0x2F137B508DE238F2(bool p0);
		void _0xE36A98D8AB3D3C66(bool p0);
		int _0x5EDEF0CF8C1DAB3C();
		void SetCutsceneCanBeSkipped(bool p0);
		void RegisterSynchronisedScriptSpeech();
		/// <summary>
		/// Full list of ped components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedComponentVariations.json
		/// </summary>
		void SetCutscenePedComponentVariation(string cutsceneEntName, int p1, int p2, int p3, int modelHash);
		void SetCutscenePedComponentVariationFromPed(string cutsceneEntName, int ped, int modelHash);
		bool DoesCutsceneEntityExist(string cutsceneEntName, int modelHash);
		/// <summary>
		/// Thanks R*! ;)
		/// if ((l_161 == 0) || (l_161 == 2)) {
		/// sub_2ea27("Trying to set Jimmy prop variation");
		/// CUTSCENE::_0546524ADE2E9723("Jimmy_Boston", 1, 0, 0, 0);
		/// }
		/// Full list of ped components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedComponentVariations.json
		/// </summary>
		void SetCutscenePedPropVariation(string cutsceneEntName, int p1, int p2, int p3, int modelHash);
		/// <summary>
		/// HAS_CUTSCENE_*
		/// Possibly HAS_CUTSCENE_CUT_THIS_FRAME, needs more research.
		/// </summary>
		bool HasCutsceneCutThisFrame();
		/// <summary>
		/// Adds the given request ID to the watch list.
		/// </summary>
		void DatafileWatchRequestId(int id);
		void DatafileClearWatchList();
		bool DatafileIsValidRequestId(int index);
		bool DatafileHasLoadedFileData(int p0);
		bool DatafileHasValidFileData(int p0);
		bool DatafileSelectActiveFile(int p0, int p1);
		bool DatafileDeleteRequestedFile(int p0);
		/// <summary>
		/// </summary>
		bool UgcCreateContent(ref int data, int dataCount, string contentName, string description, string tagsCsv, string contentTypeName, bool publish, int p7);
		bool UgcCreateMission(string contentName, string description, string tagsCsv, string contentTypeName, bool publish, int p5);
		/// <summary>
		/// </summary>
		bool UgcUpdateContent(string contentId, ref int data, int dataCount, string contentName, string description, string tagsCsv, string contentTypeName, int p7);
		bool UgcUpdateMission(string contentId, string contentName, string description, string tagsCsv, string contentTypeName, int p5);
		bool UgcSetPlayerData(string contentId, float rating, string contentTypeName, int p3);
		bool DatafileSelectUgcData(int p0, int p1);
		bool DatafileSelectUgcStats(int p0, bool p1, int p2);
		bool DatafileSelectUgcPlayerData(int p0, int p1);
		/// <summary>
		/// if ((NETWORK::_597F8DBA9B206FC7() > 0) && DATAFILE::_01095C95CD46B624(0)) {
		/// v_10 = DATAFILE::_GET_ROOT_OBJECT();
		/// v_11 = DATAFILE::_OBJECT_VALUE_GET_INTEGER(v_10, "pt");
		/// sub_20202(2, v_11);
		/// a_0 += 1;
		/// } else {
		/// a_0 += 1;
		/// }
		/// </summary>
		bool DatafileSelectCreatorStats(int p0, int p1);
		/// <summary>
		/// Loads a User-Generated Content (UGC) file. These files can be found in "[GTA5]\data\ugc" and "[GTA5]\common\patch\ugc". They seem to follow a naming convention, most likely of "[name]_[part].ugc". See example below for usage.
		/// Returns whether or not the file was successfully loaded.
		/// Example:
		/// DATAFILE::_LOAD_UGC_FILE("RockstarPlaylists") // loads "rockstarplaylists_00.ugc"
		/// </summary>
		bool DatafileLoadOfflineUgc(string filename, int p1);
		void DatafileCreate(int p0);
		void DatafileDelete(int p0);
		void DatafileStoreMissionHeader(int p0);
		void DatafileFlushMissionHeader();
		string DatafileGetFileDict(int p0);
		bool DatafileStartSaveToCloud(string filename, int p1);
		/// <summary>
		/// </summary>
		bool DatafileUpdateSaveToCloud(ref bool p0);
		/// <summary>
		/// Example:
		/// if (!DATAFILE::_BEDB96A7584AA8CF())
		/// {
		/// if (!g_109E3)
		/// {
		/// if (((sub_d4f() == 2) == 0) && (!NETWORK::NETWORK_IS_GAME_IN_PROGRESS()))
		/// {
		/// if (NETWORK::NETWORK_IS_CLOUD_AVAILABLE())
		/// {
		/// See NativeDB for reference: http://natives.altv.mp/#/0xBEDB96A7584AA8CF
		/// </summary>
		bool DatafileIsSavePending();
		int _0xA6EEF01087181EDD(int p0, int p1);
		void _0x6AD0BD5E087866CB(int p0);
		int _0xDBF860CF1DB8E599(int p0);
		/// <summary>
		/// </summary>
		void DatadictSetBool(ref int objectData, string key, bool value);
		/// <summary>
		/// </summary>
		void DatadictSetInt(ref int objectData, string key, int value);
		/// <summary>
		/// </summary>
		void DatadictSetFloat(ref int objectData, string key, float value);
		/// <summary>
		/// </summary>
		void DatadictSetString(ref int objectData, string key, string value);
		/// <summary>
		/// </summary>
		void DatadictSetVector(ref int objectData, string key, float valueX, float valueY, float valueZ);
		/// <summary>
		/// </summary>
		int DatadictCreateDict(ref int objectData, string key);
		/// <summary>
		/// </summary>
		int DatadictCreateArray(ref int objectData, string key);
		/// <summary>
		/// </summary>
		bool DatadictGetBool(ref int objectData, string key);
		/// <summary>
		/// </summary>
		int DatadictGetInt(ref int objectData, string key);
		/// <summary>
		/// </summary>
		float DatadictGetFloat(ref int objectData, string key);
		/// <summary>
		/// </summary>
		string DatadictGetString(ref int objectData, string key);
		/// <summary>
		/// </summary>
		Vector3 DatadictGetVector(ref int objectData, string key);
		/// <summary>
		/// </summary>
		int DatadictGetDict(ref int objectData, string key);
		/// <summary>
		/// </summary>
		int DatadictGetArray(ref int objectData, string key);
		/// <summary>
		/// Types:
		/// 1 = Boolean
		/// 2 = Integer
		/// 3 = Float
		/// 4 = String
		/// 5 = Vector3
		/// 6 = Object
		/// 7 = Array
		/// </summary>
		int DatadictGetType(ref int objectData, string key);
		/// <summary>
		/// </summary>
		void DataarrayAddBool(ref int arrayData, bool value);
		/// <summary>
		/// </summary>
		void DataarrayAddInt(ref int arrayData, int value);
		/// <summary>
		/// </summary>
		void DataarrayAddFloat(ref int arrayData, float value);
		/// <summary>
		/// </summary>
		void DataarrayAddString(ref int arrayData, string value);
		/// <summary>
		/// </summary>
		void DataarrayAddVector(ref int arrayData, float valueX, float valueY, float valueZ);
		/// <summary>
		/// </summary>
		int DataarrayAddDict(ref int arrayData);
		/// <summary>
		/// </summary>
		bool DataarrayGetBool(ref int arrayData, int arrayIndex);
		/// <summary>
		/// </summary>
		int DataarrayGetInt(ref int arrayData, int arrayIndex);
		/// <summary>
		/// </summary>
		float DataarrayGetFloat(ref int arrayData, int arrayIndex);
		/// <summary>
		/// </summary>
		string DataarrayGetString(ref int arrayData, int arrayIndex);
		/// <summary>
		/// </summary>
		Vector3 DataarrayGetVector(ref int arrayData, int arrayIndex);
		/// <summary>
		/// </summary>
		int DataarrayGetDict(ref int arrayData, int arrayIndex);
		/// <summary>
		/// </summary>
		int DataarrayGetCount(ref int arrayData);
		/// <summary>
		/// Types:
		/// 1 = Boolean
		/// 2 = Integer
		/// 3 = Float
		/// 4 = String
		/// 5 = Vector3
		/// 6 = Object
		/// 7 = Array
		/// </summary>
		int DataarrayGetType(ref int arrayData, int arrayIndex);
		bool DecorSetTime(int entity, string propertyName, int timestamp);
		/// <summary>
		/// This function sets metadata of type bool to specified entity.
		/// </summary>
		bool DecorSetBool(int entity, string propertyName, bool value);
		bool DecorSetFloat(int entity, string propertyName, float value);
		/// <summary>
		/// Sets property to int.
		/// </summary>
		bool DecorSetInt(int entity, string propertyName, int value);
		bool DecorGetBool(int entity, string propertyName);
		float DecorGetFloat(int entity, string propertyName);
		int DecorGetInt(int entity, string propertyName);
		/// <summary>
		/// Returns whether or not the specified property is set for the entity.
		/// </summary>
		bool DecorExistOn(int entity, string propertyName);
		bool DecorRemove(int entity, string propertyName);
		/// <summary>
		/// https://alloc8or.re/gta5/doc/enums/eDecorType.txt
		/// </summary>
		void DecorRegister(string propertyName, int type);
		/// <summary>
		/// </summary>
		/// <param name="type">see DECOR_REGISTER</param>
		bool DecorIsRegisteredAsType(string propertyName, int type);
		/// <summary>
		/// Called after all decorator type initializations.
		/// </summary>
		void DecorRegisterLock();
		/// <summary>
		/// Only used once in scripts, in maintransition.
		/// maintransition.c4, line ~82432:
		/// if (PED::_7350823473013C02(PLAYER::PLAYER_PED_ID()) && (DECORATOR::_241FCA5B1AA14F75() == 0)) {
		/// g_2542A5 = a_1; // 'g_2542A5' used in 'building_controller.ysc' for IPL stuff?
		/// }
		/// Likely used solely for the players ped. The function it's in seems to only be used for initialization/quitting. Called among natives to discard scaleforms, disable frontend, fading in/out, etc. Neighboring strings to some calls include "HUD_JOINING", "HUD_QUITTING".
		/// Most likely ARE_*
		/// </summary>
		/// <returns>    return 1;</returns>
		bool _0x241FCA5B1AA14F75();
		/// <summary>
		/// Example:
		/// DLC::IS_DLC_PRESENT($\mpbusiness2\);
		/// ($ = gethashkey)
		/// bruteforce these:
		/// 0xB119F6D
		/// 0x96F02EE6
		/// </summary>
		bool IsDlcPresent(int dlcHash);
		bool _0xF2E07819EF1A5289();
		bool _0x9489659372A81585();
		bool _0xA213B11DFF526300();
		bool GetExtraContentPackHasBeenInstalled();
		bool GetIsLoadingScreenActive();
		/// <summary>
		/// GET_IS_LOADING_*
		/// </summary>
		bool _0xC4637A6D03C24CC3();
		/// <summary>
		/// Sets the value of the specified variable to 0.
		/// </summary>
		/// <returns>Always returns true.</returns>
		bool HasCloudRequestsFinished(ref bool p0, int unused);
		/// <summary>
		/// Unloads GROUP_MAP (GTAO/MP) DLC data and loads GROUP_MAP_SP DLC. Neither are loaded by default, 0888C3502DBBEEF5 is a cognate to this function and loads MP DLC (and unloads SP DLC by extension).
		/// The original (and wrong) definition is below:
		/// This unload the GTA:O DLC map parts (like high end garages/apartments).
		/// Works in singleplayer.
		/// </summary>
		void OnEnterSp();
		/// <summary>
		/// This loads the GTA:O dlc map parts (high end garages, apartments).
		/// Works in singleplayer.
		/// In order to use GTA:O heist IPL's you have to call this native with the following params: SET_INSTANCE_PRIORITY_MODE(1);
		/// </summary>
		void OnEnterMp();
		/// <summary>
		/// Checks whether an entity exists in the game world.
		/// </summary>
		bool DoesEntityExist(int entity);
		bool DoesEntityBelongToThisScript(int entity, bool p1);
		bool DoesEntityHaveDrawable(int entity);
		bool DoesEntityHavePhysics(int entity);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		/// <param name="p3">is always 3 as far as i cant tell</param>
		bool HasEntityAnimFinished(int entity, string animDict, string animName, int p3);
		bool HasEntityBeenDamagedByAnyObject(int entity);
		bool HasEntityBeenDamagedByAnyPed(int entity);
		bool HasEntityBeenDamagedByAnyVehicle(int entity);
		/// <summary>
		/// Entity 1 = Victim
		/// Entity 2 = Attacker
		/// </summary>
		/// <param name="p2">seems to always be 1</param>
		bool HasEntityBeenDamagedByEntity(int entity1, int entity2, bool p2);
		/// <summary>
		/// There is other codes used for traceType:
		/// 19 - in jewelry_prep1a
		/// 126 - in am_hunt_the_beast
		/// 256 & 287 - in fm_mission_controller
		/// </summary>
		/// <param name="traceType">is always 17 in the scripts.</param>
		bool HasEntityClearLosToEntity(int entity1, int entity2, int traceType);
		int HasEntityClearLosToEntity2(int entity1, int entity2, int traceType);
		/// <summary>
		/// Has the entity1 got a clear line of sight to the other entity2 from the direction entity1 is facing.
		/// This is one of the most CPU demanding BOOL natives in the game; avoid calling this in things like nested for-loops
		/// </summary>
		bool HasEntityClearLosToEntityInFront(int entity1, int entity2);
		/// <summary>
		/// Called on tick.
		/// Note: for vehicles, the wheels can touch the ground and it will still return false, but if the body of the vehicle touches the ground, it will return true.
		/// </summary>
		/// <returns>Tested with vehicles, returns true whenever the vehicle is touching any entity.</returns>
		bool HasEntityCollidedWithAnything(int entity);
		int GetLastMaterialHitByEntity(int entity);
		Vector3 GetCollisionNormalOfLastHitForEntity(int entity);
		/// <summary>
		/// Based on carmod_shop script decompile this takes a vehicle parameter. It is called when repair is done on initial enter.
		/// </summary>
		void ForceEntityAiAndAnimationUpdate(int entity);
		/// <summary>
		/// Returns a float value representing animation's current playtime with respect to its total playtime. This value increasing in a range from [0 to 1] and wrap back to 0 when it reach 1.
		/// Example:
		/// 0.000000 - mark the starting of animation.
		/// 0.500000 - mark the midpoint of the animation.
		/// 1.000000 - mark the end of animation.
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		float GetEntityAnimCurrentTime(int entity, string animDict, string animName);
		/// <summary>
		/// Returns a float value representing animation's total playtime in milliseconds.
		/// Example:
		/// GET_ENTITY_ANIM_TOTAL_TIME(PLAYER_ID(),"amb@world_human_yoga@female@base","base_b")
		/// return 20800.000000
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		float GetEntityAnimTotalTime(int entity, string animDict, string animName);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		float GetAnimDuration(string animDict, string animName);
		int GetEntityAttachedTo(int entity);
		/// <summary>
		/// Gets the current coordinates for a specified entity.
		/// `entity` = The entity to get the coordinates from.
		/// `alive` = Unused by the game, potentially used by debug builds of GTA in order to assert whether or not an entity was alive.
		/// </summary>
		Vector3 GetEntityCoords(int entity, bool alive);
		/// <summary>
		/// Gets the entity's forward vector.
		/// </summary>
		Vector3 GetEntityForwardVector(int entity);
		/// <summary>
		/// Gets the X-component of the entity's forward vector.
		/// </summary>
		float GetEntityForwardX(int entity);
		/// <summary>
		/// Gets the Y-component of the entity's forward vector.
		/// </summary>
		float GetEntityForwardY(int entity);
		/// <summary>
		/// Returns the heading of the entity in degrees. Also know as the "Yaw" of an entity.
		/// </summary>
		float GetEntityHeading(int entity);
		/// <summary>
		/// Gets the heading of the entity physics in degrees, which tends to be more accurate than just "GET_ENTITY_HEADING". This can be clearly seen while, for example, ragdolling a ped/player.
		/// NOTE: The name and description of this native are based on independent research. If you find this native to be more suitable under a different name and/or described differently, please feel free to do so.
		/// GET_ENTITY_HEADING_*
		/// </summary>
		float GetEntityPhysicsHeading(int entity);
		/// <summary>
		/// Returns an integer value of entity's current health.
		/// Example of range for ped:
		/// - Player [0 to 200]
		/// - Ped [100 to 200]
		/// - Vehicle [0 to 1000]
		/// - Object [0 to 1000]
		/// Health is actually a float value but this native casts it to int.
		/// In order to get the actual value, do:
		/// float health = *(float *)(entityAddress + 0x280);
		/// </summary>
		int GetEntityHealth(int entity);
		/// <summary>
		/// Return an integer value of entity's maximum health.
		/// Example:
		/// - Player = 200
		/// - Ped = 150
		/// </summary>
		int GetEntityMaxHealth(int entity);
		/// <summary>
		/// For instance: ENTITY::SET_ENTITY_MAX_HEALTH(PLAYER::PLAYER_PED_ID(), 200); // director_mode.c4: 67849
		/// </summary>
		void SetEntityMaxHealth(int entity, int value);
		float GetEntityHeight(int entity, float X, float Y, float Z, bool atTop, bool inWorldCoords);
		/// <summary>
		/// Return height (z-dimension) above ground.
		/// Example: The pilot in a titan plane is 1.844176 above ground.
		/// How can i convert it to meters?
		/// Everything seems to be in meters, probably this too.
		/// </summary>
		float GetEntityHeightAboveGround(int entity);
		/// <summary>
		/// </summary>
		void GetEntityMatrix(int entity, ref Vector3 forwardVector, ref Vector3 rightVector, ref Vector3 upVector, ref Vector3 position);
		/// <summary>
		/// Returns the model hash from the entity
		/// </summary>
		int GetEntityModel(int entity);
		/// <summary>
		/// Converts world coords (posX - Z) to coords relative to the entity
		/// Example:
		/// entity's x coord is 40
		/// the returned x coord will then be 10 or -10, not sure haven't used this in a while (think it is 10 though).
		/// </summary>
		/// <param name="posX">is given as 50</param>
		/// <param name="posY">is given as 50</param>
		/// <param name="posZ">is given as 50</param>
		Vector3 GetOffsetFromEntityGivenWorldCoords(int entity, float posX, float posY, float posZ);
		/// <summary>
		/// Offset values are relative to the entity.
		/// x = left/right
		/// y = forward/backward
		/// z = up/down
		/// </summary>
		Vector3 GetOffsetFromEntityInWorldCoords(int entity, float offsetX, float offsetY, float offsetZ);
		float GetEntityPitch(int entity);
		/// <summary>
		/// </summary>
		/// <param name="w">is the correct parameter name!</param>
		void GetEntityQuaternion(int entity, ref float x, ref float y, ref float z, ref float w);
		/// <summary>
		/// Displays the current ROLL axis of the entity [-180.0000/180.0000+]
		/// (Sideways Roll) such as a vehicle tipped on its side
		/// </summary>
		float GetEntityRoll(int entity);
		/// <summary>
		/// rotationOrder refers to the order yaw pitch roll is applied; value ranges from 0 to 5 and is usually *2* in scripts.
		/// What you use for rotationOrder when getting must be the same as rotationOrder when setting the rotation.
		/// What it returns is the yaw on the z part of the vector, which makes sense considering R* considers z as vertical. Here's a picture for those of you who don't understand pitch, yaw, and roll: www.allstar.fiu.edu/aero/images/pic5-1.gif
		/// Rotation Orders:
		/// 0: ZYX - Rotate around the z-axis, then the y-axis and finally the x-axis.
		/// 1: YZX - Rotate around the y-axis, then the z-axis and finally the x-axis.
		/// 2: ZXY - Rotate around the z-axis, then the x-axis and finally the y-axis.
		/// 3: XZY - Rotate around the x-axis, then the z-axis and finally the y-axis.
		/// 4: YXZ - Rotate around the y-axis, then the x-axis and finally the z-axis.
		/// 5: XYZ - Rotate around the x-axis, then the y-axis and finally the z-axis.
		/// </summary>
		/// <param name="rotationOrder">is the order yaw, pitch and roll is applied. Usually 2. Returns a vector where the Z coordinate is the yaw.</param>
		/// <returns>rotationOrder is the order yaw, pitch and roll is applied. Usually 2. Returns a vector where the Z coordinate is the yaw.</returns>
		Vector3 GetEntityRotation(int entity, int rotationOrder);
		Vector3 GetEntityRotationVelocity(int entity);
		/// <summary>
		/// </summary>
		/// <returns>All ambient entities in-world seem to have the same value for the second argument (Any *script), depending on when the scripthook was activated/re-activated. I've seen numbers from ~5 to almost 70 when the value was translated with to_string. The function return value seems to always be 0.</returns>
		string GetEntityScript(int entity, ref int script);
		/// <summary>
		/// result is in meters per second
		/// ------------------------------------------------------------
		/// So would the conversion to mph and km/h, be along the lines of this.
		/// float speed = GET_ENTITY_SPEED(veh);
		/// float kmh = (speed * 3.6);
		/// float mph = (speed * 2.236936);
		/// ------------------------------------------------------------
		/// </summary>
		float GetEntitySpeed(int entity);
		/// <summary>
		/// </summary>
		/// <param name="relative">can be used for getting speed relative to the frame of the vehicle, to determine for example, if you are going in reverse (-y speed) or not (+y speed).</param>
		Vector3 GetEntitySpeedVector(int entity, bool relative);
		float GetEntityUprightValue(int entity);
		Vector3 GetEntityVelocity(int entity);
		/// <summary>
		/// </summary>
		/// <returns>Simply returns whatever is passed to it (Regardless of whether the handle is valid or not).</returns>
		int GetObjectIndexFromEntityIndex(int entity);
		/// <summary>
		/// </summary>
		/// <returns>Simply returns whatever is passed to it (Regardless of whether the handle is valid or not).</returns>
		int GetPedIndexFromEntityIndex(int entity);
		/// <summary>
		/// </summary>
		/// <returns>Simply returns whatever is passed to it (Regardless of whether the handle is valid or not).</returns>
		int GetVehicleIndexFromEntityIndex(int entity);
		/// <summary>
		/// Returns the coordinates of an entity-bone.
		/// </summary>
		Vector3 GetWorldPositionOfEntityBone(int entity, int boneIndex);
		int GetNearestPlayerToEntity(int entity);
		int GetNearestPlayerToEntityOnTeam(int entity, int team);
		/// <summary>
		/// Returns:
		/// 0 = no entity
		/// 1 = ped
		/// 2 = vehicle
		/// 3 = object
		/// </summary>
		int GetEntityType(int entity);
		/// <summary>
		/// A population type, from the following enum: https://alloc8or.re/gta5/doc/enums/ePopulationType.txt
		/// </summary>
		int GetEntityPopulationType(int entity);
		bool IsAnEntity(int handle);
		bool IsEntityAPed(int entity);
		bool IsEntityAMissionEntity(int entity);
		bool IsEntityAVehicle(int entity);
		bool IsEntityAnObject(int entity);
		/// <summary>
		/// Checks if entity is within x/y/zSize distance of x/y/z.
		/// Last three are unknown ints, almost always p7 = 0, p8 = 1, p9 = 0
		/// </summary>
		bool IsEntityAtCoord(int entity, float xPos, float yPos, float zPos, float xSize, float ySize, float zSize, bool p7, bool p8, int p9);
		/// <summary>
		/// Checks if entity1 is within the box defined by x/y/zSize of entity2.
		/// Last three parameters are almost alwasy p5 = 0, p6 = 1, p7 = 0
		/// </summary>
		bool IsEntityAtEntity(int entity1, int entity2, float xSize, float ySize, float zSize, bool p5, bool p6, int p7);
		/// <summary>
		/// Whether the entity is attached to any other entity.
		/// </summary>
		bool IsEntityAttached(int entity);
		bool IsEntityAttachedToAnyObject(int entity);
		bool IsEntityAttachedToAnyPed(int entity);
		bool IsEntityAttachedToAnyVehicle(int entity);
		bool IsEntityAttachedToEntity(int from, int to);
		bool IsEntityDead(int entity, bool p1);
		bool IsEntityInAir(int entity);
		/// <summary>
		/// `p8` is a debug flag invoking functions in the same path as ``DRAW_MARKER``
		/// `p10` is some entity flag check, also used in `IS_ENTITY_AT_ENTITY`, `IS_ENTITY_IN_AREA`, and `IS_ENTITY_AT_COORD`.
		/// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
		/// </summary>
		bool IsEntityInAngledArea(int entity, float x1, float y1, float z1, float x2, float y2, float z2, float width, bool debug, bool includeZ, int p10);
		bool IsEntityInArea(int entity, float x1, float y1, float z1, float x2, float y2, float z2, bool p7, bool p8, int p9);
		/// <summary>
		/// Full list of zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/zones.json
		/// </summary>
		bool IsEntityInZone(int entity, string zone);
		bool IsEntityInWater(int entity);
		/// <summary>
		/// Get how much of the entity is submerged.  1.0f is whole entity.
		/// </summary>
		float GetEntitySubmergedLevel(int entity);
		/// <summary>
		/// SET_ENTITY_R*
		/// </summary>
		void _0x694E00132F2823ED(int entity, bool toggle);
		/// <summary>
		/// Returns true if the entity is in between the minimum and maximum values for the 2d screen coords.
		/// Chipping
		/// </summary>
		/// <returns>This means that it will return true even if the entity is behind a wall for example, as long as you're looking at their location. </returns>
		bool IsEntityOnScreen(int entity);
		/// <summary>
		/// See also PED::IS_SCRIPTED_SCENARIO_PED_USING_CONDITIONAL_ANIM 0x6EC47A344923E1ED 0x3C30B447
		/// Taken from ENTITY::IS_ENTITY_PLAYING_ANIM(PLAYER::PLAYER_PED_ID(), "creatures@shark@move", "attack_player", 3)
		/// p4 is always 3 in the scripts.
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		bool IsEntityPlayingAnim(int entity, string animDict, string animName, int taskFlag);
		/// <summary>
		/// a static ped will not react to natives like "APPLY_FORCE_TO_ENTITY" or "SET_ENTITY_VELOCITY" and oftentimes will not react to task-natives like "TASK::TASK_COMBAT_PED". The only way I know of to make one of these peds react is to ragdoll them (or sometimes to use CLEAR_PED_TASKS_IMMEDIATELY(). Static peds include almost all far-away peds, beach-combers, peds in certain scenarios, peds crossing a crosswalk, peds walking to get back into their cars, and others. If anyone knows how to make a ped non-static without ragdolling them, please edit this with the solution.
		/// how can I make an entity static???
		/// </summary>
		bool IsEntityStatic(int entity);
		bool IsEntityTouchingEntity(int entity, int targetEntity);
		bool IsEntityTouchingModel(int entity, int modelHash);
		bool IsEntityUpright(int entity, float angle);
		bool IsEntityUpsidedown(int entity);
		bool IsEntityVisible(int entity);
		bool IsEntityVisibleToScript(int entity);
		bool IsEntityOccluded(int entity);
		bool WouldEntityBeOccluded(int entityModelHash, float x, float y, float z, bool p4);
		bool IsEntityWaitingForWorldCollision(int entity);
		/// <summary>
		/// Applies a force to the specified entity.
		/// **List of force types (p1)**:
		/// public enum ForceType
		/// {
		/// MinForce = 0,
		/// MaxForceRot = 1,
		/// MinForce2 = 2,
		/// MaxForceRot2 = 3,
		/// ForceNoRot = 4,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x18FF00FC7EFF559E
		/// </summary>
		void ApplyForceToEntityCenterOfMass(int entity, int forceType, float x, float y, float z, bool p5, bool isDirectionRel, bool isForceRel, bool p8);
		/// <summary>
		/// Documented here:
		/// gtaforums.com/topic/885669-precisely-define-object-physics/
		/// gtaforums.com/topic/887362-apply-forces-and-momentums-to-entityobject/
		/// First bit (lowest): Strong force flag, factor 100
		/// Second bit: Unkown flag
		/// If higher bits are unequal 0 the function doesn't applay any forces at all.
		/// (As integer possible values are 0-7)
		/// 0: weak force
		/// 1: strong force
		/// See NativeDB for reference: http://natives.altv.mp/#/0xC5F68BE9613E2D18
		/// </summary>
		/// <param name="x">Momentum flag=1 (vector (x,y,z) is a momentum, more research needed)</param>
		/// <param name="y">Momentum flag=1 (vector (x,y,z) is a momentum, more research needed)</param>
		/// <param name="boneIndex">!!! Whenever I set this !=0, my script stopped.</param>
		void ApplyForceToEntity(int entity, int forceFlags, float x, float y, float z, float offX, float offY, float offZ, int boneIndex, bool isDirectionRel, bool ignoreUpVec, bool isForceRel, bool p12, bool p13);
		/// <summary>
		/// Attaches entity1 to bone (boneIndex) of entity2.
		/// </summary>
		/// <param name="boneIndex">- this is different to boneID, use GET_PED_BONE_INDEX to get the index from the ID. use the index for attaching to specific bones. entity1 will be attached to entity2's centre if bone index given doesn't correspond to bone indexes for that entity type.</param>
		/// <param name="useSoftPinning">- if set to false attached entity will not detach when fixed</param>
		/// <param name="collision">- controls collision between the two entities (FALSE disables collision).</param>
		/// <param name="isPed">- pitch doesnt work when false and roll will only work on negative numbers (only peds)</param>
		/// <param name="vertexIndex">- position of vertex</param>
		/// <param name="fixedRot">- if false it ignores entity vector</param>
		void AttachEntityToEntity(int entity1, int entity2, int boneIndex, float xPos, float yPos, float zPos, float xRot, float yRot, float zRot, bool p9, bool useSoftPinning, bool collision, bool isPed, int vertexIndex, bool fixedRot);
		void AttachEntityBoneToEntityBone(int entity1, int entity2, int boneIndex1, int boneIndex2, bool p4, bool p5);
		void AttachEntityBoneToEntityBonePhysically(int entity1, int entity2, int boneIndex1, int boneIndex2, bool p4, bool p5);
		/// <summary>
		/// </summary>
		/// <param name="breakForce">is the amount of force required to break the bond.</param>
		/// <param name="fixedRot">- is always 1 in scripts</param>
		/// <param name="p15">- is 1 or 0 in scripts - unknoun what it does</param>
		/// <param name="collision">- controls collision between the two entities (FALSE disables collision).</param>
		/// <param name="p17">- do not teleport entity to be attached to the position of the bone Index of the target entity (if 1, entity will not be teleported to target bone)</param>
		/// <param name="p18">- is always 2 in scripts.</param>
		void AttachEntityToEntityPhysically(int entity1, int entity2, int boneIndex1, int boneIndex2, float xPos1, float yPos1, float zPos1, float xPos2, float yPos2, float zPos2, float xRot, float yRot, float zRot, float breakForce, bool fixedRot, bool p15, bool collision, bool p17, int p18);
		/// <summary>
		/// Called to update entity attachments.
		/// </summary>
		void ProcessEntityAttachments(int entity);
		/// <summary>
		/// Returns the index of the bone. If the bone was not found, -1 will be returned.
		/// list:
		/// pastebin.com/D7JMnX1g
		/// BoneNames:
		/// chassis,
		/// windscreen,
		/// seat_pside_r,
		/// seat_dside_r,
		/// bodyshell,
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFB71170B7E76ACBA
		/// </summary>
		int GetEntityBoneIndexByName(int entity, string boneName);
		void ClearEntityLastDamageEntity(int entity);
		/// <summary>
		/// Deletes the specified entity, then sets the handle pointed to by the pointer to NULL.
		/// </summary>
		void DeleteEntity(ref int entity);
		/// <summary>
		/// If `collision` is set to true, both entities won't collide with the other until the distance between them is above 4 meters.
		/// Set `dynamic` to true to keep velocity after dettaching
		/// </summary>
		void DetachEntity(int entity, bool dynamic, bool collision);
		/// <summary>
		/// Freezes or unfreezes an entity preventing its coordinates to change by the player if set to `true`. You can still change the entity position using SET_ENTITY_COORDS.
		/// </summary>
		void FreezeEntityPosition(int entity, bool toggle);
		/// <summary>
		/// True means it can be deleted by the engine when switching lobbies/missions/etc, false means the script is expected to clean it up.
		/// </summary>
		void SetEntityCleanupByEngine(int entity, bool toggle);
		/// <summary>
		/// The only time bitset has a value is 0x4000 and the only time delta has a value is during stealth with usually <1.0f values.
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		/// <param name="delta">and bitset are guessed fields. They are based on the fact that most of the calls have 0 or nil field types passed in.</param>
		bool PlayEntityAnim(int entity, string animName, string animDict, float p3, bool loop, bool stayInAnim, bool p6, float delta, int bitset);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		/// <param name="p4">and p7 are usually 1000.0f.</param>
		bool PlaySynchronizedEntityAnim(int entity, int syncedScene, string animation, string propName, float p4, float p5, int p6, float p7);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		bool PlaySynchronizedMapEntityAnim(float p0, float p1, float p2, float p3, int p4, int p5, ref int p6, ref int p7, float p8, float p9, int p10, float p11);
		bool StopSynchronizedMapEntityAnim(float p0, float p1, float p2, float p3, int p4, float p5);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// RAGEPluginHook list: docs.ragepluginhook.net/html/62951c37-a440-478c-b389-c471230ddfc5.htm
		/// </summary>
		int StopEntityAnim(int entity, string animation, string animGroup, float p3);
		/// <summary>
		/// </summary>
		/// <param name="p1">sync task id?</param>
		bool StopSynchronizedEntityAnim(int entity, float p1, bool p2);
		/// <summary>
		/// if (ENTITY::HAS_ANIM_EVENT_FIRED(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("CreateObject")))
		/// </summary>
		bool HasAnimEventFired(int entity, int actionHash);
		/// <summary>
		/// In the script "player_scene_t_bbfight.c4":
		/// "if (ENTITY::FIND_ANIM_EVENT_PHASE(&l_16E, &l_19F[v_416], v_9, &v_A, &v_B))"
		/// -- &l_16E (p0) is requested as an anim dictionary earlier in the script.
		/// -- &l_19F[v_416] (p1) is used in other natives in the script as the "animation" param.
		/// -- v_9 (p2) is instantiated as "victim_fall"; I'm guessing that's another anim
		/// --v_A and v_B (p3 & p4) are both set as -1.0, but v_A is used immediately after this native for:
		/// "if (v_A < ENTITY::GET_ENTITY_ANIM_CURRENT_TIME(...))"
		/// Both v_A and v_B are seemingly used to contain both Vector3's and floats, so I can't say what either really is other than that they are both output parameters. p4 looks more like a *Vector3 though
		/// -alphazolam
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		bool FindAnimEventPhase(string animDictionary, string animName, string p2, ref int p3, ref int p4);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void SetEntityAnimCurrentTime(int entity, string animDictionary, string animName, float time);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void SetEntityAnimSpeed(int entity, string animDictionary, string animName, float speedMultiplier);
		/// <summary>
		/// Makes the specified entity (ped, vehicle or object) persistent. Persistent entities will not automatically be removed by the engine.
		/// maybe a quick disassembly will tell us what it does
		/// maybe a quick disassembly will tell us what it does
		/// </summary>
		/// <param name="p1">has no effect when either its on or off</param>
		/// <param name="p2">has no effect when either its on or off</param>
		void SetEntityAsMissionEntity(int entity, bool p1, bool p2);
		/// <summary>
		/// Marks the specified entity (ped, vehicle or object) as no longer needed.
		/// Entities marked as no longer needed, will be deleted as the engine sees fit.
		/// </summary>
		void SetEntityAsNoLongerNeeded(ref int entity);
		/// <summary>
		/// This is an alias of SET_ENTITY_AS_NO_LONGER_NEEDED.
		/// </summary>
		void SetPedAsNoLongerNeeded(ref int ped);
		/// <summary>
		/// This is an alias of SET_ENTITY_AS_NO_LONGER_NEEDED.
		/// </summary>
		void SetVehicleAsNoLongerNeeded(ref int vehicle);
		/// <summary>
		/// This is an alias of SET_ENTITY_AS_NO_LONGER_NEEDED.
		/// </summary>
		void SetObjectAsNoLongerNeeded(ref int @object);
		void SetEntityCanBeDamaged(int entity, bool toggle);
		bool GetEntityCanBeDamaged(int entity);
		void SetEntityCanBeDamagedByRelationshipGroup(int entity, bool bCanBeDamaged, int relGroup);
		void _0x352E2B5CF420BF3B(int p0, int p1);
		/// <summary>
		/// Sets whether the entity can be targeted without being in line-of-sight.
		/// </summary>
		void SetEntityCanBeTargetedWithoutLos(int entity, bool toggle);
		void SetEntityCollision(int entity, bool toggle, bool keepPhysics);
		bool GetEntityCollisionDisabled(int entity);
		void SetEntityCompletelyDisableCollision(int entity, bool toggle, bool keepPhysics);
		/// <summary>
		/// Often ends with 1, 0, 0, 1); in the scripts. It works.
		/// Axis - Invert Axis Flags
		/// </summary>
		/// <param name="clearArea">is always 1 in the scripts. Set to 1, an area around the destination coords for the moved entity is cleared from other entities.</param>
		void SetEntityCoords(int entity, float xPos, float yPos, float zPos, bool xAxis, bool yAxis, bool zAxis, bool clearArea);
		void SetEntityCoordsWithoutPlantsReset(int entity, float xPos, float yPos, float zPos, bool alive, bool deadFlag, bool ragdollFlag, bool clearArea);
		/// <summary>
		/// Axis - Invert Axis Flags
		/// </summary>
		void SetEntityCoordsNoOffset(int entity, float xPos, float yPos, float zPos, bool xAxis, bool yAxis, bool zAxis);
		void SetEntityDynamic(int entity, bool toggle);
		/// <summary>
		/// Set the heading of an entity in degrees also known as "Yaw".
		/// </summary>
		void SetEntityHeading(int entity, float heading);
		/// <summary>
		/// male ped ~= 100 - 200
		/// female ped ~= 0 - 100
		/// </summary>
		/// <param name="health">>= 0</param>
		void SetEntityHealth(int entity, int health, int p2);
		/// <summary>
		/// Sets a ped or an object totally invincible. It doesn't take any kind of damage. Peds will not ragdoll on explosions and the tazer animation won't apply either.
		/// If you use this for a ped and you want Ragdoll to stay enabled, then do:
		/// *(DWORD *)(pedAddress + 0x188) |= (1 << 9);
		/// Use this if you want to get the invincibility status:
		/// bool IsPedInvincible(Ped ped)
		/// {
		/// auto addr = getScriptHandleBaseAddress(ped);
		/// if (addr)
		/// {
		/// See NativeDB for reference: http://natives.altv.mp/#/0x3882114BDE571AD4
		/// </summary>
		/// <returns>            return ((flag & (1 << 8)) != 0) || ((flag & (1 << 9)) != 0);</returns>
		void SetEntityInvincible(int entity, bool toggle);
		void SetEntityIsTargetPriority(int entity, bool p1, float p2);
		void SetEntityLights(int entity, bool toggle);
		/// <summary>
		/// Loads collision grid for an entity spawned outside of a player's loaded area. This allows peds to execute tasks rather than sit dormant because of a lack of a physics grid.
		/// Certainly not the main usage of this native but when set to true for a Vehicle, it will prevent the vehicle to explode if it is spawned far away from the player.
		/// </summary>
		void SetEntityLoadCollisionFlag(int entity, bool toggle, int p2);
		bool HasCollisionLoadedAroundEntity(int entity);
		void SetEntityMaxSpeed(int entity, float speed);
		void SetEntityOnlyDamagedByPlayer(int entity, bool toggle);
		void SetEntityOnlyDamagedByRelationshipGroup(int entity, bool p1, int p2);
		/// <summary>
		/// Enable / disable each type of damage.
		/// Can't get drownProof to work.
		/// --------------
		/// </summary>
		/// <param name="p7">is to to '1' in am_mp_property_ext/int: entity::set_entity_proofs(uParam0->f_19, true, true, true, true, true, true, 1, true);</param>
		void SetEntityProofs(int entity, bool bulletProof, bool fireProof, bool explosionProof, bool collisionProof, bool meleeProof, bool p6, bool p7, bool drownProof);
		/// <summary>
		/// </summary>
		bool GetEntityProofs(int entity, ref bool bulletProof, ref bool fireProof, ref bool explosionProof, ref bool collisionProof, ref bool meleeProof, ref bool steamProof, ref bool p7, ref bool drownProof);
		/// <summary>
		/// </summary>
		/// <param name="w">is the correct parameter name!</param>
		void SetEntityQuaternion(int entity, float x, float y, float z, float w);
		void SetEntityRecordsCollisions(int entity, bool toggle);
		/// <summary>
		/// value ranges from 0 to 5. What you use for rotationOrder when setting must be the same as rotationOrder when getting the rotation.
		/// Unsure what value corresponds to what rotation order, more testing will be needed for that.
		/// For the most part R* uses 1 or 2 as the order.
		/// </summary>
		/// <param name="rotationOrder">refers to the order yaw pitch roll is applied</param>
		/// <param name="p5">is usually set as true</param>
		void SetEntityRotation(int entity, float pitch, float roll, float yaw, int rotationOrder, bool p5);
		/// <summary>
		/// </summary>
		/// <param name="unk">was always 0.</param>
		void SetEntityVisible(int entity, bool toggle, bool unk);
		/// <summary>
		/// SET_ENTITY_*
		/// </summary>
		void _0xC34BC448DA29F5E9(int entity, bool toggle);
		/// <summary>
		/// SET_ENTITY_M*
		/// </summary>
		void _0xE66377CDDADA4810(int entity, bool p1);
		/// <summary>
		/// Note that the third parameter(denoted as z) is "up and down" with positive numbers encouraging upwards movement.
		/// </summary>
		void SetEntityVelocity(int entity, float x, float y, float z);
		void SetEntityAngularVelocity(int entity, float x, float y, float z);
		void SetEntityHasGravity(int entity, bool toggle);
		/// <summary>
		/// LOD distance can be 0 to 0xFFFF (higher values will result in 0xFFFF) as it is actually stored as a 16-bit value (aka uint16_t).
		/// </summary>
		void SetEntityLodDist(int entity, int value);
		/// <summary>
		/// Returns the LOD distance of an entity.
		/// </summary>
		int GetEntityLodDist(int entity);
		/// <summary>
		/// Set entity alpha level. Ranging from 0 to 255 but chnages occur after every 20 percent (after every 51).
		/// </summary>
		/// <param name="skin">- everything alpha except skin</param>
		void SetEntityAlpha(int entity, int alphaLevel, bool skin);
		int GetEntityAlpha(int entity);
		void ResetEntityAlpha(int entity);
		void _0x490861B88F4FD846(int p0);
		void _0xCEA7C8E1B48FF68C(int p0, int p1);
		/// <summary>
		/// Only called once in the scripts.
		/// Related to weapon objects.
		/// </summary>
		void _0x5C3B791D580E0BC2(int entity, float p1);
		void SetEntityAlwaysPrerender(int entity, bool toggle);
		void SetEntityRenderScorched(int entity, bool toggle);
		/// <summary>
		/// Example here: www.gtaforums.com/topic/830463-help-with-turning-lights-green-and-causing-peds-to-crash-into-each-other/#entry1068211340
		/// 0 = green
		/// 1 = red
		/// 2 = yellow
		/// 3 = reset changes
		/// changing lights may not change the behavior of vehicles
		/// </summary>
		void SetEntityTrafficlightOverride(int entity, int state);
		/// <summary>
		/// Related to cutscene entities. Unsure about the use.
		/// SET_ENTITY_*
		/// </summary>
		void _0x78E8E3A640178255(int entity);
		/// <summary>
		/// Only works with objects!
		/// Network players do not see changes done with this.
		/// - Did ya try modifying p6 lol
		/// </summary>
		void CreateModelSwap(float x, float y, float z, float radius, int originalModel, int newModel, bool p6);
		void RemoveModelSwap(float x, float y, float z, float radius, int originalModel, int newModel, bool p6);
		/// <summary>
		/// Same as the comment for CREATE_MODEL_SWAP unless for some reason p5 affects it this only works with objects as well.
		/// Network players do not see changes done with this.
		/// </summary>
		/// <param name="p5">= sets as true in scripts</param>
		void CreateModelHide(float x, float y, float z, float radius, int modelHash, bool p5);
		void CreateModelHideExcludingScriptObjects(float x, float y, float z, float radius, int modelHash, bool p5);
		/// <summary>
		/// This native makes entities visible that are hidden by the native CREATE_MODEL_HIDE.
		/// </summary>
		/// <param name="p5">should be false, true does nothing</param>
		void RemoveModelHide(float x, float y, float z, float radius, int modelHash, bool p5);
		void CreateForcedObject(float x, float y, float z, int p3, int modelHash, bool p5);
		void RemoveForcedObject(int p0, int p1, int p2, int p3, int p4);
		/// <summary>
		/// Calling this function disables collision between two entities.
		/// The importance of the order for entity1 and entity2 is unclear.
		/// The third parameter, `thisFrame`, decides whether the collision is to be disabled until it is turned back on, or if it's just this frame.
		/// </summary>
		void SetEntityNoCollisionEntity(int entity1, int entity2, bool thisFrameOnly);
		void SetEntityMotionBlur(int entity, bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="toggle">always false.</param>
		void SetCanAutoVaultOnEntity(int entity, bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="toggle">always false.</param>
		void SetCanClimbOnEntity(int entity, bool toggle);
		/// <summary>
		/// SET_*
		/// Only called within 1 script for x360. 'fm_mission_controller' and it used on an object.
		/// Ran after these 2 natives,
		/// set_object_targettable(uParam0, 0);
		/// set_entity_invincible(uParam0, 1);
		/// </summary>
		void _0xDC6F8601FAF2E893(int entity, bool toggle);
		/// <summary>
		/// SET_ENTITY_*
		/// </summary>
		void SetEntityDecalsDisabled(int entity, bool p1);
		/// <summary>
		/// SET_ENTITY_*
		/// </summary>
		void _0x1A092BB0C3808B96(int entity, bool p1);
		/// <summary>
		/// Gets the world rotation of the specified bone of the specified entity.
		/// </summary>
		Vector3 GetEntityBoneRotation(int entity, int boneIndex);
		/// <summary>
		/// Gets the world rotation of the specified bone of the specified entity.
		/// This native is used in casinoroulette.c but I don't know yet what is the difference with _GET_ENTITY_BONE_ROTATION
		/// </summary>
		Vector3 GetEntityBonePosition2(int entity, int boneIndex);
		/// <summary>
		/// Gets the local rotation of the specified bone of the specified entity.
		/// </summary>
		Vector3 GetEntityBoneRotationLocal(int entity, int boneIndex);
		int GetEntityBoneCount(int entity);
		/// <summary>
		/// ENABLE_*
		/// </summary>
		void EnableEntityUnk(int entity);
		void _0xB17BC6453F6CF5AC(int p0, int p1);
		/// <summary>
		/// Puts pickup2 ptr somewhere in pickup?
		/// </summary>
		void _0x68B562E124CC0AEF(int pickup, int pickup2);
		void _0x36F32DE87082343E(int p0, int p1);
		/// <summary>
		/// GET_ENTITY_*
		/// </summary>
		/// <returns>Seems to return the handle of the entity's portable pickup.</returns>
		int GetEntityPickup(int entity, int modelHash);
		/// <summary>
		/// Sets 32nd bit of pickup+188
		/// SET_PICKUP_??
		/// </summary>
		void _0xD7B80E7C3BEFC396(int pickup, bool toggle);
		void SetDecisionMaker(int ped, int name);
		/// <summary>
		/// </summary>
		/// <param name="eventType">https://alloc8or.re/gta5/doc/enums/eEventType.txt</param>
		void ClearDecisionMakerEventResponse(int name, int eventType);
		/// <summary>
		/// This is limited to 4 blocked events at a time.
		/// </summary>
		/// <param name="eventType">https://alloc8or.re/gta5/doc/enums/eEventType.txt</param>
		void BlockDecisionMakerEvent(int name, int eventType);
		/// <summary>
		/// </summary>
		/// <param name="eventType">https://alloc8or.re/gta5/doc/enums/eEventType.txt</param>
		void UnblockDecisionMakerEvent(int name, int eventType);
		/// <summary>
		/// </summary>
		/// <param name="eventType">https://alloc8or.re/gta5/doc/enums/eEventType.txt</param>
		int AddShockingEventAtPosition(int eventType, float x, float y, float z, float duration);
		/// <summary>
		/// </summary>
		/// <param name="eventType">https://alloc8or.re/gta5/doc/enums/eEventType.txt</param>
		int AddShockingEventForEntity(int eventType, int entity, float duration);
		/// <summary>
		/// </summary>
		/// <param name="eventType">https://alloc8or.re/gta5/doc/enums/eEventType.txt</param>
		bool IsShockingEventInSphere(int eventType, float x, float y, float z, float radius);
		bool RemoveShockingEvent(int @event);
		void RemoveAllShockingEvents(bool p0);
		void RemoveShockingEventSpawnBlockingAreas();
		void SuppressShockingEventsNextFrame();
		/// <summary>
		/// </summary>
		/// <param name="eventType">https://alloc8or.re/gta5/doc/enums/eEventType.txt</param>
		void SuppressShockingEventTypeNextFrame(int eventType);
		void SuppressAgitationEventsNextFrame();
		/// <summary>
		/// 0 = Michael,
		/// 1 = Franklin,
		/// 2 = Trevor,
		/// 3 = MPMale,
		/// 4 = MPFemale
		/// </summary>
		/// <param name="character">types:</param>
		int GetNumTattooShopDlcItems(int character);
		/// <summary>
		/// Character types:
		/// 0 = Michael,
		/// 1 = Franklin,
		/// 2 = Trevor,
		/// 3 = MPMale,
		/// 4 = MPFemale
		/// enum TattooZoneData
		/// {
		/// ZONE_TORSO = 0,
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFF56381874F82086
		/// </summary>
		bool GetTattooShopDlcItemData(int characterType, int decorationIndex, ref int outComponent);
		/// <summary>
		/// Returns some sort of index/offset for overlays/decorations.
		/// 0 = Michael,
		/// 1 = Franklin,
		/// 2 = Trevor,
		/// 3 = MPMale,
		/// 4 = MPFemale
		/// </summary>
		/// <param name="character">types:</param>
		int _0x10144267DD22866C(int overlayHash, int p1, int character);
		/// <summary>
		/// </summary>
		void InitShopPedComponent(ref int outComponent);
		/// <summary>
		/// </summary>
		void InitShopPedProp(ref int outProp);
		int SetupShopPedApparelQuery(int p0, int p1, int p2, int p3);
		/// <summary>
		/// componentId is -1 when p3 is true in decompiled scripts.
		/// </summary>
		/// <param name="character">is 0 for Michael, 1 for Franklin, 2 for Trevor, 3 for freemode male, and 4 for freemode female.</param>
		/// <param name="p1">could be the outfit number; unsure.</param>
		/// <param name="p2">is usually -1; unknown function.</param>
		/// <param name="p3">appears to be for selecting between clothes and props; false is used with components/clothes, true is used with props.</param>
		/// <param name="p4">is usually -1; unknown function.</param>
		/// <param name="componentId">is between 0 and 11 and corresponds to the usual component slots.</param>
		int SetupShopPedApparelQueryTu(int character, int p1, int p2, bool p3, int p4, int componentId);
		/// <summary>
		/// See https://git.io/JtcRf for example and structs.
		/// </summary>
		void GetShopPedQueryComponent(int componentId, ref int outComponent);
		/// <summary>
		/// Returns some sort of index/offset for components.
		/// </summary>
		/// <returns>Needs _GET_NUM_PROPS_FROM_OUTFIT to be called with p3 = false and componentId with the drawable's component slot first, returns -1 otherwise.</returns>
		int _0x96E2929292A4DB77(int componentHash);
		/// <summary>
		/// More info here: https://gist.github.com/root-cause/3b80234367b0c856d60bf5cb4b826f86
		/// </summary>
		void GetShopPedComponent(int componentHash, ref int outComponent);
		/// <summary>
		/// See https://git.io/JtcRf for example and structs.
		/// </summary>
		void GetShopPedQueryProp(int componentId, ref int outProp);
		/// <summary>
		/// Returns some sort of index/offset for props.
		/// </summary>
		/// <returns>Needs _GET_NUM_PROPS_FROM_OUTFIT to be called with p3 = true and componentId = -1 first, returns -1 otherwise.</returns>
		int _0x6CEBE002E58DEE97(int componentHash);
		/// <summary>
		/// More info here: https://gist.github.com/root-cause/3b80234367b0c856d60bf5cb4b826f86
		/// </summary>
		void GetShopPedProp(int componentHash, ref int outProp);
		int GetHashNameForComponent(int entity, int componentId, int drawableVariant, int textureVariant);
		int GetHashNameForProp(int entity, int componentId, int propIndex, int propTextureIndex);
		int GetItemVariantsCount(int componentHash);
		/// <summary>
		/// `propHash`: Ped helmet prop hash?
		/// </summary>
		/// <returns>This native returns 1 when the player helmet has a visor (there is another prop index for the same helmet with closed/opened visor variant) that can be toggled. 0 if there's no alternative version with a visor for this helmet prop.</returns>
		int GetShopPedApparelVariantPropCount(int propHash);
		/// <summary>
		/// </summary>
		void GetVariantComponent(int componentHash, int unkVariantComponentIndex, ref int nameHash, ref int enumValue, ref int componentType);
		/// <summary>
		/// </summary>
		void GetVariantProp(int componentHash, int unkVariantPropIndex, ref int nameHash, ref int enumValue, ref int anchorPoint);
		/// <summary>
		/// Returns number of possible values of the forcedComponentIndex argument of GET_FORCED_COMPONENT.
		/// </summary>
		int GetShopPedApparelForcedComponentCount(int componentHash);
		/// <summary>
		/// Returns number of possible values of the forcedPropIndex argument of GET_FORCED_PROP.
		/// </summary>
		int GetShopPedApparelForcedPropCount(int componentHash);
		/// <summary>
		/// </summary>
		void GetForcedComponent(int componentHash, int forcedComponentIndex, ref int nameHash, ref int enumValue, ref int componentType);
		/// <summary>
		/// </summary>
		void GetForcedProp(int componentHash, int forcedPropIndex, ref int nameHash, ref int enumValue, ref int anchorPoint);
		/// <summary>
		/// Full list of restriction tags by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedApparelRestrictionTags.json
		/// componentId/last parameter seems to be unused.
		/// </summary>
		bool IsTagRestricted(int componentHash, int restrictionTagHash, int componentId);
		/// <summary>
		/// characters
		/// 0: Michael
		/// 1: Franklin
		/// 2: Trevor
		/// 3: MPMale
		/// 4: MPFemale
		/// </summary>
		int SetupShopPedOutfitQuery(int character, bool p1);
		/// <summary>
		/// See https://git.io/JtcB8 for example and outfit struct.
		/// </summary>
		/// <param name="outfitIndex">from 0 to _GET_NUM_SHOP_PED_OUTFITS(characterIndex, false) - 1.</param>
		void GetShopPedQueryOutfit(int outfitIndex, ref int outfit);
		/// <summary>
		/// </summary>
		void GetShopPedOutfit(int p0, ref int p1);
		int GetShopPedOutfitLocate(int p0);
		/// <summary>
		/// See https://git.io/JtcBH for example and structs.
		/// </summary>
		bool GetShopPedOutfitPropVariant(int outfitHash, int unkVariantIndex, ref int outPropVariant);
		/// <summary>
		/// See https://git.io/JtcBH for example and structs.
		/// </summary>
		bool GetShopPedOutfitComponentVariant(int outfitHash, int unkVariantIndex, ref int outComponentVariant);
		int GetNumDlcVehicles();
		/// <summary>
		/// </summary>
		/// <param name="dlcVehicleIndex">is 0 to GET_NUM_DLC_VEHICLS() - 1</param>
		int GetDlcVehicleModel(int dlcVehicleIndex);
		/// <summary>
		/// The Second item in the struct *(Hash *)(outData + 1) is the vehicle hash.
		/// </summary>
		/// <param name="dlcVehicleIndex">takes a number from 0 - GET_NUM_DLC_VEHICLES() - 1.</param>
		/// <param name="outData">is a struct of 3 8-byte items.</param>
		bool GetDlcVehicleData(int dlcVehicleIndex, ref int outData);
		int GetDlcVehicleFlags(int dlcVehicleIndex);
		/// <summary>
		/// Returns the total number of DLC weapons.
		/// </summary>
		int GetNumDlcWeapons();
		/// <summary>
		/// Returns the total number of DLC weapons that are available in SP (availableInSP field in shop_weapon.meta).
		/// </summary>
		int GetNumDlcWeaponsSp();
		/// <summary>
		/// struct DlcWeaponData
		/// {
		/// int emptyCheck; //use DLC1::_IS_DLC_DATA_EMPTY on this
		/// int padding1;
		/// int weaponHash;
		/// int padding2;
		/// int unk;
		/// int padding3;
		/// int weaponCost;
		/// See NativeDB for reference: http://natives.altv.mp/#/0x79923CD21BECE14E
		/// </summary>
		/// <param name="dlcWeaponIndex">takes a number from 0 - GET_NUM_DLC_WEAPONS() - 1.</param>
		bool GetDlcWeaponData(int dlcWeaponIndex, ref int outData);
		/// <summary>
		/// Same as GET_DLC_WEAPON_DATA but only works for DLC weapons that are available in SP.
		/// </summary>
		bool GetDlcWeaponDataSp(int dlcWeaponIndex, ref int outData);
		/// <summary>
		/// Returns the total number of DLC weapon components.
		/// </summary>
		int GetNumDlcWeaponComponents(int dlcWeaponIndex);
		/// <summary>
		/// Returns the total number of DLC weapon components that are available in SP.
		/// </summary>
		int GetNumDlcWeaponComponentsSp(int dlcWeaponIndex);
		/// <summary>
		/// struct DlcComponentData{
		/// int attachBone;
		/// int padding1;
		/// int bActiveByDefault;
		/// int padding2;
		/// int unk;
		/// int padding3;
		/// int componentHash;
		/// int padding4;
		/// See NativeDB for reference: http://natives.altv.mp/#/0x6CF598A2957C2BF8
		/// </summary>
		/// <param name="dlcWeaponIndex">seems to be the weapon index</param>
		/// <param name="dlcWeapCompIndex">seems to be the weapon component index</param>
		bool GetDlcWeaponComponentData(int dlcWeaponIndex, int dlcWeapCompIndex, ref int ComponentDataPtr);
		/// <summary>
		/// Same as GET_DLC_WEAPON_COMPONENT_DATA but only works for DLC components that are available in SP.
		/// </summary>
		bool GetDlcWeaponComponentDataSp(int dlcWeaponIndex, int dlcWeapCompIndex, ref int ComponentDataPtr);
		bool IsContentItemLocked(int itemHash);
		bool IsDlcVehicleMod(int hash);
		int GetDlcVehicleModLockHash(int hash);
		/// <summary>
		/// From fm_deathmatch_creator and fm_race_creator:
		/// FILES::_UNLOAD_CONTENT_CHANGE_SET_GROUP(joaat("GROUP_MAP_SP"));
		/// FILES::_LOAD_CONTENT_CHANGE_SET_GROUP(joaat("GROUP_MAP"));
		/// </summary>
		void LoadContentChangeSetGroup(int hash);
		/// <summary>
		/// From fm_deathmatch_creator and fm_race_creator:
		/// FILES::_UNLOAD_CONTENT_CHANGE_SET_GROUP(joaat("GROUP_MAP_SP"));
		/// FILES::_LOAD_CONTENT_CHANGE_SET_GROUP(joaat("GROUP_MAP"));
		/// </summary>
		void UnloadContentChangeSetGroup(int hash);
		/// <summary>
		/// Starts a fire:
		/// xyz: Location of fire
		/// </summary>
		/// <param name="maxChildren">The max amount of times a fire can spread to other objects. Must be 25 or less, or the function will do nothing.</param>
		/// <param name="isGasFire">Whether or not the fire is powered by gasoline.</param>
		int StartScriptFire(float X, float Y, float Z, int maxChildren, bool isGasFire);
		void RemoveScriptFire(int fireHandle);
		int StartEntityFire(int entity);
		void StopEntityFire(int entity);
		bool IsEntityOnFire(int entity);
		int GetNumberOfFiresInRange(float x, float y, float z, float radius);
		/// <summary>
		/// SET_FIRE_*
		/// </summary>
		void SetFireSpreadRate(float p0);
		void StopFireInRange(float x, float y, float z, float radius);
		/// <summary>
		/// Returns TRUE if it found something. FALSE if not.
		/// </summary>
		bool GetClosestFirePos(ref Vector3 outPosition, float x, float y, float z);
		/// <summary>
		/// BOOL isAudible = If explosion makes a sound.
		/// BOOL isInvisible = If the explosion is invisible or not.
		/// </summary>
		/// <param name="explosionType">https://alloc8or.re/gta5/doc/enums/eExplosionTag.txt</param>
		void AddExplosion(float x, float y, float z, int explosionType, float damageScale, bool isAudible, bool isInvisible, float cameraShake, bool noDamage);
		/// <summary>
		/// </summary>
		/// <param name="explosionType">See ADD_EXPLOSION.</param>
		/// <param name="isAudible">If explosion makes a sound.</param>
		/// <param name="isInvisible">If the explosion is invisible or not.</param>
		void AddOwnedExplosion(int ped, float x, float y, float z, int explosionType, float damageScale, bool isAudible, bool isInvisible, float cameraShake);
		/// <summary>
		/// </summary>
		/// <param name="explosionType">See ADD_EXPLOSION.</param>
		/// <param name="isAudible">If explosion makes a sound.</param>
		/// <param name="isInvisible">If the explosion is invisible or not.</param>
		void AddExplosionWithUserVfx(float x, float y, float z, int explosionType, int explosionFx, float damageScale, bool isAudible, bool isInvisible, float cameraShake);
		/// <summary>
		/// </summary>
		/// <param name="explosionType">See ADD_EXPLOSION.</param>
		bool IsExplosionInArea(int explosionType, float x1, float y1, float z1, float x2, float y2, float z2);
		/// <summary>
		/// </summary>
		/// <param name="explosionType">See ADD_EXPLOSION.</param>
		bool IsExplosionActiveInArea(int explosionType, float x1, float y1, float z1, float x2, float y2, float z2);
		/// <summary>
		/// </summary>
		/// <param name="explosionType">See ADD_EXPLOSION.</param>
		bool IsExplosionInSphere(int explosionType, float x, float y, float z, float radius);
		/// <summary>
		/// </summary>
		/// <param name="explosionType">See ADD_EXPLOSION.</param>
		int GetEntityInsideExplosionSphere(int explosionType, float x, float y, float z, float radius);
		/// <summary>
		/// </summary>
		/// <param name="explosionType">See ADD_EXPLOSION, -1 for any explosion type</param>
		bool IsExplosionInAngledArea(int explosionType, float x1, float y1, float z1, float x2, float y2, float z2, float width);
		/// <summary>
		/// Returns a handle to the first entity within the a circle spawned inside the 2 points from a radius.
		/// </summary>
		/// <param name="explosionType">See ADD_EXPLOSION.</param>
		int GetEntityInsideExplosionArea(int explosionType, float x1, float y1, float z1, float x2, float y2, float z2, float radius);
		/// <summary>
		/// Initializes the text entry for the the text next to a loading prompt. All natives for building UI texts can be used here
		/// e.g
		/// void StartLoadingMessage(char *text, int spinnerType = 3)
		/// {
		/// _SET_LOADING_PROMPT_TEXT_ENTRY("STRING");
		/// ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
		/// _SHOW_LOADING_PROMPT(spinnerType);
		/// }
		/// OR
		/// See NativeDB for reference: http://natives.altv.mp/#/0xABA17D7CE615ADBF
		/// </summary>
		void BeginTextCommandBusyspinnerOn(string @string);
		/// <summary>
		/// enum eBusySpinnerType
		/// {
		/// BUSY_SPINNER_LEFT,
		/// BUSY_SPINNER_LEFT_2,
		/// BUSY_SPINNER_LEFT_3,
		/// BUSY_SPINNER_SAVE,
		/// BUSY_SPINNER_RIGHT,
		/// };
		/// </summary>
		void EndTextCommandBusyspinnerOn(int busySpinnerType);
		/// <summary>
		/// Removes the loading prompt at the bottom right of the screen.
		/// </summary>
		void BusyspinnerOff();
		void PreloadBusyspinner();
		bool BusyspinnerIsOn();
		bool BusyspinnerIsDisplaying();
		/// <summary>
		/// DISABLE_*
		/// </summary>
		void _0x9245E81072704B8A(bool p0);
		/// <summary>
		/// Shows the cursor on screen for one frame.
		/// </summary>
		void SetMouseCursorActiveThisFrame();
		/// <summary>
		/// Changes the mouse cursor's sprite.
		/// 1 = Normal
		/// 6 = Left Arrow
		/// 7 = Right Arrow
		/// </summary>
		void SetMouseCursorSprite(int spriteId);
		/// <summary>
		/// Shows/hides the frontend cursor on the pause menu or similar menus.
		/// Clicking off and then on the game window will show it again.
		/// </summary>
		void SetMouseCursorVisibleInMenus(bool toggle);
		int _0x3D9ACB1EB139E702();
		/// <summary>
		/// </summary>
		bool _0x632B2940C67F4EA9(int scaleformHandle, ref int p1, ref int p2, ref int p3);
		void ThefeedOnlyShowTooltips(bool toggle);
		void ThefeedSetScriptedMenuHeight(float pos);
		/// <summary>
		/// Stops loading screen tips shown by invoking either `0x488043841BBE156F` or `0x15CFA549788D35EF`
		/// </summary>
		void ThefeedDisableLoadingScreenTips();
		/// <summary>
		/// Once called each frame hides all above radar notifications.
		/// </summary>
		void ThefeedHideThisFrame();
		/// <summary>
		/// Displays loading screen tips, requires `0x56C8B608CFD49854` to be called beforehand.
		/// </summary>
		void ThefeedDisplayLoadingScreenTips();
		void ThefeedFlushQueue();
		/// <summary>
		/// Removes a notification instantly instead of waiting for it to disappear
		/// </summary>
		void ThefeedRemoveItem(int notificationId);
		void ThefeedForceRenderOn();
		/// <summary>
		/// Enables loading screen tips to be be shown (`_0x15CFA549788D35EF` and `_0x488043841BBE156F`), blocks other kinds of notifications from being displayed (at least from current script). Call `0xADED7F5748ACAFE6` to display those again.
		/// </summary>
		void ThefeedForceRenderOff();
		void ThefeedPause();
		void ThefeedResume();
		bool ThefeedIsPaused();
		void ThefeedSpsExtendWidescreenOn();
		void ThefeedSpsExtendWidescreenOff();
		/// <summary>
		/// Returns the handle for the notification currently displayed on the screen. Name may be a hash collision, but describes the function accurately.
		/// </summary>
		int ThefeedGetFirstVisibleDeleteRemaining();
		/// <summary>
		/// Enables loading screen tips to be be shown (`_0x15CFA549788D35EF` and `_0x488043841BBE156F`), blocks other kinds of notifications from being displayed (at least from current script). Call `0xADED7F5748ACAFE6` to display those again.
		/// </summary>
		void ThefeedCommentTeleportPoolOn();
		/// <summary>
		/// Displays "normal" notifications again after calling `_0x56C8B608CFD49854` (those that were drawn before calling this native too), though those will have a weird offset and stay on screen forever (tested with notifications created from same script).
		/// </summary>
		void ThefeedCommentTeleportPoolOff();
		/// <summary>
		/// From the decompiled scripts:
		/// HUD::_92F0DA1E27DB96DC(6);
		/// HUD::_92F0DA1E27DB96DC(184);
		/// HUD::_92F0DA1E27DB96DC(190);
		/// sets background color for the next notification
		/// 6 = red
		/// 184 = green
		/// 190 = yellow
		/// Here is a list of some colors that can be used: gyazo.com/68bd384455fceb0a85a8729e48216e15
		/// </summary>
		void ThefeedSetNextPostBackgroundColor(int hudColorIndex);
		void ThefeedSetAnimpostfxColor(int red, int green, int blue, int alpha);
		/// <summary>
		/// Related to notification color flashing, setting p0 to 0 invalidates a `_SET_NOTIFICATION_FLASH_COLOR` call for the target notification.
		/// </summary>
		void ThefeedSetAnimpostfxCount(int count);
		void ThefeedSetAnimpostfxSound(bool toggle);
		void ThefeedResetAllParameters();
		/// <summary>
		/// Requires manual management of game stream handles (i.e., 0xBE4390CB40B3E627).
		/// </summary>
		void ThefeedFreezeNextPost();
		void ThefeedClearFrozenPost();
		void ThefeedSetFlushAnimpostfx(bool p0);
		/// <summary>
		/// From the decompiled scripts, called 61 times:
		/// HUD::_317EBA71D7543F52(&v_13, &v_13, &v_3, &v_3);
		/// </summary>
		void ThefeedAddTxdRef(ref int p0, ref int p1, ref int p2, ref int p3);
		/// <summary>
		/// Declares the entry type of a notification, for example "STRING".
		/// int ShowNotification(char *text)
		/// {
		/// BEGIN_TEXT_COMMAND_THEFEED_POST("STRING");
		/// ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
		/// return _DRAW_NOTIFICATION(1, 1);
		/// }
		/// </summary>
		void BeginTextCommandThefeedPost(string text);
		/// <summary>
		/// List of picture names: https://pastebin.com/XdpJVbHz
		/// Example result: https://i.imgur.com/SdEZ22m.png
		/// </summary>
		int EndTextCommandThefeedPostStats(string statTitle, int iconEnum, bool stepVal, int barValue, bool isImportant, string pictureTextureDict, string pictureTextureName);
		/// <summary>
		/// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
		/// List of picNames: pastebin.com/XdpJVbHz
		/// iconTypes:
		/// 1 : Chat Box
		/// 2 : Email
		/// 3 : Add Friend Request
		/// 4 : Nothing
		/// 5 : Nothing
		/// 6 : Nothing
		/// See NativeDB for reference: http://natives.altv.mp/#/0x1CCD9A37359072CF
		/// </summary>
		/// <param name="flash">is a bool for fading in.</param>
		int EndTextCommandThefeedPostMessagetext(string txdName, string textureName, bool flash, int iconType, string sender, string subject);
		/// <summary>
		/// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
		/// Needs more research.
		/// Only one type of usage in the scripts:
		/// HUD::_C6F580E4C94926AC("CHAR_ACTING_UP", "CHAR_ACTING_UP", 0, 0, "DI_FEED_CHAR", a_0);
		/// </summary>
		int EndTextCommandThefeedPostMessagetextGxtEntry(string txdName, string textureName, bool flash, int iconType, string sender, string subject);
		/// <summary>
		/// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
		/// NOTE: 'duration' is a multiplier, so 1.0 is normal, 2.0 is twice as long (very slow), and 0.5 is half as long.
		/// Example, only occurrence in the scripts:
		/// v_8 = HUD::_1E6611149DB3DB6B("CHAR_SOCIAL_CLUB", "CHAR_SOCIAL_CLUB", 0, 0, &v_9, "", a_5);
		/// </summary>
		int EndTextCommandThefeedPostMessagetextTu(string txdName, string textureName, bool flash, int iconType, string sender, string subject, float duration);
		/// <summary>
		/// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
		/// List of picNames pastebin.com/XdpJVbHz
		/// iconTypes:
		/// 1 : Chat Box
		/// 2 : Email
		/// 3 : Add Friend Request
		/// 4 : Nothing
		/// 5 : Nothing
		/// 6 : Nothing
		/// See NativeDB for reference: http://natives.altv.mp/#/0x5CBF7BADE20DB93E
		/// </summary>
		/// <param name="flash">is a bool for fading in.</param>
		int EndTextCommandThefeedPostMessagetextWithCrewTag(string txdName, string textureName, bool flash, int iconType, string sender, string subject, float duration, string clanTag);
		/// <summary>
		/// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
		/// List of picNames: pastebin.com/XdpJVbHz
		/// iconTypes:
		/// 1 : Chat Box
		/// 2 : Email
		/// 3 : Add Friend Request
		/// 4 : Nothing
		/// 5 : Nothing
		/// 6 : Nothing
		/// See NativeDB for reference: http://natives.altv.mp/#/0x531B84E7DA981FB6
		/// </summary>
		/// <param name="flash">is a bool for fading in.</param>
		/// <param name="iconType2">is a mirror of iconType. It shows in the "subject" line, right under the original iconType.</param>
		/// <returns>   return _DRAW_NOTIFICATION(1, 1);</returns>
		int EndTextCommandThefeedPostMessagetextWithCrewTagAndAdditionalIcon(string txdName, string textureName, bool flash, int iconType1, string sender, string subject, float duration, string clanTag, int iconType2, int p9);
		int EndTextCommandThefeedPostTicker(bool blink, bool p1);
		int EndTextCommandThefeedPostTickerForced(bool blink, bool p1);
		int EndTextCommandThefeedPostTickerWithTokens(bool blink, bool p1);
		/// <summary>
		/// Shows an "award" notification above the minimap, example: https://i.imgur.com/e2DNaKX.png
		/// Example:
		/// HUD::_SET_NOTIFICATION_TEXT_ENTRY("HUNT");
		/// HUD::_0xAA295B6F28BD587D("Hunting", "Hunting_Gold_128", 0, 109, "HUD_MED_UNLKED");
		/// </summary>
		int EndTextCommandThefeedPostAward(string textureDict, string textureName, int rpBonus, int colorOverlay, string titleLabel);
		/// <summary>
		/// </summary>
		int EndTextCommandThefeedPostCrewtag(bool p0, bool p1, ref int p2, int p3, bool isLeader, bool unk0, int clanDesc, int R, int G, int B);
		/// <summary>
		/// </summary>
		int EndTextCommandThefeedPostCrewtagWithGameName(bool p0, bool p1, ref int p2, int p3, bool isLeader, bool unk0, int clanDesc, string playerName, int R, int G, int B);
		int EndTextCommandThefeedPostUnlock(int p0, int p1, int p2);
		int EndTextCommandThefeedPostUnlockTu(int p0, int p1, int p2, int p3);
		int EndTextCommandThefeedPostUnlockTuWithColor(int p0, int p1, int p2, int p3, int p4, int p5);
		int EndTextCommandThefeedPostMpticker(bool blink, bool p1);
		int EndTextCommandThefeedPostCrewRankup(string p0, string p1, string p2, bool p3, bool p4);
		/// <summary>
		/// </summary>
		int EndTextCommandThefeedPostVersusTu(ref int p0, ref int p1, int p2, ref int p3, ref int p4, int p5, int p6, int p7);
		/// <summary>
		/// returns a notification handle, prints out a notification like below:
		/// if you set type to 1, image goes from 0 - 39 - Xbox you can add text to
		/// example:
		/// HUD::_0xD202B92CBF1D816F(1, 20, "Who you trynna get crazy with, ese? Don't you know I'm LOCO?!");
		/// - imgur.com/lGBPCz3
		/// </summary>
		/// <param name="type">range: 0 - 2</param>
		int EndTextCommandThefeedPostReplayIcon(int type, int image, string text);
		/// <summary>
		/// returns a notification handle, prints out a notification like below:
		/// if you set type to 1, button accepts "~INPUT_SOMETHING~"
		/// example:
		/// HUD::_0xDD6CB2CCE7C2735C(1, "~INPUT_TALK~", "Who you trynna get crazy with, ese? Don't you know I'm LOCO?!");
		/// - imgur.com/UPy0Ial
		/// Examples from the scripts:
		/// l_D1[11]=HUD::_DD6CB2CCE7C2735C(1,"~INPUT_REPLAY_START_STOP_RECORDING~","");
		/// l_D1[21]=HUD::_DD6CB2CCE7C2735C(1,"~INPUT_SAVE_REPLAY_CLIP~","");
		/// l_D1[11]=HUD::_DD6CB2CCE7C2735C(1,"~INPUT_REPLAY_START_STOP_RECORDING~","");
		/// l_D1[21]=HUD::_DD6CB2CCE7C2735C(1,"~INPUT_REPLAY_START_STOP_RECORDING_SECONDARY~","");
		/// </summary>
		/// <param name="type">range: 0 - 2</param>
		int EndTextCommandThefeedPostReplayInput(int type, string button, string text);
		/// <summary>
		/// Used to be known as _SET_TEXT_ENTRY_2
		/// void ShowSubtitle(char *text)
		/// {
		/// BEGIN_TEXT_COMMAND_PRINT("STRING");
		/// ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
		/// END_TEXT_COMMAND_PRINT(2000, 1);
		/// }
		/// </summary>
		void BeginTextCommandPrint(string GxtEntry);
		/// <summary>
		/// Draws the subtitle at middle center of the screen.
		/// int duration = time in milliseconds to show text on screen before disappearing
		/// Used to be known as _DRAW_SUBTITLE_TIMED
		/// </summary>
		/// <param name="drawImmediately">= If true, the text will be drawn immediately, if false, the text will be drawn after the previous subtitle has finished</param>
		void EndTextCommandPrint(int duration, bool drawImmediately);
		/// <summary>
		/// nothin doin.
		/// BOOL Message(const char* text)
		/// {
		/// BEGIN_TEXT_COMMAND_IS_MESSAGE_DISPLAYED("STRING");
		/// ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
		/// }
		/// </summary>
		/// <returns>       return END_TEXT_COMMAND_IS_MESSAGE_DISPLAYED();</returns>
		void BeginTextCommandIsMessageDisplayed(string text);
		bool EndTextCommandIsMessageDisplayed();
		/// <summary>
		/// The following were found in the decompiled script files:
		/// STRING, TWOSTRINGS, NUMBER, PERCENTAGE, FO_TWO_NUM, ESMINDOLLA, ESDOLLA, MTPHPER_XPNO, AHD_DIST, CMOD_STAT_0, CMOD_STAT_1, CMOD_STAT_2, CMOD_STAT_3, DFLT_MNU_OPT, F3A_TRAFDEST, ES_HELP_SOC3
		/// ESDOLLA - cash
		/// ESMINDOLLA - cash (negative)
		/// Used to be known as _SET_TEXT_ENTRY
		/// </summary>
		void BeginTextCommandDisplayText(string text);
		/// <summary>
		/// Used to be known as _DRAW_TEXT
		/// </summary>
		void EndTextCommandDisplayText(float x, float y, int p2);
		/// <summary>
		/// BEGIN_TEXT_COMMAND_*
		/// Example:
		/// _BEGIN_TEXT_COMMAND_GET_WIDTH("NUMBER");
		/// ADD_TEXT_COMPONENT_FLOAT(69.420f, 2);
		/// float width = _END_TEXT_COMMAND_GET_WIDTH(1);
		/// </summary>
		void BeginTextCommandGetWidth(string text);
		/// <summary>
		/// END_TEXT_COMMAND_*
		/// In scripts font most of the time is passed as 1.
		/// Use _BEGIN_TEXT_GET_COMMAND_GET_WIDTH
		/// param is not font from what i've tested
		/// </summary>
		float EndTextCommandGetWidth(bool p0);
		/// <summary>
		/// BEGIN_TEXT_COMMAND_*
		/// get's line count
		/// int GetLineCount(char *text, float x, float y)
		/// {
		/// _BEGIN_TEXT_COMMAND_LINE_COUNT("STRING");
		/// ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
		/// }
		/// </summary>
		/// <returns>      return _END_TEXT_COMMAND_GET_LINE_COUNT(x, y);</returns>
		void BeginTextCommandLineCount(string entry);
		/// <summary>
		/// END_TEXT_COMMAND_*
		/// Determines how many lines the text string will use when drawn on screen.
		/// Must use 0x521FB041D93DD0E4 for setting up
		/// </summary>
		int EndTextCommandLineCount(float x, float y);
		/// <summary>
		/// Used to be known as _SET_TEXT_COMPONENT_FORMAT
		/// </summary>
		void BeginTextCommandDisplayHelp(string inputType);
		/// <summary>
		/// Example:
		/// void FloatingHelpText(const char* text)
		/// {
		/// BEGIN_TEXT_COMMAND_DISPLAY_HELP("STRING");
		/// ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
		/// END_TEXT_COMMAND_DISPLAY_HELP (0, 0, 1, -1);
		/// }
		/// Image:
		/// - imgbin.org/images/26209.jpg
		/// See NativeDB for reference: http://natives.altv.mp/#/0x238FFE5C7B0498A6
		/// </summary>
		/// <param name="p0">is always 0.</param>
		/// <param name="shape">goes from -1 to 50 (may be more).</param>
		void EndTextCommandDisplayHelp(int p0, bool loop, bool beep, int shape);
		/// <summary>
		/// BOOL IsContextActive(char *ctx)
		/// {
		/// BEGIN_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED(ctx);
		/// }
		/// </summary>
		/// <returns>     return END_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED(0);</returns>
		void BeginTextCommandIsThisHelpMessageBeingDisplayed(string labelName);
		bool EndTextCommandIsThisHelpMessageBeingDisplayed(int p0);
		/// <summary>
		/// Starts a text command to change the name of a blip displayed in the pause menu.
		/// This should be paired with `END_TEXT_COMMAND_SET_BLIP_NAME`, once adding all required text components.
		/// Example:
		/// HUD::BEGIN_TEXT_COMMAND_SET_BLIP_NAME("STRING");
		/// HUD::_ADD_TEXT_COMPONENT_STRING("Name");
		/// HUD::END_TEXT_COMMAND_SET_BLIP_NAME(blip);
		/// </summary>
		void BeginTextCommandSetBlipName(string textLabel);
		/// <summary>
		/// Finalizes a text command started with BEGIN_TEXT_COMMAND_SET_BLIP_NAME, setting the name of the specified blip.
		/// </summary>
		void EndTextCommandSetBlipName(int blip);
		void BeginTextCommandObjective(string p0);
		void EndTextCommandObjective(bool p0);
		/// <summary>
		/// clears a print text command with this text
		/// </summary>
		void BeginTextCommandClearPrint(string text);
		void EndTextCommandClearPrint();
		void BeginTextCommandOverrideButtonText(string gxtEntry);
		void EndTextCommandOverrideButtonText(int p0);
		void AddTextComponentInteger(int value);
		void AddTextComponentFloat(float value, int decimalPlaces);
		void AddTextComponentSubstringTextLabel(string labelName);
		/// <summary>
		/// It adds the localized text of the specified GXT entry name. Eg. if the argument is GET_HASH_KEY("ES_HELP"), adds "Continue". Just uses a text labels hash key
		/// </summary>
		void AddTextComponentSubstringTextLabelHashKey(int gxtEntryHash);
		void AddTextComponentSubstringBlipName(int blip);
		void AddTextComponentSubstringPlayerName(string text);
		/// <summary>
		/// </summary>
		/// <param name="flags">00</param>
		void AddTextComponentSubstringTime(int timestamp, int flags);
		void AddTextComponentFormattedInteger(int value, bool commaSeparated);
		/// <summary>
		/// </summary>
		/// <param name="p1">was always -1</param>
		void AddTextComponentSubstringPhoneNumber(string p0, int p1);
		/// <summary>
		/// This native (along with 0x5F68520888E69014 and 0x6C188BE134E074AA) do not actually filter anything. They simply add the provided text (as of 944)
		/// </summary>
		void AddTextComponentSubstringWebsite(string website);
		void AddTextComponentSubstringKeyboardDisplay(string @string);
		void SetColourOfNextTextComponent(int hudColor);
		/// <summary>
		/// Returns a substring of a specified length starting at a specified position.
		/// Example:
		/// // Get "STRING" text from "MY_STRING"
		/// subStr = HUD::_GET_TEXT_SUBSTRING("MY_STRING", 3, 6);
		/// </summary>
		string GetTextSubstring(string text, int position, int length);
		/// <summary>
		/// Returns a substring of a specified length starting at a specified position. The result is guaranteed not to exceed the specified max length.
		/// NOTE: The 'maxLength' parameter might actually be the size of the buffer that is returned. More research is needed. -CL69
		/// Example:
		/// // Condensed example of how Rockstar uses this function
		/// strLen = HUD::GET_LENGTH_OF_LITERAL_STRING(MISC::GET_ONSCREEN_KEYBOARD_RESULT());
		/// subStr = HUD::_GET_TEXT_SUBSTRING_SAFE(MISC::GET_ONSCREEN_KEYBOARD_RESULT(), 0, strLen, 63);
		/// --
		/// "fm_race_creator.ysc", line 85115:
		/// // parameters modified for clarity
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB2798643312205C5
		/// </summary>
		/// <returns>            return FALSE;</returns>
		string GetTextSubstringSafe(string text, int position, int length, int maxLength);
		/// <summary>
		/// Returns a substring that is between two specified positions. The length of the string will be calculated using (endPosition - startPosition).
		/// Example:
		/// // Get "STRING" text from "MY_STRING"
		/// subStr = HUD::_GET_TEXT_SUBSTRING_SLICE("MY_STRING", 3, 9);
		/// // Overflows are possibly replaced with underscores (needs verification)
		/// subStr = HUD::_GET_TEXT_SUBSTRING_SLICE("MY_STRING", 3, 10); // "STRING_"?
		/// </summary>
		string GetTextSubstringSlice(string text, int startPosition, int endPosition);
		/// <summary>
		/// Gets a string literal from a label name.
		/// GET_F*
		/// </summary>
		string GetLabelText(string labelName);
		void ClearPrints();
		void ClearBrief();
		void ClearAllHelpMessages();
		/// <summary>
		/// </summary>
		/// <param name="p0">found arguments in the b617d scripts: pastebin.com/X5akCN7z</param>
		void ClearThisPrint(string p0);
		void ClearSmallPrints();
		bool DoesTextBlockExist(string gxt);
		/// <summary>
		/// Request a gxt into the passed slot.
		/// </summary>
		void RequestAdditionalText(string gxt, int slot);
		void RequestAdditionalTextForDlc(string gxt, int slot);
		bool HasAdditionalTextLoaded(int slot);
		void ClearAdditionalText(int p0, bool p1);
		bool IsStreamingAdditionalText(int p0);
		/// <summary>
		/// Checks if the specified gxt has loaded into the passed slot.
		/// </summary>
		bool HasThisAdditionalTextLoaded(string gxt, int slot);
		bool IsMessageBeingDisplayed();
		/// <summary>
		/// Checks if the passed gxt name exists in the game files.
		/// </summary>
		bool DoesTextLabelExist(string gxt);
		/// <summary>
		/// GET_F*
		/// </summary>
		string _0x98C3CF913D895111(string @string, int length);
		/// <summary>
		/// Returns the string length of the string from the gxt string .
		/// </summary>
		int GetLengthOfStringWithThisTextLabel(string gxt);
		/// <summary>
		/// Returns the length of the string passed (much like strlen).
		/// </summary>
		int GetLengthOfLiteralString(string @string);
		int GetLengthOfLiteralStringInBytes(string @string);
		/// <summary>
		/// This functions converts the hash of a street name into a readable string.
		/// For how to get the hashes, see PATHFIND::GET_STREET_NAME_AT_COORD.
		/// </summary>
		string GetStreetNameFromHashKey(int hash);
		bool IsHudPreferenceSwitchedOn();
		bool IsRadarPreferenceSwitchedOn();
		bool IsSubtitlePreferenceSwitchedOn();
		/// <summary>
		/// If Hud should be displayed
		/// </summary>
		void DisplayHud(bool toggle);
		/// <summary>
		/// Enables drawing some hud components, such as help labels, this frame, when the player is dead.
		/// </summary>
		void DisplayHudWhenDeadThisFrame();
		void DisplayHudWhenPausedThisFrame();
		/// <summary>
		/// If Minimap / Radar should be displayed.
		/// </summary>
		void DisplayRadar(bool toggle);
		/// <summary>
		/// Setter for 0xC2D2AD9EAAE265B8
		/// SET_*
		/// </summary>
		void _0xCD74233600C4EA6B(bool toggle);
		/// <summary>
		/// Getter for 0xCD74233600C4EA6B
		/// GET_*
		/// </summary>
		bool _0xC2D2AD9EAAE265B8();
		bool IsHudHidden();
		bool IsRadarHidden();
		bool IsMinimapRendering();
		void _0x0C698D8F099174C7(int p0);
		void _0xE4C3B169876D33D7(int p0);
		void _0xEB81A3DADD503187();
		/// <summary>
		/// Enable / disable showing route for the Blip-object.
		/// </summary>
		void SetBlipRoute(int blip, bool enabled);
		void ClearAllBlipRoutes();
		void SetBlipRouteColour(int blip, int colour);
		/// <summary>
		/// SET_F*
		/// </summary>
		void _0x2790F4B17D098E26(bool toggle);
		void _0x6CDD58146A436083(int p0);
		void _0xD1942374085C8469(int p0);
		void AddNextMessageToPreviousBriefs(bool p0);
		/// <summary>
		/// FORCE_*
		/// </summary>
		void _0x57D760D55F54E071(int p0);
		void SetRadarZoomPrecise(float zoom);
		/// <summary>
		/// </summary>
		/// <param name="zoomLevel">ranges from 0 to 200</param>
		void SetRadarZoom(int zoomLevel);
		void SetRadarZoomToBlip(int blip, float zoom);
		void SetRadarZoomToDistance(float zoom);
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		void _0xD2049635DEB9C375();
		/// <summary>
		/// HUD colors and their values: pastebin.com/d9aHPbXN
		/// </summary>
		void GetHudColour(int hudColorIndex, ref int r, ref int g, ref int b, ref int a);
		/// <summary>
		/// Sets the color of HUD_COLOUR_SCRIPT_VARIABLE
		/// </summary>
		void SetScriptVariableHudColour(int r, int g, int b, int a);
		/// <summary>
		/// Sets the color of HUD_COLOUR_SCRIPT_VARIABLE_2
		/// </summary>
		void SetScriptVariable2HudColour(int r, int g, int b, int a);
		/// <summary>
		/// HUD colors and their values: pastebin.com/d9aHPbXN
		/// --------------------------------------------------
		/// makes hudColorIndex2 color into hudColorIndex color
		/// </summary>
		void ReplaceHudColour(int hudColorIndex, int hudColorIndex2);
		/// <summary>
		/// HUD colors and their values: pastebin.com/d9aHPbXN
		/// </summary>
		void ReplaceHudColourWithRgba(int hudColorIndex, int r, int g, int b, int a);
		void SetAbilityBarVisibilityInMultiplayer(bool visible);
		void SetAllowAbilityBarInMultiplayer(bool toggle);
		void FlashAbilityBar(int millisecondsToFlash);
		void SetAbilityBarValue(float p0, float p1);
		void FlashWantedDisplay(bool p0);
		/// <summary>
		/// FORCE_*
		/// </summary>
		void _0xBA8D65C1C65702E5(bool toggle);
		/// <summary>
		/// This gets the height of the FONT and not the total text. You need to get the number of lines your text uses, and get the height of a newline (I'm using a smaller value) to get the total text height.
		/// </summary>
		float GetRenderedCharacterHeight(float size, int font);
		/// <summary>
		/// </summary>
		/// <param name="scale">is unknown and doesn't seem to have an effect, yet in the game scripts it changes to 1.0F sometimes.</param>
		/// <param name="size">range : 0F to 1.0F</param>
		void SetTextScale(float scale, float size);
		/// <summary>
		/// colors you input not same as you think?
		/// </summary>
		/// <param name="alpha">for some reason its R B G A</param>
		void SetTextColour(int red, int green, int blue, int alpha);
		void SetTextCentre(bool align);
		void SetTextRightJustify(bool toggle);
		/// <summary>
		/// Types -
		/// 0: Center-Justify
		/// 1: Left-Justify
		/// 2: Right-Justify
		/// Right-Justify requires SET_TEXT_WRAP, otherwise it will draw to the far right of the screen
		/// </summary>
		void SetTextJustification(int justifyType);
		/// <summary>
		/// It sets the text in a specified box and wraps the text if it exceeds the boundries. Both values are for X axis. Useful when positioning text set to center or aligned to the right.
		/// </summary>
		/// <param name="start">- left boundry on screen position (0.0 - 1.0)</param>
		/// <param name="end">- right boundry on screen position (0.0 - 1.0)</param>
		void SetTextWrap(float start, float end);
		void SetTextLeading(int p0);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void SetTextProportional(bool p0);
		/// <summary>
		/// fonts that mess up your text where made for number values/misc stuff
		/// </summary>
		void SetTextFont(int fontType);
		void SetTextDropShadow();
		/// <summary>
		/// </summary>
		/// <param name="distance">- shadow distance in pixels, both horizontal and vertical</param>
		/// <param name="r">color</param>
		/// <param name="g">color</param>
		/// <param name="b">color</param>
		void SetTextDropshadow(int distance, int r, int g, int b, int a);
		void SetTextOutline();
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void SetTextEdge(int p0, int r, int g, int b, int a);
		void SetTextRenderId(int renderId);
		int GetDefaultScriptRendertargetRenderId();
		bool RegisterNamedRendertarget(string name, bool p1);
		bool IsNamedRendertargetRegistered(string name);
		bool ReleaseNamedRendertarget(string name);
		void LinkNamedRendertarget(int modelHash);
		int GetNamedRendertargetRenderId(string name);
		bool IsNamedRendertargetLinked(int modelHash);
		void ClearHelp(bool toggle);
		bool IsHelpMessageOnScreen();
		/// <summary>
		/// HAS_S*
		/// </summary>
		bool _0x214CD562A939246A();
		bool IsHelpMessageBeingDisplayed();
		bool IsHelpMessageFadingOut();
		void SetHelpMessageTextStyle(int style, int hudColor, int alpha, int p3, int p4);
		bool GetStandardBlipEnumId();
		int GetWaypointBlipEnumId();
		int GetNumberOfActiveBlips();
		int GetNextBlipInfoId(int blipSprite);
		int GetFirstBlipInfoId(int blipSprite);
		int GetClosestBlipOfType(int blipSprite);
		Vector3 GetBlipInfoIdCoord(int blip);
		int GetBlipInfoIdDisplay(int blip);
		/// <summary>
		/// Returns a value based on what the blip is attached to
		/// 1 - Vehicle
		/// 2 - Ped
		/// 3 - Object
		/// 4 - Coord
		/// 5 - unk
		/// 6 - Pickup
		/// 7 - Radius
		/// </summary>
		int GetBlipInfoIdType(int blip);
		int GetBlipInfoIdEntityIndex(int blip);
		/// <summary>
		/// </summary>
		/// <returns>This function is hard-coded to always return 0.</returns>
		int GetBlipInfoIdPickupIndex(int blip);
		/// <summary>
		/// Returns the Blip handle of given Entity.
		/// </summary>
		int GetBlipFromEntity(int entity);
		int AddBlipForRadius(float posX, float posY, float posZ, float radius);
		/// <summary>
		/// Adds a rectangular blip for the specified coordinates/area.
		/// It is recommended to use SET_BLIP_ROTATION and SET_BLIP_COLOUR to make the blip not rotate along with the camera.
		/// By default, the blip will show as a _regular_ blip with the specified color/sprite if it is outside of the minimap view.
		/// Example image:
		/// minimap https://w.wew.wtf/pdcjig.png
		/// big map https://w.wew.wtf/zgcjcm.png
		/// (Native name is _likely_ to actually be ADD_BLIP_FOR_AREA, but due to the usual reasons this can't be confirmed)
		/// </summary>
		int AddBlipForArea(float x, float y, float z, float width, float height);
		/// <summary>
		/// Returns red ( default ) blip attached to entity.
		/// Example:
		/// Blip blip; //Put this outside your case or option
		/// blip = HUD::ADD_BLIP_FOR_ENTITY(YourPedOrBodyguardName);
		/// HUD::SET_BLIP_AS_FRIENDLY(blip, true);
		/// </summary>
		int AddBlipForEntity(int entity);
		int AddBlipForPickup(int pickup);
		/// <summary>
		/// </summary>
		/// <returns>Creates an orange ( default ) Blip-object. Returns a Blip-object which can then be modified.</returns>
		int AddBlipForCoord(float x, float y, float z);
		void TriggerSonarBlip(float posX, float posY, float posZ, float radius, int p4);
		void AllowSonarBlips(bool toggle);
		void SetBlipCoords(int blip, float posX, float posY, float posZ);
		Vector3 GetBlipCoords(int blip);
		/// <summary>
		/// Sets the displayed sprite for a specific blip..
		/// You may have your own list, but since dev-c didn't show it I was bored and started looking through scripts and functions to get a presumable almost positive list of a majority of blip IDs
		/// h t t p://pastebin.com/Bpj9Sfft
		/// Blips Images + IDs:
		/// gtaxscripting.blogspot.com/2016/05/gta-v-blips-id-and-image.html
		/// </summary>
		void SetBlipSprite(int blip, int spriteId);
		/// <summary>
		/// Blips Images + IDs:
		/// gtaxscripting.blogspot.com/2016/05/gta-v-blips-id-and-image.html
		/// </summary>
		int GetBlipSprite(int blip);
		/// <summary>
		/// SET_C*
		/// </summary>
		void _0x9FCB3CBFB3EAD69A(int p0, float p1);
		/// <summary>
		/// SET_C*
		/// </summary>
		void _0xB7B873520C84C118();
		/// <summary>
		/// Doesn't work if the label text of gxtEntry is >= 80.
		/// </summary>
		void SetBlipNameFromTextFile(int blip, string gxtEntry);
		void SetBlipNameToPlayerName(int blip, int player);
		/// <summary>
		/// Sets alpha-channel for blip color.
		/// Example:
		/// HUD::SET_BLIP_COLOUR(blip , 3);
		/// HUD::SET_BLIP_ALPHA(blip , 64);
		/// </summary>
		/// <param name="blip">blip = HUD::ADD_BLIP_FOR_ENTITY(entity);</param>
		void SetBlipAlpha(int blip, int alpha);
		int GetBlipAlpha(int blip);
		void SetBlipFade(int blip, int opacity, int duration);
		/// <summary>
		/// GET_BLIP_*
		/// </summary>
		/// <returns>Seems to always return 0 from what I can tell. I've tried a lot of different blip related natives and it always seems to return 0. Decompiled scripts always pass a blip handle as p0.</returns>
		int _0x2C173AE2BDB9385E(int blip);
		/// <summary>
		/// After some testing, looks like you need to use CEIL() on the rotation (vehicle/ped heading) before using it there.
		/// </summary>
		void SetBlipRotation(int blip, int rotation);
		/// <summary>
		/// Does not require whole number/integer rotations.
		/// </summary>
		void SetBlipSquaredRotation(int blip, float heading);
		int GetBlipRotation(int blip);
		/// <summary>
		/// Adds up after viewing multiple R* scripts. I believe that the duration is in miliseconds.
		/// </summary>
		void SetBlipFlashTimer(int blip, int duration);
		void SetBlipFlashInterval(int blip, int p1);
		/// <summary>
		/// </summary>
		/// <param name="color">//gtaforums.com/topic/864881-all-blip-color-ids-pictured/</param>
		void SetBlipColour(int blip, int color);
		void SetBlipSecondaryColour(int blip, int r, int g, int b);
		int GetBlipColour(int blip);
		int GetBlipHudColour(int blip);
		bool IsBlipShortRange(int blip);
		bool IsBlipOnMinimap(int blip);
		bool DoesBlipHaveGpsRoute(int blip);
		void SetBlipHiddenOnLegend(int blip, bool toggle);
		void SetBlipHighDetail(int blip, bool toggle);
		void SetBlipAsMissionCreatorBlip(int blip, bool toggle);
		bool IsMissionCreatorBlip(int blip);
		int GetNewSelectedMissionCreatorBlip();
		bool IsHoveringOverMissionCreatorBlip();
		void ShowStartMissionInstructionalButton(bool p0);
		void _0x2916A928514C9827();
		void _0xB552929B85FC27EC(int p0, int p1);
		void SetBlipFlashes(int blip, bool toggle);
		void SetBlipFlashesAlternate(int blip, bool toggle);
		bool IsBlipFlashing(int blip);
		/// <summary>
		/// Sets whether or not the specified blip should only be displayed when nearby, or on the minimap.
		/// </summary>
		void SetBlipAsShortRange(int blip, bool toggle);
		void SetBlipScale(int blip, float scale);
		/// <summary>
		/// See https://imgur.com/a/lLkEsMN
		/// </summary>
		void SetBlipScaleTransformation(int blip, float xScale, float yScale);
		/// <summary>
		/// See this topic for more details : gtaforums.com/topic/717612-v-scriptnative-documentation-and-research/page-35?p=1069477935
		/// </summary>
		void SetBlipPriority(int blip, int priority);
		/// <summary>
		/// Display Id behaviours:
		/// 0 = Doesn't show up, ever, anywhere.
		/// 1 = Doesn't show up, ever, anywhere.
		/// 2 = Shows on both main map and minimap. (Selectable on map)
		/// 3 = Shows on main map only. (Selectable on map)
		/// 4 = Shows on main map only. (Selectable on map)
		/// 5 = Shows on minimap only.
		/// 6 = Shows on both main map and minimap. (Selectable on map)
		/// 7 = Doesn't show up, ever, anywhere.
		/// See NativeDB for reference: http://natives.altv.mp/#/0x9029B2F3DA924928
		/// </summary>
		void SetBlipDisplay(int blip, int displayId);
		/// <summary>
		/// Example: https://i.imgur.com/skY6vAJ.png
		/// 1 = No distance shown in legend
		/// 2 = Distance shown in legend
		/// 7 = "Other Players" category, also shows distance in legend
		/// 10 = "Property" category
		/// 11 = "Owned Property" category
		/// Any other value behaves like index = 1, index wraps around after 255
		/// Blips with categories 7, 10 or 11 will all show under the specific categories listing in the map legend, regardless of sprite or name.
		/// Legend entries:
		/// See NativeDB for reference: http://natives.altv.mp/#/0x234CDD44D996FD9A
		/// </summary>
		void SetBlipCategory(int blip, int index);
		/// <summary>
		/// In the C++ SDK, this seems not to work-- the blip isn't removed immediately. I use it for saving cars.
		/// E.g.:
		/// Ped pped = PLAYER::PLAYER_PED_ID();
		/// Vehicle v = PED::GET_VEHICLE_PED_IS_USING(pped);
		/// works fine.
		/// But later attempting to delete it with:
		/// Blip b = HUD::GET_BLIP_FROM_ENTITY(v);
		/// if (HUD::DOES_BLIP_EXIST(b)) HUD::REMOVE_BLIP(&b);
		/// doesn't work. And yes, doesn't work without the DOES_BLIP_EXIST check either. Also, if you attach multiple blips to the same thing (say, a vehicle), and that thing disappears, the blips randomly attach to other things (in my case, a vehicle).
		/// See NativeDB for reference: http://natives.altv.mp/#/0x86A652570E5F25DD
		/// </summary>
		/// <param name="blip">b = HUD::ADD_BLIP_FOR_ENTITY(v);</param>
		void RemoveBlip(ref int blip);
		/// <summary>
		/// false for enemy
		/// true for friendly
		/// </summary>
		void SetBlipAsFriendly(int blip, bool toggle);
		void PulseBlip(int blip);
		void ShowNumberOnBlip(int blip, int number);
		void HideNumberOnBlip(int blip);
		void ShowHeightOnBlip(int blip, bool toggle);
		/// <summary>
		/// Adds a green checkmark on top of a blip.
		/// </summary>
		void ShowTickOnBlip(int blip, bool toggle);
		/// <summary>
		/// Adds the GTA: Online player heading indicator to a blip.
		/// </summary>
		void ShowHeadingIndicatorOnBlip(int blip, bool toggle);
		/// <summary>
		/// Highlights a blip by a cyan color circle.
		/// Color can be changed with SET_BLIP_SECONDARY_COLOUR
		/// </summary>
		void ShowOutlineIndicatorOnBlip(int blip, bool toggle);
		/// <summary>
		/// Highlights a blip by a half cyan circle on the right side of the blip. https://i.imgur.com/FrV9M4e.png
		/// .Indicating that that player is a friend (in GTA:O). This color can not be changed.
		/// </summary>
		/// <param name="blip">`SHOW_CREW_INDICATOR_ON_BLIP`</param>
		void ShowFriendIndicatorOnBlip(int blip, bool toggle);
		/// <summary>
		/// Enables or disables the blue half circle https://i.imgur.com/iZes9Ec.png around the specified blip on the left side of the blip. This is used to indicate that the player is in your crew in GTA:O. Color is changeable by using `SET_BLIP_SECONDARY_COLOUR`.
		/// </summary>
		void ShowCrewIndicatorOnBlip(int blip, bool toggle);
		/// <summary>
		/// Must be toggled before being queued for animation
		/// </summary>
		void SetBlipDisplayIndicatorOnBlip(int blip, bool toggle);
		void _0x4B5B620C9B59ED34(int p0, int p1);
		void _0x2C9F302398E13141(int p0, int p1);
		/// <summary>
		/// Makes a blip go small when off the minimap.
		/// </summary>
		void SetBlipAsMinimalOnEdge(int blip, bool toggle);
		/// <summary>
		/// Enabling this on a radius blip will make it outline only. See https://cdn.discordapp.com/attachments/553235301632573459/575132227935928330/unknown.png
		/// </summary>
		void SetRadiusBlipEdge(int blip, bool toggle);
		bool DoesBlipExist(int blip);
		/// <summary>
		/// This native removes the current waypoint from the map.
		/// Example:
		/// C#:
		/// Function.Call(Hash.SET_WAYPOINT_OFF);
		/// C++:
		/// HUD::SET_WAYPOINT_OFF();
		/// </summary>
		void SetWaypointOff();
		void DeleteWaypoint();
		void RefreshWaypoint();
		bool IsWaypointActive();
		void SetNewWaypoint(float x, float y);
		void SetBlipBright(int blip, bool toggle);
		void SetBlipShowCone(int blip, bool toggle, int p2);
		/// <summary>
		/// Interesting fact: A hash collision for this is RESET_JETPACK_MODEL_SETTINGS
		/// </summary>
		void _0xC594B315EDF2D4AF(int ped);
		void _0xF83D0FEBE75E62C9(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8);
		void _0x35A3CD97B2C0A6D2(int blip);
		void _0x8410C5E0CD847B9D();
		/// <summary>
		/// This native is used to colorize certain map components like the army base at the top of the map.
		/// </summary>
		/// <param name="overrideColor">appears to be always -1. If p2 is -1 then native wouldn't change the color. See https://gfycat.com/SkinnyPinkChupacabra</param>
		int SetMinimapComponent(int componentId, bool toggle, int overrideColor);
		void SetMinimapSonarEnabled(bool toggle);
		void ShowSigninUi();
		int GetMainPlayerBlipId();
		void _0x41350B4FC28E3941(bool p0);
		void HideLoadingOnFadeThisFrame();
		/// <summary>
		/// List of interior hashes: pastebin.com/1FUyXNqY
		/// Not for every interior zoom > 0 available.
		/// </summary>
		void SetRadarAsInteriorThisFrame(int interior, float x, float y, int z, int zoom);
		void SetInteriorZoomLevelIncreased(bool toggle);
		void SetInteriorZoomLevelDecreased(bool toggle);
		void SetRadarAsExteriorThisFrame();
		/// <summary>
		/// Sets the position of the arrow icon representing the player on both the minimap and world map.
		/// Too bad this wouldn't work over the network (obviously not). Could spoof where we would be.
		/// </summary>
		void SetPlayerBlipPositionThisFrame(float x, float y);
		void _0xA17784FCA9548D15(int p0, int p1, int p2);
		bool IsMinimapInInterior();
		void HideMinimapExteriorMapThisFrame();
		void HideMinimapInteriorMapThisFrame();
		/// <summary>
		/// Toggles the Cayo Perico map.
		/// </summary>
		void SetToggleMinimapHeistIsland(bool toggle);
		/// <summary>
		/// When calling this, the current frame will have the players "arrow icon" be focused on the dead center of the radar.
		/// </summary>
		void DontTiltMinimapThisFrame();
		void _0x55F5A5F07134DE60();
		void SetWidescreenFormat(int p0);
		void DisplayAreaName(bool toggle);
		/// <summary>
		/// "DISPLAY_CASH(false);" makes the cash amount render on the screen when appropriate
		/// "DISPLAY_CASH(true);" disables cash amount rendering
		/// </summary>
		void DisplayCash(bool toggle);
		/// <summary>
		/// Related to displaying cash on the HUD
		/// Always called before HUD::_SET_SINGLEPLAYER_HUD_CASH in decompiled scripts
		/// </summary>
		void _0x170F541E1CADD1DE(bool p0);
		/// <summary>
		/// Displays cash change notifications on HUD.
		/// </summary>
		void SetPlayerCashChange(int cash, int bank);
		void DisplayAmmoThisFrame(bool display);
		/// <summary>
		/// Displays the crosshair for this frame.
		/// </summary>
		void DisplaySniperScopeThisFrame();
		/// <summary>
		/// I think this works, but seems to prohibit switching to other weapons (or accessing the weapon wheel)
		/// </summary>
		void HideHudAndRadarThisFrame();
		void _0xE67C6DFD386EA5E7(bool p0);
		void SetMultiplayerWalletCash();
		void RemoveMultiplayerWalletCash();
		void SetMultiplayerBankCash();
		void RemoveMultiplayerBankCash();
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void SetMultiplayerHudCash(int p0, int p1);
		/// <summary>
		/// Removes multiplayer cash hud each frame
		/// </summary>
		void RemoveMultiplayerHudCash();
		void HideHelpTextThisFrame();
		/// <summary>
		/// IS_*
		/// </summary>
		bool _0x801879A9B4F4B2FB();
		/// <summary>
		/// The messages are localized strings.
		/// Examples:
		/// "No_bus_money"
		/// "Enter_bus"
		/// "Tour_help"
		/// "LETTERS_HELP2"
		/// "Dummy"
		/// **The bool appears to always be false (if it even is a bool, as it's represented by a zero)**
		/// --------
		/// picture of where on the screen this is displayed?
		/// </summary>
		/// <param name="p1">doesn't seem to make a difference, regardless of the state it's in.</param>
		void DisplayHelpTextThisFrame(string message, bool p1);
		/// <summary>
		/// Forces the weapon wheel to show/hide.
		/// </summary>
		void HudForceWeaponWheel(bool show);
		/// <summary>
		/// Displays loading screen tips, requires `_0x56C8B608CFD49854` to be called beforehand.
		/// </summary>
		void HudDisplayLoadingScreenTips();
		/// <summary>
		/// Calling this each frame, stops the player from receiving a weapon via the weapon wheel.
		/// </summary>
		void BlockWeaponWheelThisFrame();
		/// <summary>
		/// Returns the weapon hash to the selected/highlighted weapon in the wheel
		/// </summary>
		int HudWeaponWheelGetSelectedHash();
		/// <summary>
		/// Set the active slotIndex in the wheel weapon to the slot associated with the provided Weapon hash
		/// </summary>
		void HudSetWeaponWheelTopSlot(int weaponHash);
		/// <summary>
		/// Returns the weapon hash active in a specific weapon wheel slotList
		/// </summary>
		int HudWeaponWheelGetSlotHash(int weaponTypeIndex);
		/// <summary>
		/// Sets a global that disables many weapon input tasks (shooting, aiming, etc.). Does not work with vehicle weapons, only used in selector.ysc
		/// </summary>
		void HudWeaponWheelIgnoreControlInput(bool toggle);
		/// <summary>
		/// Only the script that originally called SET_GPS_FLAGS can set them again. Another script cannot set the flags, until the first script that called it has called CLEAR_GPS_FLAGS.
		/// Doesn't seem like the flags are actually read by the game at all.
		/// </summary>
		void SetGpsFlags(int p0, float p1);
		/// <summary>
		/// Clears the GPS flags. Only the script that originally called SET_GPS_FLAGS can clear them.
		/// Doesn't seem like the flags are actually read by the game at all.
		/// </summary>
		void ClearGpsFlags();
		void SetRaceTrackRender(bool toggle);
		/// <summary>
		/// Does the same as SET_RACE_TRACK_RENDER(false);
		/// </summary>
		void ClearGpsRaceTrack();
		/// <summary>
		/// Starts a new GPS custom-route, allowing you to plot lines on the map.
		/// Lines are drawn directly between points.
		/// The GPS custom route works like the GPS multi route, except it does not follow roads.
		/// Example result: https://i.imgur.com/BDm5pzt.png
		/// </summary>
		/// <param name="hudColor">The HUD color of the GPS path.</param>
		/// <param name="displayOnFoot">Draws the path regardless if the player is in a vehicle or not.</param>
		/// <param name="followPlayer">Draw the path partially between the previous and next point based on the players position between them. When false, the GPS appears to not disappear after the last leg is completed.</param>
		void StartGpsCustomRoute(int hudColor, bool displayOnFoot, bool followPlayer);
		void AddPointToGpsCustomRoute(float x, float y, float z);
		/// <summary>
		/// </summary>
		/// <param name="radarThickness">The width of the GPS route on the radar</param>
		/// <param name="mapThickness">The width of the GPS route on the map</param>
		void SetGpsCustomRouteRender(bool toggle, int radarThickness, int mapThickness);
		void ClearGpsCustomRoute();
		/// <summary>
		/// Starts a new GPS multi-route, allowing you to create custom GPS paths.
		/// GPS functions like the waypoint, except it can contain multiple points it's forced to go through.
		/// Once the player has passed a point, the GPS will no longer force its path through it.
		/// Works independently from the player-placed waypoint and blip routes.
		/// Example result: https://i.imgur.com/ZZHQatX.png
		/// </summary>
		/// <param name="hudColor">The HUD color of the GPS path.</param>
		/// <param name="routeFromPlayer">Makes the GPS draw a path from the player to the next point, rather than the original path from the previous point.</param>
		/// <param name="displayOnFoot">Draws the GPS path regardless if the player is in a vehicle or not.</param>
		void StartGpsMultiRoute(int hudColor, bool routeFromPlayer, bool displayOnFoot);
		void AddPointToGpsMultiRoute(float x, float y, float z);
		void SetGpsMultiRouteRender(bool toggle);
		/// <summary>
		/// Does the same as SET_GPS_MULTI_ROUTE_RENDER(false);
		/// </summary>
		void ClearGpsMultiRoute();
		void ClearGpsPlayerWaypoint();
		void SetGpsFlashes(bool toggle);
		void SetMainPlayerBlipColour(int color);
		/// <summary>
		/// adds a short flash to the Radar/Minimap
		/// Usage: UI.FLASH_MINIMAP_DISPLAY
		/// </summary>
		void FlashMinimapDisplay();
		void FlashMinimapDisplayWithColor(int hudColorIndex);
		void ToggleStealthRadar(bool toggle);
		void SetMinimapInSpectatorMode(bool toggle, int ped);
		void SetMissionName(bool p0, string name);
		void SetMissionName2(bool p0, string name);
		/// <summary>
		/// HUD::_817B86108EB94E51(1, &g_189F36._f10CD1[016], &g_189F36._f10CD1[116], &g_189F36._f10CD1[216], &g_189F36._f10CD1[316], &g_189F36._f10CD1[416], &g_189F36._f10CD1[516], &g_189F36._f10CD1[616], &g_189F36._f10CD1[716]);
		/// </summary>
		void _0x817B86108EB94E51(bool p0, ref int p1, ref int p2, ref int p3, ref int p4, ref int p5, ref int p6, ref int p7, ref int p8);
		void SetMinimapBlockWaypoint(bool toggle);
		/// <summary>
		/// Toggles the North Yankton map
		/// </summary>
		void SetMinimapInPrologue(bool toggle);
		/// <summary>
		/// If true, the entire map will be revealed.
		/// FOW = Fog of War
		/// </summary>
		void SetMinimapHideFow(bool toggle);
		float GetMinimapFowDiscoveryRatio();
		bool GetMinimapFowCoordinateIsRevealed(float x, float y, float z);
		void _0x62E849B7EB28E770(bool p0);
		void SetMinimapFowRevealCoordinate(float x, float y, float z);
		/// <summary>
		/// Not much is known so far on what it does _exactly_.
		/// All I know for sure is that it draws the specified hole ID on the pause menu map as well as on the mini-map/radar. This native also seems to change some other things related to the pause menu map's behaviour, for example: you can no longer set waypoints, the pause menu map starts up in a 'zoomed in' state. This native does not need to be executed every tick.
		/// You need to center the minimap manually as well as change/lock it's zoom and angle in order for it to appear correctly on the minimap.
		/// You'll also need to use the `GOLF` scaleform in order to get the correct minmap border to show up.
		/// Use `0x35edd5b2e3ff01c0` to reset the map when you no longer want to display any golf holes (you still need to unlock zoom, position and angle of the radar manually after calling this).
		/// </summary>
		void SetMinimapGolfCourse(int hole);
		void SetMinimapGolfCourseOff();
		/// <summary>
		/// Locks the minimap to the specified angle in integer degrees.
		/// </summary>
		/// <param name="angle">The angle in whole degrees. If less than 0 or greater than 360, unlocks the angle.</param>
		void LockMinimapAngle(int angle);
		void UnlockMinimapAngle();
		/// <summary>
		/// Locks the minimap to the specified world position.
		/// </summary>
		void LockMinimapPosition(float x, float y);
		void UnlockMinimapPosition();
		/// <summary>
		/// Argument must be 0.0f or above 38.0f, or it will be ignored.
		/// </summary>
		void SetMinimapAltitudeIndicatorLevel(float altitude, bool p1, int p2);
		void SetHealthHudDisplayValues(int health, int capacity, bool wasAdded);
		void SetMaxHealthHudDisplay(int maximumValue);
		void SetMaxArmourHudDisplay(int maximumValue);
		/// <summary>
		/// Toggles the big minimap state like in GTA:Online.
		/// </summary>
		void SetBigmapActive(bool toggleBigMap, bool showFullMap);
		/// <summary>
		/// Full list of components below
		/// HUD = 0;
		/// HUD_WANTED_STARS = 1;
		/// HUD_WEAPON_ICON = 2;
		/// HUD_CASH = 3;
		/// HUD_MP_CASH = 4;
		/// HUD_MP_MESSAGE = 5;
		/// HUD_VEHICLE_NAME = 6;
		/// HUD_AREA_NAME = 7;
		/// See NativeDB for reference: http://natives.altv.mp/#/0xBC4C9EA5391ECC0D
		/// </summary>
		bool IsHudComponentActive(int id);
		bool IsScriptedHudComponentActive(int id);
		void HideScriptedHudComponentThisFrame(int id);
		/// <summary>
		/// SHOW_*
		/// </summary>
		void ShowScriptedHudComponentThisFrame(int id);
		bool IsScriptedHudComponentHiddenThisFrame(int id);
		/// <summary>
		/// This function hides various HUD (Heads-up Display) components.
		/// Listed below are the integers and the corresponding HUD component.
		/// - 1 : WANTED_STARS
		/// - 2 : WEAPON_ICON
		/// - 3 : CASH
		/// - 4 : MP_CASH
		/// - 5 : MP_MESSAGE
		/// - 6 : VEHICLE_NAME
		/// - 7 : AREA_NAME
		/// See NativeDB for reference: http://natives.altv.mp/#/0x6806C51AD12B83B8
		/// </summary>
		void HideHudComponentThisFrame(int id);
		/// <summary>
		/// This function hides various HUD (Heads-up Display) components.
		/// Listed below are the integers and the corresponding HUD component.
		/// - 1 : WANTED_STARS
		/// - 2 : WEAPON_ICON
		/// - 3 : CASH
		/// - 4 : MP_CASH
		/// - 5 : MP_MESSAGE
		/// - 6 : VEHICLE_NAME
		/// - 7 : AREA_NAME
		/// See NativeDB for reference: http://natives.altv.mp/#/0x0B4DF1FA60C0E664
		/// </summary>
		void ShowHudComponentThisFrame(int id);
		/// <summary>
		/// HIDE_*_THIS_FRAME
		/// Hides area and vehicle name HUD components for one frame.
		/// </summary>
		void HideAreaAndVehicleNameThisFrame();
		void ResetReticuleValues();
		void ResetHudComponentValues(int id);
		void SetHudComponentPosition(int id, float x, float y);
		Vector3 GetHudComponentPosition(int id);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void ClearReminderMessage();
		/// <summary>
		/// World to relative screen coords, this world to screen will keep the text on screen. Was named _GET_SCREEN_COORD_FROM_WORLD_COORD, but this conflicts with 0x34E82F05DF2974F5. As that hash actually matches GET_SCREEN_COORD_FROM_WORLD_COORD that one supercedes and this one was renamed to _GET_2D_COORD_FROM_3D_COORD
		/// </summary>
		bool GetScreenCoordFromWorldCoord2(float worldX, float worldY, float worldZ, ref float screenX, ref float screenY);
		/// <summary>
		/// Shows a menu for reporting UGC content.
		/// </summary>
		void OpenReportugcMenu();
		void ForceCloseReportugcMenu();
		bool IsReportugcMenuOpen();
		bool IsFloatingHelpTextOnScreen(int hudIndex);
		void SetFloatingHelpTextScreenPosition(int hudIndex, float x, float y);
		void SetFloatingHelpTextWorldPosition(int hudIndex, float x, float y, float z);
		void SetFloatingHelpTextToEntity(int hudIndex, int entity, float offsetX, float offsetY);
		void SetFloatingHelpTextStyle(int hudIndex, int p1, int p2, int p3, int p4, int p5);
		void ClearFloatingHelp(int hudIndex, bool p1);
		/// <summary>
		/// </summary>
		/// <param name="clanFlag">takes a number 0-5</param>
		void CreateMpGamerTagWithCrewColor(int player, string username, bool pointedClanTag, bool isRockstarClan, string clanTag, int clanFlag, int r, int g, int b);
		bool IsMpGamerTagMovieActive();
		/// <summary>
		/// </summary>
		/// <param name="clanFlag">takes a number 0-5</param>
		int CreateFakeMpGamerTag(int ped, string username, bool pointedClanTag, bool isRockstarClan, string clanTag, int clanFlag);
		void RemoveMpGamerTag(int gamerTagId);
		bool IsMpGamerTagActive(int gamerTagId);
		bool IsMpGamerTagFree(int gamerTagId);
		/// <summary>
		/// enum eMpGamerTagComponent
		/// {
		/// MP_TAG_GAMER_NAME,
		/// MP_TAG_CREW_TAG,
		/// MP_TAG_HEALTH_ARMOUR,
		/// MP_TAG_BIG_TEXT,
		/// MP_TAG_AUDIO_ICON,
		/// MP_TAG_USING_MENU,
		/// MP_TAG_PASSIVE_MODE,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x63BB75ABEDC1F6A0
		/// </summary>
		void SetMpGamerTagVisibility(int gamerTagId, int component, bool toggle, int p3);
		void SetMpGamerTagEnabled(int gamerTagId, bool toggle);
		/// <summary>
		/// Displays a bunch of icons above the players name, and level, and their name twice
		/// </summary>
		void SetMpGamerTagIcons(int gamerTagId, bool toggle);
		void SetMpGamerHealthBarDisplay(int gamerTagId, bool toggle);
		void SetMpGamerHealthBarMax(int gamerTagId, int value, int maximumValue);
		/// <summary>
		/// Sets a gamer tag's component colour
		/// Ranges from 0 to 255. 0 is grey health bar, ~50 yellow, 200 purple.
		/// </summary>
		/// <param name="gamerTagId">is obtained using for example CREATE_FAKE_MP_GAMER_TAG</param>
		void SetMpGamerTagColour(int gamerTagId, int component, int hudColorIndex);
		/// <summary>
		/// Ranges from 0 to 255. 0 is grey health bar, ~50 yellow, 200 purple.
		/// Should be enabled as flag (2). Has 0 opacity by default.
		/// - This was _SET_MP_GAMER_TAG_HEALTH_BAR_COLOR,
		/// -> Rockstar use the EU spelling of 'color' so I hashed the same name with COLOUR and it came back as the correct hash, so it has been corrected above.
		/// </summary>
		void SetMpGamerTagHealthBarColour(int gamerTagId, int hudColorIndex);
		/// <summary>
		/// Sets flag's sprite transparency. 0-255.
		/// </summary>
		void SetMpGamerTagAlpha(int gamerTagId, int component, int alpha);
		/// <summary>
		/// displays wanted star above head
		/// </summary>
		void SetMpGamerTagWantedLevel(int gamerTagId, int wantedlvl);
		void SetMpGamerTagUnk(int gamerTagId, int p1);
		void SetMpGamerTagName(int gamerTagId, string @string);
		/// <summary>
		/// IS_*
		/// </summary>
		bool IsValidMpGamerTagMovie(int gamerTagId);
		void SetMpGamerTagBigText(int gamerTagId, string @string);
		int GetCurrentWebpageId();
		int GetCurrentWebsiteId();
		/// <summary>
		/// Returns the ActionScript flagValue.
		/// ActionScript flags are global flags that scaleforms use
		/// Flags found during testing
		/// 1: Returns 1 if the player has clicked back twice on the opening page, otherwise 0 (web_browser)
		/// 2: Returns how many links the player has clicked in the web_browser scaleform, returns 0 when the browser gets closed
		/// 9: Returns the current selection on the mobile phone scaleform
		/// There are 20 flags in total.
		/// </summary>
		/// <returns>0: Returns 1 if the web_browser keyboard is open, otherwise 0</returns>
		int GetGlobalActionscriptFlag(int flagIndex);
		void ResetGlobalActionscriptFlag(int flagIndex);
		/// <summary>
		/// IS_WARNING_MESSAGE_*
		/// </summary>
		bool IsWarningMessageActive2();
		/// <summary>
		/// You can only use text entries. No custom text.
		/// Example: SET_WARNING_MESSAGE("t20", 3, "adder", false, -1, 0, 0, true);
		/// </summary>
		void SetWarningMessage(string titleMsg, int flags, string promptMsg, bool p3, int p4, string p5, string p6, bool showBackground, int p8);
		/// <summary>
		/// Shows a warning message on screen with a header.
		/// Note: You can only use text entries. No custom text. You can recreate this easily with scaleforms.
		/// Example: https://i.imgur.com/ITJt8bJ.png
		/// </summary>
		void SetWarningMessageWithHeader(string entryHeader, string entryLine1, int instructionalKey, string entryLine2, bool p4, int p5, ref int showBackground, ref int p7, bool p8, int p9);
		/// <summary>
		/// You can use this native for custom input, without having to use any scaleform-related natives.
		/// The native must be called on tick.
		/// The entryHeader must be a valid label.
		/// For Single lines use JL_INVITE_N as entryLine1, JL_INVITE_ND for multiple.
		/// Notes:
		/// - additionalIntInfo: replaces first occurrence of ~1~ in provided label with an integer
		/// - additionalTextInfoLine1: replaces first occurrence of ~a~ in provided label, with your custom text
		/// - additionalTextInfoLine2: replaces second occurrence of ~a~ in provided label, with your custom text
		/// - showBackground: shows black background of the warning screen
		/// See NativeDB for reference: http://natives.altv.mp/#/0x701919482C74B5AB
		/// </summary>
		void SetWarningMessageWithHeaderAndSubstringFlags(string entryHeader, string entryLine1, int instructionalKey, string entryLine2, bool p4, int p5, int additionalIntInfo, string additionalTextInfoLine1, string additionalTextInfoLine2, bool showBackground, int errorCode);
		/// <summary>
		/// </summary>
		void SetWarningMessageWithHeaderUnk(string entryHeader, string entryLine1, int flags, string entryLine2, bool p4, int p5, ref int p6, ref int p7, bool showBg, int p9, int p10);
		/// <summary>
		/// labelMsg: Label of the alert's message.
		/// labelMsg2: Label of another message line
		/// instructionalKey enum list:
		/// Buttons = {
		/// Empty = 0,
		/// Select = 1, -- (RETURN)
		/// Ok = 2, -- (RETURN)
		/// Yes = 4, -- (RETURN)
		/// Back = 8, -- (ESC)
		/// See NativeDB for reference: http://natives.altv.mp/#/0x15803FEC3B9A872B
		/// </summary>
		/// <param name="labelTitle">Label of the alert's title.</param>
		/// <param name="p2">This is an enum, check the description for a list.</param>
		/// <param name="p3">This is an enum, check the description for a list.</param>
		/// <param name="p5">usually 0</param>
		/// <param name="p6">usually -1</param>
		/// <param name="p7">usually 0</param>
		/// <param name="p8">unknown label</param>
		/// <param name="p9">unknown label</param>
		/// <param name="background">Set to anything other than 0 or false (even any string) and it will draw a background. Setting it to 0 or false will draw no background.</param>
		/// <param name="errorCode">Error code, shown at the bottom left if set to value other than 0.</param>
		void SetWarningMessageWithAlert(string labelTitle, string labelMessage, int p2, int p3, string labelMessage2, bool p5, int p6, int p7, string p8, string p9, bool background, int errorCode);
		/// <summary>
		/// Has to do with the confirmation overlay (E.g. confirm exit)
		/// </summary>
		int GetWarningMessageTitleHash();
		/// <summary>
		/// Some sort of list displayed in a warning message. Yet unknown how to prevent repeating.
		/// Param names copied from the corresponding scaleform function "SET_LIST_ROW".
		/// Example: https://i.imgur.com/arKvOYx.png
		/// </summary>
		bool SetWarningMessageListRow(int index, string name, int cash, int rp, int lvl, int colour);
		bool _0xDAF87174BE7454FF(int p0);
		void RemoveWarningMessageListItems();
		bool IsWarningMessageActive();
		void ClearDynamicPauseMenuErrorMessage();
		/// <summary>
		/// If toggle is true, the map is shown in full screen
		/// If toggle is false, the map is shown in normal mode
		/// </summary>
		void RaceGalleryFullscreen(bool toggle);
		/// <summary>
		/// Sets the sprite of the next BLIP_GALLERY blip, values used in the native scripts: 143 (ObjectiveBlue), 144 (ObjectiveGreen), 145 (ObjectiveRed), 146 (ObjectiveYellow).
		/// </summary>
		void RaceGalleryNextBlipSprite(int spriteId);
		/// <summary>
		/// Add a BLIP_GALLERY at the specific coordinate. Used in fm_maintain_transition_players to display race track points.
		/// </summary>
		int RaceGalleryAddBlip(float x, float y, float z);
		void ClearRaceGalleryBlips();
		int ForceSonarBlipsThisFrame();
		int GetNorthRadarBlip();
		/// <summary>
		/// Toggles whether or not name labels are shown on the expanded minimap next to player blips, like in GTA:O.
		/// Doesn't need to be called every frame.
		/// Preview: https://i.imgur.com/DfqKWfJ.png
		/// Make sure to call SET_BLIP_CATEGORY with index 7 for this to work on the desired blip.
		/// </summary>
		void DisplayPlayerNameTagsOnBlips(bool toggle);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void _0x211C4EF450086857();
		void _0xBF4F34A85CA2970C();
		/// <summary>
		/// Does stuff like this:
		/// gyazo.com/7fcb78ea3520e3dbc5b2c0c0f3712617
		/// Example:
		/// int GetHash = GET_HASH_KEY("fe_menu_version_corona_lobby");
		/// ACTIVATE_FRONTEND_MENU(GetHash, 0, -1);
		/// BOOL p1 is a toggle to define the game in pause.
		/// int p2 is unknown but -1 always works, not sure why though.
		/// [30/03/2017] ins1de :
		/// the int p2 is actually a component variable. When the pause menu is visible, it opens the tab related to it.
		/// See NativeDB for reference: http://natives.altv.mp/#/0xEF01D36B9C9D0C7B
		/// </summary>
		void ActivateFrontendMenu(int menuhash, bool togglePause, int component);
		/// <summary>
		/// Before using this native click the native above and look at the decription.
		/// Example:
		/// int GetHash = Function.Call<int>(Hash.GET_HASH_KEY, "fe_menu_version_corona_lobby");
		/// Function.Call(Hash.ACTIVATE_FRONTEND_MENU, GetHash, 0, -1);
		/// Function.Call(Hash.RESTART_FRONTEND_MENU(GetHash, -1);
		/// This native refreshes the frontend menu.
		/// p2 = Unknown but always works with -1.
		/// </summary>
		/// <param name="p1">= Hash of Menu</param>
		void RestartFrontendMenu(int menuHash, int p1);
		/// <summary>
		/// if (HUD::GET_CURRENT_FRONTEND_MENU_VERSION() == joaat("fe_menu_version_empty_no_background"))
		/// </summary>
		int GetCurrentFrontendMenuVersion();
		void SetPauseMenuActive(bool toggle);
		void DisableFrontendThisFrame();
		void SuppressFrontendRenderingThisFrame();
		/// <summary>
		/// Allows opening the pause menu this frame, when the player is dead.
		/// </summary>
		void AllowPauseMenuWhenDeadThisFrame();
		void SetFrontendActive(bool active);
		bool IsPauseMenuActive();
		/// <summary>
		/// Returns something related to the store.
		/// IS_S*
		/// IS_STORE_EXIT_PURCHASE_CAPABILITY_ACTIVATED ?
		/// </summary>
		bool _0x2F057596F2BD0061();
		/// <summary>
		/// Returns:
		/// 0
		/// 5
		/// 10
		/// 15
		/// 20
		/// 25
		/// 30
		/// 35
		/// </summary>
		int GetPauseMenuState();
		/// <summary>
		/// GET_PAUSE_MENU_*
		/// </summary>
		Vector3 _0x5BFF36D6ED83E0AE();
		bool IsPauseMenuRestarting();
		/// <summary>
		/// Not present in retail version of the game, actual definiton seems to be
		/// _LOG_DEBUG_INFO(const char* category, const char* debugText);
		/// </summary>
		void LogDebugInfo(string p0);
		void _0x77F16B447824DA6C(int p0);
		void _0xCDCA26E80FAECB8F();
		void _0x2DE6C5E2E996F178(int p0);
		/// <summary>
		/// Activates the specified frontend menu context.
		/// pausemenu.xml defines some specific menu options using 'context'. Context is basically a 'condition'.
		/// The `*ALL*` part of the context means that whatever is being defined, will be active when any or all of those conditions after `*ALL*` are met.
		/// The `*NONE*` part of the context section means that whatever is being defined, will NOT be active if any or all of the conditions after `*NONE*` are met.
		/// This basically allows you to hide certain menu sections, or things like instructional buttons.
		/// </summary>
		void PauseMenuActivateContext(int contextHash);
		void PauseMenuDeactivateContext(int contextHash);
		bool PauseMenuIsContextActive(int contextHash);
		bool PauseMenuIsContextMenuActive();
		int _0xDE03620F8703A9DF();
		int _0x359AF31A4B52F5ED();
		int _0x13C4B962653A5280();
		/// <summary>
		/// </summary>
		bool _0xC8E1071177A23BE5(ref int p0, ref int p1, ref int p2);
		void _0x4895BDEA16E7C080(int p0);
		void PauseMenuSetBusySpinner(bool p0, int p1, int p2);
		void _0xF06EBB91A81E09E3(bool p0);
		bool IsFrontendReadyForControl();
		/// <summary>
		/// Disables frontend (works in custom frontends, not sure about regular pause menu) navigation keys on keyboard. Not sure about controller. Does not disable mouse controls. No need to call this every tick.
		/// To enable the keys again, use `0x14621BB1DF14E2B2`.
		/// </summary>
		void TakeControlOfFrontend();
		/// <summary>
		/// Enables frontend (works in custom frontends, not sure about regular pause menu) navigation keys on keyboard if they were disabled using the native below.
		/// To disable the keys, use `0xEC9264727EEC0F28`
		/// </summary>
		void ReleaseControlOfFrontend();
		bool _0x66E7CB63C97B7D20();
		int _0x593FEAE1F73392D4();
		bool IsNavigatingMenuContent();
		bool _0xF284AC67940C6812();
		/// <summary>
		/// Returns true when the menu state(?) changed this frame.
		/// HAS_*? _GET_MENU_STATE_CHANGED_THIS_FRAME?
		/// </summary>
		bool _0x2E22FEFA0100275E();
		void _0x0CF54F20DE43879C(int p0);
		/// <summary>
		/// </summary>
		void GetPauseMenuSelection(ref int lastItemMenuId, ref int selectedItemUniqueId);
		/// <summary>
		/// when the pausemenu is closed:
		/// lastItemMenuId = -1
		/// selectedItemMenuId = -1
		/// selectedItemUniqueId = 0
		/// when the header gains focus:
		/// lastItemMenuId updates as normal or 0 if the pausemenu was just opened
		/// selectedItemMenuId becomes a unique id for the pausemenu page that focus was taken from (?) or 0 if the pausemenu was just opened
		/// selectedItemUniqueId = -1
		/// when focus is moved from the header to a pausemenu page:
		/// See NativeDB for reference: http://natives.altv.mp/#/0x7E17BE53E1AAABAF
		/// </summary>
		/// <param name="lastItemMenuId">this is the menuID of the last selected item minus 1000 (lastItem.menuID - 1000)</param>
		/// <param name="selectedItemMenuId">same as lastItemMenuId except for the currently selected menu item</param>
		/// <param name="selectedItemUniqueId">this is uniqueID of the currently selected menu item</param>
		void GetPauseMenuSelectionData(ref int lastItemMenuId, ref int selectedItemMenuId, ref int selectedItemUniqueId);
		/// <summary>
		/// </summary>
		bool _0xA238192F33110615(ref int p0, ref int p1, ref int p2);
		/// <summary>
		/// </summary>
		bool GetMenuPedIntStat(int p0, ref int p1);
		/// <summary>
		/// </summary>
		bool _0xCA6B2F7CE32AB653(int p0, ref int p1, int p2);
		/// <summary>
		/// </summary>
		bool GetMenuPedMaskedIntStat(int p0, ref int p1, int p2, int p3);
		/// <summary>
		/// </summary>
		bool _0x24A49BEAF468DC90(int p0, ref int p1, int p2, int p3, int p4);
		/// <summary>
		/// </summary>
		bool GetMenuPedFloatStat(int p0, ref float p1);
		/// <summary>
		/// </summary>
		bool _0x8F08017F9D7C47BD(int p0, ref int p1, int p2);
		/// <summary>
		/// </summary>
		/// <param name="p0">was always 0xAE2602A3.</param>
		bool GetMenuPedBoolStat(int p0, ref int p1);
		void ClearPedInPauseMenu();
		/// <summary>
		/// </summary>
		/// <param name="p1">is either 1 or 2 in the PC scripts.</param>
		void GivePedToPauseMenu(int ped, int p1);
		/// <summary>
		/// Toggles the light state for the pause menu ped in frontend menus.
		/// This is used by R* in combination with `SET_PAUSE_MENU_PED_SLEEP_STATE` to toggle the "offline" or "online" state in the "friends" tab of the pause menu in GTA Online.
		/// Example:
		/// Lights On: https://vespura.com/hi/i/2019-04-01_16-09_540ee_1015.png
		/// Lights Off: https://vespura.com/hi/i/2019-04-01_16-10_8b5e7_1016.png
		/// </summary>
		void SetPauseMenuPedLighting(bool state);
		/// <summary>
		/// Toggles the pause menu ped sleep state for frontend menus.
		/// Example: https://vespura.com/hi/i/2019-04-01_15-51_8ed38_1014.gif
		/// `state` 0 will make the ped slowly fall asleep, 1 will slowly wake the ped up.
		/// </summary>
		void SetPauseMenuPedSleepState(bool state);
		void OpenOnlinePoliciesMenu();
		bool _0xF13FE2A80C05C561();
		/// <summary>
		/// Returns the same as IS_SOCIAL_CLUB_ACTIVE
		/// </summary>
		bool IsOnlinePoliciesMenuActive();
		/// <summary>
		/// Uses the `SOCIAL_CLUB2` scaleform.
		/// </summary>
		void OpenSocialClubMenu();
		void CloseSocialClubMenu();
		/// <summary>
		/// HUD::SET_SOCIAL_CLUB_TOUR("Gallery");
		/// HUD::SET_SOCIAL_CLUB_TOUR("Missions");
		/// HUD::SET_SOCIAL_CLUB_TOUR("General");
		/// HUD::SET_SOCIAL_CLUB_TOUR("Playlists");
		/// </summary>
		void SetSocialClubTour(string name);
		bool IsSocialClubActive();
		/// <summary>
		/// SET_TEXT_??? - Used in golf and golf_mp
		/// </summary>
		void _0x1185A8087587322C(bool p0);
		void ForceCloseTextInputBox();
		void _0x577599CCED639CA2(int p0);
		void OverrideMultiplayerChatPrefix(int gxtEntryHash);
		/// <summary>
		/// Returns whether or not the text chat (MULTIPLAYER_CHAT Scaleform component) is active.
		/// </summary>
		bool IsMultiplayerChatActive();
		void CloseMultiplayerChat();
		void _0x7C226D5346D4D10A(int p0);
		void OverrideMultiplayerChatColour(int p0, int hudColor);
		/// <summary>
		/// Sets an unknown boolean value in the text chat.
		/// </summary>
		void SetTextChatUnk(bool p0);
		void FlagPlayerContextInTournament(bool toggle);
		/// <summary>
		/// This native turns on the AI blip on the specified ped. It also disappears automatically when the ped is too far or if the ped is dead. You don't need to control it with other natives.
		/// See gtaforums.com/topic/884370-native-research-ai-blips for further information.
		/// </summary>
		void SetPedHasAiBlip(int ped, bool hasCone);
		/// <summary>
		/// </summary>
		/// <param name="color">see SET_BLIP_COLOUR</param>
		void SetPedHasAiBlipWithColor(int ped, bool hasCone, int color);
		bool DoesPedHaveAiBlip(int ped);
		void SetPedAiBlipGangId(int ped, int gangId);
		void SetPedAiBlipHasCone(int ped, bool toggle);
		void SetPedAiBlipForcedOn(int ped, bool toggle);
		void SetPedAiBlipNoticeRange(int ped, float range);
		void SetPedAiBlipSprite(int ped, int spriteId);
		int GetAiBlip2(int ped);
		/// <summary>
		/// Returns the current AI BLIP for the specified ped
		/// </summary>
		int GetAiBlip(int ped);
		/// <summary>
		/// HAS_*
		/// </summary>
		bool HasDirectorModeBeenTriggered();
		/// <summary>
		/// SET_*
		/// </summary>
		void SetDirectorModeClearTriggeredFlag();
		/// <summary>
		/// If toggle is true, hides special ability bar / character name in the pause menu
		/// If toggle is false, shows special ability bar / character name in the pause menu
		/// SET_PLAYER_*
		/// </summary>
		void SetPlayerIsInDirectorMode(bool toggle);
		/// <summary>
		/// SET_*
		/// </summary>
		void _0x04655F9D075D0AE5(bool toggle);
		void _0x243296A510B562B6();
		/// <summary>
		/// GET_INTERIOR_*
		/// </summary>
		float GetInteriorHeading(int interior);
		/// <summary>
		/// GET_INTERIOR_*
		/// </summary>
		void GetInteriorInfo(int interior, ref Vector3 position, ref int nameHash);
		/// <summary>
		/// Returns the group ID of the specified interior. For example, regular interiors have group 0, subway interiors have group 1. There are a few other groups too.
		/// </summary>
		int GetInteriorGroupId(int interior);
		Vector3 GetOffsetFromInteriorInWorldCoords(int interior, float x, float y, float z);
		bool IsInteriorScene();
		bool IsValidInterior(int interior);
		void ClearRoomForEntity(int entity);
		/// <summary>
		/// Does anyone know what this does? I know online modding isn't generally supported especially by the owner of this db, but I first thought this could be used to force ourselves into someones apartment, but I see now that isn't possible.
		/// </summary>
		void ForceRoomForEntity(int entity, int interior, int roomHashKey);
		/// <summary>
		/// </summary>
		/// <returns>Gets the room hash key from the room that the specified entity is in. Each room in every interior has a unique key. Returns 0 if the entity is outside.</returns>
		int GetRoomKeyFromEntity(int entity);
		/// <summary>
		/// Seems to do the exact same as INTERIOR::GET_ROOM_KEY_FROM_ENTITY
		/// </summary>
		int GetKeyForEntityInRoom(int entity);
		/// <summary>
		/// </summary>
		/// <returns>Returns the handle of the interior that the entity is in. Returns 0 if outside.</returns>
		int GetInteriorFromEntity(int entity);
		void _0x82EBB79E258FA2B7(int entity, int interior);
		/// <summary>
		/// Immediately removes entity from an interior. Like sets entity to `limbo` room.
		/// </summary>
		void ClearInteriorForEntity(int entity);
		void _0x38C1CB1CB119A016(int p0, int p1);
		void ForceRoomForGameViewport(int interiorID, int roomHashKey);
		/// <summary>
		/// Exemple of use(carmod_shop.c4)
		/// INTERIOR::_AF348AFCB575A441("V_CarModRoom");
		/// </summary>
		void _0xAF348AFCB575A441(string roomName);
		/// <summary>
		/// Usage: INTERIOR::_0x405DC2AEF6AF95B9(INTERIOR::GET_KEY_FOR_ENTITY_IN_ROOM(PLAYER::PLAYER_PED_ID()));
		/// </summary>
		void _0x405DC2AEF6AF95B9(int roomHashKey);
		int GetRoomKeyForGameViewport();
		void ClearRoomForGameViewport();
		/// <summary>
		/// Returns the current interior id from gameplay camera
		/// </summary>
		int GetInteriorFromGameplayCam();
		/// <summary>
		/// Example for VB.NET
		/// </summary>
		/// <param name="x">Native.Function.Call(Of Integer)(Hash.GET_INTERIOR_AT_COORDS, X, Y, Z)</param>
		/// <param name="y">Native.Function.Call(Of Integer)(Hash.GET_INTERIOR_AT_COORDS, X, Y, Z)</param>
		/// <returns>Returns interior ID from specified coordinates. If coordinates are outside, then it returns 0.</returns>
		int GetInteriorAtCoords(float x, float y, float z);
		void AddPickupToInteriorRoomByName(int pickup, string roomName);
		void PinInteriorInMemory(int interior);
		/// <summary>
		/// Does something similar to INTERIOR::DISABLE_INTERIOR.
		/// You don't fall through the floor but everything is invisible inside and looks the same as when INTERIOR::DISABLE_INTERIOR is used. Peds behaves normally inside.
		/// </summary>
		void UnpinInterior(int interior);
		bool IsInteriorReady(int interior);
		/// <summary>
		/// Only used once in the entire game scripts.
		/// </summary>
		/// <returns>Does not actually return anything.</returns>
		int _0x4C2330E61D3DEB56(int interior);
		/// <summary>
		/// Returns the interior ID representing the requested interior at that location (if found?). The supplied interior string is not the same as the one used to load the interior.
		/// Interior types include: "V_Michael", "V_Franklins", "V_Franklinshouse", etc.. you can find them in the scripts.
		/// Not a very useful native as you could just use GET_INTERIOR_AT_COORDS instead and get the same result, without even having to specify the interior type.
		/// </summary>
		/// <param name="x">INTERIOR</param>
		/// <param name="y">INTERIOR</param>
		/// <param name="z">INTERIOR</param>
		int GetInteriorAtCoordsWithType(float x, float y, float z, string interiorType);
		/// <summary>
		/// Hashed version of GET_INTERIOR_AT_COORDS_WITH_TYPE
		/// </summary>
		int GetInteriorAtCoordsWithTypehash(float x, float y, float z, int typeHash);
		void _0x483ACA1176CA93F1();
		/// <summary>
		/// Returns true if the collision at the specified coords is marked as being outside (false if there's an interior)
		/// </summary>
		bool IsCollisionMarkedOutside(float x, float y, float z);
		int GetInteriorFromCollision(float x, float y, float z);
		void _0x7ECDF98587E92DEC(int p0);
		/// <summary>
		/// More info: http://gtaforums.com/topic/836367-adding-props-to-interiors/
		/// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
		/// </summary>
		void ActivateInteriorEntitySet(int interior, string entitySetName);
		/// <summary>
		/// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
		/// </summary>
		void DeactivateInteriorEntitySet(int interior, string entitySetName);
		/// <summary>
		/// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
		/// </summary>
		bool IsInteriorEntitySetActive(int interior, string entitySetName);
		/// <summary>
		/// </summary>
		/// <param name="color">https</param>
		void SetInteriorEntitySetColor(int interior, string entitySetName, int color);
		void RefreshInterior(int interior);
		/// <summary>
		/// This is the native that is used to hide the exterior of GTA Online apartment buildings when you are inside an apartment.
		/// More info: http://gtaforums.com/topic/836301-hiding-gta-online-apartment-exteriors/
		/// </summary>
		void EnableExteriorCullModelThisFrame(int mapObjectHash);
		void EnableScriptCullModelThisFrame(int mapObjectHash);
		/// <summary>
		/// Example:
		/// This removes the interior from the strip club and when trying to walk inside the player just falls:
		/// </summary>
		/// <param name="interior">:DISABLE_INTERIOR(118018, true);</param>
		void DisableInterior(int interior, bool toggle);
		bool IsInteriorDisabled(int interior);
		/// <summary>
		/// Does something similar to INTERIOR::DISABLE_INTERIOR
		/// </summary>
		void CapInterior(int interior, bool toggle);
		bool IsInteriorCapped(int interior);
		/// <summary>
		/// DISABLE_[METRO_SYSTEM]?
		/// </summary>
		void _0x9E6542F0CE8E70A3(bool toggle);
		/// <summary>
		/// Jenkins hash _might_ be 0xFC227584.
		/// </summary>
		void _0x7241CCB7D020DB69(int entity, bool toggle);
		int CreateItemset(bool p0);
		void DestroyItemset(int p0);
		bool IsItemsetValid(int p0);
		bool AddToItemset(int p0, int p1);
		void RemoveFromItemset(int p0, int p1);
		int GetItemsetSize(int x);
		int GetIndexedItemInItemset(int p0, int p1);
		bool IsInItemset(int p0, int p1);
		void CleanItemset(int p0);
		int _0xF2CA003F167E21D2();
		bool LoadingscreenGetLoadFreemode();
		void LoadingscreenSetLoadFreemode(bool toggle);
		bool LoadingscreenGetLoadFreemodeWithEventName();
		void LoadingscreenSetLoadFreemodeWithEventName(bool toggle);
		bool LoadingscreenIsLoadingFreemode();
		void LoadingscreenSetIsLoadingFreemode(bool toggle);
		void _0xFA1E0E893D915215(bool toggle);
		int LocalizationGetSystemLanguage();
		/// <summary>
		/// 0 = american (en-US)
		/// 1 = french (fr-FR)
		/// 2 = german (de-DE)
		/// 3 = italian (it-IT)
		/// 4 = spanish (es-ES)
		/// 5 = brazilian (pt-BR)
		/// 6 = polish (pl-PL)
		/// 7 = russian (ru-RU)
		/// 8 = korean (ko-KR)
		/// See NativeDB for reference: http://natives.altv.mp/#/0x2BDD44CC428A7EAE
		/// </summary>
		int GetCurrentLanguage();
		int LocalizationGetSystemDateFormat();
		int GetAllocatedStackSize();
		int GetNumberOfFreeStacksOfThisSize(int stackSize);
		void SetRandomSeed(int seed);
		/// <summary>
		/// Maximum value is 1.
		/// At a value of 0 the game will still run at a minimum time scale.
		/// Slow Motion 1: 0.6
		/// Slow Motion 2: 0.4
		/// Slow Motion 3: 0.2
		/// </summary>
		void SetTimeScale(float timeScale);
		/// <summary>
		/// If true, the player can't save the game.
		/// If the parameter is true, sets the mission flag to true, if the parameter is false, the function does nothing at all.
		/// ^ also, if the mission flag is already set, the function does nothing at all
		/// </summary>
		void SetMissionFlag(bool toggle);
		bool GetMissionFlag();
		/// <summary>
		/// If the parameter is true, sets the random event flag to true, if the parameter is false, the function does nothing at all.
		/// Does nothing if the mission flag is set.
		/// </summary>
		void SetRandomEventFlag(bool toggle);
		bool GetRandomEventFlag();
		/// <summary>
		/// Returns pointer to an empty string.
		/// GET_C*
		/// </summary>
		string GetGlobalCharBuffer();
		/// <summary>
		/// Does nothing (it's a nullsub). Seems to be PS4 specific.
		/// </summary>
		void _0x4DCDF92BF64236CD(string p0, string p1);
		/// <summary>
		/// Does nothing (it's a nullsub). Seems to be PS4 specific.
		/// </summary>
		void _0x31125FD509D9043F(string p0);
		/// <summary>
		/// Does nothing (it's a nullsub). Seems to be PS4 specific.
		/// </summary>
		void _0xEBD3205A207939ED(string p0);
		/// <summary>
		/// Does nothing (it's a nullsub). Seems to be PS4 specific.
		/// </summary>
		void _0x97E7E2C04245115B(int p0);
		/// <summary>
		/// Does nothing (it's a nullsub). Seems to be PS4 specific.
		/// </summary>
		void _0x916CA67D26FD1E37(string p0);
		/// <summary>
		/// Does nothing (it's a nullsub). Seems to be PS4 specific.
		/// </summary>
		void _0xEB078CA2B5E82ADD(string p0, string p1);
		/// <summary>
		/// Does nothing (it's a nullsub). Seems to be PS4 specific.
		/// </summary>
		void _0x703CC7F60CBB2B57(string p0);
		/// <summary>
		/// Does nothing (it's a nullsub). Seems to be PS4 specific.
		/// </summary>
		void _0x8951EB9C6906D3C8();
		/// <summary>
		/// Does nothing (it's a nullsub). Seems to be PS4 specific.
		/// Used only once in the scripts (ingamehud) with p0 = "AF_GAMEMODE"
		/// </summary>
		void _0xBA4B8D83BDC75551(string p0);
		bool HasResumedFromSuspend();
		/// <summary>
		/// Sets GtaThread+0x14A
		/// SET_S*
		/// </summary>
		void _0x65D2EBB47E1CEC21(bool toggle);
		/// <summary>
		/// Sets bit 3 in GtaThread+0x150
		/// SET_T*
		/// </summary>
		void _0x6F2135B6129620C1(bool toggle);
		/// <summary>
		/// I*
		/// </summary>
		void _0x8D74E26F54B4E5C3(string p0);
		/// <summary>
		/// </summary>
		bool GetBaseElementMetadata(ref int p0, ref int p1, int p2, bool p3);
		/// <summary>
		/// Returns current weather name hash
		/// </summary>
		int GetPrevWeatherTypeHashName();
		/// <summary>
		/// Returns weather name hash
		/// </summary>
		int GetNextWeatherTypeHashName();
		bool IsPrevWeatherType(string weatherType);
		bool IsNextWeatherType(string weatherType);
		/// <summary>
		/// The following weatherTypes are used in the scripts:
		/// "CLEAR"
		/// "EXTRASUNNY"
		/// "CLOUDS"
		/// "OVERCAST"
		/// "RAIN"
		/// "CLEARING"
		/// "THUNDER"
		/// "SMOG"
		/// See NativeDB for reference: http://natives.altv.mp/#/0x704983DF373B198F
		/// </summary>
		void SetWeatherTypePersist(string weatherType);
		/// <summary>
		/// The following weatherTypes are used in the scripts:
		/// "CLEAR"
		/// "EXTRASUNNY"
		/// "CLOUDS"
		/// "OVERCAST"
		/// "RAIN"
		/// "CLEARING"
		/// "THUNDER"
		/// "SMOG"
		/// See NativeDB for reference: http://natives.altv.mp/#/0xED712CA327900C8A
		/// </summary>
		void SetWeatherTypeNowPersist(string weatherType);
		/// <summary>
		/// The following weatherTypes are used in the scripts:
		/// "CLEAR"
		/// "EXTRASUNNY"
		/// "CLOUDS"
		/// "OVERCAST"
		/// "RAIN"
		/// "CLEARING"
		/// "THUNDER"
		/// "SMOG"
		/// See NativeDB for reference: http://natives.altv.mp/#/0x29B487C359E19889
		/// </summary>
		void SetWeatherTypeNow(string weatherType);
		void SetWeatherTypeOvertimePersist(string weatherType, float time);
		void SetRandomWeatherType();
		void ClearWeatherTypePersist();
		/// <summary>
		/// 0 as param = weird black and green screen
		/// 0.1 - 0.99 = Prevent rain effect from falling (still sound and effects on puddles) and prevent puddles from increase/decrease, seems than it prevent any weather change too
		/// 1 and more = "Unfreeze" rain puddles but clear weather too
		/// When 'freezing' is enabled, it seem to also freeze value getted with GetRainLevel
		/// </summary>
		void _0x0CF97F497FE7D048(float p0);
		/// <summary>
		/// </summary>
		void GetWeatherTypeTransition(ref int weatherType1, ref int weatherType2, ref float percentWeather2);
		/// <summary>
		/// execute "NativeFunction.Natives.x578C752848ECFA0C(Game.GetHashKey(""RAIN""), Game.GetHashKey(""SMOG""), 0.50f);
		/// Note that unlike most of the other weather natives, this native takes the hash of the weather name, not the plain string. These are the weather names and their hashes:
		/// CLEAR  0x36A83D84
		/// EXTRASUNNY  0x97AA0A79
		/// CLOUDS  0x30FDAF5C
		/// OVERCAST    0xBB898D2D
		/// RAIN    0x54A69840
		/// CLEARING    0x6DB1A50D
		/// THUNDER 0xB677829F
		/// See NativeDB for reference: http://natives.altv.mp/#/0x578C752848ECFA0C
		/// </summary>
		void SetWeatherTypeTransition(int weatherType1, int weatherType2, float percentWeather2);
		/// <summary>
		/// Appears to have an optional bool parameter that is unused in the scripts.
		/// If you pass true, something will be set to zero.
		/// </summary>
		void SetOverrideWeather(string weatherType);
		void _0x1178E104409FE58C(int p0, int p1);
		void ClearOverrideWeather();
		void WaterOverrideSetShorewaveamplitude(float amplitude);
		void WaterOverrideSetShorewaveminamplitude(float minAmplitude);
		void WaterOverrideSetShorewavemaxamplitude(float maxAmplitude);
		void WaterOverrideSetOceannoiseminamplitude(float minAmplitude);
		void WaterOverrideSetOceanwaveamplitude(float amplitude);
		void WaterOverrideSetOceanwaveminamplitude(float minAmplitude);
		void WaterOverrideSetOceanwavemaxamplitude(float maxAmplitude);
		void WaterOverrideSetRipplebumpiness(float bumpiness);
		void WaterOverrideSetRippleminbumpiness(float minBumpiness);
		void WaterOverrideSetRipplemaxbumpiness(float maxBumpiness);
		void WaterOverrideSetRippledisturb(float disturb);
		/// <summary>
		/// This seems to edit the water wave, intensity around your current location.
		/// 0.0f = Normal
		/// 1.0f = So Calm and Smooth, a boat will stay still.
		/// 3.0f = Really Intense.
		/// </summary>
		void WaterOverrideSetStrength(float strength);
		void WaterOverrideFadeIn(float p0);
		void WaterOverrideFadeOut(float p0);
		/// <summary>
		/// Sets the the raw wind speed value.
		/// </summary>
		void SetWind(float speed);
		/// <summary>
		/// Using this native will clamp the wind speed value to a range of 0.0- 12.0. Using SET_WIND sets the same value but without the restriction.
		/// </summary>
		void SetWindSpeed(float speed);
		float GetWindSpeed();
		/// <summary>
		/// The wind direction in radians
		/// 180 degrees, wind will blow from the south
		/// </summary>
		void SetWindDirection(float direction);
		Vector3 GetWindDirection();
		/// <summary>
		/// With an `intensity` higher than `0.5f`, only the creation of puddles gets faster, rain and rain sound won't increase after that.
		/// With an `intensity` of `0.0f` rain and rain sounds are disabled and there won't be any new puddles.
		/// To use the rain intensity of the current weather, call this native with `-1f` as `intensity`.
		/// </summary>
		void SetRainLevel(float intensity);
		float GetRainLevel();
		void SetSnowLevel(float level);
		float GetSnowLevel();
		/// <summary>
		/// creates single lightning+thunder at random position
		/// </summary>
		void ForceLightningFlash();
		/// <summary>
		/// Found in the scripts:
		/// MISC::_02DEAAC8F8EA7FE7("");
		/// </summary>
		void _0x02DEAAC8F8EA7FE7(string p0);
		/// <summary>
		/// Found in the scripts:
		/// MISC::_11B56FBBF7224868("CONTRAILS");
		/// </summary>
		void PreloadCloudHat(string name);
		/// <summary>
		/// The following cloudhats are useable:
		/// altostratus
		/// Cirrus
		/// cirrocumulus
		/// Clear 01
		/// Cloudy 01
		/// Contrails
		/// Horizon
		/// horizonband1
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFC4842A34657BFCB
		/// </summary>
		void LoadCloudHat(string name, float transitionTime);
		/// <summary>
		/// Called 4 times in the b617d scripts:
		/// MISC::_A74802FB8D0B7814("CONTRAILS", 0);
		/// </summary>
		void UnloadCloudHat(string name, float p1);
		void ClearCloudHat();
		void SetCloudHatOpacity(float opacity);
		float GetCloudHatOpacity();
		int GetGameTimer();
		float GetFrameTime();
		float GetBenchmarkTime();
		int GetFrameCount();
		float GetRandomFloatInRange(float startRange, float endRange);
		int GetRandomIntInRange(int startRange, int endRange);
		int GetRandomIntInRange2(int startRange, int endRange);
		/// <summary>
		/// Gets the ground elevation at the specified position. Note that if the specified position is below ground level, the function will output zero!
		/// Bear in mind this native can only calculate the elevation when the coordinates are within the client's render distance.
		/// </summary>
		/// <param name="x">Position on the X-axis to get ground elevation at.</param>
		/// <param name="y">Position on the Y-axis to get ground elevation at.</param>
		/// <param name="z">Position on the Z-axis to get ground elevation at.</param>
		/// <param name="groundZ">The ground elevation at the specified position.</param>
		/// <param name="ignoreWater">Nearly always 0, very rarely 1 in the scripts: https://gfycat.com/NiftyTatteredCricket</param>
		bool GetGroundZFor3dCoord(float x, float y, float z, ref float groundZ, bool ignoreWater, bool p5);
		/// <summary>
		/// </summary>
		bool GetGroundZAndNormalFor3dCoord(float x, float y, float z, ref float groundZ, ref Vector3 normal);
		/// <summary>
		/// </summary>
		bool GetGroundZFor3dCoord2(float x, float y, float z, ref float groundZ, bool p4, bool p5);
		float Asin(float p0);
		float Acos(float p0);
		float Tan(float p0);
		float Atan(float p0);
		float Atan2(float p0, float p1);
		/// <summary>
		/// Returns the distance between two three-dimensional points, optionally ignoring the Z values.
		/// If useZ is false, only the 2D plane (X-Y) will be considered for calculating the distance.
		/// Consider using this faster native instead: SYSTEM::VDIST - DVIST always takes in consideration the 3D coordinates.
		/// </summary>
		float GetDistanceBetweenCoords(float x1, float y1, float z1, float x2, float y2, float z2, bool useZ);
		float GetAngleBetween2dVectors(float x1, float y1, float x2, float y2);
		/// <summary>
		/// </summary>
		/// <param name="dx">= x1 - x2</param>
		/// <param name="dy">= y1 - y2</param>
		float GetHeadingFromVector2d(float dx, float dy);
		float _0x7F8F6405F4777AF6(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, bool p9);
		/// <summary>
		/// GET_C*
		/// </summary>
		Vector3 _0x21C235BC64831E5A(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, bool p9);
		/// <summary>
		/// </summary>
		bool _0xF56DFB7B61BE7276(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, ref float p12);
		int _0xA0AD167E4B39D9A2(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11, int p12, int p13);
		/// <summary>
		/// This sets bit [offset] of [address] to on.
		/// The offsets used are different bits to be toggled on and off, typically there is only one address used in a script.
		/// Example:
		/// To check if this bit has been enabled:
		/// Please note, this method may assign a value to [address] when used.
		/// </summary>
		/// <returns>MISC::IS_BIT_SET(bitAddress, 1); // will return 1 afterwards</returns>
		void SetBit(ref int address, int offset);
		/// <summary>
		/// This sets bit [offset] of [address] to off.
		/// Example:
		/// To check if this bit has been enabled:
		/// </summary>
		/// <returns>MISC::IS_BIT_SET(bitAddress, 1); // will return 0 afterwards</returns>
		void ClearBit(ref int address, int offset);
		/// <summary>
		/// This native converts its past string to hash. It is hashed using jenkins one at a time method.
		/// </summary>
		int GetHashKey(string @string);
		/// <summary>
		/// This native always come right before SET_ENTITY_QUATERNION where its final 4 parameters are SLERP_NEAR_QUATERNION p9 to p12
		/// </summary>
		void SlerpNearQuaternion(float t, float x, float y, float z, float w, float x1, float y1, float z1, float w1, ref float outX, ref float outY, ref float outZ, ref float outW);
		bool IsAreaOccupied(float p0, float p1, float p2, float p3, float p4, float p5, bool p6, bool p7, bool p8, bool p9, bool p10, int p11, bool p12);
		int _0x39455BF4F4F55186(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11, int p12);
		/// <summary>
		/// `checkVehicle`: Check for any vehicles in that area.
		/// `checkPeds`: Check for any peds in that area.
		/// `ignoreEntity`: This entity will be ignored if it's in the area. Set to 0 if you don't want to exclude any entities.
		/// The BOOL parameters that are documented have not been confirmed. They are just documented from what I've found during testing. They may not work as expected in all cases.
		/// Returns true if there is anything in that location matching the provided parameters.
		/// </summary>
		/// <param name="range">The range, seems to not be very accurate during testing.</param>
		/// <returns>`p4`: Unknown, when set to true it seems to always return true no matter what I try.</returns>
		bool IsPositionOccupied(float x, float y, float z, float range, bool p4, bool checkVehicles, bool checkPeds, bool p7, bool p8, int ignoreEntity, bool p10);
		bool IsPointObscuredByAMissionEntity(float p0, float p1, float p2, float p3, float p4, float p5, int p6);
		/// <summary>
		/// Example: CLEAR_AREA(0, 0, 0, 30, true, false, false, false);
		/// </summary>
		void ClearArea(float X, float Y, float Z, float radius, bool p4, bool ignoreCopCars, bool ignoreObjects, bool p7);
		void ClearAreaLeaveVehicleHealth(float x, float y, float z, float radius, bool p4, bool p5, bool p6, bool p7);
		/// <summary>
		/// Example:
		/// CLEAR_AREA_OF_VEHICLES(0.0f, 0.0f, 0.0f, 10000.0f, false, false, false, false, false, false);
		/// </summary>
		void ClearAreaOfVehicles(float x, float y, float z, float radius, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9);
		void ClearAngledAreaOfVehicles(float x1, float y1, float z1, float x2, float y2, float z2, float width, bool p7, bool p8, bool p9, bool p10, bool p11, int p12);
		/// <summary>
		/// I looked through the PC scripts that this site provides you with a link to find. It shows the last param mainly uses, (0, 2, 6, 16, and 17) so I am going to assume it is a type of flag.
		/// </summary>
		void ClearAreaOfObjects(float x, float y, float z, float radius, int flags);
		/// <summary>
		/// Example:       CLEAR_AREA_OF_PEDS(0, 0, 0, 10000, 1);
		/// </summary>
		void ClearAreaOfPeds(float x, float y, float z, float radius, int flags);
		/// <summary>
		/// </summary>
		/// <param name="flags">appears to always be 0</param>
		void ClearAreaOfCops(float x, float y, float z, float radius, int flags);
		/// <summary>
		/// </summary>
		/// <param name="flags">is usually 0 in the scripts.</param>
		void ClearAreaOfProjectiles(float x, float y, float z, float radius, int flags);
		/// <summary>
		/// Possibly used to clear scenario points.
		/// CLEAR_*
		/// </summary>
		void _0x7EC6F9A478A6A512();
		/// <summary>
		/// </summary>
		/// <param name="ignoreVehicle">- bypasses vehicle check of the local player (it will not open if you are in a vehicle and this is set to false)</param>
		void SetSaveMenuActive(bool ignoreVehicle);
		int _0x397BAA01068BAA96();
		void SetCreditsActive(bool toggle);
		void _0xB51B9AB9EF81868C(bool toggle);
		bool HaveCreditsReachedEnd();
		/// <summary>
		/// For a full list, see here: pastebin.com/yLNWicUi
		/// </summary>
		void TerminateAllScriptsWithThisName(string scriptName);
		void NetworkSetScriptIsSafeForNetworkGame();
		/// <summary>
		/// Returns the index of the newly created hospital spawn point.
		/// </summary>
		/// <param name="p3">might be radius?</param>
		int AddHospitalRestart(float x, float y, float z, float p3, int p4);
		/// <summary>
		/// The game by default has 5 hospital respawn points. Disabling them all will cause the player to respawn at the last position they were.
		/// </summary>
		void DisableHospitalRestart(int hospitalIndex, bool toggle);
		int AddPoliceRestart(float p0, float p1, float p2, float p3, int p4);
		/// <summary>
		/// Disables the spawn point at the police house on the specified index.
		/// - Nacorpio
		/// </summary>
		/// <param name="policeIndex">The police house index.</param>
		/// <param name="toggle">true to enable the spawn point, false to disable.</param>
		void DisablePoliceRestart(int policeIndex, bool toggle);
		void SetRestartCustomPosition(float x, float y, float z, float heading);
		void ClearRestartCustomPosition();
		void PauseDeathArrestRestart(bool toggle);
		void IgnoreNextRestart(bool toggle);
		/// <summary>
		/// Sets whether the game should fade out after the player dies.
		/// </summary>
		void SetFadeOutAfterDeath(bool toggle);
		/// <summary>
		/// Sets whether the game should fade out after the player is arrested.
		/// </summary>
		void SetFadeOutAfterArrest(bool toggle);
		/// <summary>
		/// Sets whether the game should fade in after the player dies or is arrested.
		/// </summary>
		void SetFadeInAfterDeathArrest(bool toggle);
		void SetFadeInAfterLoad(bool toggle);
		/// <summary>
		/// </summary>
		int RegisterSaveHouse(float p0, float p1, float p2, float p3, ref int p4, int p5, int p6);
		void SetSaveHouse(int p0, bool p1, bool p2);
		bool OverrideSaveHouse(bool p0, float p1, float p2, float p3, float p4, bool p5, float p6, float p7);
		/// <summary>
		/// GET_SAVE_*
		/// GET_SAVE_UNLESS_CUSTOM_DOT ?
		/// </summary>
		bool _0xA4A0065E39C9F25C(ref Vector3 p0, ref float p1, ref bool fadeInAfterLoad, ref bool p3);
		void DoAutoSave();
		/// <summary>
		/// Returns true if profile setting 208 is equal to 0.
		/// </summary>
		bool GetIsAutoSaveOff();
		bool IsAutoSaveInProgress();
		bool HasCodeRequestedAutosave();
		void ClearCodeRequestedAutosave();
		void BeginReplayStats(int p0, int p1);
		void AddReplayStatValue(int value);
		void EndReplayStats();
		int HaveReplayStatsBeenStored();
		int GetReplayStatMissionId();
		int GetReplayStatMissionType();
		int GetReplayStatCount();
		int GetReplayStatAtIndex(int index);
		void ClearReplayStats();
		bool QueueMissionRepeatLoad();
		/// <summary>
		/// Shows the screen which is visible before you redo a mission? The game will make a restoration point where you will cameback when the mission is over.
		/// Returns 1 if the message isn't currently on screen
		/// </summary>
		bool QueueMissionRepeatSave();
		int _0xEB2104E905C6F2E9();
		int GetStatusOfMissionRepeatSave();
		bool IsMemoryCardInUse();
		void ShootSingleBulletBetweenCoords(float x1, float y1, float z1, float x2, float y2, float z2, int damage, bool p7, int weaponHash, int ownerPed, bool isAudible, bool isInvisible, float speed);
		/// <summary>
		/// </summary>
		/// <param name="entity">- entity to ignore</param>
		void ShootSingleBulletBetweenCoordsIgnoreEntity(float x1, float y1, float z1, float x2, float y2, float z2, int damage, bool p7, int weaponHash, int ownerPed, bool isAudible, bool isInvisible, float speed, int entity, int p14);
		/// <summary>
		/// </summary>
		/// <param name="entity">- entity to ignore</param>
		void ShootSingleBulletBetweenCoordsIgnoreEntityNew(float x1, float y1, float z1, float x2, float y2, float z2, int damage, bool p7, int weaponHash, int ownerPed, bool isAudible, bool isInvisible, float speed, int entity, bool p14, bool p15, bool p16, bool p17, int p18, int p19, int p20);
		/// <summary>
		/// Gets the dimensions of a model.
		/// Calculate (maximum - minimum) to get the size, in which case, Y will be how long the model is.
		/// Example from the scripts: MISC::GET_MODEL_DIMENSIONS(ENTITY::GET_ENTITY_MODEL(PLAYER::PLAYER_PED_ID()), &v_1A, &v_17);
		/// </summary>
		void GetModelDimensions(int modelHash, ref Vector3 minimum, ref Vector3 maximum);
		/// <summary>
		/// Sets a visually fake wanted level on the user interface. Used by Rockstar's scripts to "override" regular wanted levels and make custom ones while the real wanted level and multipliers are still in effect.
		/// Max is 6, anything above this makes it just 6. Also the mini-map gets the red & blue flashing effect.
		/// </summary>
		void SetFakeWantedLevel(int fakeWantedLevel);
		int GetFakeWantedLevel();
		/// <summary>
		/// Returns bit's boolean state from [offset] of [address].
		/// Example:
		/// To enable and disable bits, see:
		/// MISC::SET_BIT(&bitAddress, 1);   // enable
		/// MISC::CLEAR_BIT(&bitAddress, 1); // disable
		/// </summary>
		bool IsBitSet(int address, int offset);
		void UsingMissionCreator(bool toggle);
		void AllowMissionCreatorWarp(bool toggle);
		void SetMinigameInProgress(bool toggle);
		bool IsMinigameInProgress();
		bool IsThisAMinigameScript();
		bool IsSniperInverted();
		/// <summary>
		/// Returns true if the game is using the metric measurement system (profile setting 227), false if imperial is used.
		/// </summary>
		bool ShouldUseMetricMeasurements();
		int GetProfileSetting(int profileSetting);
		bool AreStringsEqual(string string1, string string2);
		/// <summary>
		/// Compares two strings up to a specified number of characters.
		/// Parameters:
		/// Returns:
		/// A value indicating the relationship between the strings:
		/// <0 - The first non-matching character in 'str1' is less than the one in 'str2'. (e.g. 'A' < 'B', so result = -1)
		/// 0 - The contents of both strings are equal.
		/// >0 - The first non-matching character in 'str1' is less than the one in 'str2'. (e.g. 'B' > 'A', so result = 1)
		/// Examples:
		/// MISC::COMPARE_STRINGS("STRING", "string", false, -1); // 0; equal
		/// See NativeDB for reference: http://natives.altv.mp/#/0x1E34710ECD4AB0EB
		/// </summary>
		/// <param name="str1">- String to be compared.</param>
		/// <param name="str2">- String to be compared.</param>
		/// <param name="matchCase">- Comparison will be case-sensitive.</param>
		/// <param name="maxLength">- Maximum number of characters to compare. A value of -1 indicates an infinite length.</param>
		int CompareStrings(string str1, string str2, bool matchCase, int maxLength);
		int Absi(int value);
		float Absf(float value);
		/// <summary>
		/// Determines whether there is a sniper bullet within the specified coordinates. The coordinates form an axis-aligned bounding box.
		/// </summary>
		bool IsSniperBulletInArea(float x1, float y1, float z1, float x2, float y2, float z2);
		/// <summary>
		/// Determines whether there is a projectile within the specified coordinates. The coordinates form a rectangle.
		/// - Nacorpio
		/// </summary>
		/// <param name="ownedByPlayer">= only projectiles fired by the player will be detected.</param>
		bool IsProjectileInArea(float x1, float y1, float z1, float x2, float y2, float z2, bool ownedByPlayer);
		/// <summary>
		/// Determines whether there is a projectile of a specific type within the specified coordinates. The coordinates form a axis-aligned bounding box.
		/// </summary>
		bool IsProjectileTypeInArea(float x1, float y1, float z1, float x2, float y2, float z2, int type, bool ownedByPlayer);
		/// <summary>
		/// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
		/// </summary>
		bool IsProjectileTypeInAngledArea(float x1, float y1, float z1, float x2, float y2, float z2, float width, int p7, bool ownedByPlayer);
		bool IsProjectileTypeWithinDistance(float x, float y, float z, int projectileHash, float radius, bool ownedByPlayer);
		/// <summary>
		/// </summary>
		bool GetCoordsOfProjectileTypeInArea(float x1, float y1, float z1, float x2, float y2, float z2, int projectileHash, ref Vector3 projectilePos, bool ownedByPlayer);
		/// <summary>
		/// </summary>
		bool GetCoordsOfProjectileTypeWithinDistance(int ped, int weaponHash, float distance, ref Vector3 outCoords, bool p4);
		/// <summary>
		/// GET_PROJECTILE_*
		/// </summary>
		bool GetProjectileNearPed(int ped, int weaponHash, float distance, ref Vector3 outCoords, ref int outProjectile, bool p5);
		/// <summary>
		/// For projectiles, see: IS_PROJECTILE_TYPE_IN_ANGLED_AREA
		/// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
		/// Returns True if a bullet, as maintained by a pool within CWeaponManager, has been fired into the defined angled area.
		/// </summary>
		bool IsBulletInAngledArea(float x1, float y1, float z1, float x2, float y2, float z2, float width, bool ownedByPlayer);
		bool IsBulletInArea(float x, float y, float z, float radius, bool ownedByPlayer);
		bool IsBulletInBox(float x1, float y1, float z1, float x2, float y2, float z2, bool ownedByPlayer);
		/// <summary>
		/// </summary>
		/// <param name="p3">- possibly radius?</param>
		bool HasBulletImpactedInArea(float x, float y, float z, float p3, bool p4, bool p5);
		bool HasBulletImpactedInBox(float p0, float p1, float p2, float p3, float p4, float p5, bool p6, bool p7);
		/// <summary>
		/// PS4
		/// </summary>
		bool IsOrbisVersion();
		/// <summary>
		/// XBOX ONE
		/// </summary>
		bool IsDurangoVersion();
		bool IsXbox360Version();
		bool IsPs3Version();
		bool IsPcVersion();
		/// <summary>
		/// if (MISC::IS_AUSSIE_VERSION()) {
		/// sub_127a9(&l_31, 1024); // l_31 |= 1024
		/// l_129 = 3;
		/// sub_129d2("AUSSIE VERSION IS TRUE!?!?!"); // DEBUG
		/// }
		/// Used to block some of the prostitute stuff due to laws in Australia.
		/// </summary>
		bool IsAussieVersion();
		bool IsStringNull(string @string);
		bool IsStringNullOrEmpty(string @string);
		/// <summary>
		/// Returns false if it's a null or empty string or if the string is too long. outInteger will be set to -999 in that case.
		/// </summary>
		/// <returns>If all checks have passed successfully, the return value will be set to whatever strtol(string, 0i64, 10); returns.</returns>
		bool StringToInt(string @string, ref int outInteger);
		/// <summary>
		/// </summary>
		void SetBitsInRange(ref int unkVar, int rangeStart, int rangeEnd, int p3);
		int GetBitsInRange(int unkVar, int rangeStart, int rangeEnd);
		/// <summary>
		/// See description of `ADD_STUNT_JUMP_ANGLED` for detailed info. The only difference really is this one does not have the radius (or angle, not sure) floats parameters for entry and landing zones.
		/// </summary>
		int AddStuntJump(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float camX, float camY, float camZ, int p15, int p16, int p17);
		/// <summary>
		/// Creates a new stunt jump.
		/// The radius1 and radius2 might actually not be a radius at all, but that's what it seems to me testing them in-game. But they may be 'angle' floats instead, considering this native is named ADD_STUNT_JUMP_**ANGLED**.
		/// Info about the specific 'parameter sections':
		/// First coordinates are for the jump entry area, and the radius that will be checked around that area. So if you're not exactly within the coordinates, but you are within the outter radius limit then it will still register as entering the stunt jump. Note as mentioned above, the radius is just a guess, I'm not really sure about it's exact purpose.
		/// Next part is the landing area, again starting with the left bottom (nearest to the stunt jump entry zone) coordinate, and the second one being the top right furthest away part of the landing area. Followed by another (most likely) radius float, this is usually slightly larger than the entry zone 'radius' float value, just because you have quite a lot of places where you can land (I'm guessing).
		/// The final coordinate in this native is the Camera position. Rotation and zoom/FOV is managed by the game itself, you just need to provide the camera location.
		/// **unk1, unk2 and unk3:**
		/// Not sure what these are for, but they're always `150, 0, 0` in decompiled scripts.
		/// Visualized example in-game: https://d.fivem.dev/2019-03-15_18-24_c7802_846.png
		/// Here is a list of almost all of the stunt jumps from GTA V (taken from decompiled scripts): https://pastebin.com/EW1jBPkY
		/// </summary>
		/// <param name="x1">**</param>
		/// <param name="y1">**</param>
		/// <param name="z1">**</param>
		/// <param name="x2">**</param>
		/// <param name="y2">**</param>
		/// <param name="x3">**</param>
		/// <param name="y3">**</param>
		/// <param name="z3">**</param>
		/// <param name="x4">**</param>
		/// <param name="y4">**</param>
		/// <param name="camX">**</param>
		int AddStuntJumpAngled(float x1, float y1, float z1, float x2, float y2, float z2, float radius1, float x3, float y3, float z3, float x4, float y4, float z4, float radius2, float camX, float camY, float camZ, int p17, int p18, int p19);
		/// <summary>
		/// Toggles some stunt jump stuff.
		/// </summary>
		void _0xFB80AB299D2EE1BD(bool toggle);
		void DeleteStuntJump(int p0);
		void EnableStuntJumpSet(int p0);
		void DisableStuntJumpSet(int p0);
		void SetStuntJumpsCanTrigger(bool toggle);
		bool IsStuntJumpInProgress();
		bool IsStuntJumpMessageShowing();
		int GetNumSuccessfulStuntJumps();
		int GetTotalSuccessfulStuntJumps();
		void CancelStuntJump();
		/// <summary>
		/// Make sure to call this from the correct thread if you're using multiple threads because all other threads except the one which is calling SET_GAME_PAUSED will be paused which means you will lose control and the game remains in paused mode until you exit GTA5.exe
		/// </summary>
		void SetGamePaused(bool toggle);
		void SetThisScriptCanBePaused(bool toggle);
		void SetThisScriptCanRemoveBlipsCreatedByAnyScript(bool toggle);
		/// <summary>
		/// INT_SCORES_SCORTED was a hash collision
		/// </summary>
		/// <param name="hash">game. Credits to ThreeSocks for the info. The hash contains the combination, while the "amount" represents the amount of buttons used in a combination. The following page can be used to make a button combination: gta5offset.com/ts/hash/</param>
		bool HasButtonCombinationJustBeenEntered(int hash, int amount);
		/// <summary>
		/// Get inputted "Cheat code", for example:
		/// while (TRUE)
		/// {
		/// if (MISC::_557E43C447E700A8(${fugitive}))
		/// {
		/// // Do something.
		/// }
		/// SYSTEM::WAIT(0);
		/// }
		/// Calling this will also set the last saved string hash to zero.
		/// </summary>
		bool HasCheatStringJustBeenEntered(int hash);
		void _0xFA3FFB0EEBC288A3(bool p0);
		/// <summary>
		/// Formerly known as _LOWER_MAP_PROP_DENSITY and wrongly due to idiots as _ENABLE_MP_DLC_MAPS.
		/// Sets the maximum prop density and changes a loading screen flag from 'loading story mode' to 'loading GTA Online'. Does not touch DLC map data at all.
		/// In fact, I doubt this changes the flag whatsoever, that's the OTHER native idiots use together with this that does so, this one only causes a loading screen to show as it reloads map data.
		/// </summary>
		void SetInstancePriorityMode(int p0);
		/// <summary>
		/// Sets an unknown flag used by CScene in determining which entities from CMapData scene nodes to draw, similar to SET_INSTANCE_PRIORITY_MODE.
		/// </summary>
		void SetInstancePriorityHint(int flag);
		bool IsFrontendFading();
		/// <summary>
		/// spawns a few distant/out-of-sight peds, vehicles, animals etc each time it is called
		/// </summary>
		void PopulateNow();
		int GetIndexOfCurrentLevel();
		/// <summary>
		/// 0: 9.8 - normal
		/// 1: 2.4 - low
		/// 2: 0.1 - very low
		/// 3: 0.0 - off
		/// //SuckMyCoke
		/// </summary>
		/// <param name="level">can be from 0 to 3</param>
		void SetGravityLevel(int level);
		/// <summary>
		/// </summary>
		void StartSaveData(ref int p0, int p1, bool p2);
		void StopSaveData();
		int GetSizeOfSaveData(bool p0);
		/// <summary>
		/// </summary>
		void RegisterIntToSave(ref int p0, string name);
		/// <summary>
		/// </summary>
		void RegisterInt64ToSave(ref int p0, string name);
		/// <summary>
		/// </summary>
		void RegisterEnumToSave(ref int p0, string name);
		/// <summary>
		/// </summary>
		void RegisterFloatToSave(ref int p0, string name);
		/// <summary>
		/// </summary>
		void RegisterBoolToSave(ref int p0, string name);
		/// <summary>
		/// </summary>
		void RegisterTextLabelToSave(ref int p0, string name);
		/// <summary>
		/// Seems to have the same functionality as REGISTER_TEXT_LABEL_TO_SAVE?
		/// MISC::_6F7794F28C6B2535(&a_0._f1, "tlPlateText");
		/// MISC::_6F7794F28C6B2535(&a_0._f1C, "tlPlateText_pending");
		/// MISC::_6F7794F28C6B2535(&a_0._f10B, "tlCarAppPlateText");
		/// "tl" prefix sounds like "Text Label"
		/// </summary>
		void RegisterTextLabelToSave2(ref int p0, string name);
		/// <summary>
		/// Only found 3 times in decompiled scripts. Not a whole lot to go off of.
		/// MISC::_48F069265A0E4BEC(a_0, "Movie_Name_For_This_Player");
		/// MISC::_48F069265A0E4BEC(&a_0._fB, "Ringtone_For_This_Player");
		/// MISC::_48F069265A0E4BEC(&a_0._f1EC4._f12[v_A6], &v_13); // where v_13 is "MPATMLOGSCRS0" thru "MPATMLOGSCRS15"
		/// </summary>
		void _0x48F069265A0E4BEC(ref int p0, string name);
		/// <summary>
		/// Only found 2 times in decompiled scripts. Not a whole lot to go off of.
		/// MISC::_8269816F6CFD40F8(&a_0._f1F5A._f6[08], "TEMPSTAT_LABEL"); // gets saved in a struct called "g_SaveData_STRING_ScriptSaves"
		/// MISC::_8269816F6CFD40F8(&a_0._f4B4[v_1A8], &v_5); // where v_5 is "Name0" thru "Name9", gets saved in a struct called "OUTFIT_Name"
		/// </summary>
		void _0x8269816F6CFD40F8(ref int p0, string name);
		/// <summary>
		/// Another unknown label type...
		/// MISC::_FAA457EF263E8763(a_0, "Thumb_label");
		/// MISC::_FAA457EF263E8763(&a_0._f10, "Photo_label");
		/// MISC::_FAA457EF263E8763(a_0, "GXTlabel");
		/// MISC::_FAA457EF263E8763(&a_0._f21, "StringComp");
		/// MISC::_FAA457EF263E8763(&a_0._f43, "SecondStringComp");
		/// MISC::_FAA457EF263E8763(&a_0._f53, "ThirdStringComp");
		/// MISC::_FAA457EF263E8763(&a_0._f32, "SenderStringComp");
		/// MISC::_FAA457EF263E8763(&a_0._f726[v_1A16], &v_20); // where v_20 is "LastJobTL_0_1" thru "LastJobTL_2_1", gets saved in a struct called "LAST_JobGamer_TL"
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFAA457EF263E8763
		/// </summary>
		void _0xFAA457EF263E8763(ref int p0, string name);
		/// <summary>
		/// </summary>
		void StartSaveStructWithSize(ref int p0, int size, string structName);
		void StopSaveStruct();
		/// <summary>
		/// </summary>
		void StartSaveArrayWithSize(ref int p0, int size, string arrayName);
		void StopSaveArray();
		/// <summary>
		/// </summary>
		void CopyMemory(ref int dst, ref int src, int size);
		/// <summary>
		/// https://alloc8or.re/gta5/doc/enums/DispatchType.txt
		/// </summary>
		void EnableDispatchService(int dispatchService, bool toggle);
		void BlockDispatchServiceResourceCreation(int dispatchService, bool toggle);
		int GetNumDispatchedUnitsForPlayer(int dispatchService);
		/// <summary>
		/// As for the 'police' incident, it will call police cars to you, but unlike PedsInCavalcades & Merryweather they won't start shooting at you unless you shoot first or shoot at them. The top 2 however seem to cancel theirselves if there is noone dead around you or a fire. I only figured them out as I found out the 3rd param is definately the amountOfPeople and they called incident 3 in scripts with 4 people (which the firetruck has) and incident 5 with 2 people (which the ambulence has). The 4 param I cant say is radius, but for the pedsInCavalcades and Merryweather R* uses 0.0f and for the top 3 (Emergency Services) they use 3.0f.
		/// Side Note: It seems calling the pedsInCavalcades or Merryweather then removing it seems to break you from calling the EmergencyEvents and I also believe pedsInCavalcades. (The V cavalcades of course not IV).
		/// Side Note 2: I say it breaks as if you call this proper,
		/// =====================================================
		/// </summary>
		/// <returns>if(CREATE_INCIDENT) etc it will return false if you do as I said above.</returns>
		bool CreateIncident(int dispatchService, float x, float y, float z, int numUnits, float radius, ref int outIncidentID, int p7, int p8);
		/// <summary>
		/// As for the 'police' incident, it will call police cars to you, but unlike PedsInCavalcades & Merryweather they won't start shooting at you unless you shoot first or shoot at them. The top 2 however seem to cancel theirselves if there is noone dead around you or a fire. I only figured them out as I found out the 3rd param is definately the amountOfPeople and they called incident 3 in scripts with 4 people (which the firetruck has) and incident 5 with 2 people (which the ambulence has). The 4 param I cant say is radius, but for the pedsInCavalcades and Merryweather R* uses 0.0f and for the top 3 (Emergency Services) they use 3.0f.
		/// Side Note: It seems calling the pedsInCavalcades or Merryweather then removing it seems to break you from calling the EmergencyEvents and I also believe pedsInCavalcades. (The V cavalcades of course not IV).
		/// Side Note 2: I say it breaks as if you call this proper,
		/// =====================================================
		/// </summary>
		/// <returns>if(CREATE_INCIDENT) etc it will return false if you do as I said above.</returns>
		bool CreateIncidentWithEntity(int dispatchService, int ped, int numUnits, float radius, ref int outIncidentID, int p5, int p6);
		/// <summary>
		/// Delete an incident with a given id.
		/// =======================================================
		/// Correction, I have change this to int, instead of int*
		/// as it doesn't use a pointer to the createdIncident.
		/// If you try it you will crash (or) freeze.
		/// =======================================================
		/// </summary>
		void DeleteIncident(int incidentId);
		/// <summary>
		/// =======================================================
		/// Correction, I have change this to int, instead of int*
		/// as it doesn't use a pointer to the createdIncident.
		/// If you try it you will crash (or) freeze.
		/// =======================================================
		/// </summary>
		bool IsIncidentValid(int incidentId);
		void SetIncidentRequestedUnits(int incidentId, int dispatchService, int numUnits);
		/// <summary>
		/// SET_INCIDENT_*
		/// </summary>
		void SetIncidentUnk(int incidentId, float p1);
		/// <summary>
		/// Finds a position ahead of the player by predicting the players next actions.
		/// The positions match path finding node positions.
		/// When roads diverge, the position may rapidly change between two or more positions. This is due to the engine not being certain of which path the player will take.
		/// =======================================================
		/// I may sort this with alter research, but if someone
		/// already knows please tell what the difference in
		/// X2, Y2, Z2 is. I doubt it's rotation. Is it like
		/// checkpoints where X1, Y1, Z1 is your/a position and
		/// X2, Y2, Z2 is a given position ahead of that position?
		/// =======================================================
		/// </summary>
		bool FindSpawnPointInDirection(float x1, float y1, float z1, float x2, float y2, float z2, float distance, ref Vector3 spawnPoint);
		int AddPopMultiplierArea(float x1, float y1, float z1, float x2, float y2, float z2, float p6, float p7, bool p8, bool p9);
		bool DoesPopMultiplierAreaExist(int id);
		void RemovePopMultiplierArea(int id, bool p1);
		bool IsPopMultiplierAreaUnk(int id);
		/// <summary>
		/// </summary>
		/// <returns>This native is adding a zone, where you can change density settings. For example, you can add a zone on 0.0, 0.0, 0.0 with radius 900.0 and vehicleMultiplier 0.0, and you will not see any new population vehicle spawned in a radius of 900.0 from 0.0, 0.0, 0.0. Returns the id. You can have only 15 zones at the same time. You can remove zone using REMOVE_POP_MULTIPLIER_SPHERE</returns>
		int AddPopMultiplierSphere(float x, float y, float z, float radius, float pedMultiplier, float vehicleMultiplier, bool p6, bool p7);
		bool DoesPopMultiplierSphereExist(int id);
		/// <summary>
		/// Removes population multiplier sphere
		/// </summary>
		void RemovePopMultiplierSphere(int id, bool p1);
		/// <summary>
		/// Makes the ped jump around like they're in a tennis match
		/// </summary>
		void EnableTennisMode(int ped, bool toggle, bool p2);
		bool IsTennisMode(int ped);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void PlayTennisSwingAnim(int ped, string animDict, string animName, float p3, float p4, bool p5);
		bool GetTennisSwingAnimComplete(int ped);
		/// <summary>
		/// Related to tennis mode.
		/// GET_TENNIS_*
		/// </summary>
		bool _0x19BFED045C647C49(int ped);
		/// <summary>
		/// Related to tennis mode.
		/// GET_TENNIS_*
		/// </summary>
		bool _0xE95B0C7D5BA3B96B(int ped);
		void PlayTennisDiveAnim(int ped, int p1, float p2, float p3, float p4, bool p5);
		/// <summary>
		/// From the scripts:
		/// MISC::_54F157E0336A3822(sub_aa49(a_0), "ForcedStopDirection", v_E);
		/// Related to tennis mode.
		/// SET_*
		/// </summary>
		void _0x54F157E0336A3822(int ped, string p1, float p2);
		void ResetDispatchSpawnLocation();
		void SetDispatchSpawnLocation(float x, float y, float z);
		void ResetDispatchIdealSpawnDistance();
		void SetDispatchIdealSpawnDistance(float p0);
		void ResetDispatchTimeBetweenSpawnAttempts(int p0);
		void SetDispatchTimeBetweenSpawnAttempts(int p0, float p1);
		void SetDispatchTimeBetweenSpawnAttemptsMultiplier(int p0, float p1);
		/// <summary>
		/// To remove, see: REMOVE_DISPATCH_SPAWN_BLOCKING_AREA
		/// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
		/// </summary>
		int AddDispatchSpawnBlockingAngledArea(float x1, float y1, float z1, float x2, float y2, float z2, float width);
		int AddDispatchSpawnBlockingArea(float x1, float y1, float x2, float y2);
		void RemoveDispatchSpawnBlockingArea(int p0);
		void ResetDispatchSpawnBlockingAreas();
		/// <summary>
		/// RESET_*
		/// </summary>
		void _0xD9F692D349249528();
		/// <summary>
		/// SET_*
		/// </summary>
		void _0xE532EC1A63231B4F(int p0, int p1);
		/// <summary>
		/// Adds a point related to CTacticalAnalysis
		/// </summary>
		void AddTacticalAnalysisPoint(float x, float y, float z);
		void ClearTacticalAnalysisPoints();
		/// <summary>
		/// Activates (usused?) riot mode. All NPCs are being hostile to each other (including player). Also the game will give weapons (pistols, smgs) to random NPCs.
		/// </summary>
		void SetRiotModeEnabled(bool toggle);
		/// <summary>
		/// </summary>
		void DisplayOnscreenKeyboardWithLongerInitialString(int p0, string windowTitle, ref int p2, string defaultText, string defaultConcat1, string defaultConcat2, string defaultConcat3, string defaultConcat4, string defaultConcat5, string defaultConcat6, string defaultConcat7, int maxInputLength);
		/// <summary>
		/// sfink: note, p0 is set to 6 for PC platform in at least 1 script, or to `unk::_get_ui_language_id() == 0` otherwise.
		/// NOTE: windowTitle uses text labels, and an invalid value will display nothing.
		/// www.gtaforums.com/topic/788343-vrel-script-hook-v/?p=1067380474
		/// windowTitle's
		/// -----------------
		/// CELL_EMAIL_BOD  =   "Enter your Eyefind message"
		/// CELL_EMAIL_BODE =   "Message too long. Try again"
		/// CELL_EMAIL_BODF    =   "Forbidden message. Try again"
		/// CELL_EMAIL_SOD    =   "Enter your Eyefind subject"
		/// See NativeDB for reference: http://natives.altv.mp/#/0x00DC833F2568DBF6
		/// </summary>
		void DisplayOnscreenKeyboard(int p0, string windowTitle, string p2, string defaultText, string defaultConcat1, string defaultConcat2, string defaultConcat3, int maxInputLength);
		/// <summary>
		/// Returns the current status of the onscreen keyboard, and updates the output.
		/// Status Codes:
		/// -1: Keyboard isn't active
		/// 0: User still editing
		/// 1: User has finished editing
		/// 2: User has canceled editing
		/// </summary>
		int UpdateOnscreenKeyboard();
		string GetOnscreenKeyboardResult();
		/// <summary>
		/// DO NOT use this as it doesn't clean up the text input box properly and your script will get stuck in the UPDATE_ONSCREEN_KEYBOARD() loop.
		/// Use _FORCE_CLOSE_TEXT_INPUT_BOX instead.
		/// CANCEL_*
		/// </summary>
		void CancelOnscreenKeyboard();
		/// <summary>
		/// Called before calling DISPLAY_ONSCREEN_KEYBOARD if the input needs to be saved.
		/// </summary>
		/// <param name="p0">was always 2 in R* scripts.</param>
		void NextOnscreenKeyboardResultWillDisplayUsingTheseFonts(int p0);
		/// <summary>
		/// Appears to remove stealth kill action from memory
		/// </summary>
		void RemoveStealthKill(int hash, bool p1);
		/// <summary>
		/// Unsure about the use of this native but here's an example:
		/// void sub_8709() {
		/// MISC::_1EAE0A6E978894A2(0, 1);
		/// MISC::_1EAE0A6E978894A2(1, 1);
		/// MISC::_1EAE0A6E978894A2(2, 1);
		/// MISC::_1EAE0A6E978894A2(3, 1);
		/// MISC::_1EAE0A6E978894A2(4, 1);
		/// MISC::_1EAE0A6E978894A2(5, 1);
		/// MISC::_1EAE0A6E978894A2(6, 1);
		/// See NativeDB for reference: http://natives.altv.mp/#/0x1EAE0A6E978894A2
		/// </summary>
		void _0x1EAE0A6E978894A2(int p0, bool p1);
		void SetExplosiveAmmoThisFrame(int player);
		void SetFireAmmoThisFrame(int player);
		void SetExplosiveMeleeThisFrame(int player);
		void SetSuperJumpThisFrame(int player);
		void SetBeastModeActive(int player);
		void SetForcePlayerToJump(int player);
		/// <summary>
		/// HAS_*
		/// Probably something like "has game been started for the first time".
		/// </summary>
		bool _0x6FDDF453C0C756EC();
		void _0xFB00CA71DA386228();
		bool AreProfileSettingsValid();
		/// <summary>
		/// sets something to 1
		/// </summary>
		void _0xE3D969D2785FFB5E();
		/// <summary>
		/// Sets the localplayer playerinfo state back to playing (State 0)
		/// States are:
		/// -1: "Invalid"
		/// 0: "Playing"
		/// 1: "Died"
		/// 2: "Arrested"
		/// 3: "Failed Mission"
		/// 4: "Left Game"
		/// 5: "Respawn"
		/// 6: "In MP Cutscene"
		/// </summary>
		void ForceGameStatePlaying();
		void ScriptRaceInit(int p0, int p1, int p2, int p3);
		void ScriptRaceShutdown();
		/// <summary>
		/// SCRIPT_RACE_*
		/// </summary>
		void _0x1BB299305C3E8C13(int p0, int p1, int p2, int p3);
		/// <summary>
		/// </summary>
		bool ScriptRaceGetPlayerSplitTime(int player, ref int p1, ref int p2);
		/// <summary>
		/// Begins with START_*. Next character in the name is either D or E.
		/// </summary>
		void StartBenchmarkRecording();
		/// <summary>
		/// Begins with STOP_*. Next character in the name is either D or E.
		/// </summary>
		void StopBenchmarkRecording();
		/// <summary>
		/// Begins with RESET_*. Next character in the name is either D or E.
		/// </summary>
		void ResetBenchmarkRecording();
		/// <summary>
		/// Saves the benchmark recording to %USERPROFILE%\Documents\Rockstar Games\GTA V\Benchmarks and submits some metrics.
		/// </summary>
		void SaveBenchmarkRecording();
		/// <summary>
		/// Returns true if the current frontend menu is FE_MENU_VERSION_SP_PAUSE
		/// U*
		/// </summary>
		bool UiIsSingleplayerPauseMenuActive();
		/// <summary>
		/// Returns true if the current frontend menu is FE_MENU_VERSION_LANDING_MENU
		/// </summary>
		bool LandingMenuIsActive();
		/// <summary>
		/// Returns true if command line option '-benchmark' is set.
		/// </summary>
		bool IsCommandLineBenchmarkValueSet();
		/// <summary>
		/// Returns value of the '-benchmarkIterations' command line option.
		/// </summary>
		int GetBenchmarkIterationsFromCommandLine();
		/// <summary>
		/// Returns value of the '-benchmarkPass' command line option.
		/// </summary>
		int GetBenchmarkPassFromCommandLine();
		/// <summary>
		/// In singleplayer it does exactly what the name implies. In FiveM / GTA:Online it shows `Disconnecting from GTA Online` HUD and then quits the game.
		/// </summary>
		void RestartGame();
		/// <summary>
		/// Exits the game and downloads a fresh social club update on next restart.
		/// </summary>
		void ForceSocialClubUpdate();
		bool HasAsyncInstallFinished();
		void CleanupAsyncInstall();
		/// <summary>
		/// aka "constrained"
		/// </summary>
		bool IsInPowerSavingMode();
		/// <summary>
		/// Returns duration of how long the game has been in power-saving mode (aka "constrained") in milliseconds.
		/// </summary>
		int GetPowerSavingModeDuration();
		/// <summary>
		/// If toggle is true, the ped's head is shown in the pause menu
		/// If toggle is false, the ped's head is not shown in the pause menu
		/// </summary>
		void SetPlayerIsInAnimalForm(bool toggle);
		/// <summary>
		/// Although we don't have a jenkins hash for this one, the name is 100% confirmed.
		/// </summary>
		bool GetIsPlayerInAnimalForm();
		/// <summary>
		/// SET_PLAYER_*
		/// </summary>
		void SetPlayerRockstarEditorDisabled(bool toggle);
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		void _0x23227DF0B2115469();
		int _0xD10282B6E3751BA0();
		void _0x693478ACBD7F18E7();
		/// <summary>
		/// Creates a mobile phone of the specified type.
		/// Possible phone types:
		/// 0 - Default phone / Michael's phone
		/// 1 - Trevor's phone
		/// 2 - Franklin's phone
		/// 4 - Prologue phone
		/// These values represent bit flags, so a value of '3' would toggle Trevor and Franklin's phones together, causing unexpected behavior and most likely crash the game.
		/// </summary>
		void CreateMobilePhone(int phoneType);
		/// <summary>
		/// Destroys the currently active mobile phone.
		/// </summary>
		void DestroyMobilePhone();
		/// <summary>
		/// The minimum/default is 500.0f. If you plan to make it bigger set it's position as well. Also this seems to need to be called in a loop as when you close the phone the scale is reset. If not in a loop you'd need to call it everytime before you re-open the phone.
		/// </summary>
		void SetMobilePhoneScale(float scale);
		/// <summary>
		/// Last parameter is unknown and always zero.
		/// </summary>
		void SetMobilePhoneRotation(float rotX, float rotY, float rotZ, int p3);
		/// <summary>
		/// </summary>
		void GetMobilePhoneRotation(ref Vector3 rotation, int p1);
		void SetMobilePhonePosition(float posX, float posY, float posZ);
		/// <summary>
		/// </summary>
		void GetMobilePhonePosition(ref Vector3 position);
		/// <summary>
		/// If bool Toggle = true so the mobile is hide to screen.
		/// If bool Toggle = false so the mobile is show to screen.
		/// </summary>
		void ScriptIsMovingMobilePhoneOffscreen(bool toggle);
		/// <summary>
		/// I can confirm the above. This function is hard-coded to always return 1.
		/// </summary>
		/// <returns>This one is weird and seems to return a TRUE state regardless of whether the phone is visible on screen or tucked away.</returns>
		bool CanPhoneBeSeenOnScreen();
		void SetMobilePhoneUnk(bool toggle);
		/// <summary>
		/// For move the finger of player, the value of int goes 1 at 5.
		/// </summary>
		void CellCamMoveFinger(int direction);
		/// <summary>
		/// if the bool "Toggle" is "true" so the phone is lean.
		/// if the bool "Toggle" is "false" so the phone is not lean.
		/// </summary>
		void CellCamSetLean(bool toggle);
		void CellCamActivate(bool p0, bool p1);
		/// <summary>
		/// Disables the phone up-button, oddly enough.
		/// i.e.: When the phone is out, and this method is called with false as it's parameter, the phone will not be able to scroll up. However, when you use the down arrow key, it's functionality still, works on the phone.
		/// When the phone is not out, and this method is called with false as it's parameter, you will not be able to bring up the phone. Although the up arrow key still works for whatever functionality it's used for, just not for the phone.
		/// This can be used for creating menu's when trying to disable the phone from being used.
		/// You do not have to call the function again with false as a parameter, as soon as the function stops being called, the phone will again be usable.
		/// </summary>
		void CellCamDisableThisFrame(bool toggle);
		/// <summary>
		/// Needs more research. If the "phone_cam12" filter is applied, this function is called with "TRUE"; otherwise, "FALSE".
		/// Example (XBOX 360):
		/// // check current filter selection
		/// if (MISC::ARE_STRINGS_EQUAL(getElem(g_2471024, &l_17, 4), "phone_cam12") != 0)
		/// {
		/// MOBILE::_0xC273BB4D(0); // FALSE
		/// }
		/// else
		/// {
		/// See NativeDB for reference: http://natives.altv.mp/#/0xA2CCBE62CD4C91A4
		/// </summary>
		void _0xA2CCBE62CD4C91A4(ref int toggle);
		void _0x1B0B4AEED5B9B41C(float p0);
		void _0x53F4892D18EC90A4(float p0);
		void _0x3117D84EFA60F77B(float p0);
		void _0x15E69E2802C24B8D(float p0);
		void _0xAC2890471901861C(float p0);
		void _0xD6ADE981781FCA09(float p0);
		void _0xF1E22DC13F5EEBAD(float p0);
		void _0x466DA42C89865553(float p0);
		bool CellCamIsCharVisibleNoFaceCheck(int entity);
		/// <summary>
		/// </summary>
		void GetMobilePhoneRenderId(ref int renderId);
		void NetworkInitializeCash(int wallet, int bank);
		/// <summary>
		/// Note the 2nd parameters are always 1, 0. I have a feeling it deals with your money, wallet, bank. So when you delete the character it of course wipes the wallet cash at that time. So if that was the case, it would be eg, NETWORK_DELETE_CHARACTER(characterIndex, deleteWalletCash, deleteBankCash);
		/// </summary>
		void NetworkDeleteCharacter(int characterSlot, bool p1, bool p2);
		void NetworkManualDeleteCharacter(int characterSlot);
		bool NetworkGetIsHighEarner();
		void NetworkClearCharacterWallet(int characterSlot);
		/// <summary>
		/// </summary>
		void NetworkGivePlayerJobshareCash(int amount, ref int gamerHandle);
		/// <summary>
		/// </summary>
		void NetworkReceivePlayerJobshareCash(int value, ref int gamerHandle);
		bool NetworkCanShareJobCash();
		/// <summary>
		/// index
		/// -------
		/// See function sub_1005 in am_boat_taxi.ysc
		/// context
		/// ----------
		/// "BACKUP_VAGOS"
		/// "BACKUP_LOST"
		/// "BACKUP_FAMILIES"
		/// "HIRE_MUGGER"
		/// See NativeDB for reference: http://natives.altv.mp/#/0xF9C812CD7C46E817
		/// </summary>
		void NetworkRefundCash(int index, string context, string reason, bool unk);
		void NetworkDeductCash(int amount, string p1, string p2, bool p3, bool p4, bool p5);
		bool NetworkMoneyCanBet(int amount, bool p1, bool p2);
		bool NetworkCanBet(int amount);
		/// <summary>
		/// GTAO_CASINO_HOUSE
		/// GTAO_CASINO_INSIDETRACK
		/// GTAO_CASINO_LUCKYWHEEL
		/// GTAO_CASINO_BLACKJACK
		/// GTAO_CASINO_ROULETTE
		/// GTAO_CASINO_SLOTS
		/// GTAO_CASINO_PURCHASE_CHIPS
		/// NETWORK_C*
		/// </summary>
		bool NetworkCasinoCanUseGamblingType(int hash);
		/// <summary>
		/// Same as 0x8968D4D8C6C40C11.
		/// NETWORK_C*
		/// </summary>
		bool NetworkCasinoCanPurchaseChipsWithPvc();
		/// <summary>
		/// NETWORK_C*
		/// </summary>
		bool NetworkCasinoCanGamble(int p0);
		/// <summary>
		/// Same as 0x394DCDB9E836B7A9.
		/// NETWORK_C*
		/// </summary>
		bool NetworkCasinoCanPurchaseChipsWithPvc2();
		/// <summary>
		/// NETWORK_C*
		/// </summary>
		bool NetworkCasinoPurchaseChips(int p0, int p1);
		/// <summary>
		/// NETWORK_C*
		/// </summary>
		bool NetworkCasinoSellChips(int p0, int p1);
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		void _0xCD0F5B5D932AE473();
		/// <summary>
		/// CAN_*
		/// </summary>
		bool CanPayGoon(int p0, int p1, int amount, ref int p3);
		void NetworkEarnFromCashingOut(int amount);
		void NetworkEarnFromPickup(int amount);
		void NetworkEarnFromGangPickup(int amount);
		void NetworkEarnFromAssassinateTargetKilled(int amount);
		/// <summary>
		/// For the money bags that drop a max of $40,000. Often called 40k bags.
		/// Most likely NETWORK_EARN_FROM_ROB***
		/// </summary>
		void NetworkEarnFromArmourTruck(int amount);
		void NetworkEarnFromCrateDrop(int amount);
		void NetworkEarnFromBetting(int amount, string p1);
		void NetworkEarnFromJob(int amount, string p1);
		void NetworkEarnFromJobX2(int amount, string p1);
		void NetworkEarnFromPremiumJob(int amount, string p1);
		void NetworkEarnFromBendJob(int amount, string heistHash);
		/// <summary>
		/// </summary>
		void NetworkEarnFromChallengeWin(int p0, ref int p1, bool p2);
		/// <summary>
		/// </summary>
		void NetworkEarnFromBounty(int amount, ref int gamerHandle, ref int p2, int p3);
		void NetworkEarnFromImportExport(int amount, int modelHash);
		void NetworkEarnFromHoldups(int amount);
		void NetworkEarnFromProperty(int amount, int propertyName);
		/// <summary>
		/// DSPORT
		/// </summary>
		void NetworkEarnFromAiTargetKill(int p0, int p1);
		void NetworkEarnFromNotBadsport(int amount);
		void NetworkEarnFromRockstar(int amount);
		void NetworkEarnFromVehicle(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7);
		void NetworkEarnFromPersonalVehicle(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8);
		void NetworkEarnFromDailyObjectives(int p0, string p1, int p2);
		/// <summary>
		/// Example for p1: "AM_DISTRACT_COPS"
		/// </summary>
		void NetworkEarnFromAmbientJob(int p0, string p1, ref int p2);
		/// <summary>
		/// </summary>
		void NetworkEarnFromJobBonus(int p0, ref int p1, ref int p2);
		void NetworkEarnJobBonusHeistAward(int p0, int p1, int p2);
		void NetworkEarnJobBonusFirstTimeBonus(int p0, int p1, int p2);
		void NetworkEarnGoon(int p0, int p1, int p2);
		void NetworkEarnBoss(int p0, int p1, int p2);
		void NetworkEarnBossAgency(int p0, int p1, int p2, int p3);
		void NetworkEarnFromWarehouse(int amount, int id);
		void NetworkEarnFromContraband(int amount, int p1);
		void NetworkEarnFromDestroyingContraband(int p0);
		void _0x6B7E4FB50D5F3D65(int p0, int p1, int p2, int p3, int p4);
		void _0x31BA138F6304FB9F(int p0, int p1);
		void _0x55A1E095DB052FA5(int p0, int p1);
		void NetworkEarnFromBusinessProduct(int amount, int p1, int p2, int p3);
		void NetworkEarnFromVehicleExport(int amount, int p1, int p2);
		void NetworkEarnFromSmuggling(int amount, int p1, int p2, int p3);
		void NetworkEarnBountyHunterReward(int p0);
		void NetworkEarnFromBusinessBattle(int p0);
		void NetworkEarnFromClubManagementParticipation(int p0);
		void NetworkEarnFromFmbbPhonecallMission(int p0);
		void NetworkEarnFromBusinessHubSell(int p0, int p1, int p2);
		void NetworkEarnFromFmbbBossWork(int p0);
		void NetworkEarnFmbbWageBonus(int p0);
		bool NetworkCanSpendMoney(int p0, bool p1, bool p2, bool p3, int p4, int p5);
		/// <summary>
		/// NETWORK_CAN_R??? or NETWORK_CAN_S???
		/// </summary>
		bool NetworkCanSpendMoney2(int p0, bool p1, bool p2, bool p3, ref int p4, int p5, int p6);
		void NetworkBuyItem(int amount, int item, int p2, int p3, bool p4, string item_name, int p6, int p7, int p8, bool p9);
		void NetworkSpentTaxi(int amount, bool p1, bool p2);
		void NetworkPayEmployeeWage(int p0, bool p1, bool p2);
		void NetworkPayUtilityBill(int amount, bool p1, bool p2);
		void NetworkPayMatchEntryFee(int amount, string matchId, bool p2, bool p3);
		void NetworkSpentBetting(int amount, int p1, string matchId, bool p3, bool p4);
		void NetworkSpentWager(int p0, int p1, int amount);
		void NetworkSpentInStripclub(int p0, bool p1, int p2, bool p3);
		void NetworkBuyHealthcare(int cost, bool p1, bool p2);
		/// <summary>
		/// </summary>
		/// <param name="p1">= 0 (always)</param>
		/// <param name="p2">= 1 (always)</param>
		void NetworkBuyAirstrike(int cost, bool p1, bool p2);
		void NetworkBuyBackupGang(int p0, int p1, bool p2, bool p3);
		/// <summary>
		/// </summary>
		/// <param name="p1">= 0 (always)</param>
		/// <param name="p2">= 1 (always)</param>
		void NetworkBuyHeliStrike(int cost, bool p1, bool p2);
		void NetworkSpentAmmoDrop(int p0, bool p1, bool p2);
		/// <summary>
		/// </summary>
		/// <param name="victim">is just an assumption. p2 was false and p3 was true.</param>
		void NetworkBuyBounty(int amount, int victim, bool p2, bool p3);
		void NetworkBuyProperty(int cost, int propertyName, bool p2, bool p3);
		void NetworkBuySmokes(int p0, bool p1, bool p2);
		void NetworkSpentHeliPickup(int p0, bool p1, bool p2);
		void NetworkSpentBoatPickup(int p0, bool p1, bool p2);
		void NetworkSpentBullShark(int p0, bool p1, bool p2);
		void NetworkSpentCashDrop(int amount, bool p1, bool p2);
		/// <summary>
		/// Only used once in a script (am_contact_requests)
		/// </summary>
		/// <param name="p1">= 0</param>
		/// <param name="p2">= 1</param>
		void NetworkSpentHireMugger(int p0, bool p1, bool p2);
		void NetworkSpentRobbedByMugger(int amount, bool p1, bool p2);
		void NetworkSpentHireMercenary(int p0, bool p1, bool p2);
		/// <summary>
		/// </summary>
		void NetworkSpentBuyWantedlevel(int p0, ref int p1, bool p2, bool p3);
		void NetworkSpentBuyOfftheradar(int p0, bool p1, bool p2);
		void NetworkSpentBuyRevealPlayers(int p0, bool p1, bool p2);
		void NetworkSpentCarwash(int p0, int p1, int p2, bool p3, bool p4);
		void NetworkSpentCinema(int p0, int p1, bool p2, bool p3);
		void NetworkSpentTelescope(int p0, bool p1, bool p2);
		void NetworkSpentHoldups(int p0, bool p1, bool p2);
		void NetworkSpentBuyPassiveMode(int p0, bool p1, bool p2);
		void NetworkSpentBankInterest(int p0, bool p1, bool p2);
		void NetworkSpentProstitutes(int p0, bool p1, bool p2);
		void NetworkSpentArrestBail(int p0, bool p1, bool p2);
		/// <summary>
		/// According to how I understood this in the freemode script alone,
		/// The second parameter whoever put it was right, they call GET_ENTITY_MODEL with the vehicle as the paremeter.
		/// The third parameter is the network handle as they call their little struct<13> func or atleast how the script decompiled it to look which in lamens terms just returns the network handle of the previous owner based on DECOR_GET_INT(vehicle, "Previous_Owner").
		/// The fourth parameter is a bool that returns true/false depending on if your bank balance is greater then 0.
		/// The fifth and last parameter is a bool that returns true/false depending on if you have the money for the car based on the cost returned by func_5749. In the freemode script eg,
		/// bool hasTheMoney = MONEY::_GET_BANK_BALANCE() < carCost.
		/// </summary>
		/// <returns>The first parameter is determined by a function named, func_5749 within the freemode script which has a list of all the vehicles and a set price to return which some vehicles deals with globals as well. So the first parameter is basically the set in stone insurance cost it's gonna charge you for that specific vehicle model.</returns>
		void NetworkSpentPayVehicleInsurancePremium(int amount, int vehicleModel, ref int gamerHandle, bool notBankrupt, bool hasTheMoney);
		/// <summary>
		/// </summary>
		void NetworkSpentCallPlayer(int p0, ref int p1, bool p2, bool p3);
		void NetworkSpentBounty(int p0, bool p1, bool p2);
		void NetworkSpentFromRockstar(int p0, bool p1, bool p2);
		int _0x9B5016A6433A68C5();
		/// <summary>
		/// This isn't a hash collision.
		/// </summary>
		string ProcessCashGift(ref int p0, ref int p1, string p2);
		void NetworkSpentPlayerHealthcare(int p0, int p1, bool p2, bool p3);
		void NetworkSpentNoCops(int p0, bool p1, bool p2);
		void NetworkSpentRequestJob(int p0, bool p1, bool p2);
		void NetworkSpentRequestHeist(int p0, bool p1, bool p2);
		/// <summary>
		/// The last 3 parameters are,
		/// 2,0,1 in the am_ferriswheel.c
		/// 1,0,1 in the am_rollercoaster.c
		/// </summary>
		/// <returns>The first parameter is the amount spent which is store in a global when this native is called. The global returns 10. Which is the price for both rides.</returns>
		void NetworkBuyFairgroundRide(int amount, int p1, bool p2, bool p3);
		bool _0x7C4FCCD2E4DEB394();
		void NetworkSpentJobSkip(int amount, string matchId, bool p2, bool p3);
		bool NetworkSpentBoss(int amount, bool p1, bool p2);
		void NetworkSpentPayGoon(int p0, int p1, int amount);
		void NetworkSpentPayBoss(int p0, int p1, int p2);
		void NetworkSpentMoveYacht(int amount, bool p1, bool p2);
		void NetworkSpentRenameOrganization(int p0, int p1, int p2);
		void NetworkBuyContraband(int p0, int p1, int p2, bool p3, bool p4);
		void NetworkSpentVipUtilityCharges(int p0, int p1, int p2);
		void _0x112209CE0290C03A(int p0, int p1, int p2, int p3);
		void _0xED5FD7AF10F5E262(int p0, int p1, int p2, int p3);
		void _0x0D30EB83668E63C5(int p0, int p1, int p2, int p3);
		void NetworkSpentPaServiceDancer(int p0, int p1, int p2, int p3);
		void _0xE23ADC6FCB1F29AE(int p0, int p1, int p2);
		void NetworkSpentPaServiceHeliPickup(int p0, int p1, int p2, int p3);
		void _0x69EF772B192614C1(int p0, int p1, int p2, int p3);
		void _0x8E243837643D9583(int p0, int p1, int p2, int p3);
		void _0xBD0EFB25CCA8F97A(int p0, int p1, int p2, int p3);
		void _0xA95F667A755725DA(int p0, int p1, int p2, int p3);
		/// <summary>
		/// </summary>
		void NetworkSpentPurchaseWarehouse(int amount, ref int data, bool p2, bool p3);
		void _0x4128464231E3CA0B(int p0, int p1, int p2, int p3);
		void _0x2FAB6614CE22E196(int p0, int p1, int p2, int p3);
		void NetworkSpentOrderWarehouseVehicle(int p0, int p1, int p2, int p3);
		void NetworkSpentOrderBodyguardVehicle(int p0, int p1, int p2, int p3);
		void NetworkSpentJukebox(int p0, int p1, int p2, int p3);
		void _0x998E18CEB44487FC(int p0, int p1, int p2, int p3);
		void _0xFA07759E6FDDD7CF(int p0, int p1, int p2, int p3);
		void _0x6FD97159FE3C971A(int p0, int p1, int p2, int p3);
		void _0x675D19C6067CAE08(int p0, int p1, int p2, int p3);
		void _0xA51B086B0B2C0F7A(int p0, int p1, int p2, int p3);
		void NetworkSpentBaService(int p0, int p1, int p2, int p3, int p4);
		void NetworkSpentBusiness(int p0, int p1, int p2, int p3);
		void _0x5F456788B05FAEAC(int p0, int p1, int p2);
		void NetworkSpentVehicleExportMods(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9);
		void _0xB4C2EC463672474E(int p0, int p1, int p2, int p3);
		void _0x2AFC2D19B50797F2(int p0, int p1, int p2, int p3);
		void NetworkSpentImportExportRepair(int p0, int p1, int p2);
		void NetworkSpentPurchaseHangar(int p0, int p1, int p2, int p3);
		void NetworkSpentUpgradeHangar(int p0, int p1, int p2, int p3);
		void NetworkSpentHangarUtilityCharges(int amount, bool p1, bool p2);
		void NetworkSpentHangarStaffCharges(int amount, bool p1, bool p2);
		void NetworkSpentBuyTruck(int p0, int p1, int p2, int p3);
		void NetworkSpentUpgradeTruck(int p0, int p1, int p2, int p3);
		void NetworkSpentBuyBunker(int p0, int p1, int p2, int p3);
		void NetworkSpentUpgradeBunker(int p0, int p1, int p2, int p3);
		void NetworkEarnFromSellBunker(int amount, int bunkerHash);
		void NetworkSpentBallisticEquipment(int amount, bool p1, bool p2);
		void NetworkEarnFromRdrBonus(int amount, int p1);
		void NetworkEarnFromWagePayment(int amount);
		void NetworkEarnFromWagePaymentBonus(int amount);
		void NetworkSpentBuyBase(int p0, int p1, int p2, int p3);
		void NetworkSpentUpgradeBase(int p0, int p1, int p2, int p3);
		void NetworkSpentBuyTiltrotor(int p0, int p1, int p2, int p3);
		void NetworkSpentUpgradeTiltrotor(int p0, int p1, int p2, int p3);
		void NetworkSpentEmployAssassins(int p0, int p1, int p2, int p3);
		void NetworkSpentGangopsCannon(int p0, int p1, int p2, int p3);
		void NetworkSpentGangopsStartMission(int p0, int p1, int p2, int p3);
		void NetworkSpentCasinoHeistSkipMission(int p0, int p1, int p2, int p3);
		void NetworkEarnFromSellBase(int amount, int baseNameHash);
		void NetworkEarnFromTargetRefund(int amount, int p1);
		void NetworkEarnFromGangopsWages(int amount, int p1);
		void NetworkEarnFromGangopsWagesBonus(int amount, int p1);
		void NetworkEarnFromDarChallenge(int amount, int p1);
		void NetworkEarnFromDoomsdayFinaleBonus(int amount, int vehicleHash);
		void NetworkEarnFromGangopsAwards(int amount, string unk, int p2);
		void NetworkEarnFromGangopsElite(int amount, string unk, int actIndex);
		void NetworkRivalDeliveryCompleted(int earnedMoney);
		void NetworkSpentGangopsStartStrand(int type, int amount, bool p2, bool p3);
		void NetworkSpentGangopsTripSkip(int amount, bool p1, bool p2);
		void NetworkEarnFromGangopsJobsPrepParticipation(int amount);
		void NetworkEarnFromGangopsJobsSetup(int amount, string unk);
		void NetworkEarnFromGangopsJobsFinale(int amount, string unk);
		void _0x2A7CEC72C3443BCC(int p0, int p1, int p2);
		void _0xE0F82D68C7039158(int p0);
		void _0xB4DEAE67F35E2ACD(int p0);
		void NetworkEarnFromBbEventBonus(int amount);
		void _0x2A93C46AAB1EACC9(int p0, int p1, int p2, int p3);
		void _0x226C284C830D0CA8(int p0, int p1, int p2, int p3);
		void NetworkEarnFromHackerTruckMission(int p0, int amount, int p2, int p3);
		void _0xED76D195E6E3BF7F(int p0, int p1, int p2, int p3);
		void _0x1DC9B749E7AE282B(int p0, int p1, int p2, int p3);
		void _0xC6E74CF8C884C880(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		void _0x65482BFD0923C8A1(int p0, int p1, int p2, int p3, int p4, int p5);
		void NetworkSpentRdrhatchetBonus(int amount, bool p1, bool p2);
		void NetworkSpentNightclubEntryFee(int player, int amount, int p1, bool p2, bool p3);
		void NetworkSpentNightclubBarDrink(int amount, int p1, bool p2, bool p3);
		void NetworkSpentBountyHunterMission(int amount, bool p1, bool p2);
		void NetworkSpentRehireDj(int amount, int p1, bool p2, bool p3);
		void NetworkSpentArenaJoinSpectator(int amount, int p1, bool p2, bool p3);
		void NetworkEarnFromArenaSkillLevelProgression(int amount, int p1);
		void NetworkEarnFromArenaCareerProgression(int amount, int p1);
		void NetworkSpentMakeItRain(int amount, bool p1, bool p2);
		void NetworkSpentBuyArena(int amount, bool p1, bool p2, string p3);
		void NetworkSpentUpgradeArena(int amount, bool p1, bool p2, string p3);
		void NetworkSpentArenaSpectatorBox(int amount, int p1, bool p2, bool p3);
		void NetworkSpentSpinTheWheelPayment(int amount, int p1, bool p2);
		void NetworkEarnFromSpinTheWheelCash(int amount);
		void NetworkSpentArenaPremium(int amount, bool p1, bool p2);
		void NetworkEarnFromArenaWar(int amount, int p1, int p2, int p3);
		void NetworkEarnFromAssassinateTargetKilled2(int amount);
		void NetworkEarnFromBbEventCargo(int amount);
		void NetworkEarnFromRcTimeTrial(int amount);
		void NetworkEarnFromDailyObjectiveEvent(int amount);
		void NetworkSpentCasinoMembership(int amount, bool p1, bool p2, int p3);
		/// <summary>
		/// </summary>
		void NetworkSpentBuyCasino(int amount, bool p1, bool p2, ref int data);
		/// <summary>
		/// </summary>
		void NetworkSpentUpgradeCasino(int amount, bool p1, bool p2, ref int data);
		void NetworkSpentCasinoGeneric(int amount, int p1, int p2, int p3, int p4);
		void NetworkEarnFromTimeTrialWin(int amount);
		void NetworkEarnFromCollectablesActionFigures(int amount);
		void NetworkEarnFromCompleteCollection(int amount);
		void NetworkEarnFromSellingVehicle(int amount, int p1, int p2);
		void NetworkEarnFromCasinoMissionReward(int amount);
		void NetworkEarnFromCasinoStoryMissionReward(int amount);
		void NetworkEarnFromCasinoMissionParticipation(int amount);
		void NetworkEarnFromCasinoAward(int amount, int hash);
		void _0x870289A558348378(int p0, int p1, int p2, int p3);
		void _0x5574637681911FDA(int p0, int p1, int p2, int p3);
		void NetworkSpentCasinoHeist(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10);
		void _0xB5B58E24868CB09E(int p0, int p1, int p2, int p3, int p4);
		void NetworkSpentArcadeGame(int p0, int p1, int p2, int p3, int p4);
		void NetworkSpentArcadeGeneric(int p0, int p1, int p2, int p3, int p4);
		void NetworkEarnCasinoHeist(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		void _0x4C3B75694F7E0D9C(int p0, int p1, int p2);
		void _0xD29334ED1A256DBF(int p0, int p1, int p2, int p3, int p4);
		void _0xA95CFB4E02390842(int p0, int p1, int p2);
		void _0x0DD362F14F18942A(int amount, int p1, int p2);
		void NetworkEarnCasinoHeistBonus(int p0, int p1, int p2, int p3, int p4);
		void NetworkEarnFromCollectionItem(int amount, int p1);
		void NetworkEarnCollectableCompletedCollection(int amount, int p1);
		void _0xDE68E30D89F97132(int amount, int p1);
		void _0xE2E244AB823B4483(int amount, int p1);
		void NetworkSpentBeachPartyGeneric(int p0);
		void NetworkSpentSubmarine(int p0, int p1, int p2, int p3, int p4, int p5);
		void NetworkSpentCasinoClubGeneric(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8);
		void _0x90CD7C6871FBF1B4(int p0, int p1, int p2, int p3);
		void NetworkSpentUpgradeSub(int p0, int p1, int p2, int p3);
		void NetworkSpentIslandHeist(int p0, int p1, int p2, int p3);
		void NetworkEarnIslandHeist(int p0, int p1, int p2, int p3, int p4, int p5);
		void _0xA51338E0DCCD4065(int p0, int p1, int p2);
		void _0xE2BB399D90942091(int p0, int p1);
		void NetworkSpentCarclubMembership(int p0, int p1, int p2, int p3, int p4);
		void NetworkSpentCarclub(int p0, bool p1, bool p2, int p3);
		void NetworkSpentAutoshopModifications(int p0, int p1, int p2, int p3, int p4);
		void NetworkSpentCarclubTakeover(int p0, int p1, int p2, int p3);
		void NetworkSpentBuyAutoshop(int p0, int p1, int p2, int p3);
		void NetworkSpentUpgradeAutoshop(int p0, int p1, int p2, int p3);
		void NetworkEarnFromAutoshopBusiness(int p0, int p1);
		void NetworkEarnFromAutoshopIncome(int p0);
		void NetworkEarnFromCarclubMembership(int p0);
		void NetworkEarnFromVehicleAutoshop(int p0, int p1);
		void NetworkEarnFromVehicleAutoshopBonus(int p0);
		void NetworkEarnFromTunerAward(int p0, int p1, int p2);
		void NetworkEarnFromTunerFinale(int p0, int p1, int p2, int p3, int p4);
		void NetworkEarnFromUpgradeAutoshopLocation(int p0, int p1);
		void NetworkSpentImAbility(int p0, int p1, int p2, int p3);
		void NetworkSpentFromBank(int p0, int p1, int p2, bool p3);
		int NetworkGetVcBankBalance();
		int NetworkGetVcWalletBalance(int characterSlot);
		int NetworkGetVcBalance();
		int NetworkGetEvcBalance();
		int NetworkGetPvcBalance();
		string NetworkGetStringWalletBalance(int characterSlot);
		string NetworkGetStringBankBalance();
		string NetworkGetStringBankWalletBalance();
		/// <summary>
		/// Returns true if wallet balance >= amount.
		/// </summary>
		bool NetworkGetVcWalletBalanceIsNotLessThan(int amount, int characterSlot);
		/// <summary>
		/// Returns true if bank balance >= amount.
		/// </summary>
		bool NetworkGetVcBankBalanceIsNotLessThan(int amount);
		/// <summary>
		/// Returns true if bank balance + wallet balance >= amount.
		/// </summary>
		bool NetworkGetVcBankWalletBalanceIsNotLessThan(int amount, int characterSlot);
		/// <summary>
		/// Retturns the same value as NETWORK_GET_REMAINING_TRANSFER_BALANCE.
		/// </summary>
		int NetworkGetPvcTransferBalance();
		/// <summary>
		/// Returns false if amount > wallet balance or daily transfer limit has been hit.
		/// </summary>
		bool _0x08E8EEADFD0DC4A0(int amount);
		bool NetworkCanReceivePlayerCash(int p0, int p1, int p2, int p3);
		/// <summary>
		/// Returns the same value as NETWORK_GET_PVC_TRANSFER_BALANCE.
		/// </summary>
		int NetworkGetRemainingTransferBalance();
		/// <summary>
		/// </summary>
		/// <returns>Does nothing and always returns 0.</returns>
		int WithdrawVc(int amount);
		/// <summary>
		/// </summary>
		/// <returns>Does nothing and always returns false.</returns>
		bool DepositVc(int amount);
		/// <summary>
		/// </summary>
		/// <returns>This function is hard-coded to always return 1.</returns>
		bool _0xE154B48B68EF72BC(int p0);
		/// <summary>
		/// </summary>
		/// <returns>This function is hard-coded to always return 1.</returns>
		bool _0x6FCF8DDEA146C45B(int p0);
		bool NetGameserverUseServerTransactions();
		bool NetGameserverCatalogItemExists(string name);
		bool NetGameserverCatalogItemExistsHash(int hash);
		/// <summary>
		/// bool is always true in game scripts
		/// </summary>
		int NetGameserverGetPrice(int itemHash, int categoryHash, bool p2);
		bool NetGameserverCatalogIsReady();
		bool NetGameserverIsCatalogValid();
		int _0x85F6C9ABA1DE2BCF();
		int _0x357B152EF96C30B6();
		/// <summary>
		/// </summary>
		bool NetGameserverGetCatalogState(ref int state);
		int _0xE3E5A7C64CA2C6ED();
		/// <summary>
		/// </summary>
		bool _0x0395CB47B022E62C(ref int p0);
		bool NetGameserverStartSession(int charSlot);
		bool _0x72EB7BA9B69BF6AB();
		/// <summary>
		/// </summary>
		bool _0x170910093218C8B9(ref int p0);
		/// <summary>
		/// </summary>
		bool _0xC13C38E47EA5DF31(ref int p0);
		bool NetGameserverIsSessionValid(int charSlot);
		/// <summary>
		/// NET_GAMESERVER_*
		/// </summary>
		int _0x74A0FD0688F1EE45(int p0);
		bool NetGameserverSessionApplyReceivedData(int charSlot);
		bool NetGameserverIsSessionRefreshPending();
		/// <summary>
		/// Note: only one of the arguments can be set to true at a time
		/// </summary>
		bool NetGameserverGetBalance(bool inventory, bool playerbalance);
		bool _0x613F125BA3BD2EB9();
		/// <summary>
		/// </summary>
		bool NetGameserverGetTransactionManagerData(ref int p0, ref bool p1);
		/// <summary>
		/// </summary>
		bool NetGameserverBasketStart(ref int transactionId, int categoryHash, int actionHash, int flags);
		bool NetGameserverBasketDelete();
		bool NetGameserverBasketEnd();
		/// <summary>
		/// </summary>
		bool NetGameserverBasketAddItem(ref int itemData, int quantity);
		bool NetGameserverBasketIsFull();
		/// <summary>
		/// </summary>
		bool NetGameserverBasketApplyServerData(int p0, ref int p1);
		bool NetGameserverCheckoutStart(int transactionId);
		/// <summary>
		/// </summary>
		bool NetGameserverBeginService(ref int transactionId, int categoryHash, int itemHash, int actionTypeHash, int value, int flags);
		bool NetGameserverEndService(int transactionId);
		bool NetGameserverDeleteCharacterSlot(int slot, bool transfer, int reason);
		int NetGameserverDeleteCharacterSlotGetStatus();
		bool NetGameserverDeleteSetTelemetryNonceSeed();
		bool NetGameserverTransferBankToWallet(int charSlot, int amount);
		bool NetGameserverTransferWalletToBank(int charSlot, int amount);
		/// <summary>
		/// Same as 0x350AA5EBC03D3BD2
		/// </summary>
		int NetGameserverTransferCashGetStatus();
		/// <summary>
		/// Same as 0x23789E777D14CE44
		/// </summary>
		int NetGameserverTransferCashGetStatus2();
		/// <summary>
		/// Used to be NETWORK_SHOP_CASH_TRANSFER_SET_TELEMETRY_NONCE_SEED
		/// </summary>
		bool NetGameserverTransferCashSetTelemetryNonceSeed();
		bool NetGameserverSetTelemetryNonceSeed(int p0);
		/// <summary>
		/// Online version is defined here: update\update.rpf\common\data\version.txt
		/// Example:
		/// [ONLINE_VERSION_NUMBER]
		/// 1.33
		/// </summary>
		/// <returns>_GET_ONLINE_VERSION() will return "1.33"</returns>
		string GetOnlineVersion();
		/// <summary>
		/// Returns whether the player is signed into Social Club.
		/// </summary>
		bool NetworkIsSignedIn();
		/// <summary>
		/// Returns whether the game is not in offline mode.
		/// seemed not to work for some ppl
		/// </summary>
		bool NetworkIsSignedOnline();
		bool _0xBD545D44CCE70597();
		int _0xEBCAB9E5048434F4();
		/// <summary>
		/// ==== PS4 specific info ====
		/// Returns some sort of unavailable reason:
		/// -1 = REASON_INVALID
		/// 0 = REASON_OTHER
		/// 1 = REASON_SYSTEM_UPDATE
		/// 2 = REASON_GAME_UPDATE
		/// 3 = REASON_SIGNED_OUT
		/// 4 = REASON_AGE
		/// 5 = REASON_CONNECTION
		/// =================================
		/// </summary>
		/// <returns>Hardcoded to return zero.</returns>
		int _0x74FB3E29E6D10FA9();
		int _0x7808619F31FF22DB();
		int _0xA0FA4EC6A05DA44E();
		/// <summary>
		/// Returns whether the signed-in user has valid Rockstar Online Services (ROS) credentials.
		/// </summary>
		bool NetworkHasValidRosCredentials();
		/// <summary>
		/// NETWORK_IS_*
		/// Seems to be related to PlayStation
		/// </summary>
		bool _0x8D11E61A4ABF49CC();
		bool NetworkIsCloudAvailable();
		bool NetworkHasSocialClubAccount();
		bool NetworkAreSocialClubPoliciesCurrent();
		bool NetworkIsHost();
		bool _0x4237E822315D8BA9();
		bool NetworkHaveOnlinePrivileges();
		bool NetworkHasAgeRestrictedProfile();
		bool NetworkHaveUserContentPrivileges(int p0);
		bool NetworkHaveCommunicationPrivileges(int p0, int player);
		bool _0x78321BEA235FD8CD(int p0, bool p1);
		bool NetworkCheckUserContentPrivileges(int p0, int p1, bool p2);
		bool NetworkCheckCommunicationPrivileges(int p0, int p1, bool p2);
		int _0x07EAB372C8841D99(int p0, int p1, int p2);
		int _0x906CA41A4B74ECA4();
		int _0x023ACAB2DC9DC4A4();
		bool NetworkHasSocialNetworkingSharingPriv();
		int NetworkGetAgeGroup();
		int _0x0CF6CC51AA18F0F8(int p0, int p1, int p2);
		bool _0x64E5C4CC82847B73();
		void _0x1F7BC3539F9E0224();
		bool NetworkHaveOnlinePrivilege2();
		int _0xA8ACB6459542A8C8();
		void _0x83FE8D7229593017();
		int _0x53C10C8BD774F2C9();
		bool NetworkCanBail();
		void NetworkBail(int p0, int p1, int p2);
		void _0x283B6062A2C01E9B();
		int _0x8B4FFC790CA131EF(int p0, int p1, int p2, int p3);
		void NetworkTransitionTrack(int hash, int p1, int p2, int state, int p4);
		int _0x04918A41BC9B8157(int p0, int p1, int p2);
		/// <summary>
		/// 11 - Need to download tunables.
		/// 12 - Need to download background script.
		/// Returns 1 if the multiplayer is loaded, otherwhise 0.
		/// </summary>
		bool NetworkCanAccessMultiplayer(ref int loadingState);
		bool NetworkIsMultiplayerDisabled();
		bool NetworkCanEnterMultiplayer();
		/// <summary>
		/// unknown params
		/// p5 is reset to 0 if,
		/// Global_1315318 = 0 or Global_1315323 = 9 or 12 or (Global_1312629 = 0 && Global_1312631 = true/1) those are passed.
		/// </summary>
		/// <param name="p0">= 0, 2, or 999 (The global is 999 by default.)</param>
		/// <param name="p1">= 0 (Always in every script it's found in atleast.)</param>
		/// <param name="p2">= 0, 3, or 4 (Based on a var that is determined by a function.)</param>
		/// <param name="maxPlayers">= maxPlayers (It's obvious in x360 scripts it's always 18)</param>
		/// <param name="p4">= 0 (Always in every script it's found in atleast.)</param>
		/// <param name="p5">= 0 or 1. (1 if network_can_enter_multiplayer, but set to 0 if other checks after that are passed.)</param>
		int NetworkSessionEnter(int p0, int p1, int p2, int maxPlayers, int p4, int p5);
		bool NetworkSessionFriendMatchmaking(int p0, int p1, int maxPlayers, bool p3);
		bool NetworkSessionCrewMatchmaking(int p0, int p1, int p2, int maxPlayers, bool p4);
		bool NetworkSessionActivityQuickmatch(int p0, int p1, int p2, int p3);
		/// <summary>
		/// Does nothing in online but in offline it will cause the screen to fade to black. Nothing happens past then, the screen will sit at black until you restart GTA. Other stuff must be needed to actually host a session.
		/// </summary>
		bool NetworkSessionHost(int p0, int maxPlayers, bool p2);
		bool NetworkSessionHostClosed(int p0, int maxPlayers);
		/// <summary>
		/// Does nothing in online but in offline it will cause the screen to fade to black. Nothing happens past then, the screen will sit at black until you restart GTA. Other stuff must be needed to actually host a session.
		/// </summary>
		bool NetworkSessionHostFriendsOnly(int p0, int maxPlayers);
		bool NetworkSessionIsClosedFriends();
		bool NetworkSessionIsClosedCrew();
		bool NetworkSessionIsSolo();
		bool NetworkSessionIsPrivate();
		/// <summary>
		/// NETWORK_SESSION_END(0, 1)
		/// NETWORK_SESSION_END(0, 0)
		/// </summary>
		/// <param name="p0">is always false and p1 varies.</param>
		/// <returns>Results in: "Connection to session lost due to an unknown network error. Please return to Grand Theft Auto V and try again later."</returns>
		bool NetworkSessionEnd(bool p0, bool p1);
		int _0xB9351A07A0D458B1(int p0);
		/// <summary>
		/// Only works as host.
		/// </summary>
		void NetworkSessionKickPlayer(int player);
		bool NetworkSessionGetKickVote(int player);
		int _0x041C7F2A6C9894E6(int p0, int p1, int p2);
		bool NetworkJoinPreviouslyFailedSession();
		bool NetworkJoinPreviouslyFailedTransition();
		void NetworkSessionSetMatchmakingGroup(int matchmakingGroup);
		/// <summary>
		/// playerTypes:
		/// 0 = regular joiner
		/// 4 = spectator
		/// 8 = unknown
		/// </summary>
		void NetworkSessionSetMatchmakingGroupMax(int playerType, int playerCount);
		int NetworkSessionGetMatchmakingGroupFree(int p0);
		/// <summary>
		/// </summary>
		/// <param name="groupId">range: [0, 4]</param>
		void NetworkSessionAddActiveMatchmakingGroup(int groupId);
		void _0xF49ABC20D8552257(int p0);
		void _0x4811BBAC21C5FCD5(int p0);
		void _0x5539C3EBF104A53A(bool p0);
		void _0x702BC4D605522539(int p0);
		void NetworkSessionSetMatchmakingPropertyId(bool p0);
		void NetworkSessionSetMatchmakingMentalState(int p0);
		void _0x5ECD378EE64450AB(int p0);
		void _0x59D421683D31835A(int p0);
		void _0x1153FA02A659051C();
		void NetworkSessionValidateJoin(bool p0);
		/// <summary>
		/// ..
		/// </summary>
		void NetworkAddFollowers(ref int p0, int p1);
		void NetworkClearFollowers();
		/// <summary>
		/// </summary>
		void NetworkGetGlobalMultiplayerClock(ref int hours, ref int minutes, ref int seconds);
		void _0x600F8CB31C7AAB6E(int p0);
		int NetworkGetTargetingMode();
		bool NetworkFindGamersInCrew(int p0);
		bool NetworkFindMatchedGamers(int p0, float p1, float p2, float p3);
		bool NetworkIsFindingGamers();
		bool NetworkDidFindGamersSucceed();
		int NetworkGetNumFoundGamers();
		/// <summary>
		/// </summary>
		bool NetworkGetFoundGamer(ref int p0, int p1);
		void NetworkClearFoundGamers();
		/// <summary>
		/// </summary>
		bool NetworkQueueGamerForStatus(ref int p0);
		bool NetworkGetGamerStatusFromQueue();
		bool NetworkIsGettingGamerStatus();
		bool NetworkDidGetGamerStatusSucceed();
		/// <summary>
		/// </summary>
		bool NetworkGetGamerStatusResult(ref int p0, int p1);
		void NetworkClearGetGamerStatus();
		void NetworkSessionJoinInvite();
		void NetworkSessionCancelInvite();
		void NetworkSessionForceCancelInvite();
		bool NetworkHasPendingInvite();
		bool _0xC42DD763159F3461();
		/// <summary>
		/// NETWORK_RE*
		/// Triggers a CEventNetworkInviteConfirmed event
		/// </summary>
		bool NetworkAcceptInvite();
		bool NetworkSessionWasInvited();
		/// <summary>
		/// </summary>
		void NetworkSessionGetInviter(ref int gamerHandle);
		/// <summary>
		/// NETWORK_SESSION_IS_*
		/// </summary>
		bool _0xD313DE83394AF134();
		/// <summary>
		/// NETWORK_SESSION_IS_*
		/// </summary>
		bool _0xBDB6F89C729CF388();
		void NetworkSuppressInvite(bool toggle);
		void NetworkBlockInvites(bool toggle);
		void NetworkBlockJoinQueueInvites(bool toggle);
		void _0xF814FEC6A19FD6E0();
		void NetworkBlockKickedPlayers(bool p0);
		void NetworkSetScriptReadyForEvents(bool toggle);
		bool NetworkIsOfflineInvitePending();
		void NetworkClearOfflineInvitePending();
		/// <summary>
		/// Loads up the map that is loaded when beeing in mission creator
		/// Player gets placed in a mix between online/offline mode
		/// Appears to be patched in gtav b757 (game gets terminated) alonside with most other network natives to prevent online modding ~ghost30812
		/// </summary>
		/// <param name="p0">is always 2 in R* scripts.</param>
		void NetworkSessionHostSinglePlayer(int p0);
		void NetworkSessionLeaveSinglePlayer();
		bool NetworkIsGameInProgress();
		bool NetworkIsSessionActive();
		bool NetworkIsInSession();
		/// <summary>
		/// This checks if player is playing on gta online or not.
		/// Please add an if and block your mod if this is "true".
		/// </summary>
		bool NetworkIsSessionStarted();
		bool NetworkIsSessionBusy();
		bool NetworkCanSessionEnd();
		int _0x4C9034162368E206();
		void NetworkSessionMarkVisible(bool toggle);
		bool NetworkSessionIsVisible();
		void NetworkSessionBlockJoinRequests(bool toggle);
		void NetworkSessionChangeSlots(int p0, bool p1);
		int NetworkSessionGetPrivateSlots();
		void NetworkSessionVoiceHost();
		void NetworkSessionVoiceLeave();
		/// <summary>
		/// Only one occurence in the scripts:
		/// auto sub_cb43(auto a_0, auto a_1) {
		/// if (g_2594CB._f1) {
		/// if (NETWORK::_855BC38818F6F684()) {
		/// NETWORK::_ABD5E88B8A2D3DB2(&a_0._fB93);
		/// g_2594CB._f14{13} = a_0._fB93;
		/// g_2594CB._f4"64" = a_1;
		/// }
		/// }
		/// See NativeDB for reference: http://natives.altv.mp/#/0xABD5E88B8A2D3DB2
		/// </summary>
		/// <returns>            return 1;</returns>
		void NetworkSessionVoiceConnectToPlayer(ref int p0);
		void NetworkSessionVoiceRespondToRequest(bool p0, int p1);
		void NetworkSessionVoiceSetTimeout(int timeout);
		bool NetworkSessionIsInVoiceSession();
		int _0xB5D3453C98456528();
		bool NetworkSessionIsVoiceSessionBusy();
		/// <summary>
		/// </summary>
		/// <param name="message">is limited to 64 characters.</param>
		bool NetworkSendTextMessage(string message, ref int gamerHandle);
		void NetworkSetActivitySpectator(bool toggle);
		bool NetworkIsActivitySpectator();
		void _0x0E4F77F7B9D74D84(int p0);
		void NetworkSetActivitySpectatorMax(int maxSpectators);
		int NetworkGetActivityPlayerNum(bool p0);
		/// <summary>
		/// </summary>
		bool NetworkIsActivitySpectatorFromHandle(ref int gamerHandle);
		/// <summary>
		/// From what I can tell it looks like it does the following:
		/// Creates/hosts a new transition to another online session, using this in FiveM will result in other players being disconencted from the server/preventing them from joining. This is most likely because I entered the wrong session parameters since they're pretty much all unknown right now.
		/// You also need to use `NetworkJoinTransition(Player player)` and `NetworkLaunchTransition()`.
		/// </summary>
		/// <param name="p0">Unknown int</param>
		/// <param name="p1">Unknown int</param>
		/// <param name="p2">Unknown int</param>
		/// <param name="p3">Unknown int</param>
		/// <param name="p4">Unknown always 0 in decompiled scripts</param>
		/// <param name="p5">BOOL purpose unknown, both 0 and 1 are used in decompiled scripts.</param>
		/// <param name="p6">BOOL purpose unknown, both 0 and 1 are used in decompiled scripts.</param>
		/// <param name="p7">Unknown int, it's an int according to decompiled scripts, however the value is always 0 or 1.</param>
		/// <param name="p8">Unknown int, it's an int according to decompiled scripts, however the value is always 0 or 1.</param>
		/// <param name="p9">Unknown int, sometimes 0, but also 32768 or 16384 appear in decompiled scripst, maybe a flag of some sort?</param>
		bool NetworkHostTransition(int p0, int p1, int p2, int p3, int p4, bool p5, bool p6, int p7, int p8, int p9);
		bool NetworkDoTransitionQuickmatch(int p0, int p1, int p2, int p3, int p4, int p5);
		bool NetworkDoTransitionQuickmatchAsync(int p0, int p1, int p2, int p3, int p4, int p5);
		/// <summary>
		/// </summary>
		bool NetworkDoTransitionQuickmatchWithGroup(int p0, int p1, int p2, int p3, ref int p4, int p5, int p6, int p7);
		int NetworkJoinGroupActivity();
		void _0x1888694923EF4591();
		void _0xB13E88E655E5A3BC();
		bool NetworkIsTransitionClosedFriends();
		bool NetworkIsTransitionClosedCrew();
		bool NetworkIsTransitionSolo();
		bool NetworkIsTransitionPrivate();
		/// <summary>
		/// NETWORK_GET_NUM_*
		/// </summary>
		int _0x617F49C2668E6155();
		void _0x261E97AD7BCF3D40(bool p0);
		void _0x39917E1B4CB0F911(bool p0);
		void _0x2CE9D95E4051AECD(int p0);
		/// <summary>
		/// </summary>
		void NetworkSetTransitionCreatorHandle(ref int p0);
		void NetworkClearTransitionCreatorHandle();
		/// <summary>
		/// </summary>
		bool NetworkInviteGamersToTransition(ref int p0, int p1);
		/// <summary>
		/// </summary>
		void NetworkSetGamerInvitedToTransition(ref int gamerHandle);
		bool NetworkLeaveTransition();
		bool NetworkLaunchTransition();
		/// <summary>
		/// Appears to set whether a transition should be started when the session is migrating.
		/// NETWORK_SET_*
		/// </summary>
		void _0xA2E9C1AB8A92E8CD(bool toggle);
		void NetworkBailTransition(int p0, int p1, int p2);
		bool NetworkDoTransitionToGame(bool p0, int maxPlayers);
		bool NetworkDoTransitionToNewGame(bool p0, int maxPlayers, bool p2);
		/// <summary>
		/// 'players' is the number of players for a session. On PS3/360 it's always 18. On PC it's 32.
		/// </summary>
		/// <param name="p2">is true 3/4 of the occurrences I found.</param>
		bool NetworkDoTransitionToFreemode(ref int p0, int p1, bool p2, int players, bool p4);
		/// <summary>
		/// </summary>
		bool NetworkDoTransitionToNewFreemode(ref int p0, ref int p1, int players, bool p3, bool p4, bool p5);
		bool NetworkIsTransitionToGame();
		/// <summary>
		/// Returns count.
		/// </summary>
		int NetworkGetTransitionMembers(ref int data, int dataCount);
		void NetworkApplyTransitionParameter(int p0, int p1);
		void NetworkApplyTransitionParameterString(int p0, string @string, bool p2);
		/// <summary>
		/// the first arg seems to be the network player handle (&handle) and the second var is pretty much always "" and the third seems to be a number between 0 and ~10 and the 4th is is something like 0 to 5 and I guess the 5th is a bool cuz it is always 0 or 1
		/// does this send an invite to a player?
		/// </summary>
		bool NetworkSendTransitionGamerInstruction(ref int gamerHandle, string p1, int p2, int p3, bool p4);
		/// <summary>
		/// </summary>
		bool NetworkMarkTransitionGamerAsFullyJoined(ref int p0);
		bool NetworkIsTransitionHost();
		/// <summary>
		/// </summary>
		bool NetworkIsTransitionHostFromHandle(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkGetTransitionHost(ref int gamerHandle);
		bool NetworkIsInTransition();
		bool NetworkIsTransitionStarted();
		bool NetworkIsTransitionBusy();
		bool NetworkIsTransitionMatchmaking();
		/// <summary>
		/// NETWORK_IS_TRANSITION_*
		/// </summary>
		bool _0xC571D0E77D8BBC29();
		void _0x1398582B7F72B3ED(int p0);
		void _0x1F8E00FB18239600(int p0);
		void _0xF6F4383B7C92F11A(int p0);
		void NetworkOpenTransitionMatchmaking();
		void NetworkCloseTransitionMatchmaking();
		bool NetworkIsTransitionOpenToMatchmaking();
		void NetworkSetTransitionVisibilityLock(bool p0, bool p1);
		bool NetworkIsTransitionVisibilityLocked();
		void NetworkSetTransitionActivityId(int p0);
		void NetworkChangeTransitionSlots(int p0, int p1);
		void _0x973D76AA760A6CB6(bool p0);
		bool NetworkHasPlayerStartedTransition(int player);
		bool NetworkAreTransitionDetailsValid(int p0);
		/// <summary>
		/// int handle[76];
		/// NETWORK_HANDLE_FROM_FRIEND(iSelectedPlayer, &handle[0], 13);
		/// Player uVar2 = NETWORK_GET_PLAYER_FROM_GAMER_HANDLE(&handle[0]);
		/// NETWORK_JOIN_TRANSITION(uVar2);
		/// nothing doin.
		/// </summary>
		bool NetworkJoinTransition(int player);
		/// <summary>
		/// </summary>
		bool NetworkHasInvitedGamerToTransition(ref int p0);
		/// <summary>
		/// NETWORK_HAS_*
		/// </summary>
		bool _0x3F9990BF5F22759C(ref int p0);
		bool NetworkIsActivitySession();
		/// <summary>
		/// Does nothing. It's just a nullsub.
		/// </summary>
		void _0x4A9FDE3A5A6D0437(bool toggle);
		/// <summary>
		/// </summary>
		bool NetworkSendInviteViaPresence(ref int gamerHandle, ref int p1, int p2, int p3);
		/// <summary>
		/// String "NETWORK_SEND_PRESENCE_TRANSITION_INVITE" is contained in the function in ida so this one is correct.
		/// </summary>
		bool NetworkSendPresenceTransitionInvite(ref int p0, ref int p1, int p2, int p3);
		/// <summary>
		/// </summary>
		bool _0x1171A97A3D3981B6(ref int p0, ref int p1, int p2, int p3);
		int _0x742B58F723233ED9(int p0);
		int NetworkGetNumPresenceInvites();
		bool NetworkAcceptPresenceInvite(int p0);
		bool NetworkRemovePresenceInvite(int p0);
		int NetworkGetPresenceInviteId(int p0);
		int NetworkGetPresenceInviteInviter(int p0);
		/// <summary>
		/// </summary>
		bool NetworkGetPresenceInviteHandle(int p0, ref int p1);
		int NetworkGetPresenceInviteSessionId(int p0);
		int NetworkGetPresenceInviteContentId(int p0);
		int NetworkGetPresenceInvitePlaylistLength(int p0);
		int NetworkGetPresenceInvitePlaylistCurrent(int p0);
		bool NetworkGetPresenceInviteFromAdmin(int p0);
		bool NetworkGetPresenceInviteIsTournament(int p0);
		bool NetworkHasFollowInvite();
		int NetworkActionFollowInvite();
		int NetworkClearFollowInvite();
		void _0xEBF8284D8CADEB53();
		/// <summary>
		/// </summary>
		void NetworkRemoveTransitionInvite(ref int p0);
		void NetworkRemoveAllTransitionInvite();
		/// <summary>
		/// NETWORK_RE*
		/// </summary>
		void _0xF083835B70BA9BFE();
		/// <summary>
		/// </summary>
		bool NetworkInviteGamers(ref int p0, int p1, ref int p2, ref int p3);
		/// <summary>
		/// </summary>
		bool NetworkHasInvitedGamer(ref int p0);
		/// <summary>
		/// NETWORK_HAS_*
		/// </summary>
		bool _0x71DC455F5CD1C2B1(ref int gamerHandle);
		int _0x3855FB5EB2C5E8B2(int p0);
		/// <summary>
		/// </summary>
		bool NetworkGetCurrentlySelectedGamerHandleFromInviteMenu(ref int p0);
		/// <summary>
		/// </summary>
		bool NetworkSetCurrentlySelectedGamerHandleFromInviteMenu(ref int p0);
		/// <summary>
		/// </summary>
		void NetworkSetInviteOnCallForInviteMenu(ref int p0);
		/// <summary>
		/// </summary>
		bool NetworkCheckDataManagerSucceededForHandle(int p0, ref int p1);
		int _0x4AD490AE1536933B(int p0, int p1);
		/// <summary>
		/// NETWORK_SET_*
		/// </summary>
		void _0x0D77A82DC2D0DA59(ref int p0, ref int p1);
		/// <summary>
		/// </summary>
		bool FilloutPmPlayerList(ref int gamerHandle, int p1, int p2);
		/// <summary>
		/// </summary>
		bool FilloutPmPlayerListWithNames(ref int p0, ref int p1, int p2, int p3);
		bool RefreshPlayerListStats(int p0);
		/// <summary>
		/// </summary>
		bool NetworkSetCurrentDataManagerHandle(ref int p0);
		bool NetworkIsInPlatformParty();
		int NetworkGetPlatformPartyUnk();
		/// <summary>
		/// </summary>
		int NetworkGetPlatformPartyMembers(ref int data, int dataSize);
		bool NetworkIsInPlatformPartyChat();
		/// <summary>
		/// This would be nice to see if someone is in party chat, but 2 sad notes.
		/// 1) It only becomes true if said person is speaking in that party at the time.
		/// 2) It will never, become true unless you are in that party with said person.
		/// </summary>
		bool NetworkIsChattingInPlatformParty(ref int gamerHandle);
		int _0x2BF66D2E7414F686();
		/// <summary>
		/// NETWORK_IS_*
		/// </summary>
		bool _0x14922ED3E38761F0();
		void _0x6CE50E47F5543D0C();
		void _0xFA2888E3833C8E96();
		void _0x25D990F8E0E3F13C();
		void NetworkSeedRandomNumberGenerator(int seed);
		int NetworkGetRandomInt();
		/// <summary>
		/// Same as GET_RANDOM_INT_IN_RANGE
		/// </summary>
		int NetworkGetRandomIntRanged(int rangeStart, int rangeEnd);
		bool NetworkPlayerIsCheater();
		int NetworkPlayerGetCheaterReason();
		bool NetworkPlayerIsBadsport();
		/// <summary>
		/// </summary>
		/// <param name="p1">= 6</param>
		bool TriggerScriptCrcCheckOnPlayer(int player, int p1, int scriptHash);
		int _0xA12D3A5A3753CC23();
		int _0xF287F506767CC8A9();
		bool RemoteCheatDetected(int player, int a, int b);
		/// <summary>
		/// </summary>
		bool BadSportPlayerLeftDetected(ref int gamerHandle, int @event, int amountReceived);
		void NetworkApplyPedScarData(int ped, int p1);
		void NetworkSetThisScriptIsNetworkScript(int maxNumMissionParticipants, bool p1, int instanceId);
		bool NetworkIsThisScriptMarked(int p0, bool p1, int p2);
		bool NetworkGetThisScriptIsNetworkScript();
		/// <summary>
		/// for (num3 = 0; num3 < NETWORK::0xCCD8C02D(); num3++)
		/// {
		/// if (NETWORK::NETWORK_IS_PARTICIPANT_ACTIVE(PLAYER::0x98F3B274(num3)) != 0)
		/// {
		/// var num5 = NETWORK::NETWORK_GET_PLAYER_INDEX(PLAYER::0x98F3B274(num3));
		/// </summary>
		/// <returns>Seems to always return 0, but it's used in quite a few loops.</returns>
		int NetworkGetMaxNumParticipants();
		int NetworkGetNumParticipants();
		int NetworkGetScriptStatus();
		/// <summary>
		/// </summary>
		void NetworkRegisterHostBroadcastVariables(ref int unkVars, int numVars);
		/// <summary>
		/// </summary>
		void NetworkRegisterPlayerBroadcastVariables(ref int unkVars, int numVars);
		void _0xEA8C0DDB10E2822A(int p0, int p1);
		void _0xD6D7478CA62B8D41(int p0, int p1);
		void NetworkFinishBroadcastingData();
		bool NetworkHasReceivedHostBroadcastData();
		int NetworkGetPlayerIndex(int player);
		int NetworkGetParticipantIndex(int index);
		/// <summary>
		/// Returns the Player associated to a given Ped when in an online session.
		/// </summary>
		int NetworkGetPlayerIndexFromPed(int ped);
		/// <summary>
		/// Returns the amount of players connected in the current session. Only works when connected to a session/server.
		/// </summary>
		int NetworkGetNumConnectedPlayers();
		bool NetworkIsPlayerConnected(int player);
		int NetworkGetTotalNumPlayers();
		bool NetworkIsParticipantActive(int p0);
		bool NetworkIsPlayerActive(int player);
		bool NetworkIsPlayerAParticipant(int player);
		bool NetworkIsHostOfThisScript();
		int NetworkGetHostOfThisScript();
		/// <summary>
		/// "freemode", "AM_CR_SecurityVan", ...
		/// Most of the time, these values are used:
		/// </summary>
		/// <param name="scriptName">examples:</param>
		/// <param name="p1">= -1</param>
		/// <param name="p2">= 0</param>
		int NetworkGetHostOfScript(string scriptName, int p1, int p2);
		void NetworkSetMissionFinished();
		bool NetworkIsScriptActive(string scriptName, int player, bool p2, int p3);
		bool NetworkIsScriptActiveByHash(int scriptHash, int p1, bool p2, int p3);
		int _0x560B423D73015E77(int p0);
		/// <summary>
		/// </summary>
		int NetworkGetNumScriptParticipants(ref int p0, int p1, int p2);
		int NetworkGetInstanceIdOfThisScript();
		int NetworkGetPositionHashOfThisScript();
		bool NetworkIsPlayerAParticipantOnScript(int player1, string script, int player2);
		void _0x2302C0264EA58D31();
		/// <summary>
		/// Has something to do with a host request.
		/// NETWORK_RE*
		/// </summary>
		void _0x741A3D8380319A81();
		/// <summary>
		/// Return the local Participant ID
		/// </summary>
		int ParticipantId();
		/// <summary>
		/// Return the local Participant ID.
		/// This native is exactly the same as 'PARTICIPANT_ID' native.
		/// </summary>
		int ParticipantIdToInt();
		int _0x2DA41ED6E1FCD7A5(int p0, int p1);
		/// <summary>
		/// </summary>
		int NetworkGetDestroyerOfNetworkId(int netId, ref int weaponHash);
		int _0xC434133D9BA52777(int p0, int p1);
		int _0x83660B734994124D(int p0, int p1, int p2);
		/// <summary>
		/// </summary>
		bool NetworkGetDestroyerOfEntity(int p0, int p1, ref int weaponHash);
		/// <summary>
		/// </summary>
		int NetworkGetEntityKillerOfPlayer(int player, ref int weaponHash);
		void NetworkResurrectLocalPlayer(float x, float y, float z, float heading, bool unk, bool changetime, int p6);
		void NetworkSetLocalPlayerInvincibleTime(int time);
		bool NetworkIsLocalPlayerInvincible();
		void NetworkDisableInvincibleFlashing(int player, bool toggle);
		void NetworkPedForceGameStateUpdate(int ped);
		void NetworkSetLocalPlayerSyncLookAt(bool toggle);
		bool NetworkHasEntityBeenRegisteredWithThisThread(int entity);
		int NetworkGetNetworkIdFromEntity(int entity);
		int NetworkGetEntityFromNetworkId(int netId);
		bool NetworkGetEntityIsNetworked(int entity);
		bool NetworkGetEntityIsLocal(int entity);
		void NetworkRegisterEntityAsNetworked(int entity);
		void NetworkUnregisterNetworkedEntity(int entity);
		bool NetworkDoesNetworkIdExist(int netId);
		bool NetworkDoesEntityExistWithNetworkId(int netId);
		bool NetworkRequestControlOfNetworkId(int netId);
		bool NetworkHasControlOfNetworkId(int netId);
		/// <summary>
		/// Returns true if the specified network id is controlled by someone else.
		/// </summary>
		bool NetworkIsNetworkIdAClone(int netId);
		bool NetworkRequestControlOfEntity(int entity);
		bool NetworkRequestControlOfDoor(int doorID);
		bool NetworkHasControlOfEntity(int entity);
		bool NetworkHasControlOfPickup(int pickup);
		bool NetworkHasControlOfDoor(int doorHash);
		bool NetworkIsDoorNetworked(int doorHash);
		/// <summary>
		/// calls from vehicle to net.
		/// </summary>
		int VehToNet(int vehicle);
		/// <summary>
		/// gets the network id of a ped
		/// </summary>
		int PedToNet(int ped);
		/// <summary>
		/// Lets objects spawn online simply do it like this:
		/// int createdObject = OBJ_TO_NET(CREATE_OBJECT_NO_OFFSET(oball, pCoords.x, pCoords.y, pCoords.z, 1, 0, 0));
		/// </summary>
		int ObjToNet(int @object);
		int NetToVeh(int netHandle);
		/// <summary>
		/// gets the ped id of a network id
		/// </summary>
		int NetToPed(int netHandle);
		/// <summary>
		/// gets the object id of a network id
		/// </summary>
		int NetToObj(int netHandle);
		/// <summary>
		/// gets the entity id of a network id
		/// </summary>
		int NetToEnt(int netHandle);
		/// <summary>
		/// </summary>
		void NetworkGetLocalHandle(ref int gamerHandle, int gamerHandleSize);
		/// <summary>
		/// </summary>
		void NetworkHandleFromUserId(string userId, ref int gamerHandle, int gamerHandleSize);
		/// <summary>
		/// </summary>
		void NetworkHandleFromMemberId(string memberId, ref int gamerHandle, int gamerHandleSize);
		/// <summary>
		/// </summary>
		void NetworkHandleFromPlayer(int player, ref int gamerHandle, int gamerHandleSize);
		int NetworkHashFromPlayerHandle(int player);
		/// <summary>
		/// </summary>
		int NetworkHashFromGamerHandle(ref int gamerHandle);
		/// <summary>
		/// </summary>
		void NetworkHandleFromFriend(int friendIndex, ref int gamerHandle, int gamerHandleSize);
		/// <summary>
		/// </summary>
		bool NetworkGamertagFromHandleStart(ref int gamerHandle);
		bool NetworkGamertagFromHandlePending();
		bool NetworkGamertagFromHandleSucceeded();
		/// <summary>
		/// </summary>
		string NetworkGetGamertagFromHandle(ref int gamerHandle);
		/// <summary>
		/// </summary>
		/// <returns>Hardcoded to return -1.</returns>
		int NetworkDisplaynamesFromHandlesStart(ref int p0, int p1);
		/// <summary>
		/// </summary>
		/// <returns>MulleDK19: This function is hard-coded to always return 0.</returns>
		int NetworkGetDisplaynamesFromHandles(int p0, int p1, int p2);
		/// <summary>
		/// </summary>
		bool NetworkAreHandlesTheSame(ref int gamerHandle1, ref int gamerHandle2);
		/// <summary>
		/// </summary>
		bool NetworkIsHandleValid(ref int gamerHandle, int gamerHandleSize);
		/// <summary>
		/// </summary>
		int NetworkGetPlayerFromGamerHandle(ref int gamerHandle);
		/// <summary>
		/// </summary>
		string NetworkMemberIdFromGamerHandle(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkIsGamerInMySession(ref int gamerHandle);
		/// <summary>
		/// </summary>
		void NetworkShowProfileUi(ref int gamerHandle);
		/// <summary>
		/// </summary>
		/// <returns>Returns the name of a given player. Returns "**Invalid**" if rlGamerInfo of the given player cannot be retrieved or the player doesn't exist.</returns>
		string NetworkPlayerGetName(int player);
		/// <summary>
		/// Returns a string of the player's Rockstar Id.
		/// </summary>
		/// <returns>Takes a 24 char buffer. Returns the buffer or "**Invalid**" if rlGamerInfo of the given player cannot be retrieved or the player doesn't exist.</returns>
		string NetworkPlayerGetUserid(int player, ref int userID);
		/// <summary>
		/// Checks if a specific value (BYTE) in CNetGamePlayer is nonzero.
		/// Returns always false in Singleplayer.
		/// No longer used for dev checks since first mods were released on PS3 & 360.
		/// R* now checks with the IS_DLC_PRESENT native for the dlc hash 2532323046,
		/// if that is present it will unlock dev stuff.
		/// </summary>
		bool NetworkPlayerIsRockstarDev(int player);
		bool NetworkPlayerIndexIsCheater(int player);
		int NetworkGetEntityNetScriptId(int entity);
		/// <summary>
		/// Whatever p0 is, it's at least not synced to other players.
		/// At least not all the time, some p0 values actually output the same entity, (different handle of course, but same entity).
		/// But another p0 value may return an entity for player x, but not for player y (it'll just return -1 even if the entity exists on both clients).
		/// Returns an entity handle or -1, value changes based on p0's value.
		/// </summary>
		/// <returns>I've had this return the player's ped handle sometimes, but also other random entities.</returns>
		int _0x37D5F739FD494675(int p0);
		/// <summary>
		/// </summary>
		bool NetworkIsInactiveProfile(ref int p0);
		int NetworkGetMaxFriends();
		int NetworkGetFriendCount();
		string NetworkGetFriendName(int friendIndex);
		string NetworkGetFriendNameFromIndex(int friendIndex);
		bool NetworkIsFriendOnline(string name);
		/// <summary>
		/// </summary>
		bool NetworkIsFriendHandleOnline(ref int gamerHandle);
		/// <summary>
		/// In scripts R* calls 'NETWORK_GET_FRIEND_NAME' in this param.
		/// </summary>
		bool NetworkIsFriendInSameTitle(string friendName);
		bool NetworkIsFriendInMultiplayer(string friendName);
		/// <summary>
		/// </summary>
		bool NetworkIsFriend(ref int gamerHandle);
		/// <summary>
		/// </summary>
		/// <returns>This function is hard-coded to always return 0.</returns>
		int NetworkIsPendingFriend(int p0);
		int NetworkIsAddingFriend();
		/// <summary>
		/// </summary>
		bool NetworkAddFriend(ref int gamerHandle, string message);
		bool NetworkIsFriendIndexOnline(int friendIndex);
		void NetworkSetPlayerIsPassive(bool toggle);
		bool NetworkGetPlayerOwnsWaypoint(int player);
		bool NetworkCanSetWaypoint();
		void _0x4C2A9FDC22377075();
		int _0xB309EBEA797E001F(int p0);
		int _0x26F07DD83A5F7F98();
		bool NetworkHasHeadset();
		void _0x7D395EA61622E116(bool p0);
		bool NetworkIsLocalTalking();
		/// <summary>
		/// </summary>
		bool NetworkGamerHasHeadset(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkIsGamerTalking(ref int gamerHandle);
		/// <summary>
		/// Same as NETWORK_CAN_COMMUNICATE_WITH_GAMER
		/// NETWORK_CAN_*
		/// </summary>
		bool NetworkCanCommunicateWithGamer2(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkCanCommunicateWithGamer(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkIsGamerMutedByMe(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkAmIMutedByGamer(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkIsGamerBlockedByMe(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkAmIBlockedByGamer(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkCanViewGamerUserContent(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkHasViewGamerUserContentResult(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkCanPlayMultiplayerWithGamer(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkCanGamerPlayMultiplayerWithMe(ref int gamerHandle);
		/// <summary>
		/// returns true if someone is screaming or talking in a microphone
		/// </summary>
		bool NetworkIsPlayerTalking(int player);
		bool NetworkPlayerHasHeadset(int player);
		bool NetworkIsPlayerMutedByMe(int player);
		bool NetworkAmIMutedByPlayer(int player);
		bool NetworkIsPlayerBlockedByMe(int player);
		bool NetworkAmIBlockedByPlayer(int player);
		float NetworkGetPlayerLoudness(int player);
		void NetworkSetTalkerProximity(float value);
		float NetworkGetTalkerProximity();
		void NetworkSetVoiceActive(bool toggle);
		void _0xCFEB46DCD7D8D5EB(bool p0);
		void NetworkOverrideTransitionChat(bool p0);
		void NetworkSetTeamOnlyChat(bool toggle);
		void _0x265559DA40B3F327(int p0);
		int _0x4348BFDA56023A2F(int p0, int p1);
		void NetworkOverrideTeamRestrictions(int team, bool toggle);
		void NetworkSetOverrideSpectatorMode(bool toggle);
		/// <summary>
		/// Sets some voice chat related value.
		/// NETWORK_SET_*
		/// </summary>
		void _0x3C5C1E2C2FF814B1(bool toggle);
		/// <summary>
		/// Sets some voice chat related value.
		/// NETWORK_SET_*
		/// </summary>
		void _0x9D7AFCBF21C51712(bool toggle);
		void NetworkSetNoSpectatorChat(bool toggle);
		/// <summary>
		/// Sets some voice chat related value.
		/// NETWORK_SET_*
		/// </summary>
		void _0x6A5D89D7769A40D8(bool toggle);
		/// <summary>
		/// Could possibly bypass being muted or automatically muted
		/// </summary>
		void NetworkOverrideChatRestrictions(int player, bool toggle);
		/// <summary>
		/// This is used alongside the native,
		/// 'NETWORK_OVERRIDE_RECEIVE_RESTRICTIONS'. Read its description for more info.
		/// </summary>
		void NetworkOverrideSendRestrictions(int player, bool toggle);
		void NetworkOverrideSendRestrictionsAll(bool toggle);
		/// <summary>
		/// R* uses this to hear all player when spectating.
		/// It allows you to hear other online players when their chat is on none, crew and or friends
		/// </summary>
		void NetworkOverrideReceiveRestrictions(int player, bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="toggle">is always false in scripts.</param>
		void NetworkOverrideReceiveRestrictionsAll(bool toggle);
		void NetworkSetVoiceChannel(int channel);
		void NetworkClearVoiceChannel();
		void NetworkApplyVoiceProximityOverride(float x, float y, float z);
		void NetworkClearVoiceProximityOverride();
		void _0x5E3AA4CA2B6FB0EE(int p0);
		void _0xCA575C391FEA25CC(int p0);
		/// <summary>
		/// </summary>
		void _0xADB57E5B663CCA8B(int p0, ref float p1, ref float p2);
		/// <summary>
		/// NETWORK_SET_*
		/// </summary>
		void _0x8EF52ACAECC51D9C(bool toggle);
		/// <summary>
		/// Same as _IS_TEXT_CHAT_ACTIVE, except it does not check if the text chat HUD component is initialized, and therefore may crash.
		/// </summary>
		bool NetworkIsTextChatActive();
		/// <summary>
		/// Starts a new singleplayer game (at the prologue).
		/// </summary>
		void ShutdownAndLaunchSinglePlayerGame();
		/// <summary>
		/// In singleplayer this will re-load your game.
		/// In FiveM / GTA:Online this disconnects you from the session, and starts loading single player, however you still remain connected to the server (only if you're the host, if you're not then you also (most likely) get disconnected from the server) and other players will not be able to join until you exit the game.
		/// You might need to DoScreenFadeIn and ShutdownLoadingScreen otherwise you probably won't end up loading into SP at all.
		/// Somewhat related note: opening the pause menu after loading into this 'singleplayer' mode crashes the game.
		/// </summary>
		bool ShutdownAndLoadMostRecentSave();
		void NetworkSetFriendlyFireOption(bool toggle);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void NetworkSetRichPresence(int p0, int p1, int p2, int p3);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void NetworkSetRichPresenceString(int p0, string textLabel);
		int NetworkGetTimeoutTime();
		/// <summary>
		/// </summary>
		/// <param name="p4">and p5 are always 0 in scripts</param>
		void NetworkLeavePedBehindBeforeWarp(int player, float x, float y, float z, bool p4, bool p5);
		void NetworkLeavePedBehindBeforeCutscene(int player, bool p1);
		/// <summary>
		/// </summary>
		/// <param name="entity">must be a valid entity; ped can be NULL</param>
		void RemoveAllStickyBombsFromEntity(int entity, int ped);
		void _0x17C9E241111A674D(int p0, int p1);
		int _0x2E4C123D1C8A710E(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		bool NetworkClanServiceIsValid();
		/// <summary>
		/// </summary>
		bool NetworkClanPlayerIsActive(ref int gamerHandle);
		/// <summary>
		/// bufferSize is the elementCount of p0(desc), sizeof(p0) == 280 == p1*8 == 35 * 8, p2(netHandle) is obtained from NETWORK::NETWORK_HANDLE_FROM_PLAYER.  And no, I can't explain why 35 * sizeof(int) == 280 and not 140, but I'll get back to you on that.
		/// the answer is: because p0 an int64_t* / int64_t[35].  and FYI p2 is an int64_t[13]
		/// pastebin.com/cSZniHak
		/// </summary>
		/// <param name="bufferSize">is 35 in the scripts.</param>
		bool NetworkClanPlayerGetDesc(ref int clanDesc, int bufferSize, ref int gamerHandle);
		/// <summary>
		/// </summary>
		/// <param name="bufferSize">is 35 in the scripts.</param>
		bool NetworkClanIsRockstarClan(ref int clanDesc, int bufferSize);
		/// <summary>
		/// </summary>
		/// <param name="bufferSize">is 35 in the scripts.</param>
		void NetworkClanGetUiFormattedTag(ref int clanDesc, int bufferSize, ref string formattedTag);
		int NetworkClanGetLocalMembershipsCount();
		/// <summary>
		/// </summary>
		bool NetworkClanGetMembershipDesc(ref int memberDesc, int p1);
		/// <summary>
		/// </summary>
		bool NetworkClanDownloadMembership(ref int gamerHandle);
		/// <summary>
		/// </summary>
		bool NetworkClanDownloadMembershipPending(ref int p0);
		bool NetworkClanAnyDownloadMembershipPending();
		/// <summary>
		/// </summary>
		bool NetworkClanRemoteMembershipsAreInCache(ref int p0);
		/// <summary>
		/// </summary>
		int NetworkClanGetMembershipCount(ref int p0);
		/// <summary>
		/// </summary>
		bool NetworkClanGetMembershipValid(ref int p0, int p1);
		/// <summary>
		/// </summary>
		bool NetworkClanGetMembership(ref int p0, ref int clanMembership, int p2);
		bool NetworkClanJoin(int clanDesc);
		/// <summary>
		/// Only documented...
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		bool NetworkClanAnimation(string animDict, string animName);
		bool _0x2B51EDBEFC301339(int p0, string p1);
		int _0xC32EA7A2F6CA7557();
		/// <summary>
		/// </summary>
		bool NetworkClanGetEmblemTxdName(ref int netHandle, ref string txdName);
		bool NetworkClanRequestEmblem(int p0);
		/// <summary>
		/// </summary>
		bool NetworkClanIsEmblemReady(int p0, ref int p1);
		void NetworkClanReleaseEmblem(int p0);
		int NetworkGetPrimaryClanDataClear();
		void NetworkGetPrimaryClanDataCancel();
		/// <summary>
		/// </summary>
		bool NetworkGetPrimaryClanDataStart(ref int p0, int p1);
		int NetworkGetPrimaryClanDataPending();
		int NetworkGetPrimaryClanDataSuccess();
		/// <summary>
		/// </summary>
		bool NetworkGetPrimaryClanDataNew(ref int p0, ref int p1);
		/// <summary>
		/// Whether or not another player is allowed to take control of the entity
		/// </summary>
		void SetNetworkIdCanMigrate(int netId, bool toggle);
		void SetNetworkIdExistsOnAllMachines(int netId, bool toggle);
		void SetNetworkIdAlwaysExistsForPlayer(int netId, int player, bool toggle);
		void _0x9D724B400A7E8FFC(int p0, int p1);
		void NetworkSetEntityCanBlend(int entity, bool toggle);
		void _0x0379DAF89BA09AA5(int p0, int p1);
		/// <summary>
		/// if set to true other network players can't see it
		/// if set to false other network player can see it
		/// =========================================
		/// ^^ I attempted this by grabbing an object with GET_ENTITY_PLAYER_IS_FREE_AIMING_AT and setting this naive no matter the toggle he could still see it.
		/// pc or last gen?
		/// ^^ last-gen
		/// </summary>
		void NetworkSetEntityInvisibleToNetwork(int entity, bool toggle);
		void SetNetworkIdVisibleInCutscene(int netId, bool p1, bool p2);
		void _0x32EBD154CB6B8B99(int p0, int p1, int p2);
		void _0x76B3F29D3F967692(int p0, int p1);
		void SetNetworkCutsceneEntities(bool toggle);
		void _0x3FA36981311FA4FF(int netId, bool state);
		bool IsNetworkIdOwnedByParticipant(int netId);
		void SetLocalPlayerVisibleInCutscene(bool p0, bool p1);
		void SetLocalPlayerInvisibleLocally(bool p0);
		void SetLocalPlayerVisibleLocally(bool p0);
		void SetPlayerInvisibleLocally(int player, bool toggle);
		void SetPlayerVisibleLocally(int player, bool toggle);
		/// <summary>
		/// Hardcoded to not work in SP.
		/// </summary>
		void FadeOutLocalPlayer(bool p0);
		/// <summary>
		/// </summary>
		/// <param name="normal">- transition like when your coming out of LSC</param>
		/// <param name="slow">- transition like when you walk into a mission</param>
		void NetworkFadeOutEntity(int entity, bool normal, bool slow);
		/// <summary>
		/// state - 1 does 6 fades
		/// p3: setting to 1 made vehicle fade in slower, probably "slow" as per NETWORK_FADE_OUT_ENTITY
		/// </summary>
		/// <param name="state">- 0 does 5 fades</param>
		void NetworkFadeInEntity(int entity, bool state, int p2);
		bool NetworkIsPlayerFading(int player);
		bool NetworkIsEntityFading(int entity);
		bool IsPlayerInCutscene(int player);
		void SetEntityVisibleInCutscene(int p0, bool p1, bool p2);
		/// <summary>
		/// Makes the provided entity visible for yourself for the current frame.
		/// </summary>
		void SetEntityLocallyInvisible(int entity);
		void SetEntityLocallyVisible(int entity);
		bool IsDamageTrackerActiveOnNetworkId(int netID);
		void ActivateDamageTrackerOnNetworkId(int netID, bool toggle);
		bool IsDamageTrackerActiveOnPlayer(int player);
		void ActivateDamageTrackerOnPlayer(int player, bool toggle);
		bool IsSphereVisibleToAnotherMachine(float p0, float p1, float p2, float p3);
		bool IsSphereVisibleToPlayer(int p0, float p1, float p2, float p3, float p4);
		void ReserveNetworkMissionObjects(int amount);
		void ReserveNetworkMissionPeds(int amount);
		void ReserveNetworkMissionVehicles(int amount);
		void ReserveNetworkLocalObjects(int amount);
		void ReserveNetworkLocalPeds(int amount);
		void ReserveNetworkLocalVehicles(int amount);
		bool CanRegisterMissionObjects(int amount);
		bool CanRegisterMissionPeds(int amount);
		bool CanRegisterMissionVehicles(int amount);
		bool CanRegisterMissionPickups(int amount);
		int _0xE16AA70CE9BEEDC3(int p0);
		bool CanRegisterMissionEntities(int ped_amt, int vehicle_amt, int object_amt, int pickup_amt);
		/// <summary>
		/// </summary>
		/// <param name="p0">appears to be for MP</param>
		int GetNumReservedMissionObjects(bool p0, int p1);
		/// <summary>
		/// </summary>
		/// <param name="p0">appears to be for MP</param>
		int GetNumReservedMissionPeds(bool p0, int p1);
		/// <summary>
		/// </summary>
		/// <param name="p0">appears to be for MP</param>
		int GetNumReservedMissionVehicles(bool p0, int p1);
		int GetNumCreatedMissionObjects(bool p0);
		int GetNumCreatedMissionPeds(bool p0);
		int GetNumCreatedMissionVehicles(bool p0);
		void _0xE42D626EEC94E5D9(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		int GetMaxNumNetworkObjects();
		int GetMaxNumNetworkPeds();
		int GetMaxNumNetworkVehicles();
		int GetMaxNumNetworkPickups();
		void _0xBA7F0B77D80A4EB7(int p0, int p1);
		void _0x0F1A4B45B7693B95(int p0, int p1);
		int GetNetworkTime();
		/// <summary>
		/// Returns the same value as GET_NETWORK_TIME in freemode, but as opposed to `GET_NETWORK_TIME` it always gets the most recent time, instead of once per tick.
		/// </summary>
		/// <returns>Could be used for benchmarking since it can return times in ticks.</returns>
		int GetNetworkTimeAccurate();
		bool HasNetworkTimeStarted();
		/// <summary>
		/// Adds the first argument to the second.
		/// </summary>
		int GetTimeOffset(int timeA, int timeB);
		/// <summary>
		/// </summary>
		/// <returns>Subtracts the second argument from the first, then returns whether the result is negative.</returns>
		bool IsTimeLessThan(int timeA, int timeB);
		/// <summary>
		/// </summary>
		/// <returns>Subtracts the first argument from the second, then returns whether the result is negative.</returns>
		bool IsTimeMoreThan(int timeA, int timeB);
		/// <summary>
		/// </summary>
		/// <returns>Returns true if the two times are equal; otherwise returns false.</returns>
		bool IsTimeEqualTo(int timeA, int timeB);
		/// <summary>
		/// Subtracts the second argument from the first.
		/// </summary>
		int GetTimeDifference(int timeA, int timeB);
		string GetTimeAsString(int time);
		string GetCloudTimeAsString();
		/// <summary>
		/// Returns POSIX timestamp, an int representing the cloud time.
		/// </summary>
		int GetCloudTimeAsInt();
		/// <summary>
		/// Takes the specified time and writes it to the structure specified in the second argument.
		/// struct date_time
		/// {
		/// int year;
		/// int PADDING1;
		/// int month;
		/// int PADDING2;
		/// int day;
		/// int PADDING3;
		/// See NativeDB for reference: http://natives.altv.mp/#/0xAC97AF97FA68E5D5
		/// </summary>
		void ConvertPosixTime(int posixTime, ref int timeStructure);
		void NetworkSetInSpectatorMode(bool toggle, int playerPed);
		void NetworkSetInSpectatorModeExtended(bool toggle, int playerPed, bool p2);
		void NetworkSetInFreeCamMode(bool toggle);
		void NetworkSetChoiceMigrateOptions(bool toggle, int player);
		bool NetworkIsInSpectatorMode();
		void NetworkSetInMpCutscene(bool p0, bool p1);
		bool NetworkIsInMpCutscene();
		bool NetworkIsPlayerInMpCutscene(int player);
		void _0xFAC18E7356BD3210();
		void SetNetworkVehicleRespotTimer(int netId, int time, int p2, int p3);
		void SetNetworkVehicleAsGhost(int vehicle, bool toggle);
		/// <summary>
		/// rage::netBlenderLinInterp::GetPositionMaxForUpdateLevel
		/// </summary>
		void SetNetworkVehiclePositionUpdateMultiplier(int vehicle, float multiplier);
		/// <summary>
		/// Enables a periodic ShapeTest within the NetBlender and invokes rage::netBlenderLinInterp::GoStraightToTarget (or some functional wrapper).
		/// </summary>
		void SetNetworkEnableVehiclePositionCorrection(int vehicle, bool toggle);
		void SetLocalPlayerAsGhost(bool toggle, bool p1);
		bool IsEntityGhostedToLocalPlayer(int entity);
		/// <summary>
		/// SET_NETWORK_*
		/// </summary>
		void _0x13F1FCB111B820B0(bool p0);
		/// <summary>
		/// Enables ghosting between specific players
		/// </summary>
		void SetRelationshipToPlayer(int player, bool p1);
		/// <summary>
		/// Must be a value between 1 and 254
		/// </summary>
		void SetGhostedEntityAlpha(int alpha);
		/// <summary>
		/// Resets the entity ghost alpha to the default value (128)
		/// </summary>
		void ResetGhostedEntityAlpha();
		void NetworkSetEntityGhostedWithOwner(int entity, bool p1);
		void _0xD7B6C73CAD419BCF(bool p0);
		/// <summary>
		/// IS_*
		/// </summary>
		bool _0x7EF7649B64D7FF10(int entity);
		void UsePlayerColourInsteadOfTeamColour(bool toggle);
		int NetworkCreateSynchronisedScene(float x, float y, float z, float xRot, float yRot, float zRot, int rotationOrder, bool useOcclusionPortal, bool looped, float p9, float animTime, float p11);
		void NetworkAddPedToSynchronisedScene(int ped, int netScene, string animDict, string animnName, float speed, float speedMultiplier, int duration, int flag, float playbackRate, int p9);
		void _0xA5EAFE473E45C442(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9);
		void NetworkAddEntityToSynchronisedScene(int entity, int netScene, string animDict, string animName, float speed, float speedMulitiplier, int flag);
		/// <summary>
		/// NETWORK_A*
		/// Similar structure as NETWORK_ADD_ENTITY_TO_SYNCHRONISED_SCENE but it includes this time a hash.
		/// In casino_slots it is used one time in a synced scene involving a ped and the slot machine?
		/// </summary>
		void _0x45F35C0EDC33B03B(int netScene, int modelHash, float x, float y, float z, float p5, string p6, float p7, float p8, int flags);
		void NetworkAddSynchronisedSceneCamera(int netScene, string animDict, string animName);
		void NetworkAttachSynchronisedSceneToEntity(int netScene, int entity, int bone);
		void NetworkStartSynchronisedScene(int netScene);
		void NetworkStopSynchronisedScene(int netScene);
		int NetworkGetLocalSceneFromNetworkId(int netId);
		void _0xC9B43A33D09CADA7(int p0);
		void _0x144DA052257AE7D8(int p0);
		/// <summary>
		/// </summary>
		/// <param name="p0">is always 0. p1 is pointing to a global.</param>
		int _0xFB1F9381E80FA13F(int p0, int p1);
		/// <summary>
		/// One of the first things it does is get the players ped.
		/// Then it calls a function that is used in some tasks and ped based functions.
		/// p5, p6, p7 is another coordinate (or zero), often related to `GET_BLIP_COORDS, in the decompiled scripts.
		/// </summary>
		bool NetworkStartRespawnSearchForPlayer(int player, float x, float y, float z, float radius, float p5, float p6, float p7, int flags);
		/// <summary>
		/// p8, p9, p10 is another coordinate, or zero, often related to `GET_BLIP_COORDS in the decompiled scripts.
		/// </summary>
		bool NetworkStartRespawnSearchInAngledAreaForPlayer(int player, float x1, float y1, float z1, float x2, float y2, float z2, float width, float p8, float p9, float p10, int flags);
		/// <summary>
		/// </summary>
		int NetworkQueryRespawnResults(ref int p0);
		void NetworkCancelRespawnSearch();
		/// <summary>
		/// Based on scripts such as in freemode.c how they call their vars vVar and fVar the 2nd and 3rd param it a Vector3 and Float, but the first is based on get_random_int_in_range..
		/// </summary>
		void NetworkGetRespawnResult(int randomInt, ref Vector3 coordinates, ref float heading);
		int NetworkGetRespawnResultFlags(int p0);
		/// <summary>
		/// *
		/// </summary>
		void NetworkStartSoloTutorialSession();
		/// <summary>
		/// NETWORK_A*
		/// </summary>
		/// <param name="teamId">must be < 3, instanceId must be < 64</param>
		void _0xFB680D403909DC70(int teamId, int instanceId);
		void NetworkEndTutorialSession();
		bool NetworkIsInTutorialSession();
		bool _0xB37E4E6A2388CA7B();
		bool NetworkIsTutorialSessionChangePending();
		int NetworkGetPlayerTutorialSessionInstance(int player);
		/// <summary>
		/// NETWORK_ARE_*
		/// </summary>
		bool NetworkIsPlayerEqualToIndex(int player, int index);
		void NetworkConcealPlayer(int player, bool toggle, bool p2);
		bool NetworkIsPlayerConcealed(int player);
		void NetworkConcealEntity(int entity, bool toggle);
		/// <summary>
		/// Note: This only works for vehicles, which appears to be a bug (since the setter _does_ work for every entity type and the name is 99% correct).
		/// </summary>
		bool NetworkIsEntityConcealed(int entity);
		/// <summary>
		/// Works in Singleplayer too.
		/// Passing wrong data (e.g. hours above 23) will cause the game to crash.
		/// </summary>
		void NetworkOverrideClockTime(int hours, int minutes, int seconds);
		void NetworkOverrideClockMillisecondsPerGameMinute(int ms);
		void NetworkClearClockTimeOverride();
		bool NetworkIsClockTimeOverridden();
		int NetworkAddEntityArea(float p0, float p1, float p2, float p3, float p4, float p5);
		/// <summary>
		/// To remove, see: NETWORK_REMOVE_ENTITY_AREA
		/// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
		/// </summary>
		int NetworkAddEntityAngledArea(float x1, float y1, float z1, float x2, float y2, float z2, float width);
		int NetworkAddEntityDisplayedBoundaries(float p0, float p1, float p2, float p3, float p4, float p5);
		int _0x2B1C623823DB0D9D(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		bool NetworkRemoveEntityArea(int p0);
		bool NetworkEntityAreaDoesExist(int areaHandle);
		bool _0x4DF7CFFF471A7FB1(int p0);
		bool NetworkEntityAreaIsOccupied(int areaHandle);
		void NetworkUseHighPrecisionBlending(int netID, bool toggle);
		void _0xA6FCECCF4721D679(int p0);
		void _0x95BAF97C82464629(int p0, int p1);
		bool NetworkRequestCloudBackgroundScripts();
		bool NetworkIsCloudBackgroundScriptRequestPending();
		void NetworkRequestCloudTunables();
		bool NetworkIsTunableCloudRequestPending();
		int NetworkGetTunableCloudCrc();
		bool NetworkDoesTunableExist(string tunableContext, string tunableName);
		/// <summary>
		/// </summary>
		bool NetworkAccessTunableInt(string tunableContext, string tunableName, ref int value);
		/// <summary>
		/// </summary>
		bool NetworkAccessTunableFloat(string tunableContext, string tunableName, ref float value);
		bool NetworkAccessTunableBool(string tunableContext, string tunableName);
		bool NetworkDoesTunableExistHash(int tunableContext, int tunableName);
		bool NetworkAllocateTunablesRegistrationDataMap();
		/// <summary>
		/// </summary>
		bool NetworkAccessTunableIntHash(int tunableContext, int tunableName, ref int value);
		/// <summary>
		/// </summary>
		bool NetworkRegisterTunableIntHash(int contextHash, int nameHash, ref int value);
		/// <summary>
		/// </summary>
		bool NetworkAccessTunableFloatHash(int tunableContext, int tunableName, ref float value);
		/// <summary>
		/// </summary>
		bool NetworkRegisterTunableFloatHash(int contextHash, int nameHash, ref float value);
		bool NetworkAccessTunableBoolHash(int tunableContext, int tunableName);
		/// <summary>
		/// </summary>
		bool NetworkRegisterTunableBoolHash(int contextHash, int nameHash, ref bool value);
		/// <summary>
		/// Returns defaultValue if the tunable doesn't exist.
		/// </summary>
		bool NetworkTryAccessTunableBoolHash(int tunableContext, int tunableName, bool defaultValue);
		/// <summary>
		/// Return the content modifier id (the tunables context if you want) of a specific content.
		/// The mission id can be found on the Social club, for example, 'socialclub.rockstargames.com/games/gtav/jobs/job/A8M6Bz8MLEC5xngvDCzGwA'
		/// 'A8M6Bz8MLEC5xngvDCzGwA' is the mission id, so the game hash this and use it as the parameter for this native.
		/// </summary>
		/// <returns>It takes the content hash (which is the mission id hash), and return the content modifier id, used as the tunables context.</returns>
		int NetworkGetContentModifierListId(int contentHash);
		int _0x7DB53B37A2F211A0();
		void NetworkResetBodyTracker();
		int NetworkGetNumBodyTrackers();
		bool _0x2E0BF682CC778D49(int p0);
		bool _0x0EDE326D47CD0F3E(int ped, int player);
		/// <summary>
		/// Allows vehicle wheels to be destructible even when the vehicle entity is invincible.
		/// </summary>
		void NetworkSetVehicleWheelsDestructible(int entity, bool toggle);
		void _0x38B7C51AB1EDC7D8(int entity, bool toggle);
		/// <summary>
		/// nullsub, doesn't do anything
		/// </summary>
		void _0x3FC795691834481D(int p0, int p1);
		/// <summary>
		/// In the console script dumps, this is only referenced once.
		/// ^^^^^ That must be PC script dumps? In X360 Script Dumps it is reference a few times with 2 differences in the parameters.
		/// Which as you see below is 1, 0, 0 + 1, 1, 0 + 1, 0, and a *param?
		/// am_plane_takedown.c
		/// network_explode_vehicle(net_to_veh(Local_40.imm_2), 1, 1, 0);
		/// armenian2.c
		/// network_explode_vehicle(Local_80[6 <2>], 1, 0, 0);
		/// fm_horde_controler.c
		/// network_explode_vehicle(net_to_veh(*uParam0), 1, 0, *uParam0);
		/// See NativeDB for reference: http://natives.altv.mp/#/0x301A42153C9AD707
		/// </summary>
		void NetworkExplodeVehicle(int vehicle, bool isAudible, bool isInvisible, bool p3);
		void _0x2A5E0621DD815A9A(int p0, int p1, int p2, int p3);
		void NetworkUseLogarithmicBlendingThisFrame(int entity);
		void NetworkOverrideCoordsAndHeading(int entity, float x, float y, float z, float heading);
		void _0xE6717E652B8C8D8A(int p0, int p1);
		void NetworkDisableProximityMigration(int netID);
		/// <summary>
		/// value must be < 255
		/// </summary>
		void NetworkSetPropertyId(int id);
		void NetworkClearPropertyId();
		void _0x367EF5E2F439B4C6(int p0);
		void _0x94538037EE44F5CF(bool p0);
		void NetworkCacheLocalPlayerHeadBlendData();
		bool NetworkHasCachedPlayerHeadBlendData(int player);
		bool NetworkApplyCachedPlayerHeadBlendData(int ped, int player);
		int GetNumCommerceItems();
		bool IsCommerceDataValid();
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		void _0xB606E6CC59664972(int p0);
		/// <summary>
		/// IS_COMMERCE_*
		/// </summary>
		bool _0x1D4DC17C38FEAFF0();
		string GetCommerceItemId(int index);
		string GetCommerceItemName(int index);
		string GetCommerceProductPrice(int index);
		int GetCommerceItemNumCats(int index);
		/// <summary>
		/// </summary>
		/// <param name="index2">is unused</param>
		string GetCommerceItemCat(int index, int index2);
		void OpenCommerceStore(string p0, string p1, int p2);
		bool IsCommerceStoreOpen();
		/// <summary>
		/// Access to the store for shark cards etc...
		/// </summary>
		void SetStoreEnabled(bool toggle);
		bool RequestCommerceItemImage(int index);
		void ReleaseAllCommerceItemImages();
		string GetCommerceItemTexturename(int index);
		bool IsStoreAvailableToUser();
		void _0x265635150FB0D82E();
		/// <summary>
		/// RESET_*
		/// sfink: related to: NETWORK_BAIL
		/// NETWORK_BAIL_TRANSITION
		/// NETWORK_JOIN_GROUP_ACTIVITY
		/// NETWORK_JOIN_TRANSITION
		/// NETWORK_LAUNCH_TRANSITION
		/// NETWORK_SESSION_HOST
		/// NETWORK_SESSION_HOST_CLOSED
		/// NETWORK_SESSION_HOST_FRIENDS_ONLY
		/// See NativeDB for reference: http://natives.altv.mp/#/0x444C4525ECE0A4B9
		/// </summary>
		void _0x444C4525ECE0A4B9();
		/// <summary>
		/// IS_*
		/// </summary>
		bool _0x59328EB08C5CEB2B();
		void _0xFAE628F1E9ADB239(int p0, int p1, int p2);
		/// <summary>
		/// Checks some commerce stuff
		/// </summary>
		int _0x754615490A029508();
		/// <summary>
		/// Checks some commerce stuff
		/// </summary>
		int _0x155467ACA0F55705();
		int CloudDeleteMemberFile(string p0);
		bool CloudHasRequestCompleted(int handle);
		bool CloudDidRequestSucceed(int handle);
		/// <summary>
		/// Downloads prod.cloud.rockstargames.com/titles/gta5/[platform]/check.json
		/// </summary>
		void CloudCheckAvailability();
		bool CloudIsCheckingAvailability();
		bool CloudGetAvailabilityCheckResult();
		int _0x8B0C2964BA471961();
		int _0x88B588B41FF7868E();
		int _0x67FC09BC554A75E5();
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void ClearLaunchParams();
		/// <summary>
		/// </summary>
		bool UgcCopyContent(ref int p0, ref int p1);
		int _0x9FEDF86898F100E9();
		bool UgcHasCreateFinished();
		int UgcDidCreateSucceed();
		int UgcGetCreateResult();
		int UgcGetCreateContentId();
		void UgcClearCreateResult();
		/// <summary>
		/// </summary>
		bool UgcQueryMyContent(int p0, int p1, ref int p2, int p3, int p4, int p5);
		bool _0x692D58DF40657E8C(int p0, int p1, int p2, string p3, int p4, bool p5);
		bool UgcQueryByContentId(string contentId, bool latestVersion, string contentTypeName);
		/// <summary>
		/// </summary>
		bool UgcQueryByContentIds(ref int data, int count, bool latestVersion, string contentTypeName);
		bool UgcQueryRecentlyCreatedContent(int offset, int count, string contentTypeName, int p3);
		/// <summary>
		/// </summary>
		bool UgcGetBookmarkedContent(int p0, int p1, string p2, ref int p3);
		/// <summary>
		/// </summary>
		bool UgcGetMyContent(int p0, int p1, string p2, ref int p3);
		/// <summary>
		/// </summary>
		bool UgcGetFriendContent(int p0, int p1, string p2, ref int p3);
		/// <summary>
		/// </summary>
		bool UgcGetCrewContent(int p0, int p1, int p2, string p3, ref int p4);
		/// <summary>
		/// </summary>
		bool UgcGetGetByCategory(int p0, int p1, int p2, string p3, ref int p4);
		bool SetBalanceAddMachine(string contentId, string contentTypeName);
		/// <summary>
		/// </summary>
		bool SetBalanceAddMachines(ref int data, int dataCount, string contentTypeName);
		/// <summary>
		/// </summary>
		bool _0xA7862BC5ED1DFD7E(int p0, int p1, ref int p2, ref int p3);
		/// <summary>
		/// </summary>
		bool _0x97A770BEEF227E2B(int p0, int p1, ref int p2, ref int p3);
		/// <summary>
		/// </summary>
		bool _0x5324A0E3E4CE3570(int p0, int p1, ref int p2, ref int p3);
		void UgcCancelQuery();
		bool UgcIsGetting();
		bool UgcHasGetFinished();
		int UgcDidGetSucceed();
		int _0xC87E740D9F3872CC();
		int UgcGetQueryResult();
		int UgcGetContentNum();
		int UgcGetContentTotal();
		int UgcGetContentHash();
		void UgcClearQueryResults();
		string UgcGetContentUserId(int p0);
		/// <summary>
		/// </summary>
		bool _0x584770794D758C18(int p0, ref int p1);
		bool _0x8C8D2739BA44AF0F(int p0);
		int UgcGetContentUserName(int p0);
		bool _0xAEAB987727C5A8A4(int p0);
		int UgcGetContentCategory(int p0);
		/// <summary>
		/// Return the mission id of a job.
		/// </summary>
		string UgcGetContentId(int p0);
		/// <summary>
		/// Return the root content id of a job.
		/// </summary>
		string UgcGetRootContentId(int p0);
		int UgcGetContentName(int p0);
		int UgcGetContentDescriptionHash(int p0);
		string UgcGetContentPath(int p0, int p1);
		/// <summary>
		/// </summary>
		void UgcGetContentUpdatedDate(int p0, ref int p1);
		int UgcGetContentFileVersion(int p0, int p1);
		bool _0x1D610EB0FEA716D9(int p0);
		bool _0x7FCC39C46C3C03BD(int p0);
		int UgcGetContentLanguage(int p0);
		bool UgcGetContentIsPublished(int p0);
		bool UgcGetContentIsVerified(int p0);
		int UgcGetContentRating(int p0, int p1);
		int UgcGetContentRatingCount(int p0, int p1);
		int UgcGetContentRatingPositiveCount(int p0, int p1);
		int UgcGetContentRatingNegativeCount(int p0, int p1);
		bool UgcGetContentHasPlayerRecord(int p0);
		bool UgcGetContentHasPlayerBookmarked(int p0);
		int UgcRequestContentDataFromIndex(int p0, int p1);
		int UgcRequestContentDataFromParams(string contentTypeName, string contentId, int p2, int p3, int p4);
		int UgcRequestCachedDescription(int p0);
		bool _0x2D5DC831176D0114(int p0);
		bool _0xEBFA8D50ADDC54C4(int p0);
		bool _0x162C23CA83ED0A62(int p0);
		int UgcGetCachedDescription(int p0, int p1);
		bool _0x5A34CD9C3C5BEC44(int p0);
		void _0x68103E2247887242();
		bool UgcPublish(string contentId, string baseContentId, string contentTypeName);
		bool UgcSetBookmarked(string contentId, bool bookmarked, string contentTypeName);
		/// <summary>
		/// </summary>
		bool UgcSetDeleted(ref int p0, bool p1, string p2);
		int _0x45E816772E93A9DB();
		bool UgcHasModifyFinished();
		int _0x793FF272D5B365F4();
		int UgcGetModifyResult();
		void UgcClearModifyResult();
		/// <summary>
		/// </summary>
		bool _0xB746D20B17F2A229(ref int p0, ref int p1);
		int _0x63B406D7884BFA95();
		int _0x4D02279C83BE69FE();
		int UgcGetCreatorNum();
		bool UgcPoliciesMakePrivate(int p0);
		void UgcClearOfflineQuery();
		void UgcSetQueryDataFromOffline(bool p0);
		void _0xFD75DABC0957BF33(bool p0);
		bool UgcIsLanguageSupported(int p0);
		bool FacebookSetHeistComplete(string heistName, int cashEarned, int xpEarned);
		bool FacebookSetCreateCharacterComplete();
		bool FacebookSetMilestoneComplete(int milestoneId);
		bool FacebookIsSendingData();
		bool FacebookDoUnkCheck();
		bool FacebookIsAvailable();
		/// <summary>
		/// </summary>
		int TextureDownloadRequest(ref int gamerHandle, string filePath, string name, bool p3);
		int TitleTextureDownloadRequest(string filePath, string name, bool p2);
		int UgcTextureDownloadRequest(string p0, int p1, int p2, int p3, string p4, bool p5);
		void TextureDownloadRelease(int p0);
		bool TextureDownloadHasFailed(int p0);
		string TextureDownloadGetName(int p0);
		/// <summary>
		/// 0 = succeeded
		/// 1 = pending
		/// 2 = failed
		/// </summary>
		int GetStatusOfTextureDownload(int p0);
		/// <summary>
		/// Returns true if profile setting 901 is set to true and sets it to false.
		/// NETWORK_C*
		/// </summary>
		bool _0x60EDD13EB3AC1FF3();
		/// <summary>
		/// Returns true if the NAT type is Strict (3) and a certain number of connections have failed.
		/// </summary>
		bool NetworkShouldShowConnectivityTroubleshooting();
		bool NetworkIsCableConnected();
		bool NetworkGetRosPrivilege9();
		bool NetworkHaveRosSocialClubPriv();
		bool NetworkHaveRosBannedPriv();
		bool NetworkHaveRosCreateTicketPriv();
		bool NetworkHaveRosMultiplayerPriv();
		bool NetworkHaveRosLeaderboardWritePriv();
		/// <summary>
		/// </summary>
		/// <param name="index">is always 18 in scripts</param>
		bool NetworkHasRosPrivilege(int index);
		/// <summary>
		/// </summary>
		bool NetworkHasRosPrivilegeEndDate(int privilege, ref int banType, ref int timeData);
		bool NetworkGetRosPrivilege24();
		bool NetworkGetRosPrivilege25();
		int _0x36391F397731595D(int p0);
		/// <summary>
		/// </summary>
		/// <returns>Always returns -1. Seems to be XB1 specific.</returns>
		int NetworkStartUserContentPermissionsCheck(ref int netHandle);
		void _0x9465E683B12D3F6B();
		/// <summary>
		/// NETWORK_S*
		/// </summary>
		void _0xCA59CCAE5D01E4CE();
		/// <summary>
		/// Returns true if dinput8.dll is present in the game directory.
		/// You will get following error message if that is true: "You are attempting to access GTA Online servers with an altered version of the game."
		/// </summary>
		bool NetworkHasGameBeenAltered();
		void NetworkUpdatePlayerScars();
		void NetworkDisableLeaveRemotePedBehind(bool toggle);
		void NetworkAllowLocalEntityAttachment(int entity, bool toggle);
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		void _0x6BFF5F84102DF80A(int player);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void _0x5C497525F803486B();
		int _0x6FB7BB3607D27FA2();
		void _0x45A83257ED02D9BC();
		bool NetworkIsConnectionEndpointRelayServer(int player);
		float NetworkGetAverageLatencyForPlayer(int player);
		/// <summary>
		/// Same as _NETWORK_GET_AVERAGE_LATENCY_FOR_PLAYER (0xD414BE129BB81B32)
		/// </summary>
		float NetworkGetAverageLatencyForPlayer2(int player);
		float NetworkGetAveragePacketLossForPlayer(int player);
		int NetworkGetNumUnackedForPlayer(int player);
		int NetworkGetUnreliableResendCountForPlayer(int player);
		/// <summary>
		/// NETWORK_GET_*
		/// </summary>
		int NetworkGetOldestResendCountForPlayer(int player);
		void NetworkReportMyself();
		/// <summary>
		/// NETWORK_GET_*
		/// </summary>
		Vector3 _0x64D779659BC37B19(int entity);
		/// <summary>
		/// Returns the coordinates of another player.
		/// </summary>
		/// <returns>Does not work if you enter your own player id as p0 (will return `(0.0, 0.0, 0.0)` in that case).</returns>
		Vector3 NetworkGetPlayerCoords(int player);
		/// <summary>
		/// Used by NetBlender
		/// </summary>
		Vector3 NetworkGetLastVelocityReceived(int entity);
		/// <summary>
		/// NETWORK_GET_P*
		/// </summary>
		Vector3 _0xAA5FAFCD2C5F5E47(int entity);
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		int _0xAEDF1BC1C133D6E3();
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		int _0x2555CF7DA5473794();
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		int _0x6FD992C4A1C1B986();
		int _0xDB663CC9FF3407A9(int player);
		void NetworkUgcNav(int p0, int p1);
		int CreateObject(int modelHash, float x, float y, float z, bool isNetwork, bool bScriptHostObj, bool dynamic);
		int CreateObjectNoOffset(int modelHash, float x, float y, float z, bool isNetwork, bool bScriptHostObj, bool dynamic);
		/// <summary>
		/// Deletes the specified object, then sets the handle pointed to by the pointer to NULL.
		/// </summary>
		void DeleteObject(ref int @object);
		bool PlaceObjectOnGroundProperly(int @object);
		bool PlaceObjectOnGroundProperly2(int @object);
		bool _0xAFE24E4D29249E4A(int @object, float p1, float p2, bool p3);
		/// <summary>
		/// Returns true if the object has finished moving.
		/// If false, moves the object towards the specified X, Y and Z coordinates with the specified X, Y and Z speed.
		/// See also: https://gtagmodding.com/opcode-database/opcode/034E/
		/// </summary>
		/// <returns>Has to be looped until it returns true.</returns>
		bool SlideObject(int @object, float toX, float toY, float toZ, float speedX, float speedY, float speedZ, bool collision);
		void SetObjectTargettable(int @object, bool targettable);
		/// <summary>
		/// Overrides a flag on the object which determines if the object should be avoided by a vehicle in task CTaskVehicleGoToPointWithAvoidanceAutomobile.
		/// </summary>
		void SetObjectForceVehiclesToAvoid(int @object, bool toggle);
		/// <summary>
		/// Has 8 params in the latest patches.
		/// </summary>
		/// <param name="isMission">- if true doesn't return mission objects</param>
		/// <returns>isMission - if true doesn't return mission objects</returns>
		int GetClosestObjectOfType(float x, float y, float z, float radius, int modelHash, bool isMission, bool p6, bool p7);
		bool HasObjectBeenBroken(int @object, int p1);
		bool HasClosestObjectOfTypeBeenBroken(float p0, float p1, float p2, float p3, int modelHash, int p5);
		bool HasClosestObjectOfTypeBeenCompletelyDestroyed(float x, float y, float z, float radius, int modelHash, bool p5);
		int _0x2542269291C6AC84(int p0);
		Vector3 GetObjectOffsetFromCoords(float xPos, float yPos, float zPos, float heading, float xOffset, float yOffset, float zOffset);
		/// <summary>
		/// </summary>
		int GetCoordsAndRotationOfClosestObjectOfType(float x, float y, float z, float radius, int modelHash, ref Vector3 outPosition, ref Vector3 outRotation, int rotationOrder);
		/// <summary>
		/// Hardcoded to not work in multiplayer.
		/// Used to lock/unlock doors to interior areas of the game.
		/// (Possible) Door Types:
		/// pastebin.com/9S2m3qA4
		/// 225 door types, model names and coords found in stripclub.c4:
		/// pastebin.com/gywnbzsH
		/// get door info: pastebin.com/i14rbekD
		/// </summary>
		/// <param name="locked">means that the heading is locked.</param>
		/// <param name="heading">is either 1, 0 or -1 in the scripts. Means default closed(0) or opened either into(1) or out(-1) of the interior.</param>
		/// <param name="p6">is always 0.</param>
		void SetStateOfClosestDoorOfType(int type, float x, float y, float z, bool locked, float heading, bool p6);
		/// <summary>
		/// locked is 0 if door is unlocked
		/// locked is 1 if door is found and unlocked.
		/// -------------
		/// the locked bool is either 0(unlocked)(false) or 1(locked)(true)
		/// </summary>
		/// <param name="locked">is 0 if no door is found</param>
		void GetStateOfClosestDoorOfType(int type, float x, float y, float z, ref bool locked, ref float heading);
		/// <summary>
		/// Hardcoded not to work in multiplayer environments.
		/// When you set locked to 0 the door open and to 1 the door close
		/// OBJECT::_9B12F9A24FABEDB0(${prop_gate_prison_01}, 1845.0, 2605.0, 45.0, 0, 0.0, 50.0, 0);  //door open
		/// OBJECT::_9B12F9A24FABEDB0(${prop_gate_prison_01}, 1845.0, 2605.0, 45.0, 1, 0.0, 50.0, 0);  //door close
		/// </summary>
		void DoorControl(int modelHash, float x, float y, float z, bool locked, float xRotMult, float yRotMult, float zRotMult);
		void _0x006E4B040ED37EC3(int p0);
		/// <summary>
		/// If scriptDoor is true, register the door on the script handler host (note: there's a hardcap on the number of script IDs that can be added to the system at a given time). If scriptDoor and isLocal are both false, the door is considered to be in a "Persists w/o netobj" state.
		/// door hashes normally look like PROP_[int]_DOOR_[int] for interior doors and PROP_BUILDING_[int]_DOOR_[int] exterior doors but you can just make up your own hash if you want
		/// All doors need to be registered with ADD_DOOR_TO_SYSTEM before they can be manipulated with the door natives and the easiest way to get door models is just find the door in codewalker.
		/// Example: AddDoorToSystem("PROP_43_DOOR_0", "hei_v_ilev_fh_heistdoor2", -1456.818, -520.5037, 69.67043, 0, 0, 0)
		/// </summary>
		/// <param name="doorHash">has to be unique. scriptDoor false; relies upon getNetworkGameScriptHandler. isLocal On true disables the creation CRequestDoorEvent's in DOOR_SYSTEM_SET_DOOR_STATE.</param>
		/// <param name="p5">only set to true in single player native scripts.</param>
		void AddDoorToSystem(int doorHash, int modelHash, float x, float y, float z, bool p5, bool scriptDoor, bool isLocal);
		/// <summary>
		/// CDoor and CDoorSystemData still internally allocated (and their associations between doorHash, modelHash, and coordinates).
		/// Only its NetObj removed and flag ``*(v2 + 192) |= 8u`` (1604 retail) toggled.
		/// </summary>
		void RemoveDoorFromSystem(int doorHash);
		/// <summary>
		/// `requestDoor` on true, and when door system is configured to, i.e., "persists w/o netobj", generate a CRequestDoorEvent.
		/// `forceUpdate` on true, forces an update on the door system (same path as netObjDoor_applyDoorStuff)
		/// Door lock states:
		/// 0: UNLOCKED
		/// 1: LOCKED
		/// 2: DOORSTATE_FORCE_LOCKED_UNTIL_OUT_OF_AREA
		/// 3: DOORSTATE_FORCE_UNLOCKED_THIS_FRAME
		/// 4: DOORSTATE_FORCE_LOCKED_THIS_FRAME
		/// 5: DOORSTATE_FORCE_OPEN_THIS_FRAME
		/// 6: DOORSTATE_FORCE_CLOSED_THIS_FRAME
		/// </summary>
		/// <returns>Lockstates not applied and CNetObjDoor's not created until DOOR_SYSTEM_GET_IS_PHYSICS_LOADED returns true.</returns>
		void DoorSystemSetDoorState(int doorHash, int state, bool requestDoor, bool forceUpdate);
		int DoorSystemGetDoorState(int doorHash);
		int DoorSystemGetDoorPendingState(int doorHash);
		/// <summary>
		/// Includes networking check: ownership vs. or the door itself **isn't** networked.
		/// `forceUpdate` on true invokes DOOR_SYSTEM_SET_DOOR_STATE otherwise requestDoor is unused.
		/// </summary>
		void DoorSystemSetAutomaticRate(int doorHash, float rate, bool requestDoor, bool forceUpdate);
		/// <summary>
		/// `forceUpdate` on true invokes DOOR_SYSTEM_SET_DOOR_STATE otherwise requestDoor is unused.
		/// </summary>
		void DoorSystemSetAutomaticDistance(int doorHash, float distance, bool requestDoor, bool forceUpdate);
		/// <summary>
		/// Sets the ajar angle of a door.
		/// Ranges from -1.0 to 1.0, and 0.0 is closed / default.
		/// `forceUpdate` on true invokes DOOR_SYSTEM_SET_DOOR_STATE otherwise requestDoor is unused.
		/// </summary>
		void DoorSystemSetOpenRatio(int doorHash, float ajar, bool requestDoor, bool forceUpdate);
		int _0xE851471AEFC3374F(int p0);
		float DoorSystemGetOpenRatio(int doorHash);
		/// <summary>
		/// Includes networking check: ownership vs. or the door itself **isn't** networked.
		/// `forceUpdate` on true invokes DOOR_SYSTEM_SET_DOOR_STATE otherwise requestDoor is unused.
		/// </summary>
		void DoorSystemSetSpringRemoved(int doorHash, bool removed, bool requestDoor, bool forceUpdate);
		/// <summary>
		/// Includes networking check: ownership vs. or the door itself **isn't** networked.
		/// </summary>
		void DoorSystemSetHoldOpen(int doorHash, bool toggle);
		/// <summary>
		/// Some property related to gates. Native name between ``DOOR_SYSTEM_SET_AUTOMATIC_RATE`` and ``DOOR_SYSTEM_SET_DOOR_STATE``.
		/// </summary>
		void _0xA85A21582451E951(int doorHash, bool p1);
		/// <summary>
		/// if (OBJECT::IS_DOOR_REGISTERED_WITH_SYSTEM(doorHash))
		/// {
		/// OBJECT::REMOVE_DOOR_FROM_SYSTEM(doorHash);
		/// }
		/// </summary>
		bool IsDoorRegisteredWithSystem(int doorHash);
		bool IsDoorClosed(int doorHash);
		void _0xC7F29CA00F46350E(bool p0);
		/// <summary>
		/// Clears the fields sets by 0xC7F29CA00F46350E (1604 retail: 0x1424A7A10, 0x1424A7A11) and iterates over the global CDoor's bucket-list.
		/// Related to its "Pre-networked state"?
		/// </summary>
		void _0x701FDA1E82076BA4();
		bool DoorSystemGetIsPhysicsLoaded(int p0);
		/// <summary>
		/// Search radius: 0.5
		/// </summary>
		bool DoorSystemFindExistingDoor(float x, float y, float z, int modelHash, ref int outDoorHash);
		bool IsGarageEmpty(int garageHash, bool p1, int p2);
		bool IsPlayerEntirelyInsideGarage(int garageHash, int player, float p2, int p3);
		bool IsPlayerPartiallyInsideGarage(int garageHash, int player, int p2);
		bool AreEntitiesEntirelyInsideGarage(int garageHash, bool p1, bool p2, bool p3, int p4);
		bool IsAnyEntityEntirelyInsideGarage(int garageHash, bool p1, bool p2, bool p3, int p4);
		/// <summary>
		/// Despite the name, it does work for any entity type.
		/// </summary>
		bool IsObjectEntirelyInsideGarage(int garageHash, int entity, float p2, int p3);
		/// <summary>
		/// Despite the name, it does work for any entity type.
		/// </summary>
		bool IsObjectPartiallyInsideGarage(int garageHash, int entity, int p2);
		/// <summary>
		/// CLEAR_*
		/// </summary>
		void ClearGarageArea(int garageHash, bool isNetwork);
		void ClearObjectsInsideGarage(int garageHash, bool vehicles, bool peds, bool objects, bool isNetwork);
		/// <summary>
		/// Sets a flag. A valid id is 0x157DC10D
		/// SET_FLAG_??
		/// </summary>
		void _0x659F9D71F52843F8(int id, bool toggle);
		void EnableSavingInGarage(int garageHash, bool toggle);
		void _0x66A49D021870FE88();
		/// <summary>
		/// </summary>
		/// <param name="p5">is usually 0.</param>
		bool DoesObjectOfTypeExistAtCoords(float x, float y, float z, float radius, int hash, bool p5);
		/// <summary>
		/// An angled area is an X-Z oriented rectangle with three parameters:
		/// 1. origin: the mid-point along a base edge of the rectangle;
		/// 2. extent: the mid-point of opposite base edge on the other Z;
		/// 3. width: the length of the base edge; (named derived from logging strings ``CNetworkRoadNodeWorldStateData``).
		/// 1. golf_mp https://i.imgur.com/JhsQAK9.png
		/// 2. am_taxi https://i.imgur.com/TJWCZaT.jpg
		/// </summary>
		/// <param name="width">extent)``), its orthonormal, and the width, e.g:</param>
		bool IsPointInAngledArea(float xPos, float yPos, float zPos, float x1, float y1, float z1, float x2, float y2, float z2, float width, bool debug, bool includeZ);
		/// <summary>
		/// Overrides the climbing/blocking flags of the object, used in the native scripts mostly for "prop_dock_bouy_*"
		/// </summary>
		void SetObjectAllowLowLodBuoyancy(int @object, bool toggle);
		/// <summary>
		/// Adjust the physics parameters of a prop, or otherwise known as "object". This is useful for simulated gravity.
		/// Other parameters seem to be unknown.
		/// </summary>
		/// <param name="p2">seems to be weight and gravity related. Higher value makes the obj fall faster. Very sensitive?</param>
		/// <param name="p3">seems similar to p2</param>
		/// <param name="p4">makes obj fall slower the higher the value</param>
		/// <param name="p5">similar to p4</param>
		void SetObjectPhysicsParams(int @object, float weight, float p2, float p3, float p4, float p5, float gravity, float p7, float p8, float p9, float p10, float buoyancy);
		float GetObjectFragmentDamageHealth(int p0, bool p1);
		void SetActivateObjectPhysicsAsSoonAsItIsUnfrozen(int @object, bool toggle);
		bool IsAnyObjectNearPoint(float x, float y, float z, float range, bool p4);
		bool IsObjectNearPoint(int objectHash, float x, float y, float z, float range);
		void RemoveObjectHighDetailModel(int @object);
		void BreakObjectFragmentChild(int p0, int p1, bool p2);
		void _0xE05F6AEEFEB0BB02(int p0, int p1, int p2);
		void _0xF9C1681347C8BD15(int @object);
		void TrackObjectVisibility(int @object);
		bool IsObjectVisible(int @object);
		void _0xC6033D32241F6FB5(int @object, bool toggle);
		void _0xEB6F1A9B5510A5D2(int p0, bool p1);
		void SetUnkGlobalBoolRelatedToDamage(bool value);
		/// <summary>
		/// Requires a component_at_*_flsh to be attached to the weapon object
		/// </summary>
		void SetCreateWeaponObjectLightSource(int @object, bool toggle);
		/// <summary>
		/// Example:
		/// OBJECT::GET_RAYFIRE_MAP_OBJECT(-809.9619750976562, 170.919, 75.7406997680664, 3.0, "des_tvsmash");
		/// </summary>
		int GetRayfireMapObject(float x, float y, float z, float radius, string name);
		/// <summary>
		/// Defines the state of a destructible object.
		/// Use the GET_RAYFIRE_MAP_OBJECT native to find an object's handle with its name / coords.
		/// State 4 == Beginning of the animation
		/// State 6 == Start animation
		/// State 9 == End of the animation
		/// </summary>
		/// <param name="state">2 == object just spawned</param>
		void SetStateOfRayfireMapObject(int @object, int state);
		/// <summary>
		/// Get a destructible object's state.
		/// Substract 1 to get the real state.
		/// See SET_STATE_OF_RAYFIRE_MAP_OBJECT to see the different states
		/// </summary>
		/// <returns>For example, if the object just spawned (state 2), the native will return 3.</returns>
		int GetStateOfRayfireMapObject(int @object);
		/// <summary>
		/// Returns true if a destructible object with this handle exists, false otherwise.
		/// </summary>
		bool DoesRayfireMapObjectExist(int @object);
		/// <summary>
		/// `object`: The des-object handle to get the animation progress from.
		/// Return value is a float between 0.0 and 1.0, 0.0 is the beginning of the animation, 1.0 is the end. Value resets to 0.0 instantly after reaching 1.0.
		/// </summary>
		float GetRayfireMapObjectAnimPhase(int @object);
		/// <summary>
		/// Pickup hashes: pastebin.com/8EuSv2r1
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		int CreatePickup(int pickupHash, float posX, float posY, float posZ, int p4, int value, bool p6, int modelHash);
		/// <summary>
		/// Pickup hashes: pastebin.com/8EuSv2r1
		/// flags:
		/// 8 (1 << 3): place on ground
		/// 512 (1 << 9): spin around
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		int CreatePickupRotate(int pickupHash, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, int flag, int amount, int p9, bool p10, int modelHash);
		void _0x394CD08E31313C28();
		void _0x826D1EE4D1CAFC78(int p0, int p1);
		/// <summary>
		/// Used for doing money drop
		/// Pickup hashes: pastebin.com/8EuSv2r1
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		int CreateAmbientPickup(int pickupHash, float posX, float posY, float posZ, int flags, int value, int modelHash, bool p7, bool p8);
		int CreateNonNetworkedAmbientPickup(int pickupHash, float posX, float posY, float posZ, int flags, int value, int modelHash, bool p7, bool p8);
		void _0x1E3F1B1B891A2AAA(int p0, int p1);
		/// <summary>
		/// Pickup hashes: pastebin.com/8EuSv2r1
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		int CreatePortablePickup(int pickupHash, float x, float y, float z, bool placeOnGround, int modelHash);
		/// <summary>
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		int CreateNonNetworkedPortablePickup(int pickupHash, float x, float y, float z, bool placeOnGround, int modelHash);
		void AttachPortablePickupToPed(int pickupObject, int ped);
		void DetachPortablePickupFromPed(int pickupObject);
		void HidePickup(int pickupObject, bool toggle);
		void SetMaxNumPortablePickupsCarriedByPlayer(int modelHash, int p1);
		void SetLocalPlayerCanCollectPortablePickups(bool p0);
		Vector3 GetSafePickupCoords(float x, float y, float z, float p3, float p4);
		/// <summary>
		/// Adds an area that seems to be related to pickup physics behavior.
		/// Max amount of areas is 10. Only works in multiplayer.
		/// ADD_*
		/// </summary>
		void _0xD4A7A435B3710D05(float x, float y, float z, float radius);
		/// <summary>
		/// Clears all areas created by 0xD4A7A435B3710D05
		/// CLEAR_*
		/// </summary>
		void _0xB7C6D80FB371659A();
		Vector3 GetPickupCoords(int pickup);
		void _0x8DCA505A5C196F05(int p0, int p1);
		/// <summary>
		/// Pickup hashes: pastebin.com/8EuSv2r1
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		void RemoveAllPickupsOfType(int pickupHash);
		bool HasPickupBeenCollected(int pickup);
		void RemovePickup(int pickup);
		/// <summary>
		/// Spawns one or more money pickups.
		/// Example:
		/// CREATE_MONEY_PICKUPS(x, y, z, 1000, 3, 0x684a97ae);
		/// Spawns 3 spray cans that'll collectively give $1000 when picked up. (Three spray cans, each giving $334, $334, $332 = $1000).
		/// ==============================================
		/// Max is 2000 in MP. So if you put the amount to 20, but the value to $400,000 eg. They will only be able to pickup 20 - $2,000 bags. So, $40,000
		/// </summary>
		/// <param name="x">The X-component of the world position to spawn the money pickups at.</param>
		/// <param name="y">The Y-component of the world position to spawn the money pickups at.</param>
		/// <param name="z">The Z-component of the world position to spawn the money pickups at.</param>
		/// <param name="value">The combined value of the pickups (in dollars).</param>
		/// <param name="amount">The number of pickups to spawn.</param>
		/// <param name="model">The model to use, or 0 for default money model.</param>
		void CreateMoneyPickups(float x, float y, float z, int value, int amount, int model);
		bool DoesPickupExist(int pickup);
		bool DoesPickupObjectExist(int pickupObject);
		int GetPickupObject(int pickup);
		bool IsObjectAPortablePickup(int @object);
		bool IsObjectAPickup(int @object);
		/// <summary>
		/// Pickup hashes: pastebin.com/8EuSv2r1
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		bool DoesPickupOfTypeExistInArea(int pickupHash, float x, float y, float z, float radius);
		void SetPickupRegenerationTime(int pickup, int duration);
		void ForcePickupRegenerate(int p0);
		/// <summary>
		/// Disabling/enabling a player from getting pickups. From the scripts:
		/// OBJECT::_616093EC6B139DD9(PLAYER::PLAYER_ID(), ${pickup_portable_package}, 0);
		/// OBJECT::_616093EC6B139DD9(PLAYER::PLAYER_ID(), ${pickup_portable_package}, 0);
		/// OBJECT::_616093EC6B139DD9(PLAYER::PLAYER_ID(), ${pickup_portable_package}, 1);
		/// OBJECT::_616093EC6B139DD9(PLAYER::PLAYER_ID(), ${pickup_portable_package}, 0);
		/// OBJECT::_616093EC6B139DD9(PLAYER::PLAYER_ID(), ${pickup_armour_standard}, 0);
		/// OBJECT::_616093EC6B139DD9(PLAYER::PLAYER_ID(), ${pickup_armour_standard}, 1);
		/// SET_PLAYER_*
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		void ToggleUsePickupsForPlayer(int player, int pickupHash, bool toggle);
		/// <summary>
		/// Maximum amount of pickup models that can be disallowed is 30.
		/// SET_LOCAL_PLAYER_*
		/// </summary>
		void SetLocalPlayerCanUsePickupsWithThisModel(int modelHash, bool toggle);
		/// <summary>
		/// A*
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		void _0xFDC07C58E8AAB715(int pickupHash);
		void SetTeamPickupObject(int @object, int p1, bool p2);
		void PreventCollectionOfPortablePickup(int @object, bool p1, bool p2);
		void _0x27F248C3FEBFAAD3(int p0, int p1);
		void _0x0596843B34B95CE5(int p0, int p1);
		void _0xA08FE5E49BDC39DD(int p0, float p1, bool p2);
		void _0x62454A641B41F3C5(int p0);
		void _0x39A5FB7EAF150840(int p0, int p1);
		void _0x834344A414C7C85D(int p0, int p1);
		int _0xDB41D07A45A6D4B7(int p0);
		void SetPickupGenerationRangeMultiplier(float multiplier);
		float GetPickupGenerationRangeMultiplier();
		void _0x31F924B53EADDF65(bool p0);
		void SetPickupUncollectable(int p0, int p1);
		void _0x858EC9FD25DE04AA(int p0, int p1);
		void SetPickupHiddenWhenUncollectable(int p0, int p1);
		void _0x8881C98A31117998(int p0, int p1);
		void _0x8CFF648FBD7330F1(int p0);
		void _0x46F3ADD1E2D5BAF2(int p0, int p1);
		void _0x641F272B52E2F0F8(int p0, int p1);
		/// <summary>
		/// Sets some bit of pickup
		/// SET_PICKUP_*
		/// </summary>
		void _0x4C134B4DF76025D0(int pickup, bool toggle);
		/// <summary>
		/// Sets some value of pickup
		/// SET_PICKUP_*
		/// </summary>
		void _0xAA059C615DE9DD03(int pickup, bool toggle);
		void _0xF92099527DB8E2A7(int p0, int p1);
		/// <summary>
		/// CLEAR_*
		/// </summary>
		void _0xA2C1F5E92AFE49ED();
		void _0x762DB2D380B48D04(int p0);
		/// <summary>
		/// draws circular marker at pos
		/// -1 = none
		/// 0 = red
		/// 1 = green
		/// 2 = blue
		/// 3 = green larger
		/// 4 = nothing
		/// 5 = green small
		/// </summary>
		void RenderFakePickupGlow(float x, float y, float z, int colorIndex);
		/// <summary>
		/// SET_PICKUP_*
		/// </summary>
		void _0x7813E8B8C4AE4799(int pickup);
		/// <summary>
		/// Sets some pickup flag?
		/// SET_PICKUP_*
		/// </summary>
		void _0xBFFE53AE7E67FCDC(int pickup, bool toggle);
		/// <summary>
		/// Sets entity+38 to C (when false) or 0xFF3f (when true)
		/// SET_ENTITY_??
		/// </summary>
		void _0xD05A3241B9A86F19(int entity, bool toggle);
		void _0xB2D0BDE54F0E8E5A(int @object, bool toggle);
		/// <summary>
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		int GetWeaponTypeFromPickupType(int pickupHash);
		/// <summary>
		/// Returns the pickup hash for the given weapon hash
		/// </summary>
		int GetPickupHashFromWeapon(int weaponHash);
		bool IsPickupWeaponObjectValid(int @object);
		int GetObjectTextureVariation(int @object);
		/// <summary>
		/// enum ObjectPaintVariants
		/// {
		/// Pacific = 0,
		/// Azure = 1,
		/// Nautical = 2,
		/// Continental = 3,
		/// Battleship = 4,
		/// Intrepid = 5,
		/// Uniform = 6,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x971DA0055324D033
		/// </summary>
		void SetObjectTextureVariation(int @object, int textureVariation);
		bool SetTextureVariationOfClosestObjectOfType(float x, float y, float z, float radius, int modelHash, int textureVariation);
		int SetObjectLightColor(int @object, bool p1, int r, int g, int b);
		/// <summary>
		/// GET_OBJECT_??
		/// </summary>
		bool _0xADF084FB8F075D06(int @object);
		/// <summary>
		/// SET_OBJECT_*
		/// </summary>
		void _0x3B2FD68DB5F8331C(int @object, bool toggle);
		void SetObjectStuntPropSpeedup(int @object, int p1);
		void SetObjectStuntPropDuration(int @object, float duration);
		/// <summary>
		/// returns pickup hash.
		/// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
		/// </summary>
		int GetPickupHash(int pickupHash);
		void SetForceObjectThisFrame(float x, float y, float z, float p3);
		/// <summary>
		/// is this like setting is as no longer needed?
		/// </summary>
		void MarkObjectForDeletion(int @object);
		void _0x8CAAB2BD3EA58BD4(int p0);
		void _0x63ECF581BC70E363(int p0, int p1);
		/// <summary>
		/// Activate the physics to: "xs_prop_arena_{flipper,wall,bollard,turntable,pit}"
		/// </summary>
		void SetEnableArenaPropPhysics(int @object, bool toggle, int p2);
		void SetEnableArenaPropPhysicsOnPed(int @object, bool toggle, int p2, int ped);
		/// <summary>
		/// Sets some bit of object
		/// SET_OBJECT_*
		/// </summary>
		void _0x734E1714D077DA9A(int @object, bool toggle);
		/// <summary>
		/// Sets some bit of object
		/// SET_OBJECT_*
		/// </summary>
		void _0x1A6CBB06E2D0D79D(int @object, bool p1);
		bool GetIsArenaPropPhysicsDisabled(int @object, int p1);
		int _0x3BD770D281982DB5(int p0, int p1);
		/// <summary>
		/// Sets some flag of object
		/// SET_OBJECT_*
		/// </summary>
		void _0x1C57C94A6446492A(int @object, bool toggle);
		/// <summary>
		/// Sets some bit of object
		/// SET_OBJECT_*
		/// </summary>
		void _0xB5B7742424BD4445(int @object, bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsControlEnabled(int padIndex, int control);
		/// <summary>
		/// Returns whether a control is currently pressed.
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsControlPressed(int padIndex, int control);
		/// <summary>
		/// Returns whether a control is currently _not_ pressed.
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsControlReleased(int padIndex, int control);
		/// <summary>
		/// Returns whether a control was newly pressed since the last check.
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsControlJustPressed(int padIndex, int control);
		/// <summary>
		/// Returns whether a control was newly released since the last check.
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsControlJustReleased(int padIndex, int control);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		int GetControlValue(int padIndex, int control);
		/// <summary>
		/// Returns the value of GET_CONTROL_VALUE normalized (i.e. a real number value between -1 and 1)
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		float GetControlNormal(int padIndex, int control);
		void _0x5B73C77D9EB66E24(bool p0);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		/// <returns>Seems to return values between -1 and 1 for controls like gas and steering.</returns>
		float GetControlUnboundNormal(int padIndex, int control);
		/// <summary>
		/// This is for simulating player input.
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		/// <param name="amount">is a float value from 0 - 1</param>
		bool SetControlNormal(int padIndex, int control, float amount);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsDisabledControlPressed(int padIndex, int control);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsDisabledControlReleased(int padIndex, int control);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsDisabledControlJustPressed(int padIndex, int control);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsDisabledControlJustReleased(int padIndex, int control);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		/// <param name="control">- c# works with (int)GTA.Control.CursorY / (int)GTA.Control.CursorX and returns the mouse movement (additive).</param>
		/// <returns>control - c# works with (int)GTA.Control.CursorY / (int)GTA.Control.CursorX and returns the mouse movement (additive).</returns>
		float GetDisabledControlNormal(int padIndex, int control);
		/// <summary>
		/// The "disabled" variant of _0x5B84D09CEC5209C5.
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		float GetDisabledControlUnboundNormal(int padIndex, int control);
		int _0xD7D22F5592AED8BA(int p0);
		/// <summary>
		/// Used to be known as _GET_LAST_INPUT_METHOD & _IS_INPUT_DISABLED
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsUsingKeyboard(int padIndex);
		/// <summary>
		/// Used to be known as _IS_INPUT_JUST_DISABLED
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool IsUsingKeyboard2(int padIndex);
		bool SetCursorLocation(float x, float y);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		/// <returns>Hardcoded to return false.</returns>
		bool _0x23F09EADC01449D6(int padIndex);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		bool _0x6CD79468A1E595C6(int padIndex);
		/// <summary>
		/// formerly called _GET_CONTROL_ACTION_NAME incorrectly
		/// p2 is unused variable in function.
		/// EG:
		/// GET_CONTROL_INSTRUCTIONAL_BUTTON (2, 201, 1) INPUT_FRONTEND_ACCEPT (e.g. Enter button)
		/// GET_CONTROL_INSTRUCTIONAL_BUTTON (2, 202, 1) INPUT_FRONTEND_CANCEL (e.g. ESC button)
		/// GET_CONTROL_INSTRUCTIONAL_BUTTON (2, 51, 1) INPUT_CONTEXT (e.g. E button)
		/// gtaforums.com/topic/819070-c-draw-instructional-buttons-scaleform-movie/#entry1068197378
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		/// <param name="p2">appears to always be true.</param>
		string GetControlInstructionalButton(int padIndex, int control, bool p2);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		string GetControlGroupInstructionalButton(int padIndex, int controlGroup, bool p2);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		void SetControlLightEffectColor(int padIndex, int red, int green, int blue);
		void _0xCB0360EFEFB2580D(int padIndex);
		/// <summary>
		/// appears to be a hash collision, though it does do what it says
		/// example:
		/// SET_PAD_SHAKE(0, 100, 200);
		/// </summary>
		/// <param name="padIndex">always seems to be 0</param>
		/// <param name="duration">in milliseconds</param>
		/// <param name="frequency">should range from about 10 (slow vibration) to 255 (very fast)</param>
		void SetPadShake(int padIndex, int duration, int frequency);
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		void _0x14D29BB12D47F68C(int p0, int p1, int p2, int p3, int p4);
		void StopPadShake(int padIndex);
		void SetPadShakeSuppressedId(int padIndex, int p1);
		void _0xA0CEFCEA390AAB9B(int p0);
		bool IsLookInverted();
		/// <summary>
		/// Used with IS_LOOK_INVERTED() and negates its affect.
		/// --
		/// Not sure how the person above got that description, but here's an actual example:
		/// if (PAD::_GET_LAST_INPUT_METHOD(2)) {
		/// if (a_5) {
		/// if (PAD::IS_LOOK_INVERTED()) {
		/// a_3 *= -1;
		/// }
		/// if (PAD::_E1615EC03B3BB4FD()) {
		/// See NativeDB for reference: http://natives.altv.mp/#/0xE1615EC03B3BB4FD
		/// </summary>
		bool _0xE1615EC03B3BB4FD();
		/// <summary>
		/// Returns the local player's targeting mode. See PLAYER::SET_PLAYER_TARGETING_MODE.
		/// </summary>
		int GetLocalPlayerAimState();
		/// <summary>
		/// Same behavior as GET_LOCAL_PLAYER_AIM_STATE but only used on the PC version.
		/// </summary>
		int GetLocalPlayerAimState2();
		int _0x25AAA32BDC98F2A3();
		/// <summary>
		/// Returns profile setting 225.
		/// </summary>
		bool GetIsUsingAlternateDriveby();
		/// <summary>
		/// Returns profile setting 17.
		/// </summary>
		bool GetAllowMovementWhileZoomed();
		void SetPlayerpadShakesWhenControllerDisabled(bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		void SetInputExclusive(int padIndex, int control);
		/// <summary>
		/// Control values from the decompiled scripts: 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
		/// 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,5
		/// 4,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,
		/// 79,80,81,82,85,86,87,88,89,90,91,92,93,95,96,97,98,99,100,101,102,103,105,
		/// 107,108,109,110,111,112,113,114,115,116,117,118,119,123,126,129,130,131,132,
		/// 133,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,
		/// 153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,171,172
		/// ,177,187,188,189,190,195,196,199,200,201,202,203,205,207,208,209,211,212,213, 217,219,220,221,225,226,230,234,235,236,237,238,239,240,241,242,243,244,257,
		/// 261,262,263,264,265,270,271,272,273,274,278,279,280,281,282,283,284,285,286,
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFE99B66D079CF6BC
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		/// <param name="control">values and meaning: github.com/crosire/scripthookvdotnet/blob/dev_v3/source/scripting/Controls.cs</param>
		void DisableControlAction(int padIndex, int control, bool disable);
		/// <summary>
		/// Control values from the decompiled scripts:
		/// 0,1,2,3,4,5,6,8,9,10,11,14,15,16,17,19,21,22,24,25,26,30,31,32,33,34,35,36,
		/// 37,44,46,47,59,60,65,68,69,70,71,72,73,74,75,76,79,80,81,82,86,95,98,99,100
		/// ,101,114,140,141,143,172,173,174,175,176,177,178,179,180,181,187,188,189,19
		/// 0,195,196,197,198,199,201,202,203,204,205,206,207,208,209,210,217,218,219,2
		/// 20,221,225,228,229,230,231,234,235,236,237,238,239,240,241,242,245,246,257,
		/// 261,262,263,264,286,287,288,289,337,338,339,340,341,342,343
		/// INPUTGROUP_MOVE
		/// INPUTGROUP_LOOK
		/// See NativeDB for reference: http://natives.altv.mp/#/0x351220255D64C155
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		/// <param name="control">values and meaning: github.com/crosire/scripthookvdotnet/blob/dev/source/scripting/Controls.hpp</param>
		void EnableControlAction(int padIndex, int control, bool enable);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		void DisableAllControlActions(int padIndex);
		/// <summary>
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		void EnableAllControlActions(int padIndex);
		/// <summary>
		/// Used in carsteal3 script with p0 = "Carsteal4_spycar".
		/// S*
		/// </summary>
		bool SwitchToInputMappingScheme(string name);
		/// <summary>
		/// Same as 0x3D42B92563939375
		/// S*
		/// </summary>
		bool SwitchToInputMappingScheme2(string name);
		/// <summary>
		/// S*
		/// </summary>
		void ResetInputMappingScheme();
		/// <summary>
		/// A*
		/// </summary>
		/// <param name="padIndex">0 (PLAYER_CONTROL), 1 (unk) and 2 (unk) used in the scripts.</param>
		void DisableInputGroup(int padIndex);
		/// <summary>
		/// When nodeEnabled is set to false, all nodes in the area get disabled.
		/// If it's true, `GET_VEHICLE_NODE_IS_SWITCHED_OFF` returns false.
		/// </summary>
		/// <returns>`GET_VEHICLE_NODE_IS_SWITCHED_OFF` returns true afterwards.</returns>
		void SetRoadsInArea(float x1, float y1, float z1, float x2, float y2, float z2, bool nodeEnabled, bool unknown2);
		/// <summary>
		/// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
		/// </summary>
		/// <param name="unknown3">is related to `SEND_SCRIPT_WORLD_STATE_EVENT > CNetworkRoadNodeWorldStateData` in networked environments.</param>
		void SetRoadsInAngledArea(float x1, float y1, float z1, float x2, float y2, float z2, float width, bool unknown1, bool unknown2, bool unknown3);
		void SetPedPathsInArea(float x1, float y1, float z1, float x2, float y2, float z2, bool unknown, int p7);
		/// <summary>
		/// 1 = 1 = B02_IsFootpath
		/// 2 = 4 = !B15_InteractionUnk
		/// 4 = 0x20 = !B14_IsInterior
		/// 8 = 0x40 = !B07_IsWater
		/// 16 = 0x200 = B17_IsFlatGround
		/// When onGround == true outPosition is a position located on the nearest pavement.
		/// When a safe coord could not be found the result of a function is false and outPosition == Vector3.Zero.
		/// In the scripts these flags are used: 0, 14, 12, 16, 20, 21, 28. 0 is most commonly used, then 16.
		/// 16 works for me, 0 crashed the script.
		/// </summary>
		/// <param name="flags">are:</param>
		bool GetSafeCoordForPed(float x, float y, float z, bool onGround, ref Vector3 outPosition, int flags);
		/// <summary>
		/// FYI: When falling through the map (or however you got under it) you will respawn when your player ped's height is <= -200.0 meters (I think you all know this) and when in a vehicle you will actually respawn at the closest vehicle node.
		/// ----------
		/// Vector3 nodePos;
		/// GET_CLOSEST_VEHICLE_NODE(x,y,z,&nodePos,...)
		/// 0x40400000 (3.0), 0
		/// p5 can also be 100.0 and p6 can be 2.5:
		/// PATHFIND::GET_CLOSEST_VEHICLE_NODE(a_0, &v_5, v_9, 100.0, 2.5)
		/// Known node types: simple path/asphalt road, only asphalt road, water, under the map at always the same coords.
		/// The node types follows a pattern. For example, every fourth node is of the type water i.e. 3, 7, 11, 15, 19, 23, 27, 31, 35, 39... 239. Could not see any difference between nodes within certain types.
		/// See NativeDB for reference: http://natives.altv.mp/#/0x240A18690AE96513
		/// </summary>
		/// <param name="nodeType">is either 0, 1 or 8. 1 means any path/road. 0 means node in the middle of the closest main (asphalt) road.</param>
		bool GetClosestVehicleNode(float x, float y, float z, ref Vector3 outPosition, int nodeType, float p5, float p6);
		/// <summary>
		/// Get the closest vehicle node to a given position, unknown1 = 3.0, unknown2 = 0
		/// </summary>
		bool GetClosestMajorVehicleNode(float x, float y, float z, ref Vector3 outPosition, float unknown1, int unknown2);
		/// <summary>
		/// p5, p6 and p7 seems to be about the same as p4, p5 and p6 for GET_CLOSEST_VEHICLE_NODE. p6 and/or p7 has something to do with finding a node on the same path/road and same direction(at least for this native, something to do with the heading maybe). Edit this when you find out more.
		/// Known node types: simple path/asphalt road, only asphalt road, water, under the map at always the same coords.
		/// The node types follows a pattern. For example, every fourth node is of the type water i.e. 3, 7, 11, 15, 19, 23, 27, 31, 35, 39... 239. Could not see any difference between nodes within certain types.
		/// Starting at 2, every fourth node is under the map, always same coords.
		/// Same with only asphalt road (0, 4, 8, etc) and simple path/asphalt road (1, 5, 9, etc).
		/// gtaforums.com/topic/843561-pathfind-node-types
		/// Example of usage, moving vehicle to closest path/road:
		/// Vector3 coords = ENTITY::GET_ENTITY_COORDS(playerVeh, true);
		/// Vector3 closestVehicleNodeCoords;
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFF071FB798B803B0
		/// </summary>
		/// <param name="nodeType">is either 1 or 12. 1 means any path/road. 12, 8, 0 means node in the middle of the closest main (asphalt) road.</param>
		/// <param name="p6">is always 3.0</param>
		/// <param name="p7">is always 0.</param>
		bool GetClosestVehicleNodeWithHeading(float x, float y, float z, ref Vector3 outPosition, ref float outHeading, int nodeType, float p6, int p7);
		/// <summary>
		/// </summary>
		bool GetNthClosestVehicleNode(float x, float y, float z, int nthClosest, ref Vector3 outPosition, int unknown1, int unknown2, int unknown3);
		/// <summary>
		/// Returns the id.
		/// </summary>
		int GetNthClosestVehicleNodeId(float x, float y, float z, int nth, int nodetype, float p5, float p6);
		/// <summary>
		/// Get the nth closest vehicle node and its heading. (unknown2 = 9, unknown3 = 3.0, unknown4 = 2.5)
		/// </summary>
		bool GetNthClosestVehicleNodeWithHeading(float x, float y, float z, int nthClosest, ref Vector3 outPosition, ref float outHeading, ref int unknown1, int unknown2, float unknown3, float unknown4);
		/// <summary>
		/// </summary>
		int GetNthClosestVehicleNodeIdWithHeading(float x, float y, float z, int nthClosest, ref Vector3 outPosition, ref float outHeading, int p6, float p7, float p8);
		/// <summary>
		/// </summary>
		/// <param name="y">pathfind</param>
		/// <param name="p10">always equals 3.0</param>
		/// <param name="p11">always equals 0</param>
		bool GetNthClosestVehicleNodeFavourDirection(float x, float y, float z, float desiredX, float desiredY, float desiredZ, int nthClosest, ref Vector3 outPosition, ref float outHeading, int nodetype, float p10, int p11);
		/// <summary>
		/// MulleDK19: Gets the density and flags of the closest node to the specified position.
		/// </summary>
		/// <param name="density">is a value between 0 and 15, indicating how busy the road is.</param>
		/// <param name="flags">is a bit field.</param>
		bool GetVehicleNodeProperties(float x, float y, float z, ref int density, ref int flags);
		/// <summary>
		/// Returns true if the id is non zero.
		/// </summary>
		bool IsVehicleNodeIdValid(int vehicleNodeId);
		/// <summary>
		/// Calling this with an invalid node id, will crash the game.
		/// Note that IS_VEHICLE_NODE_ID_VALID simply checks if nodeId is not zero. It does not actually ensure that the id is valid.
		/// </summary>
		/// <returns>Eg. IS_VEHICLE_NODE_ID_VALID(1) will return true, but will crash when calling GET_VEHICLE_NODE_POSITION().</returns>
		void GetVehicleNodePosition(int nodeId, ref Vector3 outPosition);
		/// <summary>
		/// Returns false for nodes that aren't used for GPS routes.
		/// Example:
		/// Nodes in Fort Zancudo and LSIA are false
		/// </summary>
		bool GetVehicleNodeIsGpsAllowed(int nodeID);
		/// <summary>
		/// Normal roads where plenty of Peds spawn will return false
		/// </summary>
		/// <returns>Returns true when the node is Offroad. Alleys, some dirt roads, and carparks return true.</returns>
		bool GetVehicleNodeIsSwitchedOff(int nodeID);
		/// <summary>
		/// </summary>
		/// <param name="y">seems to be always 1.0f in the scripts</param>
		int GetClosestRoad(float x, float y, float z, float p3, int p4, ref Vector3 p5, ref Vector3 p6, ref int p7, ref int p8, ref float p9, bool p10);
		/// <summary>
		/// Toggles a global boolean, name is probably a hash collision but describes its functionality.
		/// </summary>
		void SetAllPathsCacheBoundingstruct(bool toggle);
		/// <summary>
		/// Activates Cayo Perico path nodes if passed `1`. GPS navigation will start working, maybe more stuff will change, not sure. It seems if you try to unload (pass `0`) when close to the island, your game might crash.
		/// </summary>
		void SetAiGlobalPathNodesType(int type);
		/// <summary>
		/// ARE_*
		/// </summary>
		bool AreNodesLoadedForArea(float x1, float y1, float x2, float y2);
		/// <summary>
		/// Used internally for long range tasks
		/// </summary>
		bool RequestPathsPreferAccurateBoundingstruct(float x1, float y1, float x2, float y2);
		/// <summary>
		/// missing a last parameter int p6
		/// </summary>
		void SetRoadsBackToOriginal(float p0, float p1, float p2, float p3, float p4, float p5, int p6);
		/// <summary>
		/// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
		/// bool p7 - always 1
		/// </summary>
		void SetRoadsBackToOriginalInAngledArea(float x1, float y1, float z1, float x2, float y2, float z2, float width, int p7);
		void SetAmbientPedRangeMultiplierThisFrame(float multiplier);
		void _0xAA76052DDA9BFC3E(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		void SetPedPathsBackToOriginal(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		/// <summary>
		/// </summary>
		bool GetRandomVehicleNode(float x, float y, float z, float radius, bool p4, bool p5, bool p6, ref Vector3 outPosition, ref int nodeId);
		/// <summary>
		/// Determines the name of the street which is the closest to the given coordinates.
		/// Note: the names are returned as hashes, the strings can be returned using the function HUD::GET_STREET_NAME_FROM_HASH_KEY.
		/// </summary>
		/// <param name="x">the coordinates of the street</param>
		/// <param name="y">the coordinates of the street</param>
		/// <param name="streetName">- returns a hash to the name of the street the coords are on</param>
		/// <param name="crossingRoad">- if the coordinates are on an intersection, a hash to the name of the crossing road</param>
		/// <returns>streetName - returns a hash to the name of the street the coords are on</returns>
		void GetStreetNameAtCoord(float x, float y, float z, ref int streetName, ref int crossingRoad);
		/// <summary>
		/// 0 = This happens randomly during the drive for seemingly no reason but if you consider that this native is only used in trevor3, it seems to mean "Next frame, stop whatever's being said and tell the player the direction."
		/// 1 = Route is being calculated or the player is going in the wrong direction
		/// 2 = Please Proceed the Highlighted Route
		/// 3 = In (distToNxJunction) Turn Left
		/// 4 = In (distToNxJunction) Turn Right
		/// 5 = In (distToNxJunction) Keep Straight
		/// 6 = In (distToNxJunction) Turn Sharply To The Left
		/// 7 = In (distToNxJunction) Turn Sharply To The Right
		/// return value set to 0 always
		/// </summary>
		/// <param name="y">Route is being recalculated or the navmesh is confusing. This happens randomly during the drive but consistently at {2044.0358, 2996.6116, 44.9717} if you face towards the bar and the route needs you to turn right. In that particular case, it could be a bug with how the turn appears to be 270 deg. CCW instead of "right." Either way, this seems to be the engine saying "I don't know the route right now."</param>
		/// <param name="p3">is 0 in the only game script occurrence (trevor3) but 1 doesn't seem to make a difference</param>
		/// <param name="distToNxJunction">seems to be the distance in metres * 10.0f</param>
		int GenerateDirectionsToCoord(float x, float y, float z, bool p3, ref int direction, ref float p5, ref float distToNxJunction);
		void SetIgnoreNoGpsFlag(bool toggle);
		/// <summary>
		/// See: SET_BLIP_ROUTE
		/// </summary>
		void SetIgnoreSecondaryRouteNodes(bool toggle);
		void SetGpsDisabledZone(float x1, float y1, float z1, float x2, float y2, float z3);
		int GetGpsBlipRouteLength();
		int _0xF3162836C28F9DA5(int p0, int p1, int p2, int p3);
		bool GetGpsBlipRouteFound();
		/// <summary>
		/// </summary>
		bool GetRoadSidePointWithHeading(float x, float y, float z, float heading, ref Vector3 outPosition);
		/// <summary>
		/// </summary>
		bool GetPointOnRoadSide(float x, float y, float z, int p3, ref Vector3 outPosition);
		/// <summary>
		/// Gets a value indicating whether the specified position is on a road.
		/// The vehicle parameter is not implemented (ignored).
		/// -MulleDK19
		/// </summary>
		bool IsPointOnRoad(float x, float y, float z, int vehicle);
		/// <summary>
		/// Gets the next zone that has been disabled using SET_GPS_DISABLED_ZONE_AT_INDEX.
		/// </summary>
		int GetNextGpsDisabledZoneIndex();
		/// <summary>
		/// Disables the GPS route displayed on the minimap while within a certain zone (area). When in a disabled zone and creating a waypoint, the GPS route is not shown on the minimap until you are outside of the zone. When disabled, the direct distance is shown on minimap opposed to distance to travel. Seems to only work before setting a waypoint.
		/// You can clear the disabled zone with CLEAR_GPS_DISABLED_ZONE_AT_INDEX.
		/// **Setting a waypoint at the same coordinate:**
		/// Disabled Zone: https://i.imgur.com/P9VUuxM.png
		/// Enabled Zone (normal): https://i.imgur.com/BPi24aw.png
		/// </summary>
		void SetGpsDisabledZoneAtIndex(float x1, float y1, float z1, float x2, float y2, float z2, int index);
		/// <summary>
		/// Clears a disabled GPS route area from a certain index previously set using `SET_GPS_DISABLED_ZONE_AT_INDEX`.
		/// </summary>
		void ClearGpsDisabledZoneAtIndex(int index);
		void AddNavmeshRequiredRegion(float x, float y, float radius);
		void RemoveNavmeshRequiredRegions();
		/// <summary>
		/// IS_*
		/// </summary>
		bool IsNavmeshRequiredRegionOwnedByAnyThread();
		void DisableNavmeshInArea(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		bool AreAllNavmeshRegionsLoaded();
		/// <summary>
		/// Returns whether navmesh for the region is loaded. The region is a rectangular prism defined by it's top left deepest corner to it's bottom right shallowest corner.
		/// If you can re-word this so it makes more sense, please do. I'm horrible with words sometimes...
		/// </summary>
		bool IsNavmeshLoadedInArea(float x1, float y1, float z1, float x2, float y2, float z2);
		int _0x01708E8DD3FF8C65(float p0, float p1, float p2, float p3, float p4, float p5);
		int AddNavmeshBlockingObject(float p0, float p1, float p2, float p3, float p4, float p5, float p6, bool p7, int p8);
		void UpdateNavmeshBlockingObject(int p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, int p8);
		void RemoveNavmeshBlockingObject(int p0);
		bool DoesNavmeshBlockingObjectExist(int p0);
		/// <summary>
		/// Returns CGameWorldHeightMap's maximum Z value at specified point (grid node).
		/// </summary>
		float GetHeightmapTopZForPosition(float x, float y);
		/// <summary>
		/// Returns CGameWorldHeightMap's maximum Z among all grid nodes that intersect with the specified rectangle.
		/// </summary>
		float GetHeightmapTopZForArea(float x1, float y1, float x2, float y2);
		/// <summary>
		/// Returns CGameWorldHeightMap's minimum Z value at specified point (grid node).
		/// </summary>
		float GetHeightmapBottomZForPosition(float x, float y);
		/// <summary>
		/// Returns CGameWorldHeightMap's minimum Z among all grid nodes that intersect with the specified rectangle.
		/// </summary>
		float GetHeightmapBottomZForArea(float x1, float y1, float x2, float y2);
		/// <summary>
		/// Calculates the travel distance between a set of points.
		/// Doesn't seem to correlate with distance on gps sometimes.
		/// </summary>
		/// <returns>This function returns the value 100000.0 over long distances, seems to be a failure mode result, potentially occurring when not all path nodes are loaded into pathfind.</returns>
		float CalculateTravelDistanceBetweenPoints(float x1, float y1, float z1, float x2, float y2, float z2);
		/// <summary>
		/// https://alloc8or.re/gta5/doc/enums/ePedType.txt
		/// Full list of peds by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/peds.json
		/// </summary>
		int CreatePed(int pedType, int modelHash, float x, float y, float z, float heading, bool isNetwork, bool bScriptHostPed);
		/// <summary>
		/// Deletes the specified ped, then sets the handle pointed to by the pointer to NULL.
		/// </summary>
		void DeletePed(ref int ped);
		int ClonePed(int ped, bool isNetwork, bool bScriptHostPed, bool copyHeadBlendFlag);
		int ClonePedEx(int ped, bool isNetwork, bool bScriptHostPed, bool copyHeadBlendFlag, bool p4);
		/// <summary>
		/// Copies ped's components and props to targetPed.
		/// </summary>
		void ClonePedToTarget(int ped, int targetPed);
		void ClonePedToTargetEx(int ped, int targetPed, bool p2);
		/// <summary>
		/// Gets a value indicating whether the specified ped is in the specified vehicle.
		/// </summary>
		/// <returns>If 'atGetIn' is false, the function will not return true until the ped is sitting in the vehicle and is about to close the door. If it's true, the function returns true the moment the ped starts to get onto the seat (after opening the door). Eg. if false, and the ped is getting into a submersible, the function will not return true until the ped has descended down into the submersible and gotten into the seat, while if it's true, it'll return true the moment the hatch has been opened and the ped is about to descend into the submersible.</returns>
		bool IsPedInVehicle(int ped, int vehicle, bool atGetIn);
		bool IsPedInModel(int ped, int modelHash);
		/// <summary>
		/// Gets a value indicating whether the specified ped is in any vehicle.
		/// </summary>
		/// <returns>If 'atGetIn' is false, the function will not return true until the ped is sitting in the vehicle and is about to close the door. If it's true, the function returns true the moment the ped starts to get onto the seat (after opening the door). Eg. if false, and the ped is getting into a submersible, the function will not return true until the ped has descended down into the submersible and gotten into the seat, while if it's true, it'll return true the moment the hatch has been opened and the ped is about to descend into the submersible.</returns>
		bool IsPedInAnyVehicle(int ped, bool atGetIn);
		/// <summary>
		/// xyz - relative to the world origin.
		/// </summary>
		bool IsCopPedInArea3d(float x1, float y1, float z1, float x2, float y2, float z2);
		/// <summary>
		/// Gets a value indicating whether this ped's health is below its injured threshold.
		/// The default threshold is 100.
		/// </summary>
		bool IsPedInjured(int ped);
		/// <summary>
		/// Returns whether the specified ped is hurt.
		/// </summary>
		bool IsPedHurt(int ped);
		/// <summary>
		/// Gets a value indicating whether this ped's health is below its fatally injured threshold. The default threshold is 100.
		/// </summary>
		/// <returns>If the handle is invalid, the function returns true.</returns>
		bool IsPedFatallyInjured(int ped);
		/// <summary>
		/// I suggest to remove "OR_DYING" part, because it does not detect dying phase.
		/// That's what the devs call it, cry about it.
		/// lol
		/// </summary>
		/// <param name="p1">is always passed 1 in the scripts.</param>
		/// <returns>Seems to consistently return true if the ped is dead.</returns>
		bool IsPedDeadOrDying(int ped, bool p1);
		bool IsConversationPedDead(int ped);
		bool IsPedAimingFromCover(int ped);
		/// <summary>
		/// Returns whether the specified ped is reloading.
		/// </summary>
		bool IsPedReloading(int ped);
		/// <summary>
		/// Returns true if the given ped has a valid pointer to CPlayerInfo in its CPed class. That's all.
		/// </summary>
		bool IsPedAPlayer(int ped);
		/// <summary>
		/// Full list of peds by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/peds.json
		/// </summary>
		/// <param name="pedType">see CREATE_PED</param>
		int CreatePedInsideVehicle(int vehicle, int pedType, int modelHash, int seat, bool isNetwork, bool bScriptHostPed);
		void SetPedDesiredHeading(int ped, float heading);
		void FreezePedCameraRotation(int ped);
		/// <summary>
		/// </summary>
		/// <param name="angle">is ped's view cone</param>
		bool IsPedFacingPed(int ped, int otherPed, float angle);
		/// <summary>
		/// A.) Swinging a random melee attack (including pistol-whipping)
		/// B.) Reacting to being hit by a melee attack (including pistol-whipping)
		/// C.) Is locked-on to an enemy (arms up, strafing/skipping in the default fighting-stance, ready to dodge+counter).
		/// You don't have to be holding the melee-targetting button to be in this stance; you stay in it by default for a few seconds after swinging at someone. If you do a sprinting punch, it returns true for the duration of the punch animation and then returns false again, even if you've punched and made-angry many peds
		/// </summary>
		/// <returns>Notes: The function only returns true while the ped is: </returns>
		bool IsPedInMeleeCombat(int ped);
		/// <summary>
		/// </summary>
		/// <returns>Returns true if the ped doesn't do any movement. If the ped is being pushed forwards by using APPLY_FORCE_TO_ENTITY for example, the function returns false.</returns>
		bool IsPedStopped(int ped);
		bool IsPedShootingInArea(int ped, float x1, float y1, float z1, float x2, float y2, float z2, bool p7, bool p8);
		bool IsAnyPedShootingInArea(float x1, float y1, float z1, float x2, float y2, float z2, bool p6, bool p7);
		/// <summary>
		/// Returns whether the specified ped is shooting.
		/// </summary>
		bool IsPedShooting(int ped);
		/// <summary>
		/// </summary>
		/// <param name="accuracy">= 0-100, 100 being perfectly accurate</param>
		void SetPedAccuracy(int ped, int accuracy);
		int GetPedAccuracy(int ped);
		/// <summary>
		/// SET_A*
		/// </summary>
		void _0x87DDEB611B329A9C(float multiplier);
		bool IsPedModel(int ped, int modelHash);
		/// <summary>
		/// Forces the ped to fall back and kills it.
		/// It doesn't really explode the ped's head but it kills the ped
		/// </summary>
		void ExplodePedHead(int ped, int weaponHash);
		/// <summary>
		/// Judging purely from a quick disassembly, if the ped is in a vehicle, the ped will be deleted immediately. If not, it'll be marked as no longer needed. - very elegant..
		/// </summary>
		void RemovePedElegantly(ref int ped);
		/// <summary>
		/// Same as SET_PED_ARMOUR, but ADDS 'amount' to the armor the Ped already has.
		/// </summary>
		void AddArmourToPed(int ped, int amount);
		/// <summary>
		/// Sets the armor of the specified ped.
		/// </summary>
		/// <param name="ped">The Ped to set the armor of.</param>
		/// <param name="amount">A value between 0 and 100 indicating the value to set the Ped's armor to.</param>
		void SetPedArmour(int ped, int amount);
		/// <summary>
		/// Seat_Index: [-1 is driver seat, -2 first free passenger seat]
		/// Moreinfo of Seat Index
		/// DriverSeat = -1
		/// Passenger = 0
		/// Left Rear = 1
		/// RightRear = 2
		/// </summary>
		/// <param name="ped">The ped to warp.</param>
		/// <param name="vehicle">The vehicle to warp the ped into.</param>
		void SetPedIntoVehicle(int ped, int vehicle, int seatIndex);
		void SetPedAllowVehiclesOverride(int ped, bool toggle);
		bool CanCreateRandomPed(bool unk);
		/// <summary>
		/// vb.net
		/// Dim ped_handle As Integer
		/// With Game.Player.Character
		/// Dim pos As Vector3 = .Position + .ForwardVector * 3
		/// ped_handle = Native.Function.Call(Of Integer)(Hash.CREATE_RANDOM_PED, pos.X, pos.Y, pos.Z)
		/// End With
		/// Ped will not act until SET_PED_AS_NO_LONGER_NEEDED is called.
		/// </summary>
		/// <returns>Creates a Ped at the specified location, returns the Ped Handle.  </returns>
		int CreateRandomPed(float posX, float posY, float posZ);
		int CreateRandomPedAsDriver(int vehicle, bool returnHandle);
		bool CanCreateRandomDriver();
		bool CanCreateRandomBikeRider();
		void SetPedMoveAnimsBlendOut(int ped);
		void SetPedCanBeDraggedOut(int ped, bool toggle);
		/// <summary>
		/// SET_PED_ALLOW*
		/// The one time this is set to true seems to do with when you fail the mission.
		/// </summary>
		/// <param name="toggle">was always false except in one instance (b678).</param>
		void _0xF2BEBCDFAFDAA19E(bool toggle);
		/// <summary>
		/// Returns true/false if the ped is/isn't male.
		/// </summary>
		bool IsPedMale(int ped);
		/// <summary>
		/// Returns true/false if the ped is/isn't humanoid.
		/// </summary>
		bool IsPedHuman(int ped);
		/// <summary>
		/// If the Ped is not in a vehicle and includeLastVehicle is true, the vehicle they were last in is returned.
		/// </summary>
		/// <returns>Gets the vehicle the specified Ped is in. Returns 0 if the ped is/was not in a vehicle.</returns>
		int GetVehiclePedIsIn(int ped, bool includeLastVehicle);
		/// <summary>
		/// Resets the value for the last vehicle driven by the Ped.
		/// </summary>
		void ResetPedLastVehicle(int ped);
		void SetPedDensityMultiplierThisFrame(float multiplier);
		void SetScenarioPedDensityMultiplierThisFrame(float p0, float p1);
		void _0x5A7F62FDA59759BD();
		void SetScriptedConversionCoordThisFrame(float x, float y, float z);
		/// <summary>
		/// The distance between these points, is the diagonal of a box (remember it's 3D).
		/// </summary>
		void SetPedNonCreationArea(float x1, float y1, float z1, float x2, float y2, float z2);
		void ClearPedNonCreationArea();
		void InstantlyFillPedPopulation();
		/// <summary>
		/// </summary>
		/// <returns>Same function call as PED::GET_MOUNT, aka just returns 0</returns>
		bool IsPedOnMount(int ped);
		/// <summary>
		/// void __fastcall ped__get_mount(NativeContext *a1)
		/// {
		/// NativeContext *v1; // rbx@1
		/// v1 = a1;
		/// GetAddressOfPedFromScriptHandle(a1->Args->Arg1);
		/// v1->Returns->Item1= 0;
		/// }
		/// </summary>
		/// <returns>Function just returns 0</returns>
		int GetMount(int ped);
		/// <summary>
		/// Gets a value indicating whether the specified ped is on top of any vehicle.
		/// Return 1 when ped is on vehicle.
		/// Return 0 when ped is not on a vehicle.
		/// </summary>
		bool IsPedOnVehicle(int ped);
		bool IsPedOnSpecificVehicle(int ped, int vehicle);
		/// <summary>
		/// Maximum possible amount of money on MP is 2000. ~JX
		/// -----------------------------------------------------------------------------
		/// Maximum amount that a ped can theoretically have is 65535 (0xFFFF) since the amount is stored as an unsigned short (uint16_t) value.
		/// </summary>
		void SetPedMoney(int ped, int amount);
		int GetPedMoney(int ped);
		/// <summary>
		/// Related to Peds dropping pickup_health_snack; p0 is a value between [0.0, 1.0] that corresponds to drop rate
		/// </summary>
		void _0xFF4803BC019852D9(float p0, int p1);
		void SetAmbientPedsDropMoney(bool p0);
		void _0x9911F4A24485F653(bool p0);
		/// <summary>
		/// Example: Headshotting a player no longer one shots them. Instead they will take the same damage as a torso shot.
		/// </summary>
		/// <param name="ped">no longer takes critical damage modifiers if set to FALSE.</param>
		void SetPedSuffersCriticalHits(int ped, bool toggle);
		/// <summary>
		/// SET_PED_*
		/// </summary>
		void _0xAFC976FD0580C7B3(int ped, bool toggle);
		/// <summary>
		/// Detect if ped is sitting in the specified vehicle
		/// [True/False]
		/// </summary>
		bool IsPedSittingInVehicle(int ped, int vehicle);
		/// <summary>
		/// Detect if ped is in any vehicle
		/// [True/False]
		/// </summary>
		bool IsPedSittingInAnyVehicle(int ped);
		bool IsPedOnFoot(int ped);
		bool IsPedOnAnyBike(int ped);
		bool IsPedPlantingBomb(int ped);
		Vector3 GetDeadPedPickupCoords(int ped, float p1, float p2);
		bool IsPedInAnyBoat(int ped);
		bool IsPedInAnySub(int ped);
		bool IsPedInAnyHeli(int ped);
		bool IsPedInAnyPlane(int ped);
		bool IsPedInFlyingVehicle(int ped);
		void SetPedDiesInWater(int ped, bool toggle);
		void SetPedDiesInSinkingVehicle(int ped, bool toggle);
		int GetPedArmour(int ped);
		void SetPedStayInVehicleWhenJacked(int ped, bool toggle);
		void SetPedCanBeShotInVehicle(int ped, bool toggle);
		/// <summary>
		/// </summary>
		bool GetPedLastDamageBone(int ped, ref int outBone);
		void ClearPedLastDamageBone(int ped);
		void SetAiWeaponDamageModifier(float value);
		void ResetAiWeaponDamageModifier();
		void SetAiMeleeWeaponDamageModifier(float modifier);
		void ResetAiMeleeWeaponDamageModifier();
		void _0x2F3C3D9F50681DE4(int p0, bool p1);
		void SetPedCanBeTargetted(int ped, bool toggle);
		void SetPedCanBeTargettedByTeam(int ped, int team, bool toggle);
		void SetPedCanBeTargettedByPlayer(int ped, int player, bool toggle);
		void _0x061CB768363D6424(int ped, bool toggle);
		void _0xFD325494792302D7(int ped, bool toggle);
		bool IsPedInAnyPoliceVehicle(int ped);
		void ForcePedToOpenParachute(int ped);
		bool IsPedInParachuteFreeFall(int ped);
		bool IsPedFalling(int ped);
		bool IsPedJumping(int ped);
		int _0x412F1364FA066CFB(int p0);
		int _0x451D05012CCEC234(int p0);
		bool IsPedClimbing(int ped);
		bool IsPedVaulting(int ped);
		bool IsPedDiving(int ped);
		bool IsPedJumpingOutOfVehicle(int ped);
		/// <summary>
		/// IS_PED_*
		/// Returns true if the ped is currently opening a door (CTaskOpenDoor).
		/// </summary>
		bool IsPedOpeningADoor(int ped);
		/// <summary>
		/// Returns:
		/// -1: Normal
		/// 0: Wearing parachute on back
		/// 1: Parachute opening
		/// 2: Parachute open
		/// 3: Falling to doom (e.g. after exiting parachute)
		/// Normal means no parachute?
		/// </summary>
		int GetPedParachuteState(int ped);
		/// <summary>
		/// -1: no landing
		/// 0: landing on both feet
		/// 1: stumbling
		/// 2: rolling
		/// 3: ragdoll
		/// </summary>
		int GetPedParachuteLandingType(int ped);
		void SetPedParachuteTintIndex(int ped, int tintIndex);
		/// <summary>
		/// </summary>
		void GetPedParachuteTintIndex(int ped, ref int outTintIndex);
		void SetPedReserveParachuteTintIndex(int ped, int p1);
		int CreateParachuteBagObject(int ped, bool p1, bool p2);
		/// <summary>
		/// </summary>
		/// <returns>This is the SET_CHAR_DUCKING from GTA IV, that makes Peds duck. This function does nothing in GTA V. It cannot set the ped as ducking in vehicles, and IS_PED_DUCKING will always return false.</returns>
		void SetPedDucking(int ped, bool toggle);
		bool IsPedDucking(int ped);
		bool IsPedInAnyTaxi(int ped);
		void SetPedIdRange(int ped, float value);
		void SetPedHighlyPerceptive(int ped, bool toggle);
		void _0x2F074C904D85129E(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		/// <summary>
		/// SET_PED_*
		/// Has most likely to do with some shooting attributes as it sets the float which is in the same range as shootRate.
		/// </summary>
		void _0xEC4B4B3B9908052A(int ped, float unk);
		void _0x733C87D4CE22BEA2(int p0);
		void SetPedSeeingRange(int ped, float value);
		void SetPedHearingRange(int ped, float value);
		void SetPedVisualFieldMinAngle(int ped, float value);
		void SetPedVisualFieldMaxAngle(int ped, float value);
		/// <summary>
		/// This native refers to the field of vision the ped has below them, starting at 0 degrees. The angle value should be negative.
		/// -90f should let the ped see 90 degrees below them, for example.
		/// </summary>
		void SetPedVisualFieldMinElevationAngle(int ped, float angle);
		/// <summary>
		/// This native refers to the field of vision the ped has above them, starting at 0 degrees. 90f would let the ped see enemies directly above of them.
		/// </summary>
		void SetPedVisualFieldMaxElevationAngle(int ped, float angle);
		void SetPedVisualFieldPeripheralRange(int ped, float range);
		void SetPedVisualFieldCenterAngle(int ped, float angle);
		float GetPedVisualFieldCenterAngle(int ped);
		/// <summary>
		/// </summary>
		/// <param name="p1">is usually 0 in the scripts. action is either 0 or a pointer to "DEFAULT_ACTION".</param>
		void SetPedStealthMovement(int ped, bool p1, string action);
		/// <summary>
		/// Returns whether the entity is in stealth mode
		/// </summary>
		bool GetPedStealthMovement(int ped);
		/// <summary>
		/// Creates a new ped group.
		/// Groups can contain up to 8 peds.
		/// The parameter is unused.
		/// Returns a handle to the created group, or 0 if a group couldn't be created.
		/// </summary>
		int CreateGroup(int unused);
		void SetPedAsGroupLeader(int ped, int groupId);
		void SetPedAsGroupMember(int ped, int groupId);
		/// <summary>
		/// This only will teleport the ped to the group leader if the group leader teleports (sets coords).
		/// Only works in singleplayer
		/// </summary>
		void SetPedCanTeleportToGroupLeader(int pedHandle, int groupHandle, bool toggle);
		void RemoveGroup(int groupId);
		void RemovePedFromGroup(int ped);
		bool IsPedGroupMember(int ped, int groupId);
		bool IsPedHangingOnToVehicle(int ped);
		/// <summary>
		/// Sets the range at which members will automatically leave the group.
		/// </summary>
		void SetGroupSeparationRange(int groupHandle, float separationRange);
		/// <summary>
		/// </summary>
		/// <param name="ped">will stay on the ground after being stunned for at lest ms time. (in milliseconds)</param>
		void SetPedMinGroundTimeForStungun(int ped, int ms);
		bool IsPedProne(int ped);
		/// <summary>
		/// </summary>
		/// <param name="target">is usually 0 in the scripts because it gets the ped id during the task sequence. For instance: PED::IS_PED_IN_COMBAT(l_42E[414], PLAYER::PLAYER_PED_ID()) // armenian2.ct4: 43794</param>
		/// <returns>Checks to see if ped and target are in combat with eachother. Only goes one-way: if target is engaged in combat with ped but ped has not yet reacted, the function will return false until ped starts fighting back.</returns>
		bool IsPedInCombat(int ped, int target);
		int GetPedTaskCombatTarget(int ped, int p1);
		bool CanPedInCombatSeeTarget(int ped, int target);
		bool IsPedDoingDriveby(int ped);
		bool IsPedJacking(int ped);
		bool IsPedBeingJacked(int ped);
		/// <summary>
		/// </summary>
		/// <param name="p1">is always 0</param>
		bool IsPedBeingStunned(int ped, int p1);
		int GetPedsJacker(int ped);
		int GetJackTarget(int ped);
		bool IsPedFleeing(int ped);
		/// <summary>
		/// </summary>
		/// <param name="exceptUseWeapon">is nearly always 0 in the scripts.</param>
		bool IsPedInCover(int ped, bool exceptUseWeapon);
		bool IsPedInCoverFacingLeft(int ped);
		bool IsPedInHighCover(int ped);
		bool IsPedGoingIntoCover(int ped);
		/// <summary>
		/// </summary>
		/// <param name="i">could be time. Only example in the decompiled scripts uses it as -1.</param>
		int SetPedPinnedDown(int ped, bool pinned, int i);
		int GetSeatPedIsTryingToEnter(int ped);
		int GetVehiclePedIsTryingToEnter(int ped);
		/// <summary>
		/// Returns the Entity (Ped, Vehicle, or ?Object?) that killed the 'ped'
		/// Is best to check if the Ped is dead before asking for its killer.
		/// </summary>
		int GetPedSourceOfDeath(int ped);
		/// <summary>
		/// Returns the hash of the weapon/model/object that killed the ped.
		/// </summary>
		int GetPedCauseOfDeath(int ped);
		int GetPedTimeOfDeath(int ped);
		int _0x5407B7288D0478B7(int p0);
		int _0x336B3D200AB007CB(int p0, float p1, float p2, float p3, float p4);
		void SetPedRelationshipGroupDefaultHash(int ped, int hash);
		void SetPedRelationshipGroupHash(int ped, int hash);
		/// <summary>
		/// Sets the relationship between two groups. This should be called twice (once for each group).
		/// 0 = Companion
		/// 1 = Respect
		/// 2 = Like
		/// 3 = Neutral
		/// 4 = Dislike
		/// 5 = Hate
		/// 255 = Pedestrians
		/// Example:
		/// See NativeDB for reference: http://natives.altv.mp/#/0xBF25EB89375A37AD
		/// </summary>
		/// <param name="relationship">types:</param>
		void SetRelationshipBetweenGroups(int relationship, int group1, int group2);
		/// <summary>
		/// Clears the relationship between two groups. This should be called twice (once for each group).
		/// 0 = Companion
		/// 1 = Respect
		/// 2 = Like
		/// 3 = Neutral
		/// 4 = Dislike
		/// 5 = Hate
		/// 255 = Pedestrians
		/// (Credits: Inco)
		/// See NativeDB for reference: http://natives.altv.mp/#/0x5E29243FB56FC6D4
		/// </summary>
		/// <param name="relationship">types:</param>
		void ClearRelationshipBetweenGroups(int relationship, int group1, int group2);
		/// <summary>
		/// </summary>
		/// <returns>Can't select void. This function returns nothing. The hash of the created relationship group is output in the second parameter.</returns>
		int AddRelationshipGroup(string name, ref int groupHash);
		void RemoveRelationshipGroup(int groupHash);
		bool DoesRelationshipGroupExist(int groupHash);
		/// <summary>
		/// Gets the relationship between two peds. This should be called twice (once for each ped).
		/// Relationship types:
		/// 0 = Companion
		/// 1 = Respect
		/// 2 = Like
		/// 3 = Neutral
		/// 4 = Dislike
		/// 5 = Hate
		/// 255 = Pedestrians
		/// See NativeDB for reference: http://natives.altv.mp/#/0xEBA5AD3A0EAF7121
		/// </summary>
		int GetRelationshipBetweenPeds(int ped1, int ped2);
		int GetPedRelationshipGroupDefaultHash(int ped);
		int GetPedRelationshipGroupHash(int ped);
		/// <summary>
		/// Gets the relationship between two groups. This should be called twice (once for each group).
		/// Relationship types:
		/// 0 = Companion
		/// 1 = Respect
		/// 2 = Like
		/// 3 = Neutral
		/// 4 = Dislike
		/// 5 = Hate
		/// 255 = Pedestrians
		/// See NativeDB for reference: http://natives.altv.mp/#/0x9E6B70061662AE5C
		/// </summary>
		int GetRelationshipBetweenGroups(int group1, int group2);
		void SetRelationshipGroupDontAffectWantedLevel(int group, bool p1);
		/// <summary>
		/// Does something with ped relationships
		/// </summary>
		void _0xAD27D957598E49E9(int ped, int p1, float p2, int hash, int p4, int p5);
		void SetPedCanBeTargetedWithoutLos(int ped, bool toggle);
		void SetPedToInformRespectedFriends(int ped, float radius, int maxFriends);
		bool IsPedRespondingToEvent(int ped, int @event);
		/// <summary>
		/// </summary>
		bool GetPedEventData(int ped, int eventType, ref int outData);
		/// <summary>
		/// FIRING_PATTERN_BURST_FIRE = 0xD6FF6D61 ( 1073727030 )
		/// FIRING_PATTERN_BURST_FIRE_IN_COVER = 0x026321F1 ( 40051185 )
		/// FIRING_PATTERN_BURST_FIRE_DRIVEBY = 0xD31265F2 ( -753768974 )
		/// FIRING_PATTERN_FROM_GROUND = 0x2264E5D6 ( 577037782 )
		/// FIRING_PATTERN_DELAY_FIRE_BY_ONE_SEC = 0x7A845691 ( 2055493265 )
		/// FIRING_PATTERN_FULL_AUTO = 0xC6EE6B4C ( -957453492 )
		/// FIRING_PATTERN_SINGLE_SHOT = 0x5D60E4E0 ( 1566631136 )
		/// FIRING_PATTERN_BURST_FIRE_PISTOL = 0xA018DB8A ( -1608983670 )
		/// FIRING_PATTERN_BURST_FIRE_SMG = 0xD10DADEE ( 1863348768 )
		/// See NativeDB for reference: http://natives.altv.mp/#/0x9AC577F5A12AD8A9
		/// </summary>
		void SetPedFiringPattern(int ped, int patternHash);
		/// <summary>
		/// </summary>
		/// <param name="shootRate">0-1000</param>
		void SetPedShootRate(int ped, int shootRate);
		/// <summary>
		/// </summary>
		/// <param name="combatType">can be between 0-14. See GET_COMBAT_FLOAT below for a list of possible parameters.</param>
		void SetCombatFloat(int ped, int combatType, float p2);
		/// <summary>
		/// p1 probably refers to the attributes configured in combatbehavior.meta. There are 13. Example:
		/// <BlindFireChance value="0.1"/>
		/// <WeaponShootRateModifier value="1.0"/>
		/// <TimeBetweenBurstsInCover value="1.25"/>
		/// <BurstDurationInCover value="2.0"/>
		/// <TimeBetweenPeeks value="10.0"/>
		/// <WeaponAccuracy value="0.18"/>
		/// <FightProficiency value="0.8"/>
		/// <StrafeWhenMovingChance value="1.0"/>
		/// See NativeDB for reference: http://natives.altv.mp/#/0x52DFF8A10508090A
		/// </summary>
		/// <param name="ped">Ped Handle</param>
		/// <param name="p1">int i | 0 <= i <= 27</param>
		float GetCombatFloat(int ped, int p1);
		/// <summary>
		/// </summary>
		/// <param name="unknown">may be a BOOL representing whether or not the group even exists</param>
		void GetGroupSize(int groupID, ref int unknown, ref int sizeInMembers);
		bool DoesGroupExist(int groupId);
		/// <summary>
		/// Returns the group id of which the specified ped is a member of.
		/// </summary>
		int GetPedGroupIndex(int ped);
		bool IsPedInGroup(int ped);
		int GetPlayerPedIsFollowing(int ped);
		/// <summary>
		/// 0: Default
		/// 1: Circle Around Leader
		/// 2: Alternative Circle Around Leader
		/// 3: Line, with Leader at center
		/// </summary>
		void SetGroupFormation(int groupId, int formationType);
		void SetGroupFormationSpacing(int groupId, float p1, float p2, float p3);
		void ResetGroupFormationDefaultSpacing(int groupHandle);
		/// <summary>
		/// Gets ID of vehicle player using. It means it can get ID at any interaction with vehicle. Enter\exit for example. And that means it is faster than GET_VEHICLE_PED_IS_IN but less safe.
		/// </summary>
		int GetVehiclePedIsUsing(int ped);
		int GetVehiclePedIsEntering(int ped);
		/// <summary>
		/// enable or disable the gravity of a ped
		/// Examples:
		/// PED::SET_PED_GRAVITY(Local_289[iVar0 20], 0x00000001);
		/// </summary>
		/// <param name="ped">:SET_PED_GRAVITY(PLAYER::PLAYER_PED_ID(), 0x00000001);</param>
		void SetPedGravity(int ped, bool toggle);
		/// <summary>
		/// damages a ped with the given amount
		/// </summary>
		void ApplyDamageToPed(int ped, int damageAmount, bool p2, int p3);
		/// <summary>
		/// GET_TIME_*
		/// </summary>
		int GetTimeOfLastPedWeaponDamage(int ped, int weaponHash);
		void SetPedAllowedToDuck(int ped, bool toggle);
		void SetPedNeverLeavesGroup(int ped, bool toggle);
		/// <summary>
		/// https://alloc8or.re/gta5/doc/enums/ePedType.txt
		/// </summary>
		int GetPedType(int ped);
		/// <summary>
		/// </summary>
		/// <param name="ped">vision</param>
		void SetPedAsCop(int ped, bool toggle);
		/// <summary>
		/// sets the maximum health of a ped
		/// I think it's never been used in any script
		/// </summary>
		void SetPedMaxHealth(int ped, int value);
		int GetPedMaxHealth(int ped);
		void SetPedMaxTimeInWater(int ped, float value);
		void SetPedMaxTimeUnderwater(int ped, float value);
		void _0x2735233A786B1BEF(int ped, float p1);
		/// <summary>
		/// </summary>
		/// <param name="seatIndex">must be <= 2</param>
		void SetPedVehicleForcedSeatUsage(int ped, int vehicle, int seatIndex, int flags, int p4);
		void ClearAllPedVehicleForcedSeatUsage(int ped);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void _0xB282749D5E028163(int p0, int p1);
		/// <summary>
		/// </summary>
		/// <param name="state">https://alloc8or.re/gta5/doc/enums/eKnockOffVehicle.txt</param>
		void SetPedCanBeKnockedOffVehicle(int ped, int state);
		bool CanKnockPedOffVehicle(int ped);
		void KnockPedOffVehicle(int ped);
		void SetPedCoordsNoGang(int ped, float posX, float posY, float posZ);
		/// <summary>
		/// from fm_mission_controller.c4 (variable names changed for clarity):
		/// int groupID = PLAYER::GET_PLAYER_GROUP(PLAYER::PLAYER_ID());
		/// PED::GET_GROUP_SIZE(group, &unused, &groupSize);
		/// if (groupSize >= 1) {
		/// . . . . for (int memberNumber = 0; memberNumber < groupSize; memberNumber++) {
		/// . . . . . . . . //and so on
		/// </summary>
		/// <param name="groupID">PED::GET_PED_AS_GROUP_MEMBER(groupID, memberNumber);</param>
		int GetPedAsGroupMember(int groupID, int memberNumber);
		int GetPedAsGroupLeader(int groupID);
		void SetPedKeepTask(int ped, bool toggle);
		/// <summary>
		/// SET_PED_ALLOW*
		/// </summary>
		void _0x49E50BDB8BA4DAB2(int ped, bool toggle);
		bool IsPedSwimming(int ped);
		bool IsPedSwimmingUnderWater(int ped);
		/// <summary>
		/// teleports ped to coords along with the vehicle ped is in
		/// </summary>
		void SetPedCoordsKeepVehicle(int ped, float posX, float posY, float posZ);
		void SetPedDiesInVehicle(int ped, bool toggle);
		void SetCreateRandomCops(bool toggle);
		void SetCreateRandomCopsNotOnScenarios(bool toggle);
		void SetCreateRandomCopsOnScenarios(bool toggle);
		bool CanCreateRandomCops();
		void SetPedAsEnemy(int ped, bool toggle);
		void SetPedCanSmashGlass(int ped, bool p1, bool p2);
		bool IsPedInAnyTrain(int ped);
		bool IsPedGettingIntoAVehicle(int ped);
		bool IsPedTryingToEnterALockedVehicle(int ped);
		/// <summary>
		/// </summary>
		/// <param name="ped">can not pull out a weapon when true</param>
		void SetEnableHandcuffs(int ped, bool toggle);
		/// <summary>
		/// Used with SET_ENABLE_HANDCUFFS in decompiled scripts. From my observations, I have noticed that while being ragdolled you are not able to get up but you can still run. Your legs can also bend.
		/// </summary>
		void SetEnableBoundAnkles(int ped, bool toggle);
		/// <summary>
		/// Enables diving motion when underwater.
		/// </summary>
		void SetEnableScuba(int ped, bool toggle);
		/// <summary>
		/// Setting ped to true allows the ped to shoot "friendlies".
		/// p1 = true & p2 = false for able to aim at.
		/// </summary>
		/// <param name="toggle">= false & p2 = false for unable to aim at.</param>
		/// <param name="p2">set to true when toggle is also true seams to make peds permanently unable to aim at, even if you set p2 back to false.</param>
		void SetCanAttackFriendly(int ped, bool toggle, bool p2);
		/// <summary>
		/// Returns the ped's alertness (0-3).
		/// Values :
		/// 0 : Neutral
		/// 1 : Heard something (gun shot, hit, etc)
		/// 2 : Knows (the origin of the event)
		/// 3 : Fully alerted (is facing the event?)
		/// </summary>
		/// <returns>If the Ped does not exist, returns -1.</returns>
		int GetPedAlertness(int ped);
		/// <summary>
		/// </summary>
		/// <param name="value">ranges from 0 to 3.</param>
		void SetPedAlertness(int ped, int value);
		void SetPedGetOutUpsideDownVehicle(int ped, bool toggle);
		/// <summary>
		/// List of movement clipsets:
		/// Thanks to elsewhat for list.
		/// "ANIM_GROUP_MOVE_BALLISTIC"
		/// "ANIM_GROUP_MOVE_LEMAR_ALLEY"
		/// "clipset@move@trash_fast_turn"
		/// "FEMALE_FAST_RUNNER"
		/// "missfbi4prepp1_garbageman"
		/// "move_characters@franklin@fire"
		/// "move_characters@Jimmy@slow@"
		/// See NativeDB for reference: http://natives.altv.mp/#/0xAF8A94EDE7712BEF
		/// </summary>
		/// <param name="transitionSpeed">is the time in seconds it takes to transition from one movement clipset to another.	ransitionSpeed is usually 1.0f</param>
		void SetPedMovementClipset(int ped, string clipSet, float transitionSpeed);
		/// <summary>
		/// If p1 is 0.0, I believe you are back to normal.
		/// If p1 is 1.0, it looks like you can only rotate the ped, not walk.
		/// Using the following code to reset back to normal
		/// </summary>
		/// <param name="ped">:RESET_PED_MOVEMENT_CLIPSET(PLAYER::PLAYER_PED_ID(), 0.0);</param>
		void ResetPedMovementClipset(int ped, float p1);
		/// <summary>
		/// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
		/// </summary>
		void SetPedStrafeClipset(int ped, string clipSet);
		void ResetPedStrafeClipset(int ped);
		void SetPedWeaponMovementClipset(int ped, string clipSet);
		void ResetPedWeaponMovementClipset(int ped);
		void SetPedDriveByClipsetOverride(int ped, string clipset);
		void ClearPedDriveByClipsetOverride(int ped);
		/// <summary>
		/// Found in the b617d scripts:
		/// SET_PED_MO*
		/// </summary>
		/// <param name="ped">:_9DBA107B4937F809(v_7, "trevor_heist_cover_2h");</param>
		void SetPedCoverClipsetOverride(int ped, string p1);
		/// <summary>
		/// CLEAR_PED_*
		/// </summary>
		void ClearPedCoverClipsetOverride(int ped);
		/// <summary>
		/// CLEAR_PED_*
		/// </summary>
		void _0x80054D7FCC70EEC6(int ped);
		/// <summary>
		/// PED::SET_PED_IN_VEHICLE_CONTEXT(l_128, MISC::GET_HASH_KEY("MINI_PROSTITUTE_LOW_RESTRICTED_PASSENGER"));
		/// PED::SET_PED_IN_VEHICLE_CONTEXT(l_3212, MISC::GET_HASH_KEY("MISS_FAMILY1_JIMMY_SIT"));
		/// PED::SET_PED_IN_VEHICLE_CONTEXT(l_3212, MISC::GET_HASH_KEY("MISS_FAMILY1_JIMMY_SIT_REAR"));
		/// PED::SET_PED_IN_VEHICLE_CONTEXT(l_95, MISC::GET_HASH_KEY("MISS_FAMILY2_JIMMY_BICYCLE"));
		/// PED::SET_PED_IN_VEHICLE_CONTEXT(num3, MISC::GET_HASH_KEY("MISSFBI2_MICHAEL_DRIVEBY"));
		/// PED::SET_PED_IN_VEHICLE_CONTEXT(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("MISS_ARMENIAN3_FRANKLIN_TENSE"));
		/// PED::SET_PED_IN_VEHICLE_CONTEXT(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("MISSFBI5_TREVOR_DRIVING"));
		/// </summary>
		/// <param name="ped">:SET_PED_IN_VEHICLE_CONTEXT(l_128, MISC::GET_HASH_KEY("MINI_PROSTITUTE_LOW_PASSENGER"));</param>
		void SetPedInVehicleContext(int ped, int context);
		void ResetPedInVehicleContext(int ped);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		bool IsScriptedScenarioPedUsingConditionalAnim(int ped, string animDict, string anim);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
		/// </summary>
		void SetPedAlternateWalkAnim(int ped, string animDict, string animName, float p3, bool p4);
		void ClearPedAlternateWalkAnim(int ped, float p1);
		/// <summary>
		/// 0 = idle
		/// 1 = walk
		/// 2 = running
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
		/// </summary>
		/// <param name="p5">= usually set to true</param>
		void SetPedAlternateMovementAnim(int ped, int stance, string animDictionary, string animationName, float p4, bool p5);
		void ClearPedAlternateMovementAnim(int ped, int stance, float p2);
		/// <summary>
		/// From the scripts:
		/// "ANIM_GROUP_GESTURE_MISS_FRA0");
		/// PED::SET_PED_GESTURE_GROUP(PLAYER::PLAYER_PED_ID(),
		/// "ANIM_GROUP_GESTURE_MISS_DocksSetup1");
		/// </summary>
		/// <param name="ped">:SET_PED_GESTURE_GROUP(PLAYER::PLAYER_PED_ID(),</param>
		void SetPedGestureGroup(int ped, string animGroupGesture);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		Vector3 GetAnimInitialOffsetPosition(string animDict, string animName, float x, float y, float z, float xRot, float yRot, float zRot, float p8, int p9);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		Vector3 GetAnimInitialOffsetRotation(string animDict, string animName, float x, float y, float z, float xRot, float yRot, float zRot, float p8, int p9);
		/// <summary>
		/// Ids
		/// 0 - Head
		/// 1 - Beard
		/// 2 - Hair
		/// 3 - Torso
		/// 4 - Legs
		/// 5 - Hands
		/// 6 - Foot
		/// 7 - ------
		/// See NativeDB for reference: http://natives.altv.mp/#/0x67F3780DD425D4FC
		/// </summary>
		int GetPedDrawableVariation(int ped, int componentId);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		int GetNumberOfPedDrawableVariations(int ped, int componentId);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		int GetPedTextureVariation(int ped, int componentId);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		int GetNumberOfPedTextureVariations(int ped, int componentId, int drawableId);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		int GetNumberOfPedPropDrawableVariations(int ped, int propId);
		/// <summary>
		/// Need to check behavior when drawableId = -1
		/// - Doofy.Ass
		/// GET_NUMBER_OF_PED_PROP_TEXTURE_VARIATIONS(PLAYER.PLAYER_PED_ID(), 0, 5)
		/// tick: scripts/addins/menu_execute.lua:51: attempt to call field 'GET_NUMBER_OF_PED_PROP_TEXTURE_VARIATIONS' (a nil value)
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		/// <returns>Why this function doesn't work and return nill value?</returns>
		int GetNumberOfPedPropTextureVariations(int ped, int propId, int drawableId);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		int GetPedPaletteVariation(int ped, int componentId);
		/// <summary>
		/// </summary>
		bool _0x9E30E91FB03A2CAF(ref int p0, ref int p1);
		/// <summary>
		/// GET_*
		/// </summary>
		int _0x1E77FA7A62EE6C4C(int p0);
		/// <summary>
		/// GET_*
		/// </summary>
		int _0xF033419D1B81FAE8(int p0);
		/// <summary>
		/// Checks if the component variation is valid, this works great for randomizing components using loops.
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// Full list of ped components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedComponentVariations.json
		/// </summary>
		bool IsPedComponentVariationValid(int ped, int componentId, int drawableId, int textureId);
		/// <summary>
		/// enum ePedVarComp
		/// {
		/// PV_COMP_INVALID = -1,
		/// PV_COMP_HEAD,
		/// PV_COMP_BERD,
		/// PV_COMP_HAIR,
		/// PV_COMP_UPPR,
		/// PV_COMP_LOWR,
		/// PV_COMP_HAND,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x262B14F48D29DE80
		/// </summary>
		/// <param name="paletteId">0 to 3.</param>
		void SetPedComponentVariation(int ped, int componentId, int drawableId, int textureId, int paletteId);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		/// <param name="p1">is always 0 in R* scripts.</param>
		void SetPedRandomComponentVariation(int ped, int p1);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		void SetPedRandomProps(int ped);
		/// <summary>
		/// Sets Ped Default Clothes
		/// </summary>
		void SetPedDefaultComponentVariation(int ped);
		void SetPedBlendFromParents(int ped, int p1, int p2, float p3, float p4);
		/// <summary>
		/// The "shape" parameters control the shape of the ped's face. The "skin" parameters control the skin tone. ShapeMix and skinMix control how much the first and second IDs contribute,(typically mother and father.) ThirdMix overrides the others in favor of the third IDs. IsParent is set for "children" of the player character's grandparents during old-gen character creation. It has unknown effect otherwise.
		/// The IDs start at zero and go Male Non-DLC, Female Non-DLC, Male DLC, and Female DLC.
		/// !!!Can someone add working example for this???
		/// try this:
		/// headBlendData headData;
		/// GET_PED_HEAD_BLEND_DATA(PLAYER_PED_ID(), &headData);
		/// SET_PED_HEAD_BLEND_DATA(PLAYER_PED_ID(), headData.shapeFirst, headData.shapeSecond, headData.shapeThird, headData.skinFirst, headData.skinSecond
		/// , headData.skinThird, headData.shapeMix, headData.skinMix, headData.skinThird, 0);
		/// For more info please refer to this topic.
		/// gtaforums.com/topic/858970-all-gtao-face-ids-pedset-ped-head-blend-data-explained
		/// </summary>
		void SetPedHeadBlendData(int ped, int shapeFirstID, int shapeSecondID, int shapeThirdID, int skinFirstID, int skinSecondID, int skinThirdID, float shapeMix, float skinMix, float thirdMix, bool isParent);
		/// <summary>
		/// The pointer is to a padded struct that matches the arguments to SET_PED_HEAD_BLEND_DATA(...). There are 4 bytes of padding after each field.
		/// pass this struct in the second parameter
		/// typedef struct
		/// {
		/// int shapeFirst, shapeSecond, shapeThird;
		/// int skinFirst, skinSecond, skinThird;
		/// float shapeMix, skinMix, thirdMix;
		/// } headBlendData;
		/// </summary>
		bool GetPedHeadBlendData(int ped, ref int headBlendData);
		/// <summary>
		/// See SET_PED_HEAD_BLEND_DATA().
		/// </summary>
		void UpdatePedHeadBlendData(int ped, float shapeMix, float skinMix, float thirdMix);
		/// <summary>
		/// Used for freemode (online) characters.
		/// For some reason, the scripts use a rounded float for the index.
		/// Indexes:
		/// 1. black
		/// 2. very light blue/green
		/// 3. dark blue
		/// 4. brown
		/// 5. darker brown
		/// 6. light brown
		/// See NativeDB for reference: http://natives.altv.mp/#/0x50B56988B170AFDF
		/// </summary>
		void SetPedEyeColor(int ped, int index);
		/// <summary>
		/// </summary>
		/// <returns>A getter for _SET_PED_EYE_COLOR. Returns -1 if fails to get.</returns>
		int GetPedEyeColor(int ped);
		/// <summary>
		/// overlayID       Part                  Index, to disable
		/// 0               Blemishes             0 - 23, 255
		/// 1               Facial Hair           0 - 28, 255
		/// 2               Eyebrows              0 - 33, 255
		/// 3               Ageing                0 - 14, 255
		/// 4               Makeup                0 - 74, 255
		/// 5               Blush                 0 - 6, 255
		/// 6               Complexion            0 - 11, 255
		/// 7               Sun Damage            0 - 10, 255
		/// See NativeDB for reference: http://natives.altv.mp/#/0x48F44967FA05CC1E
		/// </summary>
		/// <param name="overlayID">ranges from 0 to 12, index from 0 to _GET_NUM_OVERLAY_VALUES(overlayID)-1, and opacity from 0.0 to 1.0.</param>
		void SetPedHeadOverlay(int ped, int overlayID, int index, float opacity);
		/// <summary>
		/// This might be the once removed native GET_PED_HEAD_OVERLAY.
		/// </summary>
		/// <returns>Likely a char, if that overlay is not set, e.i. "None" option, returns 255;</returns>
		int GetPedHeadOverlayValue(int ped, int overlayID);
		/// <summary>
		/// Used with freemode (online) characters.
		/// </summary>
		int GetPedHeadOverlayNum(int overlayID);
		/// <summary>
		/// Used for freemode (online) characters.
		/// Called after SET_PED_HEAD_OVERLAY().
		/// </summary>
		/// <param name="colorType">is 1 for eyebrows, beards, and chest hair; 2 for blush and lipstick; and 0 otherwise, though not called in those cases.</param>
		void SetPedHeadOverlayColor(int ped, int overlayID, int colorType, int colorID, int secondColorID);
		/// <summary>
		/// Used for freemode (online) characters.
		/// </summary>
		void SetPedHairColor(int ped, int colorID, int highlightColorID);
		/// <summary>
		/// Used for freemode (online) characters.
		/// </summary>
		int GetNumHairColors();
		int GetNumMakeupColors();
		/// <summary>
		/// Input: Haircolor index, value between 0 and 63 (inclusive).
		/// Output: RGB values for the haircolor specified in the input.
		/// This is used with the hair color swatches scaleform.
		/// Use `_0x013E5CFC38CD5387` to get the makeup colors.
		/// </summary>
		void GetPedHairRgbColor(int hairColorIndex, ref int outR, ref int outG, ref int outB);
		/// <summary>
		/// Input: Makeup color index, value between 0 and 63 (inclusive).
		/// Output: RGB values for the makeup color specified in the input.
		/// This is used with the makeup color swatches scaleform.
		/// Use `_0x4852FC386E2E1BB5` to get the hair colors.
		/// </summary>
		void GetPedMakeupRgbColor(int makeupColorIndex, ref int outR, ref int outG, ref int outB);
		bool IsPedHairColorValid2(int colorId);
		int _0xEA9960D07DADCF10(int p0);
		bool IsPedLipstickColorValid2(int colorId);
		bool IsPedBlushColorValid2(int colorId);
		bool IsPedHairColorValid(int colorID);
		int _0xAAA6A3698A69E048(int p0);
		bool IsPedLipstickColorValid(int colorID);
		bool IsPedBlushColorValid(int colorID);
		bool IsPedBodyBlemishValid(int colorId);
		int _0xC56FBF2F228E1DAC(int modelHash, int p1, int p2);
		/// <summary>
		/// Sets the various freemode face features, e.g. nose length, chin shape. Scale ranges from -1.0 to 1.0.
		/// SET_PED_M*
		/// Here is the list of names. It starts at 0 and runs in sequence
		/// Face_Feature
		/// Nose_Width
		/// Nose_Peak_Hight
		/// Nose_Peak_Lenght
		/// Nose_Bone_High
		/// Nose_Peak_Lowering
		/// See NativeDB for reference: http://natives.altv.mp/#/0x71A5C1DBA060049E
		/// </summary>
		/// <param name="index">can be 0 - 19</param>
		void SetPedFaceFeature(int ped, int index, float scale);
		bool HasPedHeadBlendFinished(int ped);
		void FinalizeHeadBlend(int ped);
		/// <summary>
		/// Preview: https://gfycat.com/MaleRareAmazonparrot
		/// </summary>
		/// <param name="id">seems to vary from 0 to 3.</param>
		void SetHeadBlendPaletteColor(int ped, int r, int g, int b, int id);
		void DisableHeadBlendPaletteColor(int ped);
		/// <summary>
		/// Used when calling SET_PED_HEAD_BLEND_DATA.
		/// </summary>
		/// <param name="type">equals 0 for male non-dlc, 1 for female non-dlc, 2 for male dlc, and 3 for female dlc.</param>
		int GetPedHeadBlendFirstIndex(int type);
		/// <summary>
		/// </summary>
		/// <param name="type">equals 0 for male non-dlc, 1 for female non-dlc, 2 for male dlc, and 3 for female dlc.</param>
		int GetPedHeadBlendNumHeads(int type);
		/// <summary>
		/// from extreme3.c4
		/// </summary>
		/// <param name="ped">:_39D55A620FCB6A3A(PLAYER::PLAYER_PED_ID(), 8, PED::GET_PED_DRAWABLE_VARIATION(PLAYER::PLAYER_PED_ID(), 8), PED::GET_PED_TEXTURE_VARIATION(PLAYER::PLAYER_PED_ID(), 8));</param>
		/// <param name="slot">is probably componentId</param>
		int SetPedPreloadVariationData(int ped, int slot, int drawableId, int textureId);
		bool HasPedPreloadVariationDataFinished(int ped);
		void ReleasePedPreloadVariationData(int ped);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		bool SetPedPreloadPropData(int ped, int componentId, int drawableId, int TextureId);
		bool HasPedPreloadPropDataFinished(int ped);
		void ReleasePedPreloadPropData(int ped);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		int GetPedPropIndex(int ped, int componentId);
		/// <summary>
		/// enum PedPropsData
		/// {
		/// PED_PROP_HATS = 0,
		/// PED_PROP_GLASSES = 1,
		/// PED_PROP_EARS = 2,
		/// PED_PROP_WATCHES = 3,
		/// };
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		/// <param name="ped">SET_PED_PROP_INDEX(playerPed, PED_PROP_HATS, GET_NUMBER_OF_PED_PROP_DRAWABLE_VARIATIONS(playerPed, PED_PROP_HATS), GET_NUMBER_OF_PED_PROP_TEXTURE_VARIATIONS(playerPed, PED_PROP_HATS, 0), TRUE);</param>
		/// <param name="componentId">can be set to various things based on what category you're wanting to set</param>
		void SetPedPropIndex(int ped, int componentId, int drawableId, int TextureId, bool attach);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		void KnockOffPedProp(int ped, bool p1, bool p2, bool p3, bool p4);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		void ClearPedProp(int ped, int propId);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		void ClearAllPedProps(int ped);
		void DropAmbientProp(int ped);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		int GetPedPropTextureIndex(int ped, int componentId);
		void ClearPedParachutePackVariation(int ped);
		/// <summary>
		/// This native sets a scuba mask for freemode models and an oxygen bottle for player_* models. It works on freemode and player_* models.
		/// </summary>
		void SetPedScubaGearVariation(int ped);
		/// <summary>
		/// Removes the scubagear (for mp male: component id: 8, drawableId: 123, textureId: any) from peds. Does not play the 'remove scuba gear' animation, but instantly removes it.
		/// </summary>
		void ClearPedScubaGearVariation(int ped);
		bool _0xFEC9A3B1820F3331(int p0);
		/// <summary>
		/// works with TASK::TASK_SET_BLOCKING_OF_NON_TEMPORARY_EVENTS to make a ped completely oblivious to all events going on around him
		/// </summary>
		void SetBlockingOfNonTemporaryEvents(int ped, bool toggle);
		void SetPedBoundsOrientation(int ped, float p1, float p2, float p3, float p4, float p5);
		/// <summary>
		/// l_216 = RECSBRobber1
		/// </summary>
		/// <param name="ped">:REGISTER_TARGET(l_216, PLAYER::PLAYER_PED_ID()); from re_prisonbreak.txt.</param>
		void RegisterTarget(int ped, int target);
		/// <summary>
		/// Based on TASK_COMBAT_HATED_TARGETS_AROUND_PED, the parameters are likely similar (PedHandle, and area to attack in).
		/// </summary>
		void RegisterHatedTargetsAroundPed(int ped, float radius);
		/// <summary>
		/// Gets a random ped in the x/y/zRadius near the x/y/z coordinates passed.
		/// Ped Types:
		/// Any = -1
		/// Player = 1
		/// Male = 4
		/// Female = 5
		/// Cop = 6
		/// Human = 26
		/// SWAT = 27
		/// See NativeDB for reference: http://natives.altv.mp/#/0x876046A8E3A4B71C
		/// </summary>
		int GetRandomPedAtCoord(float x, float y, float z, float xRadius, float yRadius, float zRadius, int pedType);
		/// <summary>
		/// Gets the closest ped in a radius.
		/// Ped Types:
		/// Any ped = -1
		/// Player = 1
		/// Male = 4
		/// Female = 5
		/// Cop = 6
		/// Human = 26
		/// SWAT = 27
		/// See NativeDB for reference: http://natives.altv.mp/#/0xC33AB876A77F8164
		/// </summary>
		/// <param name="x">1  1  x  = return Ped you are using</param>
		/// <param name="p4">P5 P7 P8</param>
		/// <returns>1  0  x  x  = return nearest walking Ped</returns>
		bool GetClosestPed(float x, float y, float z, float radius, bool p4, bool p5, ref int outPed, bool p7, bool p8, int pedType);
		/// <summary>
		/// </summary>
		/// <returns>Sets a value indicating whether scenario peds should be returned by the next call to a command that returns peds. Eg. GET_CLOSEST_PED.</returns>
		void SetScenarioPedsToBeReturnedByNextCommand(bool value);
		bool _0x03EA03AF85A85CB7(int ped, bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, int p8);
		/// <summary>
		/// Scripts use 0.2, 0.5 and 1.0. Value must be >= 0.0 && <= 1.0
		/// </summary>
		void SetDriverRacingModifier(int driver, float modifier);
		/// <summary>
		/// The function specifically verifies the value is equal to, or less than 1.0f. If it is greater than 1.0f, the function does nothing at all.
		/// </summary>
		void SetDriverAbility(int driver, float ability);
		/// <summary>
		/// range 0.0f - 1.0f
		/// </summary>
		void SetDriverAggressiveness(int driver, float aggressiveness);
		/// <summary>
		/// Prevents the ped from going limp.
		/// [Example: Can prevent peds from falling when standing on moving vehicles.]
		/// </summary>
		bool CanPedRagdoll(int ped);
		/// <summary>
		/// Ragdoll Types:
		/// **0**: CTaskNMRelax
		/// **1**: CTaskNMScriptControl: Hardcoded not to work in networked environments.
		/// **Else**: CTaskNMBalance
		/// time1- Time(ms) Ped is in ragdoll mode; only applies to ragdoll types 0 and not 1.
		/// time2- Unknown time, in milliseconds
		/// ragdollType-
		/// 0 : Normal ragdoll
		/// 1 : Falls with stiff legs/body
		/// See NativeDB for reference: http://natives.altv.mp/#/0xAE99FB955581844A
		/// </summary>
		/// <param name="p4">Unused in TU27</param>
		/// <param name="p5">No idea. In R*'s scripts they are usually either "true, true, false" or "false, false, false".</param>
		bool SetPedToRagdoll(int ped, int time1, int time2, int ragdollType, bool p4, bool p5, bool p6);
		/// <summary>
		/// Return variable is never used in R*'s scripts.
		/// Not sure what p2 does. It seems like it would be a time judging by it's usage in R*'s scripts, but didn't seem to affect anything in my testings.
		/// x, y, and z are coordinates, most likely to where the ped will fall.
		/// (Simplified) Example of the usage of the function from R*'s scripts:
		/// </summary>
		/// <param name="ped">:set_ped_to_ragdoll_with_fall(ped, 1500, 2000, 1, -entity::get_entity_forward_vector(ped), 1f, 0f, 0f, 0f, 0f, 0f, 0f);</param>
		/// <param name="p7">is probably the force of the fall, but untested, so I left the variable name the same.</param>
		/// <param name="p8">to p13 are always 0f in R*'s scripts.</param>
		bool SetPedToRagdollWithFall(int ped, int time, int p2, int ragdollType, float x, float y, float z, float p7, float p8, float p9, float p10, float p11, float p12, float p13);
		/// <summary>
		/// Causes Ped to ragdoll on collision with any object (e.g Running into trashcan). If applied to player you will sometimes trip on the sidewalk.
		/// </summary>
		void SetPedRagdollOnCollision(int ped, bool toggle);
		/// <summary>
		/// </summary>
		/// <returns>If the ped handle passed through the parenthesis is in a ragdoll state this will return true.</returns>
		bool IsPedRagdoll(int ped);
		bool IsPedRunningRagdollTask(int ped);
		void SetPedRagdollForceFall(int ped);
		void ResetPedRagdollTimer(int ped);
		void SetPedCanRagdoll(int ped, bool toggle);
		bool IsPedRunningMeleeTask(int ped);
		bool IsPedRunningMobilePhoneTask(int ped);
		bool IsMobilePhoneToPedEar(int ped);
		/// <summary>
		/// Works for both player and peds, but some flags don't seem to work for the player (1, for example)
		/// 1 - Blocks ragdolling when shot.
		/// 2 - Blocks ragdolling when hit by a vehicle. The ped still might play a falling animation.
		/// 4 - Blocks ragdolling when set on fire.
		/// -----------------------------------------------------------------------
		/// There seem to be 26 flags
		/// </summary>
		void SetRagdollBlockingFlags(int ped, int flags);
		/// <summary>
		/// There seem to be 26 flags
		/// </summary>
		void ClearRagdollBlockingFlags(int ped, int flags);
		void SetPedAngledDefensiveArea(int ped, float p1, float p2, float p3, float p4, float p5, float p6, float p7, bool p8, bool p9);
		void SetPedSphereDefensiveArea(int ped, float x, float y, float z, float radius, bool p5, bool p6);
		void SetPedDefensiveSphereAttachedToPed(int ped, int target, float xOffset, float yOffset, float zOffset, float radius, bool p6);
		void SetPedDefensiveSphereAttachedToVehicle(int ped, int target, float xOffset, float yOffset, float zOffset, float radius, bool p6);
		void SetPedDefensiveAreaAttachedToPed(int ped, int attachPed, float p2, float p3, float p4, float p5, float p6, float p7, float p8, bool p9, bool p10);
		void SetPedDefensiveAreaDirection(int ped, float p1, float p2, float p3, bool p4);
		/// <summary>
		/// </summary>
		/// <param name="ped">will no longer get angry when you stay near him.</param>
		void RemovePedDefensiveArea(int ped, bool toggle);
		Vector3 GetPedDefensiveAreaPosition(int ped, bool p1);
		bool IsPedDefensiveAreaActive(int ped, bool p1);
		void SetPedPreferredCoverSet(int ped, int itemSet);
		void RemovePedPreferredCoverSet(int ped);
		/// <summary>
		/// It will revive/cure the injured ped. The condition is ped must not be dead.
		/// Upon setting and converting the health int, found, if health falls below 5, the ped will lay on the ground in pain(Maximum default health is 100).
		/// This function is well suited there.
		/// </summary>
		void ReviveInjuredPed(int ped);
		/// <summary>
		/// This function will simply bring the dead person back to life.
		/// Try not to use it alone, since using this function alone, will make peds fall through ground in hell(well for the most of the times).
		/// Instead, before calling this function, you may want to declare the position, where your Resurrected ped to be spawn at.(For instance, Around 2 floats of Player's current position.)
		/// Also, disabling any assigned task immediately helped in the number of scenarios, where If you want peds to perform certain decided tasks.
		/// </summary>
		void ResurrectPed(int ped);
		/// <summary>
		/// NOTE: Debugging functions are not present in the retail version of the game.
		/// *untested but char *name could also be a hash for a localized string
		/// </summary>
		void SetPedNameDebug(int ped, string name);
		/// <summary>
		/// Gets the offset the specified ped has moved since the previous tick.
		/// If worldSpace is true, the returned offset is relative to the world. That is, if the ped has moved 1 meter on the X axis and 5 meters on the Y axis, it'll return 1,5,0.
		/// </summary>
		/// <returns>If worldSpace is false, the returned offset is relative to the ped. That is, if the ped has moved 1 meter right and 5 meters forward, it'll return 1,5,0.</returns>
		Vector3 GetPedExtractedDisplacement(int ped, bool worldSpace);
		void SetPedDiesWhenInjured(int ped, bool toggle);
		void SetPedEnableWeaponBlocking(int ped, bool toggle);
		/// <summary>
		/// Actual name begins with 'S'
		/// </summary>
		/// <param name="ped">focus on this ped (also disables its collision). If doing this for your player ped, you'll still be able to drive the vehicle.</param>
		/// <param name="p1">was always 1 (true).</param>
		void _0xF9ACF4A08098EA25(int ped, bool p1);
		void ResetPedVisibleDamage(int ped);
		void ApplyPedBloodDamageByZone(int ped, int p1, float p2, float p3, int p4);
		/// <summary>
		/// woundTypes:
		/// - soak_splat
		/// - wound_sheet
		/// - BulletSmall
		/// - BulletLarge
		/// - ShotgunSmall
		/// - ShotgunSmallMonolithic
		/// - ShotgunLarge
		/// - ShotgunLargeMonolithic
		/// See NativeDB for reference: http://natives.altv.mp/#/0x83F7E01C7B769A26
		/// </summary>
		void ApplyPedBlood(int ped, int boneIndex, float xRot, float yRot, float zRot, string woundType);
		void ApplyPedBloodByZone(int ped, int p1, float p2, float p3, string p4);
		void ApplyPedBloodSpecific(int ped, int p1, float p2, float p3, float p4, float p5, int p6, float p7, string p8);
		/// <summary>
		/// enum eDamageZone
		/// {
		/// DZ_Torso = 0,
		/// DZ_Head,
		/// DZ_LeftArm,
		/// DZ_RightArm,
		/// DZ_LeftLeg,
		/// DZ_RightLeg,
		/// };
		/// See NativeDB for reference: http://natives.altv.mp/#/0x397C38AA7B4A5F83
		/// </summary>
		void ApplyPedDamageDecal(int ped, int damageZone, float xOffset, float yOffset, float heading, float scale, float alpha, int unkVariation, bool fadeIn, string decalName);
		/// <summary>
		/// "SCR_TrevorTreeBang"
		/// "HOSPITAL_0"
		/// "HOSPITAL_1"
		/// "HOSPITAL_2"
		/// "HOSPITAL_3"
		/// "HOSPITAL_4"
		/// "HOSPITAL_5"
		/// "HOSPITAL_6"
		/// "HOSPITAL_7"
		/// See NativeDB for reference: http://natives.altv.mp/#/0x46DF918788CB093F
		/// </summary>
		/// <param name="damage">Packs:</param>
		void ApplyPedDamagePack(int ped, string damagePack, float damage, float mult);
		void ClearPedBloodDamage(int ped);
		/// <summary>
		/// Somehow related to changing ped's clothes.
		/// </summary>
		void ClearPedBloodDamageByZone(int ped, int p1);
		void HidePedBloodDamageByZone(int ped, int p1, bool p2);
		/// <summary>
		/// </summary>
		/// <param name="p1">from 0 to 5 in the b617d scripts.</param>
		/// <param name="p2">"blushing" and "ALL" found in the b617d scripts.</param>
		void ClearPedDamageDecalByZone(int ped, int p1, string p2);
		int GetPedDecorationsState(int ped);
		void _0x2B694AFCF64E6994(int ped, bool p1);
		/// <summary>
		/// It clears the wetness of the selected Ped/Player. Clothes have to be wet to notice the difference.
		/// </summary>
		void ClearPedWetness(int ped);
		/// <summary>
		/// It adds the wetness level to the player clothing/outfit. As if player just got out from water surface.
		/// </summary>
		void SetPedWetnessHeight(int ped, float height);
		/// <summary>
		/// combined with PED::SET_PED_WETNESS_HEIGHT(), this native makes the ped drenched in water up to the height specified in the other function
		/// </summary>
		void SetPedWetnessEnabledThisFrame(int ped);
		void ClearPedEnvDirt(int ped);
		/// <summary>
		/// </summary>
		/// <param name="sweat">is set to 100.0 or 0.0 in the decompiled scripts.</param>
		void SetPedSweat(int ped, float sweat);
		/// <summary>
		/// Applies an Item from a PedDecorationCollection to a ped. These include tattoos and shirt decals.
		/// Example:
		/// Entry inside "mpbeach_overlays.xml" -
		/// <Item>
		/// <uvPos x="0.500000" y="0.500000" />
		/// <scale x="0.600000" y="0.500000" />
		/// <rotation value="0.000000" />
		/// <nameHash>FM_Hair_Fuzz</nameHash>
		/// <txdHash>mp_hair_fuzz</txdHash>
		/// See NativeDB for reference: http://natives.altv.mp/#/0x5F5D1665E352A839
		/// </summary>
		/// <param name="ped">:_0x5F5D1665E352A839(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("mpbeach_overlays"), MISC::GET_HASH_KEY("fm_hair_fuzz"))</param>
		/// <param name="collection">- PedDecorationCollection filename hash</param>
		/// <param name="overlay">- Item name hash</param>
		void AddPedDecorationFromHashes(int ped, int collection, int overlay);
		/// <summary>
		/// Full list of ped overlays / decorations by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedOverlayCollections.json
		/// </summary>
		void AddPedDecorationFromHashesInCorona(int ped, int collection, int overlay);
		/// <summary>
		/// Returns the zoneID for the overlay if it is a member of collection.
		/// enum ePedDecorationZone
		/// {
		/// ZONE_TORSO = 0,
		/// ZONE_HEAD = 1,
		/// ZONE_LEFT_ARM = 2,
		/// ZONE_RIGHT_ARM = 3,
		/// ZONE_LEFT_LEG = 4,
		/// ZONE_RIGHT_LEG = 5,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x9FD452BFBE7A7A8B
		/// </summary>
		int GetPedDecorationZoneFromHashes(int collection, int overlay);
		void ClearPedDecorations(int ped);
		void ClearPedDecorationsLeaveScars(int ped);
		/// <summary>
		/// </summary>
		/// <returns>Despite this function's name, it simply returns whether the specified handle is a Ped.</returns>
		bool WasPedSkeletonUpdated(int ped);
		/// <summary>
		/// Gets the position of the specified bone of the specified ped.
		/// </summary>
		/// <param name="ped">The ped to get the position of a bone from.</param>
		/// <param name="boneId">The ID of the bone to get the position from. This is NOT the index.</param>
		/// <param name="offsetX">The X-component of the offset to add to the position relative to the bone's rotation.</param>
		/// <param name="offsetY">The Y-component of the offset to add to the position relative to the bone's rotation.</param>
		/// <param name="offsetZ">The Z-component of the offset to add to the position relative to the bone's rotation.</param>
		Vector3 GetPedBoneCoords(int ped, int boneId, float offsetX, float offsetY, float offsetZ);
		/// <summary>
		/// Creates a new NaturalMotion message.
		/// If a message already exists, this function does nothing. A message exists until the point it has been successfully dispatched by GIVE_PED_NM_MESSAGE.
		/// </summary>
		/// <param name="startImmediately">If set to true, the character will perform the message the moment it receives it by GIVE_PED_NM_MESSAGE. If false, the Ped will get the message but won't perform it yet. While it's a boolean value, if negative, the message will not be initialized.</param>
		/// <param name="messageId">The ID of the NaturalMotion message.</param>
		void CreateNmMessage(bool startImmediately, int messageId);
		/// <summary>
		/// Sends the message that was created by a call to CREATE_NM_MESSAGE to the specified Ped.
		/// If a message hasn't been created already, this function does nothing.
		/// If the Ped is not ragdolled with Euphoria enabled, this function does nothing.
		/// Call order:
		/// SET_PED_TO_RAGDOLL
		/// CREATE_NM_MESSAGE
		/// GIVE_PED_NM_MESSAGE
		/// Multiple messages can be chained. Eg. to make the ped stagger and swing his arms around, the following calls can be made:
		/// SET_PED_TO_RAGDOLL(ped, 4000, 5000, 1, 1, 1, 0);
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB158DFCCC56E5C5B
		/// </summary>
		/// <param name="ped">SET_PED_TO_RAGDOLL(ped, 4000, 5000, 1, 1, 1, 0);</param>
		void GivePedNmMessage(int ped);
		int AddScenarioBlockingArea(float x1, float y1, float z1, float x2, float y2, float z2, bool p6, bool p7, bool p8, bool p9);
		void RemoveScenarioBlockingAreas();
		void RemoveScenarioBlockingArea(int p0, bool p1);
		void SetScenarioPedsSpawnInSphereArea(float x, float y, float z, float range, int p4);
		bool DoesScenarioBlockingAreaExist(float x1, float y1, float z1, float x2, float y2, float z2);
		/// <summary>
		/// Full list of ped scenarios by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenariosCompact.json
		/// </summary>
		bool IsPedUsingScenario(int ped, string scenario);
		bool IsPedUsingAnyScenario(int ped);
		int SetPedPanicExitScenario(int p0, int p1, int p2, int p3);
		void _0x9A77DFD295E29B09(int p0, bool p1);
		int _0x25361A96E0F7E419(int p0, int p1, int p2, int p3);
		int SetPedShouldPlayDirectedScenarioExit(int p0, int p1, int p2, int p3);
		void SetPedShouldPlayNormalScenarioExit(int ped);
		void SetPedShouldPlayImmediateScenarioExit(int ped);
		int SetPedShouldPlayFleeScenarioExit(int ped, int p1, int p2, int p3);
		void _0x425AECF167663F48(int ped, bool p1);
		void _0x5B6010B3CBC29095(int p0, bool p1);
		void _0xCEDA60A74219D064(int p0, bool p1);
		int _0xC30BDAEE47256C13(int p0);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void PlayFacialAnim(int ped, string animName, string animDict);
		/// <summary>
		/// Clipsets:
		/// facials@gen_female@base
		/// facials@gen_male@base
		/// facials@p_m_zero@base
		/// Typically followed with SET_FACIAL_IDLE_ANIM_OVERRIDE:
		/// mood_drunk_1
		/// mood_stressed_1
		/// mood_happy_1
		/// mood_talking_1
		/// </summary>
		void SetFacialClipsetOverride(int ped, string animDict);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void SetFacialIdleAnimOverride(int ped, string animName, string animDict);
		void ClearFacialIdleAnimOverride(int ped);
		void SetPedCanPlayGestureAnims(int ped, bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="p2">usually 0</param>
		void SetPedCanPlayVisemeAnims(int ped, bool toggle, bool p2);
		void SetPedCanPlayInjuredAnims(int ped, bool p1);
		void SetPedCanPlayAmbientAnims(int ped, bool toggle);
		void SetPedCanPlayAmbientBaseAnims(int ped, bool toggle);
		void _0xC2EE020F5FB4DB53(int ped);
		void SetPedCanArmIk(int ped, bool toggle);
		void SetPedCanHeadIk(int ped, bool toggle);
		void SetPedCanLegIk(int ped, bool toggle);
		void SetPedCanTorsoIk(int ped, bool toggle);
		void SetPedCanTorsoReactIk(int ped, bool p1);
		void _0x6647C5F6F5792496(int ped, bool p1);
		void SetPedCanUseAutoConversationLookat(int ped, bool toggle);
		bool IsPedHeadtrackingPed(int ped1, int ped2);
		bool IsPedHeadtrackingEntity(int ped, int entity);
		/// <summary>
		/// This is only called once in the scripts.
		/// sub_1CD9(&l_49, 0, getElem(3, &l_34, 4), "MICHAEL", 0, 1);
		/// sub_1CA8("WORLD_HUMAN_SMOKING", 2);
		/// PED::SET_PED_PRIMARY_LOOKAT(getElem(3, &l_34, 4), PLAYER::PLAYER_PED_ID());
		/// </summary>
		void SetPedPrimaryLookat(int ped, int lookAt);
		void SetPedClothPackageIndex(int p0, int p1);
		void SetPedClothProne(int p0, int p1);
		void _0xA660FAF550EB37E5(int p0, bool p1);
		/// <summary>
		/// enum ePedConfigFlags
		/// {
		/// _CPED_CONFIG_FLAG_0x67D1A445 = 0,
		/// _CPED_CONFIG_FLAG_0xC63DE95E = 1,
		/// CPED_CONFIG_FLAG_NoCriticalHits = 2,
		/// CPED_CONFIG_FLAG_DrownsInWater = 3,
		/// CPED_CONFIG_FLAG_DisableReticuleFixedLockon = 4,
		/// _CPED_CONFIG_FLAG_0x37D196F4 = 5,
		/// _CPED_CONFIG_FLAG_0xE2462399 = 6,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x1913FE4CBF41C463
		/// </summary>
		void SetPedConfigFlag(int ped, int flagId, bool value);
		/// <summary>
		/// Known values:
		/// PRF_PreventGoingIntoStillInVehicleState = 236 *(fanatic2.c)*
		/// </summary>
		/// <param name="ped">:SET_PED_RESET_FLAG(PLAYER::PLAYER_PED_ID(), 240, 1);</param>
		void SetPedResetFlag(int ped, int flagId, bool doReset);
		/// <summary>
		/// See SET_PED_CONFIG_FLAG
		/// </summary>
		bool GetPedConfigFlag(int ped, int flagId, bool p2);
		bool GetPedResetFlag(int ped, int flagId);
		void SetPedGroupMemberPassengerIndex(int ped, int index);
		void SetPedCanEvasiveDive(int ped, bool toggle);
		/// <summary>
		/// var num3;
		/// if (PED::IS_PED_EVASIVE_DIVING(A_0, &num3) != 0)
		/// if (ENTITY::IS_ENTITY_A_VEHICLE(num3) != 0)
		/// </summary>
		/// <returns>Presumably returns the Entity that the Ped is currently diving out of the way of.</returns>
		bool IsPedEvasiveDiving(int ped, ref int evadingEntity);
		void SetPedShootsAtCoord(int ped, float x, float y, float z, bool toggle);
		/// <summary>
		/// Full list of peds by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/peds.json
		/// </summary>
		void SetPedModelIsSuppressed(int modelHash, bool toggle);
		void StopAnyPedModelBeingSuppressed();
		void SetPedCanBeTargetedWhenInjured(int ped, bool toggle);
		void SetPedGeneratesDeadBodyEvents(int ped, bool toggle);
		void BlockPedDeadBodyShockingEvents(int ped, bool toggle);
		void _0x3E9679C1DFCF422C(int p0, int p1);
		void SetPedCanRagdollFromPlayerImpact(int ped, bool toggle);
		/// <summary>
		/// PoliceMotorcycleHelmet   1024
		/// RegularMotorcycleHelmet   4096
		/// FiremanHelmet 16384
		/// PilotHeadset  32768
		/// PilotHelmet   65536
		/// --
		/// </summary>
		/// <param name="helmetFlag">is generally 4096 or 16384 in the scripts. p1 varies between 1 and 0.</param>
		void GivePedHelmet(int ped, bool cannotRemove, int helmetFlag, int textureIndex);
		void RemovePedHelmet(int ped, bool instantly);
		bool IsPedTakingOffHelmet(int ped);
		void SetPedHelmet(int ped, bool canWearHelmet);
		void SetPedHelmetFlag(int ped, int helmetFlag);
		/// <summary>
		/// List of component/props ID
		/// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
		/// </summary>
		void SetPedHelmetPropIndex(int ped, int propIndex, bool p2);
		void SetPedHelmetUnk(int ped, bool p1, int p2, int p3);
		bool IsPedHelmetUnk(int ped);
		void SetPedHelmetTextureIndex(int ped, int textureIndex);
		/// <summary>
		/// Returns true if the ped passed through the parenthesis is wearing a helmet.
		/// </summary>
		bool IsPedWearingHelmet(int ped);
		void ClearPedStoredHatProp(int ped);
		int GetPedHelmetStoredHatPropIndex(int ped);
		int GetPedHelmetStoredHatTexIndex(int ped);
		bool _0xF2385935BFFD4D92(int p0);
		void SetPedToLoadCover(int ped, bool toggle);
		/// <summary>
		/// It simply makes the said ped to cower behind cover object(wall, desk, car)
		/// Peds flee attributes must be set to not to flee, first. Else, most of the peds, will just flee from gunshot sounds or any other panic situations.
		/// </summary>
		void SetPedCanCowerInCover(int ped, bool toggle);
		void SetPedCanPeekInCover(int ped, bool toggle);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void SetPedPlaysHeadOnHornAnimWhenDiesInVehicle(int ped, bool toggle);
		/// <summary>
		/// "IK" stands for "Inverse kinematics." I assume this has something to do with how the ped uses his legs to balance. In the scripts, the second parameter is always an int with a value of 2, 0, or sometimes 1
		/// </summary>
		void SetPedLegIkMode(int ped, int mode);
		void SetPedMotionBlur(int ped, bool toggle);
		void SetPedCanSwitchWeapon(int ped, bool toggle);
		void SetPedDiesInstantlyInWater(int ped, bool toggle);
		/// <summary>
		/// Only appears in lamar1 script.
		/// </summary>
		void _0x1A330D297AAC6BC1(int ped, int p1);
		void StopPedWeaponFiringWhenDropped(int ped);
		void SetScriptedAnimSeatOffset(int ped, float p1);
		/// <summary>
		/// enum eCombatMovement // 0x4F456B61
		/// {
		/// CM_Stationary,
		/// CM_Defensive,
		/// CM_WillAdvance,
		/// CM_WillRetreat
		/// };
		/// </summary>
		void SetPedCombatMovement(int ped, int combatMovement);
		/// <summary>
		/// See SET_PED_COMBAT_MOVEMENT
		/// </summary>
		int GetPedCombatMovement(int ped);
		/// <summary>
		/// enum eCombatAbility // 0xE793438C
		/// {
		/// CA_Poor,
		/// CA_Average,
		/// CA_Professional,
		/// CA_NumTypes
		/// };
		/// </summary>
		void SetPedCombatAbility(int ped, int abilityLevel);
		/// <summary>
		/// enum eCombatRange // 0xB69160F5
		/// {
		/// CR_Near,
		/// CR_Medium,
		/// CR_Far,
		/// CR_VeryFar,
		/// CR_NumRanges
		/// };
		/// </summary>
		void SetPedCombatRange(int ped, int combatRange);
		/// <summary>
		/// See SET_PED_COMBAT_RANGE
		/// </summary>
		int GetPedCombatRange(int ped);
		/// <summary>
		/// enum eCombatAttributes // 0x0E8E7201
		/// {
		/// BF_CanUseCover = 0,
		/// BF_CanUseVehicles = 1,
		/// BF_CanDoDrivebys = 2,
		/// BF_CanLeaveVehicle = 3,
		/// BF_CanUseDynamicStrafeDecisions = 4,
		/// BF_AlwaysFight = 5,
		/// BF_0x66BB9FCC = 6,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x9F7794730795E019
		/// </summary>
		void SetPedCombatAttributes(int ped, int attributeId, bool enabled);
		/// <summary>
		/// enum eTargetLossResponseType
		/// {
		/// TLR_ExitTask,
		/// TLR_NeverLoseTarget,
		/// TLR_SearchForTarget
		/// };
		/// </summary>
		void SetPedTargetLossResponse(int ped, int responseType);
		bool IsPedPerformingMeleeAction(int ped);
		bool IsPedPerformingStealthKill(int ped);
		bool IsPedPerformingDependentComboLimit(int ped);
		bool IsPedBeingStealthKilled(int ped);
		int GetMeleeTargetForPed(int ped);
		bool WasPedKilledByStealth(int ped);
		bool WasPedKilledByTakedown(int ped);
		bool WasPedKnockedOut(int ped);
		/// <summary>
		/// bit 15 (0x8000) = force cower
		/// </summary>
		void SetPedFleeAttributes(int ped, int attributeFlags, bool enable);
		/// <summary>
		/// </summary>
		/// <param name="p1">Only "CODE_HUMAN_STAND_COWER" found in the b617d scripts.</param>
		void SetPedCowerHash(int ped, string p1);
		/// <summary>
		/// SET_PED_STE*
		/// </summary>
		void _0x2016C603D6B8987C(int ped, bool toggle);
		void SetPedSteersAroundPeds(int ped, bool toggle);
		void SetPedSteersAroundObjects(int ped, bool toggle);
		void SetPedSteersAroundVehicles(int ped, bool toggle);
		void _0xA9B61A329BFDCBEA(int p0, bool p1);
		void SetPedIncreasedAvoidanceRadius(int ped);
		void SetPedBlocksPathingWhenDead(int ped, bool toggle);
		void _0xA52D5247A4227E14(int p0);
		bool IsAnyPedNearPoint(float x, float y, float z, float radius);
		void ForcePedAiAndAnimationUpdate(int ped, bool p1, bool p2);
		bool IsPedHeadingTowardsPosition(int ped, float x, float y, float z, float p4);
		void RequestPedVisibilityTracking(int ped);
		void RequestPedVehicleVisibilityTracking(int ped, bool p1);
		/// <summary>
		/// REQUEST_*
		/// </summary>
		void _0xCD018C591F94CB43(int ped, bool p1);
		/// <summary>
		/// REQUEST_*
		/// </summary>
		void _0x75BA1CB3B7D40CAF(int ped, bool p1);
		/// <summary>
		/// returns whether or not a ped is visible within your FOV, not this check auto's to false after a certain distance.
		/// Target needs to be tracked.. won't work otherwise.
		/// </summary>
		bool IsTrackedPedVisible(int ped);
		/// <summary>
		/// GET_*
		/// </summary>
		int _0x511F1A683387C7E2(int ped);
		bool IsPedTracked(int ped);
		bool HasPedReceivedEvent(int ped, int eventId);
		bool CanPedSeeHatedPed(int ped1, int ped2);
		/// <summary>
		/// </summary>
		bool _0x9C6A6C19B6C0C496(int ped, ref int p1);
		/// <summary>
		/// </summary>
		bool _0x2DFC81C9B9608549(int ped, ref int p1);
		/// <summary>
		/// no bone= -1
		/// boneIds:
		/// SKEL_ROOT = 0x0,
		/// SKEL_Pelvis = 0x2e28,
		/// SKEL_L_Thigh = 0xe39f,
		/// SKEL_L_Calf = 0xf9bb,
		/// SKEL_L_Foot = 0x3779,
		/// SKEL_L_Toe0 = 0x83c,
		/// IK_L_Foot = 0xfedd,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x3F428D08BE5AAE31
		/// </summary>
		int GetPedBoneIndex(int ped, int boneId);
		int GetPedRagdollBoneIndex(int ped, int bone);
		/// <summary>
		/// Values look to be between 0.0 and 1.0
		/// From decompiled scripts: 0.0, 0.6, 0.65, 0.8, 1.0
		/// You are correct, just looked in IDA it breaks from the function if it's less than 0.0f or greater than 1.0f.
		/// </summary>
		void SetPedEnveffScale(int ped, float value);
		float GetPedEnveffScale(int ped);
		void SetEnablePedEnveffScale(int ped, bool toggle);
		/// <summary>
		/// In agency_heist3b.c4, its like this 90% of the time:
		/// PED::SET_PED_ENVEFF_SCALE(ped, 1.0);
		/// PED::_D69411AA0CEBF9E9(ped, 87, 81, 68);
		/// PED::SET_ENABLE_PED_ENVEFF_SCALE(ped, 1);
		/// and its like this 10% of the time:
		/// PED::_110F526AB784111F(ped, 0.2);
		/// PED::SET_PED_ENVEFF_SCALE(ped, 0.65);
		/// PED::_D69411AA0CEBF9E9(ped, 74, 69, 60);
		/// PED::SET_ENABLE_PED_ENVEFF_SCALE(ped, 1);
		/// </summary>
		/// <param name="ped">:_110F526AB784111F(ped, 0.099);</param>
		void _0x110F526AB784111F(int ped, float p1);
		/// <summary>
		/// Something related to the environmental effects natives.
		/// In the "agency_heist3b" script, p1 - p3 are always under 100 - usually they are {87, 81, 68}. If SET_PED_ENVEFF_SCALE is set to 0.65 (instead of the usual 1.0), they use {74, 69, 60}
		/// </summary>
		void SetPedEnveffColorModulator(int ped, int p1, int p2, int p3);
		/// <summary>
		/// This native sets the emissive intensity for the given ped. It is used for different 'glow' levels on illuminated clothing.
		/// </summary>
		/// <param name="intensity">0.0f - 1.0f</param>
		void SetPedEmissiveIntensity(int ped, float intensity);
		/// <summary>
		/// Use 0x4E90D746056E273D to set the illuminated clothing glow intensity for a specific ped.
		/// Returns a float between 0.0 and 1.0 representing the current illuminated clothing glow intensity.
		/// </summary>
		float GetPedEmissiveIntensity(int ped);
		bool IsPedShaderEffectValid(int ped);
		void _0xE906EC930F5FE7C8(int p0, int p1);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void _0x1216E0BFA72CC703(int p0, int p1);
		/// <summary>
		/// Enable/disable ped shadow (ambient occlusion). https://gfycat.com/thankfulesteemedgecko
		/// </summary>
		void SetPedAoBlobRendering(int ped, bool toggle);
		bool _0xB8B52E498014F5B0(int ped);
		/// <summary>
		/// </summary>
		/// <param name="roll">and pitch 0</param>
		/// <param name="yaw">to Ped.rotation</param>
		/// <param name="p6">always 2 (but it doesnt seem to matter...)</param>
		int CreateSynchronizedScene(float x, float y, float z, float roll, float pitch, float yaw, int p6);
		int CreateSynchronizedScene2(float x, float y, float z, float radius, int @object);
		/// <summary>
		/// Returns true if a synchronized scene is running
		/// </summary>
		bool IsSynchronizedSceneRunning(int sceneId);
		void SetSynchronizedSceneOrigin(int sceneID, float x, float y, float z, float roll, float pitch, float yaw, bool p7);
		void SetSynchronizedScenePhase(int sceneID, float phase);
		float GetSynchronizedScenePhase(int sceneID);
		void SetSynchronizedSceneRate(int sceneID, float rate);
		float GetSynchronizedSceneRate(int sceneID);
		void SetSynchronizedSceneLooped(int sceneID, bool toggle);
		bool IsSynchronizedSceneLooped(int sceneID);
		void SetSynchronizedSceneHoldLastFrame(int sceneID, bool toggle);
		bool IsSynchronizedSceneHoldLastFrame(int sceneID);
		void AttachSynchronizedSceneToEntity(int sceneID, int entity, int boneIndex);
		void DetachSynchronizedScene(int sceneID);
		void DisposeSynchronizedScene(int scene);
		/// <summary>
		/// enum eMotionState // 0x92A659FE
		/// {
		/// MotionState_None = 0xEE717723,
		/// MotionState_Idle = 0x9072A713,
		/// MotionState_Walk = 0xD827C3DB,
		/// MotionState_Run = 0xFFF7E7A4,
		/// MotionState_Sprint = 0xBD8817DB,
		/// MotionState_Crouch_Idle = 0x43FB099E,
		/// MotionState_Crouch_Walk = 0x08C31A98,
		/// See NativeDB for reference: http://natives.altv.mp/#/0xF28965D04F570DCA
		/// </summary>
		/// <param name="p2">Most common is 0, 0, 0); followed by 0, 1, 0); and 1, 1, 0); in R* scripts. p4 is very rarely something other than 0.</param>
		bool ForcePedMotionState(int ped, int motionStateHash, bool p2, int p3, bool p4);
		/// <summary>
		/// </summary>
		bool GetPedCurrentMovementSpeed(int ped, ref float speedX, ref float speedY);
		void SetPedMaxMoveBlendRatio(int ped, float value);
		void SetPedMinMoveBlendRatio(int ped, float value);
		/// <summary>
		/// Min: 0.00
		/// Max: 10.00
		/// Can be used in combo with fast run cheat.
		/// When value is set to 10.00:
		/// Sprinting without fast run cheat: 66 m/s
		/// Sprinting with fast run cheat: 77 m/s
		/// Needs to be looped!
		/// Note: According to IDA for the Xbox360 xex, when they check bgt they seem to have the min to 0.0f, but the max set to 1.15f not 10.0f.
		/// </summary>
		void SetPedMoveRateOverride(int ped, float value);
		void _0x0B3E35AC043707D9(int p0, int p1);
		/// <summary>
		/// Checks if the specified unknown flag is set in the ped's model.
		/// The engine itself seems to exclusively check for flags 1 and 4 (Might be inlined code of the check that checks for other flags).
		/// Game scripts exclusively check for flags 1 and 4.
		/// </summary>
		bool _0x46B05BCAE43856B0(int ped, int flag);
		/// <summary>
		/// Returns size of array, passed into the second variable.
		/// See below for usage information.
		/// This function actually requires a struct, where the first value is the maximum number of elements to return.  Here is a sample of how I was able to get it to work correctly, without yet knowing the struct format.
		/// //Setup the array
		/// const int numElements = 10;
		/// const int arrSize = numElements * 2 + 2;
		/// Any veh[arrSize];
		/// //0 index is the size of the array
		/// veh[0] = numElements;
		/// See NativeDB for reference: http://natives.altv.mp/#/0xCFF869CBFA210D82
		/// </summary>
		int GetPedNearbyVehicles(int ped, ref int sizeAndVehs);
		/// <summary>
		/// Return value is the number of peds found and added to the array passed.
		/// -----------------------------------
		/// To make this work in most menu bases at least in C++ do it like so,
		/// Formatted Example: pastebin.com/D8an9wwp
		/// -----------------------------------
		/// Example: gtaforums.com/topic/789788-function-args-to-pedget-ped-nearby-peds/?p=1067386687
		/// </summary>
		/// <param name="sizeAndPeds">- is a pointer to an array. The array is filled with peds found nearby the ped supplied to the first argument.</param>
		/// <param name="ignore">- ped type to ignore</param>
		int GetPedNearbyPeds(int ped, ref int sizeAndPeds, int ignore);
		bool HaveAllStreamingRequestsCompleted(int ped);
		bool IsPedUsingActionMode(int ped);
		/// <summary>
		/// </summary>
		/// <param name="p2">is usually -1 in the scripts. action is either 0 or "DEFAULT_ACTION".</param>
		void SetPedUsingActionMode(int ped, bool p1, int p2, string action);
		/// <summary>
		/// </summary>
		/// <param name="name">"MP_FEMALE_ACTION" found multiple times in the b617d scripts.</param>
		void SetMovementModeOverride(int ped, string name);
		/// <summary>
		/// Overrides the ped's collision capsule radius for the current tick.
		/// Must be called every tick to be effective.
		/// Setting this to 0.001 will allow warping through some objects.
		/// </summary>
		void SetPedCapsule(int ped, float value);
		/// <summary>
		/// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
		/// </summary>
		int RegisterPedheadshot(int ped);
		int RegisterPedheadshot3(int ped);
		/// <summary>
		/// Similar to REGISTER_PEDHEADSHOT but creates a transparent background instead of black. Example: https://i.imgur.com/iHz8ztn.png
		/// </summary>
		int RegisterPedheadshotTransparent(int ped);
		/// <summary>
		/// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
		/// </summary>
		void UnregisterPedheadshot(int id);
		/// <summary>
		/// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
		/// </summary>
		bool IsPedheadshotValid(int id);
		/// <summary>
		/// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
		/// </summary>
		bool IsPedheadshotReady(int id);
		/// <summary>
		/// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
		/// </summary>
		string GetPedheadshotTxdString(int id);
		bool RequestPedheadshotImgUpload(int id);
		void ReleasePedheadshotImgUpload(int id);
		bool IsPedheadshotImgUploadAvailable();
		bool HasPedheadshotImgUploadFailed();
		bool HasPedheadshotImgUploadSucceeded();
		void SetPedHeatscaleOverride(int ped, float heatScale);
		void DisablePedHeatscaleOverride(int ped);
		void SpawnpointsStartSearch(float p0, float p1, float p2, float p3, float p4, int interiorFlags, float scale, int duration);
		void SpawnpointsStartSearchInAngledArea(float x, float y, float z, float p3, float p4, float p5, float p6, int interiorFlags, float scale, int duration);
		void SpawnpointsCancelSearch();
		bool SpawnpointsIsSearchActive();
		bool SpawnpointsIsSearchComplete();
		bool SpawnpointsIsSearchFailed();
		int SpawnpointsGetNumSearchResults();
		/// <summary>
		/// </summary>
		void SpawnpointsGetSearchResult(int randomInt, ref float x, ref float y, ref float z);
		/// <summary>
		/// </summary>
		void SpawnpointsGetSearchResultFlags(int p0, ref int p1);
		void SetIkTarget(int ped, int ikIndex, int entityLookAt, int boneLookAt, float offsetX, float offsetY, float offsetZ, int p7, int blendInDuration, int blendOutDuration);
		/// <summary>
		/// FORCE_*
		/// </summary>
		void _0xED3C76ADFA6D07C4(int ped);
		void RequestActionModeAsset(string asset);
		bool HasActionModeAssetLoaded(string asset);
		void RemoveActionModeAsset(string asset);
		void RequestStealthModeAsset(string asset);
		bool HasStealthModeAssetLoaded(string asset);
		void RemoveStealthModeAsset(string asset);
		void SetPedLodMultiplier(int ped, float multiplier);
		void SetPedCanLosePropsOnDamage(int ped, bool toggle, int p2);
		void SetForceFootstepUpdate(int ped, bool toggle);
		void SetForceStepType(int ped, bool p1, int type, int p3);
		bool IsAnyHostilePedNearPoint(int ped, float x, float y, float z, float radius);
		/// <summary>
		/// Toggles config flag CPED_CONFIG_FLAG_CanPlayInCarIdles.
		/// </summary>
		void SetPedCanPlayInCarIdles(int ped, bool toggle);
		bool IsTargetPedInPerceptionArea(int ped, int targetPed, float p2, float p3, float p4, float p5);
		/// <summary>
		/// </summary>
		/// <param name="min">and max are usually 100.0 and 200.0</param>
		void SetPopControlSphereThisFrame(float x, float y, float z, float min, float max);
		void _0xD33DAA36272177C4(int ped);
		void _0x711794453CFD692B(int p0, int p1);
		void _0x83A169EABCDB10A2(int p0, int p1);
		void _0x288DF530C92DAD6F(int p0, float p1);
		bool IsPedSwappingWeapon(int Ped);
		void _0x0F62619393661D6E(int p0, int p1, int p2);
		void _0xDFE68C4B787E1BFB(int ped);
		void SetEnableScubaGearLight(int ped, bool toggle);
		bool IsScubaGearLightEnabled(int ped);
		void ClearFacialClipsetOverride(int ped);
		/// <summary>
		/// SET_A*
		/// </summary>
		void _0xFAB944D4D481ACCB(int ped, bool toggle);
		/// <summary>
		/// Creates a rope at the specific position, that extends in the specified direction when not attached to any entities.
		/// __
		/// Add_Rope(pos.x,pos.y,pos.z,0.0,0.0,0.0,20.0,4,20.0,1.0,0.0,false,false,false,5.0,false,NULL)
		/// When attached, Position<vector> does not matter
		/// When attached, Angle<vector> does not matter
		/// Rope Type:
		/// 4 and bellow is a thick rope
		/// 5 and up are small metal wires
		/// 0 crashes the game
		/// See NativeDB for reference: http://natives.altv.mp/#/0xE832D760399EB220
		/// </summary>
		/// <param name="length">Rope is forced to this length, generally best to keep this the same as your rope length.</param>
		/// <param name="windingSpeed">- Speed the Rope is being winded, using native START_ROPE_WINDING. Set positive for winding and negative for unwinding.</param>
		/// <param name="rigid">- If max length is zero, and this is set to false the rope will become rigid (it will force a specific distance, what ever length is, between the objects).</param>
		/// <param name="unkPtr">- unknown ptr, always 0 in orig scripts</param>
		int AddRope(float x, float y, float z, float rotX, float rotY, float rotZ, float length, int ropeType, float maxLength, float minLength, float windingSpeed, bool p11, bool p12, bool rigid, float p14, bool breakWhenShot, ref int unkPtr);
		/// <summary>
		/// </summary>
		void DeleteRope(ref int ropeId);
		void DeleteChildRope(int ropeId);
		/// <summary>
		/// </summary>
		bool DoesRopeExist(ref int ropeId);
		/// <summary>
		/// ROPE_*
		/// </summary>
		void _0xA1AE736541B0FCA3(ref int ropeId, bool p1);
		/// <summary>
		/// </summary>
		void RopeDrawShadowEnabled(ref int ropeId, bool toggle);
		/// <summary>
		/// Rope presets can be found in the gamefiles. One example is "ropeFamily3", it is NOT a hash but rather a string.
		/// </summary>
		void LoadRopeData(int ropeId, string rope_preset);
		void PinRopeVertex(int ropeId, int vertex, float x, float y, float z);
		void UnpinRopeVertex(int ropeId, int vertex);
		int GetRopeVertexCount(int ropeId);
		/// <summary>
		/// Attaches entity 1 to entity 2.
		/// </summary>
		void AttachEntitiesToRope(int ropeId, int ent1, int ent2, float ent1_x, float ent1_y, float ent1_z, float ent2_x, float ent2_y, float ent2_z, float length, bool p10, bool p11, ref int p12, ref int p13);
		/// <summary>
		/// The position supplied can be anywhere, and the entity should anchor relative to that point from it's origin.
		/// </summary>
		void AttachRopeToEntity(int ropeId, int entity, float x, float y, float z, bool p5);
		void DetachRopeFromEntity(int ropeId, int entity);
		void RopeSetUpdatePinverts(int ropeId);
		void RopeSetUpdateOrder(int ropeId, int p1);
		/// <summary>
		/// ROPE_*
		/// </summary>
		void _0x36CCB9BE67B970FD(int ropeId, bool p1);
		/// <summary>
		/// IS_*
		/// </summary>
		bool _0x84DE3B5FB3E666F0(ref int ropeId);
		Vector3 GetRopeLastVertexCoord(int ropeId);
		Vector3 GetRopeVertexCoord(int ropeId, int vertex);
		void StartRopeWinding(int ropeId);
		void StopRopeWinding(int ropeId);
		void StartRopeUnwindingFront(int ropeId);
		void StopRopeUnwindingFront(int ropeId);
		void RopeConvertToSimple(int ropeId);
		/// <summary>
		/// Loads rope textures for all ropes in the current scene.
		/// </summary>
		void RopeLoadTextures();
		bool RopeAreTexturesLoaded();
		/// <summary>
		/// Unloads rope textures for all ropes in the current scene.
		/// </summary>
		void RopeUnloadTextures();
		bool DoesRopeBelongToThisScript(int ropeId);
		/// <summary>
		/// Most likely ROPE_ATTACH_*
		/// </summary>
		void _0xBC0CE682D4D05650(int ropeId, int p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13);
		void _0xB1B6216CA2E7B55E(int p0, bool p1, bool p2);
		/// <summary>
		/// ROPE_*
		/// </summary>
		void _0xB743F735C03D7810(int ropeId, int p1);
		float RopeGetDistanceBetweenEnds(int ropeId);
		/// <summary>
		/// Forces a rope to a certain length.
		/// </summary>
		void RopeForceLength(int ropeId, float length);
		/// <summary>
		/// Reset a rope to a certain length.
		/// </summary>
		void RopeResetLength(int ropeId, float length);
		void ApplyImpulseToCloth(float posX, float posY, float posZ, float vecX, float vecY, float vecZ, float impulse);
		void SetDamping(int entity, int vertex, float value);
		void ActivatePhysics(int entity);
		void SetCgoffset(int entity, float x, float y, float z);
		Vector3 GetCgoffset(int entity);
		void SetCgAtBoundcenter(int entity);
		void BreakEntityGlass(int entity, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, int p9, bool p10);
		/// <summary>
		/// GET_*
		/// </summary>
		bool GetHasObjectFragInst(int @object);
		void SetDisableBreaking(int @object, bool toggle);
		/// <summary>
		/// RESET_*
		/// </summary>
		void _0xCC6E963682533882(int @object);
		void SetDisableFragDamage(int @object, bool toggle);
		void SetEntityProofUnk(int entity, bool toggle);
		/// <summary>
		/// SET_*
		/// </summary>
		void _0x9EBD751E5787BAF2(bool p0);
		/// <summary>
		/// Related to the lower-end of a vehicles fTractionCurve, e.g., from standing starts and acceleration from low/zero speeds.
		/// </summary>
		void SetLaunchControlEnabled(bool toggle);
		/// <summary>
		/// Gets the ped for a specified player index.
		/// </summary>
		int GetPlayerPed(int player);
		/// <summary>
		/// Does the same like PLAYER::GET_PLAYER_PED
		/// </summary>
		int GetPlayerPedScriptIndex(int player);
		/// <summary>
		/// Set the model for a specific Player. Be aware that this will destroy the current Ped for the Player and create a new one, any reference to the old ped should be reset
		/// Make sure to request the model first and wait until it has loaded.
		/// </summary>
		void SetPlayerModel(int player, int model);
		void ChangePlayerPed(int player, int ped, bool p2, bool resetDamage);
		/// <summary>
		/// </summary>
		void GetPlayerRgbColour(int player, ref int r, ref int g, ref int b);
		/// <summary>
		/// Gets the number of players in the current session.
		/// </summary>
		/// <returns>If not multiplayer, always returns 1.</returns>
		int GetNumberOfPlayers();
		/// <summary>
		/// Gets the player's team.
		/// Does nothing in singleplayer.
		/// </summary>
		int GetPlayerTeam(int player);
		/// <summary>
		/// Set player team on deathmatch and last team standing..
		/// </summary>
		void SetPlayerTeam(int player, int team);
		int GetNumberOfPlayersInTeam(int team);
		string GetPlayerName(int player);
		/// <summary>
		/// Remnant from GTA IV. Does nothing in GTA V.
		/// </summary>
		float GetWantedLevelRadius(int player);
		Vector3 GetPlayerWantedCentrePosition(int player);
		/// <summary>
		/// # Predominant call signatures
		/// # Parameter value ranges
		/// P0: PLAYER::PLAYER_ID()
		/// </summary>
		/// <param name="player">:SET_PLAYER_WANTED_CENTRE_POSITION(PLAYER::PLAYER_ID(), ENTITY::GET_ENTITY_COORDS(PLAYER::PLAYER_PED_ID(), 1));</param>
		/// <param name="position">ENTITY::GET_ENTITY_COORDS(PLAYER::PLAYER_PED_ID(), 1)</param>
		/// <param name="p2">Not set by any call</param>
		void SetPlayerWantedCentrePosition(int player, ref Vector3 position, bool p2, bool p3);
		/// <summary>
		/// Drft
		/// </summary>
		int GetWantedLevelThreshold(int wantedLevel);
		/// <summary>
		/// Call SET_PLAYER_WANTED_LEVEL_NOW for immediate effect
		/// disableNoMission-  Disables When Off Mission- appears to always be false
		/// </summary>
		/// <param name="wantedLevel">is an integer value representing 0 to 5 stars even though the game supports the 6th wanted level but no police will appear since no definitions are present for it in the game files</param>
		void SetPlayerWantedLevel(int player, int wantedLevel, bool disableNoMission);
		/// <summary>
		/// </summary>
		/// <param name="p2">is always false in R* scripts</param>
		void SetPlayerWantedLevelNoDrop(int player, int wantedLevel, bool p2);
		/// <summary>
		/// Forces any pending wanted level to be applied to the specified player immediately.
		/// Call SET_PLAYER_WANTED_LEVEL with the desired wanted level, followed by SET_PLAYER_WANTED_LEVEL_NOW.
		/// Second parameter is unknown (always false).
		/// </summary>
		void SetPlayerWantedLevelNow(int player, bool p1);
		bool ArePlayerFlashingStarsAboutToDrop(int player);
		bool ArePlayerStarsGreyedOut(int player);
		int _0x7E07C78925D5FD96(int p0);
		void SetDispatchCopsForPlayer(int player, bool toggle);
		bool IsPlayerWantedLevelGreater(int player, int wantedLevel);
		/// <summary>
		/// PLAYER::GET_PLAYER_WANTED_LEVEL(player); executes in less than half the time. Which means that it's worth first checking if the wanted level needs to be cleared before clearing. However, this is mostly about good code practice and can important in other situations. The difference in time in this example is negligible.
		/// </summary>
		void ClearPlayerWantedLevel(int player);
		bool IsPlayerDead(int player);
		bool IsPlayerPressingHorn(int player);
		/// <summary>
		/// SPC_AMBIENT_SCRIPT = (1 << 1),
		/// SPC_CLEAR_TASKS = (1 << 2),
		/// SPC_REMOVE_FIRES = (1 << 3),
		/// SPC_REMOVE_EXPLOSIONS = (1 << 4),
		/// SPC_REMOVE_PROJECTILES = (1 << 5),
		/// SPC_DEACTIVATE_GADGETS = (1 << 6),
		/// SPC_REENABLE_CONTROL_ON_DEATH = (1 << 7),
		/// SPC_LEAVE_CAMERA_CONTROL_ON = (1 << 8),
		/// SPC_ALLOW_PLAYER_DAMAGE = (1 << 9),
		/// See NativeDB for reference: http://natives.altv.mp/#/0x8D32347D6D4C40A2
		/// </summary>
		void SetPlayerControl(int player, bool bHasControl, int flags);
		int GetPlayerWantedLevel(int player);
		void SetMaxWantedLevel(int maxWantedLevel);
		/// <summary>
		/// If toggle is set to false:
		/// The police won't be shown on the (mini)map
		/// If toggle is set to true:
		/// The police will be shown on the (mini)map
		/// </summary>
		void SetPoliceRadarBlips(bool toggle);
		/// <summary>
		/// The player will be ignored by the police if toggle is set to true
		/// </summary>
		void SetPoliceIgnorePlayer(int player, bool toggle);
		/// <summary>
		/// Checks whether the specified player has a Ped, the Ped is not dead, is not injured and is not arrested.
		/// </summary>
		bool IsPlayerPlaying(int player);
		void SetEveryoneIgnorePlayer(int player, bool toggle);
		void SetAllRandomPedsFlee(int player, bool toggle);
		void SetAllRandomPedsFleeThisFrame(int player);
		void _0xDE45D1A1EF45EE61(int player, bool toggle);
		/// <summary>
		/// - This is called after SET_ALL_RANDOM_PEDS_FLEE_THIS_FRAME
		/// </summary>
		void _0xC3376F42B1FACCC6(int player);
		void _0xFAC75988A7D078D3(int player);
		void SetIgnoreLowPriorityShockingEvents(int player, bool toggle);
		void SetWantedLevelMultiplier(float multiplier);
		/// <summary>
		/// Max value is 1.0
		/// </summary>
		void SetWantedLevelDifficulty(int player, float difficulty);
		void ResetWantedLevelDifficulty(int player);
		int GetWantedLevelParoleDuration();
		void SetWantedLevelHiddenEvasionTime(int player, int wantedLevel, int lossTime);
		void _0x823EC8E82BA45986(int p0);
		void StartFiringAmnesty(int duration);
		/// <summary>
		/// From am_armybase.ysc.c4:
		/// PLAYER::REPORT_CRIME(PLAYER::PLAYER_ID(4), 36, PLAYER::GET_WANTED_LEVEL_THRESHOLD(4));
		/// -----
		/// This was taken from the GTAV.exe v1.334. The function is called sub_140592CE8. For a full decompilation of the function, see here: pastebin.com/09qSMsN7
		/// -----
		/// 1: Firearms possession
		/// 2: Person running a red light ("5-0-5")
		/// 3: Reckless driver
		/// 4: Speeding vehicle (a "5-10")
		/// See NativeDB for reference: http://natives.altv.mp/#/0xE9B09589827545E7
		/// </summary>
		/// <param name="player">:REPORT_CRIME(PLAYER::PLAYER_ID(), 37, PLAYER::GET_WANTED_LEVEL_THRESHOLD(1));</param>
		void ReportCrime(int player, int crimeType, int wantedLvlThresh);
		/// <summary>
		/// This was previously named as "RESERVE_ENTITY_EXPLODES_ON_HIGH_EXPLOSION_COMBO"
		/// which is obviously incorrect.
		/// Seems to only appear in scripts used in Singleplayer. p1 ranges from 2 - 46.
		/// I assume this switches the crime type
		/// </summary>
		void SwitchCrimeType(int player, int p1);
		/// <summary>
		/// Seems to only appear in scripts used in Singleplayer.
		/// Always used like this in scripts
		/// </summary>
		/// <param name="player">:_BC9490CA15AEA8FB(PLAYER::PLAYER_ID());</param>
		void _0xBC9490CA15AEA8FB(int player);
		/// <summary>
		/// This has been found in use in the decompiled files.
		/// </summary>
		void _0x4669B3ED80F24B4E(int player);
		void _0x2F41A3BAE005E5FA(int p0, int p1);
		/// <summary>
		/// This has been found in use in the decompiled files.
		/// </summary>
		void _0xAD73CE5A09E42D12(int player);
		void _0x36F1B38855F2A8DF(int player);
		void ReportPoliceSpottedPlayer(int player);
		/// <summary>
		/// PLAYER::0xBF6993C7(rPtr((&l_122) + 71)); // Found in decompilation
		/// ***
		/// In "am_hold_up.ysc" used once:
		/// l_8d._f47 = MISC::GET_RANDOM_FLOAT_IN_RANGE(18.0, 28.0);
		/// PLAYER::_B45EFF719D8427A6((l_8d._f47));
		/// </summary>
		void _0xB45EFF719D8427A6(float p0);
		/// <summary>
		/// 2 matches in 1 script - am_hold_up
		/// Used in multiplayer scripts?
		/// </summary>
		void _0x0032A6DBA562C518();
		bool CanPlayerStartMission(int player);
		bool IsPlayerReadyForCutscene(int player);
		bool IsPlayerTargettingEntity(int player, int entity);
		/// <summary>
		/// Assigns the handle of locked-on melee target to *entity that you pass it.
		/// Returns false if no entity found.
		/// </summary>
		bool GetPlayerTargetEntity(int player, ref int entity);
		/// <summary>
		/// Gets a value indicating whether the specified player is currently aiming freely.
		/// </summary>
		bool IsPlayerFreeAiming(int player);
		/// <summary>
		/// Gets a value indicating whether the specified player is currently aiming freely at the specified entity.
		/// </summary>
		bool IsPlayerFreeAimingAtEntity(int player, int entity);
		/// <summary>
		/// Returns TRUE if it found an entity in your crosshair within range of your weapon. Assigns the handle of the target to the *entity that you pass it.
		/// Returns false if no entity found.
		/// </summary>
		bool GetEntityPlayerIsFreeAimingAt(int player, ref int entity);
		/// <summary>
		/// Affects the range of auto aim target.
		/// </summary>
		void SetPlayerLockonRangeOverride(int player, float range);
		/// <summary>
		/// Set whether this player should be able to do drive-bys.
		/// "A drive-by is when a ped is aiming/shooting from vehicle. This includes middle finger taunts. By setting this value to false I confirm the player is unable to do all that. Tested on tick."
		/// </summary>
		void SetPlayerCanDoDriveBy(int player, bool toggle);
		/// <summary>
		/// Sets whether this player can be hassled by gangs.
		/// </summary>
		void SetPlayerCanBeHassledByGangs(int player, bool toggle);
		/// <summary>
		/// Sets whether this player can take cover.
		/// </summary>
		void SetPlayerCanUseCover(int player, bool toggle);
		/// <summary>
		/// Gets the maximum wanted level the player can get.
		/// Ranges from 0 to 5.
		/// </summary>
		int GetMaxWantedLevel();
		bool IsPlayerTargettingAnything(int player);
		void SetPlayerSprint(int player, bool toggle);
		void ResetPlayerStamina(int player);
		void RestorePlayerStamina(int player, float p1);
		float GetPlayerSprintStaminaRemaining(int player);
		float GetPlayerSprintTimeRemaining(int player);
		float GetPlayerUnderwaterTimeRemaining(int player);
		int SetPlayerUnderwaterTimeRemaining(int player, float time);
		/// <summary>
		/// Returns the group ID the player is member of.
		/// </summary>
		int GetPlayerGroup(int player);
		int GetPlayerMaxArmour(int player);
		/// <summary>
		/// Can the player control himself, used to disable controls for player for things like a cutscene.
		/// ---
		/// You can't disable controls with this, use SET_PLAYER_CONTROL(...) for this.
		/// </summary>
		bool IsPlayerControlOn(int player);
		/// <summary>
		/// Returns true when the player is not able to control the cam i.e. when running a benchmark test, switching the player or viewing a cutscene.
		/// Note: I am not 100% sure if the native actually checks if the cam control is disabled but it seems promising.
		/// </summary>
		bool IsPlayerCamControlDisabled();
		bool IsPlayerScriptControlOn(int player);
		/// <summary>
		/// Returns TRUE if the player ('s ped) is climbing at the moment.
		/// </summary>
		bool IsPlayerClimbing(int player);
		/// <summary>
		/// Return true while player is being arrested / busted.
		/// If atArresting is set to 0, this function will return 1 only when the busted screen is shown.
		/// </summary>
		/// <returns>If atArresting is set to 1, this function will return 1 when player is being arrested (while player is putting his hand up, but still have control)</returns>
		bool IsPlayerBeingArrested(int player, bool atArresting);
		void ResetPlayerArrestState(int player);
		/// <summary>
		/// Alternative: GET_VEHICLE_PED_IS_IN(PLAYER_PED_ID(), 1);
		/// </summary>
		int GetPlayersLastVehicle();
		/// <summary>
		/// Returns the same as PLAYER_ID and NETWORK_PLAYER_ID_TO_INT
		/// </summary>
		int GetPlayerIndex();
		/// <summary>
		/// </summary>
		/// <returns>Simply returns whatever is passed to it (Regardless of whether the handle is valid or not).</returns>
		int IntToPlayerindex(int value);
		/// <summary>
		/// --------------------------------------------------------
		/// if (NETWORK::NETWORK_IS_PARTICIPANT_ACTIVE(PLAYER::INT_TO_PARTICIPANTINDEX(i)))
		/// </summary>
		/// <returns>Simply returns whatever is passed to it (Regardless of whether the handle is valid or not).</returns>
		int IntToParticipantindex(int value);
		int GetTimeSincePlayerHitVehicle(int player);
		int GetTimeSincePlayerHitPed(int player);
		int GetTimeSincePlayerDroveOnPavement(int player);
		int GetTimeSincePlayerDroveAgainstTraffic(int player);
		bool IsPlayerFreeForAmbientTask(int player);
		/// <summary>
		/// Always returns 0 in story mode.
		/// </summary>
		/// <returns>This returns YOUR 'identity' as a Player type.</returns>
		int PlayerId();
		/// <summary>
		/// Returns current player ped
		/// </summary>
		int PlayerPedId();
		/// <summary>
		/// Does exactly the same thing as PLAYER_ID()
		/// </summary>
		int NetworkPlayerIdToInt();
		bool HasForceCleanupOccurred(int cleanupFlags);
		/// <summary>
		/// used with 1,2,8,64,128 in the scripts
		/// </summary>
		void ForceCleanup(int cleanupFlags);
		/// <summary>
		/// PLAYER::FORCE_CLEANUP_FOR_ALL_THREADS_WITH_THIS_NAME("pb_prostitute", 1); // Found in decompilation
		/// </summary>
		void ForceCleanupForAllThreadsWithThisName(string name, int cleanupFlags);
		void ForceCleanupForThreadWithThisId(int id, int cleanupFlags);
		int GetCauseOfMostRecentForceCleanup();
		void SetPlayerMayOnlyEnterThisVehicle(int player, int vehicle);
		void SetPlayerMayNotEnterAnyVehicle(int player);
		/// <summary>
		/// 1 - Welcome to Los Santos
		/// 2 - A Friendship Resurrected
		/// 3 - A Fair Day's Pay
		/// 4 - The Moment of Truth
		/// 5 - To Live or Die in Los Santos
		/// 6 - Diamond Hard
		/// 7 - Subversive
		/// 8 - Blitzed
		/// 9 - Small Town, Big Job
		/// See NativeDB for reference: http://natives.altv.mp/#/0xBEC7076D64130195
		/// </summary>
		bool GiveAchievementToPlayer(int achievementId);
		/// <summary>
		/// For Steam.
		/// </summary>
		/// <returns>Does nothing and always returns false in the retail version of the game.</returns>
		bool SetAchievementProgress(int achievementId, int progress);
		/// <summary>
		/// For Steam.
		/// </summary>
		/// <returns>Always returns 0 in retail version of the game.</returns>
		int GetAchievementProgress(int achievementId);
		/// <summary>
		/// See GIVE_ACHIEVEMENT_TO_PLAYER
		/// </summary>
		bool HasAchievementBeenPassed(int achievementId);
		/// <summary>
		/// Returns TRUE if the game is in online mode and FALSE if in offline mode.
		/// This is an alias for NETWORK_IS_SIGNED_ONLINE.
		/// </summary>
		bool IsPlayerOnline();
		bool IsPlayerLoggingInNp();
		/// <summary>
		/// Purpose of the BOOL currently unknown.
		/// Both, true and false, work
		/// </summary>
		void DisplaySystemSigninUi(bool unk);
		bool IsSystemUiBeingDisplayed();
		/// <summary>
		/// Simply sets you as invincible (Health will not deplete).
		/// Use 0x733A643B5B0C53C1 instead if you want Ragdoll enabled, which is equal to:
		/// *(DWORD *)(playerPedAddress + 0x188) |= (1 << 9);
		/// </summary>
		void SetPlayerInvincible(int player, bool toggle);
		/// <summary>
		/// Returns the Player's Invincible status.
		/// bool IsPlayerInvincible(Player player)
		/// {
		/// auto addr = getScriptHandleBaseAddress(GET_PLAYER_PED(player));
		/// if (addr)
		/// {
		/// DWORD flag = *(DWORD *)(addr + 0x188);
		/// return ((flag & (1 << 8)) != 0) || ((flag & (1 << 9)) != 0);
		/// }
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB721981B2B939E07
		/// </summary>
		/// <returns>This function will always return false if 0x733A643B5B0C53C1 is used to set the invincibility status. To always get the correct result, use this:</returns>
		bool GetPlayerInvincible(int player);
		/// <summary>
		/// </summary>
		/// <returns>Always returns false.</returns>
		bool _0xDCC07526B8EC45AF(int player);
		void SetPlayerInvincibleKeepRagdollEnabled(int player, bool toggle);
		/// <summary>
		/// Found in "director_mode", "fm_bj_race_controler", "fm_deathmatch_controler", "fm_impromptu_dm_controler", "fm_race_controler", "gb_deathmatch".
		/// </summary>
		void _0xCAC57395B151135F(int player, bool p1);
		void RemovePlayerHelmet(int player, bool p2);
		void GivePlayerRagdollControl(int player, bool toggle);
		/// <summary>
		/// Example from fm_mission_controler.ysc.c4:
		/// All other decompiled scripts using this seem to be using the player id as the first parameter, so I feel the need to confirm it as so.
		/// No need to confirm it says PLAYER_ID() so it uses PLAYER_ID() lol.
		/// </summary>
		/// <param name="player">:SET_PLAYER_LOCKON(PLAYER::PLAYER_ID(), 1);</param>
		void SetPlayerLockon(int player, bool toggle);
		/// <summary>
		/// Sets your targeting mode.
		/// 0 = Assisted Aim - Full
		/// 1 = Assisted Aim - Partial
		/// 2 = Free Aim - Assisted
		/// 3 = Free Aim
		/// </summary>
		void SetPlayerTargetingMode(int targetMode);
		void SetPlayerTargetLevel(int targetLevel);
		/// <summary>
		/// Returns profile setting 237.
		/// GET_*
		/// </summary>
		bool _0xB9CF1F793A9F1BF1();
		/// <summary>
		/// Returns profile setting 243.
		/// GET_*
		/// </summary>
		bool _0xCB645E85E97EA48B();
		void ClearPlayerHasDamagedAtLeastOnePed(int player);
		bool HasPlayerDamagedAtLeastOnePed(int player);
		void ClearPlayerHasDamagedAtLeastOneNonAnimalPed(int player);
		bool HasPlayerDamagedAtLeastOneNonAnimalPed(int player);
		/// <summary>
		/// This can be between 1.0f - 14.9f
		/// You can change the max in IDA from 15.0. I say 15.0 as the function blrs if what you input is greater than or equal to 15.0 hence why it's 14.9 max default.
		/// </summary>
		void SetAirDragMultiplierForPlayersVehicle(int player, float multiplier);
		/// <summary>
		/// Swim speed multiplier.
		/// Just call it one time, it is not required to be called once every tick. - Note copied from below native.
		/// Note: At least the IDA method if you change the max float multiplier from 1.5 it will change it for both this and RUN_SPRINT below. I say 1.5 as the function blrs if what you input is greater than or equal to 1.5 hence why it's 1.49 max default.
		/// </summary>
		/// <param name="multiplier">goes up to 1.49</param>
		void SetSwimMultiplierForPlayer(int player, float multiplier);
		/// <summary>
		/// Just call it one time, it is not required to be called once every tick.
		/// Note: At least the IDA method if you change the max float multiplier from 1.5 it will change it for both this and SWIM above. I say 1.5 as the function blrs if what you input is greater than or equal to 1.5 hence why it's 1.49 max default.
		/// </summary>
		/// <param name="multiplier">goes up to 1.49 any value above will be completely overruled by the game and the multiplier will not take effect, this can be edited in memory however.</param>
		void SetRunSprintMultiplierForPlayer(int player, float multiplier);
		/// <summary>
		/// Returns the time since the character was arrested in (ms) milliseconds.
		/// example
		/// var time = Function.call<int>(Hash.GET_TIME_SINCE_LAST_ARREST();
		/// UI.DrawSubtitle(time.ToString());
		/// if player has not been arrested, the int returned will be -1.
		/// </summary>
		int GetTimeSinceLastArrest();
		/// <summary>
		/// Returns the time since the character died in (ms) milliseconds.
		/// example
		/// var time = Function.call<int>(Hash.GET_TIME_SINCE_LAST_DEATH();
		/// UI.DrawSubtitle(time.ToString());
		/// if player has not died, the int returned will be -1.
		/// </summary>
		int GetTimeSinceLastDeath();
		void AssistedMovementCloseRoute();
		void AssistedMovementFlushRoute();
		void SetPlayerForcedAim(int player, bool toggle);
		void SetPlayerForcedZoom(int player, bool toggle);
		void SetPlayerForceSkipAimIntro(int player, bool toggle);
		/// <summary>
		/// Inhibits the player from using any method of combat including melee and firearms.
		/// NOTE: Only disables the firing for one frame
		/// </summary>
		void DisablePlayerFiring(int player, bool toggle);
		/// <summary>
		/// Disables something. Used only once in R* scripts (freemode.ysc).
		/// DISABLE_PLAYER_*
		/// </summary>
		void _0xB885852C39CC265D();
		void SetDisableAmbientMeleeMove(int player, bool toggle);
		/// <summary>
		/// Default is 100. Use player id and not ped id. For instance: PLAYER::SET_PLAYER_MAX_ARMOUR(PLAYER::PLAYER_ID(), 100); // main_persistent.ct4
		/// </summary>
		void SetPlayerMaxArmour(int player, int value);
		/// <summary>
		/// </summary>
		/// <param name="p1">is always 0 in the scripts</param>
		void SpecialAbilityActivate(int player, int p1);
		void SetSpecialAbility(int player, int p1, int p2);
		/// <summary>
		/// </summary>
		/// <param name="p1">is always 0 in the scripts</param>
		void SpecialAbilityDeplete(int player, int p1);
		void SpecialAbilityDeactivate(int player, int p1);
		void SpecialAbilityDeactivateFast(int player, int p1);
		void SpecialAbilityReset(int player, int p1);
		void SpecialAbilityChargeOnMissionFailed(int player, int p1);
		/// <summary>
		/// Every occurrence of p1 & p2 were both true.
		/// </summary>
		void SpecialAbilityChargeSmall(int player, bool p1, bool p2, int p3);
		/// <summary>
		/// Only 1 match. Both p1 & p2 were true.
		/// </summary>
		void SpecialAbilityChargeMedium(int player, bool p1, bool p2, int p3);
		/// <summary>
		/// 2 matches. p1 was always true.
		/// </summary>
		void SpecialAbilityChargeLarge(int player, bool p1, bool p2, int p3);
		/// <summary>
		/// </summary>
		/// <param name="p1">appears to always be 1 (only comes up twice)</param>
		void SpecialAbilityChargeContinuous(int player, int p1, int p2);
		/// <summary>
		/// </summary>
		/// <param name="p1">appears as 5, 10, 15, 25, or 30. p2 is always true.</param>
		void SpecialAbilityChargeAbsolute(int player, int p1, bool p2, int p3);
		/// <summary>
		/// </summary>
		/// <param name="normalizedValue">is from 0.0 - 1.0</param>
		/// <param name="p2">is always 1</param>
		void SpecialAbilityChargeNormalized(int player, float normalizedValue, bool p2, int p3);
		/// <summary>
		/// Also known as _RECHARGE_SPECIAL_ABILITY
		/// </summary>
		void SpecialAbilityFillMeter(int player, bool p1, int p2);
		/// <summary>
		/// </summary>
		/// <param name="p1">was always true.</param>
		void SpecialAbilityDepleteMeter(int player, bool p1, int p2);
		void SpecialAbilityLock(int playerModel, int p1);
		void SpecialAbilityUnlock(int playerModel, int p1);
		bool IsSpecialAbilityUnlocked(int playerModel);
		bool IsSpecialAbilityActive(int player, int p1);
		bool IsSpecialAbilityMeterFull(int player, int p1);
		void EnableSpecialAbility(int player, bool toggle, int p2);
		bool IsSpecialAbilityEnabled(int player, int p1);
		void SetSpecialAbilityMultiplier(float multiplier);
		void _0xFFEE8FA29AB9A18E(int player, int p1);
		/// <summary>
		/// Appears once in "re_dealgonewrong"
		/// </summary>
		bool _0x5FC472C501CCADB3(int player);
		/// <summary>
		/// Only 1 occurrence. p1 was 2.
		/// </summary>
		bool _0xF10B44FD479D69F3(int player, int p1);
		/// <summary>
		/// 2 occurrences in agency_heist3a. p1 was 0.7f then 0.4f.
		/// </summary>
		bool _0xDD2620B7B9D16FF1(int player, float p1);
		/// <summary>
		/// `findCollisionLand`: This teleports the player to land when set to true and will not consider the Z coordinate parameter provided by you. It will automatically put the Z coordinate so that you don't fall from sky.
		/// </summary>
		void StartPlayerTeleport(int player, float x, float y, float z, float heading, bool p5, bool findCollisionLand, bool p7);
		bool UpdatePlayerTeleport(int player);
		/// <summary>
		/// Disables the player's teleportation
		/// </summary>
		void StopPlayerTeleport();
		bool IsPlayerTeleportActive();
		float GetPlayerCurrentStealthNoise(int player);
		/// <summary>
		/// `regenRate`: The recharge multiplier, a value between 0.0 and 1.0.
		/// Use 1.0 to reset it back to normal
		/// </summary>
		void SetPlayerHealthRechargeMultiplier(int player, float regenRate);
		float GetPlayerHealthRechargeLimit(int player);
		void SetPlayerHealthRechargeLimit(int player, float limit);
		void SetPlayerFallDistance(int player, float p1);
		/// <summary>
		/// This modifies the damage value of your weapon. Whether it is a multiplier or base damage is unknown.
		/// Based on tests, it is unlikely to be a multiplier.
		/// modifier's min value is 0.1
		/// </summary>
		void SetPlayerWeaponDamageModifier(int player, float modifier);
		/// <summary>
		/// modifier's min value is 0.1
		/// </summary>
		void SetPlayerWeaponDefenseModifier(int player, float modifier);
		/// <summary>
		/// modifier's min value is 0.1
		/// </summary>
		void SetPlayerWeaponDefenseModifier2(int player, float modifier);
		/// <summary>
		/// modifier's min value is 0.1
		/// </summary>
		void SetPlayerMeleeWeaponDamageModifier(int player, float modifier, bool p2);
		/// <summary>
		/// modifier's min value is 0.1
		/// </summary>
		void SetPlayerMeleeWeaponDefenseModifier(int player, float modifier);
		/// <summary>
		/// modifier's min value is 0.1
		/// </summary>
		void SetPlayerVehicleDamageModifier(int player, float modifier);
		/// <summary>
		/// modifier's min value is 0.1
		/// </summary>
		void SetPlayerVehicleDefenseModifier(int player, float modifier);
		/// <summary>
		/// SET_PLAYER_MAX_*
		/// </summary>
		void _0x8D768602ADEF2245(int player, float p1);
		void _0xD821056B9ACF8052(int player, int p1);
		void _0x31E90B8873A4CD3B(int player, float p1);
		/// <summary>
		/// Tints:
		/// None = -1,
		/// Rainbow = 0,
		/// Red = 1,
		/// SeasideStripes = 2,
		/// WidowMaker = 3,
		/// Patriot = 4,
		/// Blue = 5,
		/// Black = 6,
		/// See NativeDB for reference: http://natives.altv.mp/#/0xA3D0E54541D9A5E5
		/// </summary>
		void SetPlayerParachuteTintIndex(int player, int tintIndex);
		/// <summary>
		/// Tints:
		/// None = -1,
		/// Rainbow = 0,
		/// Red = 1,
		/// SeasideStripes = 2,
		/// WidowMaker = 3,
		/// Patriot = 4,
		/// Blue = 5,
		/// Black = 6,
		/// See NativeDB for reference: http://natives.altv.mp/#/0x75D3F7A1B0D9B145
		/// </summary>
		void GetPlayerParachuteTintIndex(int player, ref int tintIndex);
		/// <summary>
		/// Tints:
		/// None = -1,
		/// Rainbow = 0,
		/// Red = 1,
		/// SeasideStripes = 2,
		/// WidowMaker = 3,
		/// Patriot = 4,
		/// Blue = 5,
		/// Black = 6,
		/// See NativeDB for reference: http://natives.altv.mp/#/0xAF04C87F5DC1DF38
		/// </summary>
		void SetPlayerReserveParachuteTintIndex(int player, int index);
		/// <summary>
		/// Tints:
		/// None = -1,
		/// Rainbow = 0,
		/// Red = 1,
		/// SeasideStripes = 2,
		/// WidowMaker = 3,
		/// Patriot = 4,
		/// Blue = 5,
		/// Black = 6,
		/// See NativeDB for reference: http://natives.altv.mp/#/0xD5A016BC3C09CF40
		/// </summary>
		void GetPlayerReserveParachuteTintIndex(int player, ref int index);
		/// <summary>
		/// tints 0- 13
		/// 0 - unkown
		/// 1 - unkown
		/// 2 - unkown
		/// 3 - unkown
		/// 4 - unkown
		/// </summary>
		void SetPlayerParachutePackTintIndex(int player, int tintIndex);
		/// <summary>
		/// </summary>
		void GetPlayerParachutePackTintIndex(int player, ref int tintIndex);
		void SetPlayerHasReserveParachute(int player);
		bool GetPlayerHasReserveParachute(int player);
		void SetPlayerCanLeaveParachuteSmokeTrail(int player, bool enabled);
		void SetPlayerParachuteSmokeTrailColor(int player, int r, int g, int b);
		/// <summary>
		/// </summary>
		void GetPlayerParachuteSmokeTrailColor(int player, ref int r, ref int g, ref int b);
		/// <summary>
		/// example:
		/// wouldnt the flag be the seatIndex?
		/// </summary>
		/// <param name="player">:SET_PLAYER_RESET_FLAG_PREFER_REAR_SEATS(PLAYER::PLAYER_ID(), 6);</param>
		/// <param name="flags">0-6</param>
		void SetPlayerResetFlagPreferRearSeats(int player, int flags);
		void SetPlayerNoiseMultiplier(int player, float multiplier);
		/// <summary>
		/// Values around 1.0f to 2.0f used in game scripts.
		/// </summary>
		void SetPlayerSneakingNoiseMultiplier(int player, float multiplier);
		bool CanPedHearPlayer(int player, int ped);
		/// <summary>
		/// This is to make the player walk without accepting input from INPUT.
		/// C# Example :
		/// Function.Call(Hash.SIMULATE_PLAYER_INPUT_GAIT, Game.Player, 1.0f, 100, 1.0f, 1, 0); //Player will go forward for 100ms
		/// </summary>
		/// <param name="gaitType">is in increments of 100s. 2000, 500, 300, 200, etc.</param>
		/// <param name="p4">is always 1 and p5 is always 0.</param>
		void SimulatePlayerInputGait(int player, float amount, int gaitType, float speed, bool p4, bool p5);
		void ResetPlayerInputGait(int player);
		void SetAutoGiveParachuteWhenEnterPlane(int player, bool toggle);
		void SetAutoGiveScubaGearWhenExitVehicle(int player, bool toggle);
		void SetPlayerStealthPerceptionModifier(int player, float value);
		/// <summary>
		/// IS_*
		/// </summary>
		bool _0x690A61A6D13583F6(int player);
		void _0x9EDD76E87D5D51BA(int player);
		void SetPlayerSimulateAiming(int player, bool toggle);
		void SetPlayerClothPinFrames(int player, int p1);
		/// <summary>
		/// Every occurrence was either 0 or 2.
		/// </summary>
		void SetPlayerClothPackageIndex(int index);
		/// <summary>
		/// 6 matches across 4 scripts. 5 occurrences were 240. The other was 255.
		/// </summary>
		void SetPlayerClothLockCounter(int value);
		/// <summary>
		/// Only 1 match. ob_sofa_michael.
		/// PLAYER::PLAYER_ATTACH_VIRTUAL_BOUND(-804.5928f, 173.1801f, 71.68436f, 0f, 0f, 0.590625f, 1f, 0.7f);1.0.335.2, 1.0.350.1/2, 1.0.372.2, 1.0.393.2, 1.0.393.4, 1.0.463.1;
		/// </summary>
		void PlayerAttachVirtualBound(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7);
		/// <summary>
		/// 1.0.335.2, 1.0.350.1/2, 1.0.372.2, 1.0.393.2, 1.0.393.4, 1.0.463.1;
		/// </summary>
		void PlayerDetachVirtualBound();
		bool HasPlayerBeenSpottedInStolenVehicle(int player);
		/// <summary>
		/// Returns true if an unk value is greater than 0.0f
		/// </summary>
		bool IsPlayerBattleAware(int player);
		/// <summary>
		/// var num3 = PLAYER::GET_PLAYER_PED(l_2171); // proof l_2171 is a player
		/// var num17 = PLAYER::0x9DF75B2A(l_2171, 100, 0); // l_2171
		/// .ysc:
		/// if (PLAYER::GET_PLAYER_WANTED_LEVEL(l_6EF) < v_4) { // l_6EF is a player
		/// PLAYER::SET_PLAYER_WANTED_LEVEL(l_6EF, v_4, 0); // l_6EF
		/// PLAYER::SET_PLAYER_WANTED_LEVEL_NOW(l_6EF, 0); // l_6EF
		/// } else {
		/// PLAYER::_4669B3ED80F24B4E(l_6EF); // l_6EF
		/// HUD::_BA8D65C1C65702E5(1);
		/// See NativeDB for reference: http://natives.altv.mp/#/0xBC0753C9CA14B506
		/// </summary>
		bool _0xBC0753C9CA14B506(int player, int p1, bool p2);
		/// <summary>
		/// Appears only 3 times in the scripts, more specifically in michael1.ysc
		/// -
		/// This can be used to prevent dying if you are "out of the world"
		/// </summary>
		void ExtendWorldBoundaryForPlayer(float x, float y, float z);
		void ResetWorldBoundaryForPlayer();
		/// <summary>
		/// Returns true if the player is riding a train.
		/// </summary>
		bool IsPlayerRidingTrain(int player);
		bool HasPlayerLeftTheWorld(int player);
		void SetPlayerLeavePedBehind(int player, bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="p1">was always 5.</param>
		/// <param name="p4">was always false.</param>
		void SetPlayerParachuteVariationOverride(int player, int p1, int p2, int p3, bool p4);
		void ClearPlayerParachuteVariationOverride(int player);
		void SetPlayerParachuteModelOverride(int player, int model);
		void SetPlayerReserveParachuteModelOverride(int player, int model);
		int GetPlayerParachuteModelOverride(int player);
		int GetPlayerReserveParachuteModelOverride(int player);
		void ClearPlayerParachuteModelOverride(int player);
		void ClearPlayerReserveParachuteModelOverride(int player);
		void SetPlayerParachutePackModelOverride(int player, int model);
		void ClearPlayerParachutePackModelOverride(int player);
		void DisablePlayerVehicleRewards(int player);
		/// <summary>
		/// Used with radios:
		/// void sub_cf383(auto _a0) {
		/// if ((a_0)==1) {
		/// if (MISC::IS_BIT_SET((g_240005._f1), 3)) {
		/// PLAYER::_2F7CEB6520288061(0);
		/// AUDIO::SET_AUDIO_FLAG("AllowRadioDuringSwitch", 0);
		/// AUDIO::SET_MOBILE_PHONE_RADIO_STATE(0);
		/// AUDIO::SET_AUDIO_FLAG("MobileRadioInGame", 0);
		/// }
		/// See NativeDB for reference: http://natives.altv.mp/#/0x2F7CEB6520288061
		/// </summary>
		void _0x2F7CEB6520288061(bool p0);
		void SetPlayerBluetoothState(int player, bool state);
		bool IsPlayerBluetoothEnable(int player);
		/// <summary>
		/// DISABLE_*
		/// </summary>
		void _0x5501B7A5CDB79D37(int player);
		int GetPlayerFakeWantedLevel(int player);
		void _0x55FCC0C390620314(int p0, int p1, int p2);
		void _0x2382AB11450AE7BA(int p0, int p1);
		int _0x6E4361FF3E8CD7CA(int p0);
		/// <summary>
		/// Unsets playerPed+330 if the current weapon has certain flags.
		/// </summary>
		void _0x237440E46D918649(int p0);
		void SetPlayerHomingRocketDisabled(int p0, int p1);
		/// <summary>
		/// ADD_*
		/// </summary>
		void _0x9097EB6D4BB9A12A(int player, int entity);
		/// <summary>
		/// REMOVE_*
		/// </summary>
		void _0x9F260BFB59ADBCA3(int player, int entity);
		void _0x7BAE68775557AE0B(int p0, int p1, int p2, int p3, int p4, int p5);
		/// <summary>
		/// Resets values set by 0x70A382ADEC069DD3
		/// _RESET_VOIP_*
		/// </summary>
		void _0x7148E0F43D11F0D9();
		/// <summary>
		/// Might be voip related
		/// _SET_VOIP_*
		/// </summary>
		void _0x70A382ADEC069DD3(float coordX, float coordY, float coordZ);
		void _0x48621C9FCA3EBD28(int p0);
		void _0x81CBAE94390F9F89();
		void _0x13B350B8AD0EEE10();
		void _0x293220DA1B46CEBC(float p0, float p1, int p2);
		/// <summary>
		/// -This function appears to be deprecated/ unused. Tracing the call internally leads to a _nullsub -
		/// first one seems to be a string of a mission name, second one seems to be a bool/toggle
		/// </summary>
		/// <param name="p1">was always 0.</param>
		void _0x208784099002BC30(string missionNameLabel, int p1);
		/// <summary>
		/// This disable the recording feature and has to be called every frame.
		/// </summary>
		void StopRecordingThisFrame();
		void _0xF854439EFBB3B583();
		/// <summary>
		/// This will disable the ability to make camera changes in R* Editor.
		/// RE*
		/// </summary>
		void DisableRockstarEditorCameraChanges();
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		void _0x66972397E0757E7A(int p0, int p1, int p2);
		/// <summary>
		/// Starts recording a replay.
		/// If mode is 0, turns on action replay.
		/// If mode is 1, starts recording.
		/// If already recording a replay, does nothing.
		/// </summary>
		void StartRecording(int mode);
		/// <summary>
		/// Stops recording and saves the recorded clip.
		/// </summary>
		void StopRecordingAndSaveClip();
		/// <summary>
		/// Stops recording and discards the recorded clip.
		/// </summary>
		void StopRecordingAndDiscardClip();
		bool SaveRecordingClip();
		/// <summary>
		/// mov al, cs:g_bIsRecordingGameplay // byte_141DD0CD0 in b944
		/// retn
		/// </summary>
		/// <returns>Checks if you're recording, returns TRUE when you start recording (F1) or turn on action replay (F2)</returns>
		bool IsRecording();
		int _0xDF4B952F7D381B95();
		int _0x4282E08174868BE3();
		bool _0x33D47E85B476ABCD(bool p0);
		/// <summary>
		/// Does nothing (it's a nullsub).
		/// </summary>
		void _0x7E2BD3EF6C205F09(string p0, bool p1);
		/// <summary>
		/// Returns a bool if interior rendering is disabled, if yes, all "normal" rendered interiors are invisible
		/// </summary>
		bool IsInteriorRenderingDisabled();
		/// <summary>
		/// Disables some other rendering (internal)
		/// </summary>
		void _0x5AD3932DAEB1E5D3();
		void _0xE058175F8EAFE79A(bool p0);
		/// <summary>
		/// Sets (almost, not sure) all Rockstar Editor values (bIsRecording etc) to 0.
		/// </summary>
		void ResetEditorValues();
		/// <summary>
		/// Please note that you will need to call DO_SCREEN_FADE_IN after exiting the Rockstar Editor when you call this.
		/// </summary>
		void ActivateRockstarEditor(int p0);
		void RequestScript(string scriptName);
		void SetScriptAsNoLongerNeeded(string scriptName);
		/// <summary>
		/// Returns if a script has been loaded into the game. Used to see if a script was loaded after requesting.
		/// </summary>
		bool HasScriptLoaded(string scriptName);
		bool DoesScriptExist(string scriptName);
		/// <summary>
		/// formerly _REQUEST_STREAMED_SCRIPT
		/// </summary>
		void RequestScriptWithNameHash(int scriptHash);
		void SetScriptWithNameHashAsNoLongerNeeded(int scriptHash);
		bool HasScriptWithNameHashLoaded(int scriptHash);
		bool DoesScriptWithNameHashExist(int scriptHash);
		void TerminateThread(int threadId);
		bool IsThreadActive(int threadId);
		string GetNameOfThread(int threadId);
		/// <summary>
		/// Starts a new iteration of the current threads.
		/// Call this first, then SCRIPT_THREAD_ITERATOR_GET_NEXT_THREAD_ID (0x30B4FA1C82DD4B9F)
		/// </summary>
		void ScriptThreadIteratorReset();
		int ScriptThreadIteratorGetNextThreadId();
		int GetIdOfThisThread();
		void TerminateThisThread();
		/// <summary>
		/// Gets the number of instances of the specified script is currently running.
		/// if (program)
		/// v3 = rage::scrProgram::GetNumRefs(program) - 1;
		/// return v3;
		/// </summary>
		/// <returns>Actually returns numRefs - 1.</returns>
		int GetNumberOfReferencesOfScriptWithNameHash(int scriptHash);
		string GetThisScriptName();
		int GetHashOfThisScriptName();
		/// <summary>
		/// </summary>
		/// <param name="eventGroup">0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)</param>
		int GetNumberOfEvents(int eventGroup);
		/// <summary>
		/// </summary>
		/// <param name="eventGroup">0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)</param>
		bool GetEventExists(int eventGroup, int eventIndex);
		/// <summary>
		/// </summary>
		/// <param name="eventGroup">0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)</param>
		int GetEventAtIndex(int eventGroup, int eventIndex);
		/// <summary>
		/// Note: eventDataSize is NOT the size in bytes, it is the size determined by the SIZE_OF operator (RAGE Script operator, not C/C++ sizeof). That is, the size in bytes divided by 8 (script variables are always 8-byte aligned!).
		/// </summary>
		/// <param name="eventGroup">0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)</param>
		bool GetEventData(int eventGroup, int eventIndex, ref int eventData, int eventDataSize);
		/// <summary>
		/// Note: eventDataSize is NOT the size in bytes, it is the size determined by the SIZE_OF operator (RAGE Script operator, not C/C++ sizeof). That is, the size in bytes divided by 8 (script variables are always 8-byte aligned!).
		/// </summary>
		/// <param name="eventGroup">0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)</param>
		/// <param name="playerBits">(also known as playersToBroadcastTo) is a bitset that indicates which players this event should be sent to. In order to send the event to specific players only, use (1 << playerIndex). Set all bits if it should be broadcast to all players.</param>
		void TriggerScriptEvent(int eventGroup, ref int eventData, int eventDataSize, int playerBits);
		void ShutdownLoadingScreen();
		void SetNoLoadingScreen(bool toggle);
		bool GetNoLoadingScreen();
		void _0xB1577667C3708F9B();
		/// <summary>
		/// Returns true if bit 0 in GtaThread+0x154 is set.
		/// BG_*
		/// </summary>
		bool _0x836B62713E0534CA();
		/// <summary>
		/// Sets bit 1 in GtaThread+0x154
		/// BG_*
		/// </summary>
		void _0x760910B49D2B98EA();
		/// <summary>
		/// Hashed version of 0x9D5A25BADB742ACD.
		/// </summary>
		void BgStartContextHash(int contextHash);
		/// <summary>
		/// Hashed version of 0xDC2BACD920D0A0DD.
		/// </summary>
		void BgEndContextHash(int contextHash);
		/// <summary>
		/// Inserts the given context into the background scripts context map.
		/// </summary>
		void BgStartContext(string contextName);
		/// <summary>
		/// Deletes the given context from the background scripts context map.
		/// </summary>
		void BgEndContext(string contextName);
		/// <summary>
		/// BG_*
		/// </summary>
		bool _0x0F6F1EBBC4E1D5E6(int scriptIndex, string p1);
		/// <summary>
		/// BG_*
		/// </summary>
		int _0x22E21FBCFC88C149(int scriptIndex, string p1);
		/// <summary>
		/// BG_*
		/// </summary>
		int _0x829CD22E043A2577(int p0);
		/// <summary>
		/// Asynchronously starts a line-of-sight (raycast) world probe shape test.
		/// </summary>
		/// <param name="p8">is a bit mask with bits 1, 2 and/or 4, relating to collider types; 4 should usually be used.</param>
		/// <returns>Use the handle with 0x3D87450E15D98694 or 0x65287525D951F6BE until it returns 0 or 2.</returns>
		int StartShapeTestLosProbe(float x1, float y1, float z1, float x2, float y2, float z2, int flags, int entity, int p8);
		/// <summary>
		/// Does the same as 0x7EE9F5D83DD4F90E, except blocking until the shape test completes.
		/// </summary>
		int StartExpensiveSynchronousShapeTestLosProbe(float x1, float y1, float z1, float x2, float y2, float z2, int flags, int entity, int p8);
		int StartShapeTestBoundingBox(int entity, int flags1, int flags2);
		int StartShapeTestBox(float x, float y, float z, float x1, float y2, float z2, float rotX, float rotY, float rotZ, int p9, int flags, int entity, int p12);
		int StartShapeTestBound(int entity, int flags1, int flags2);
		/// <summary>
		/// Raycast from point to point, where the ray has a radius.
		/// vehicles=10
		/// peds =12
		/// Iterating through flags yields many ped / vehicle/ object combinations
		/// </summary>
		/// <param name="entity">is an entity to ignore</param>
		/// <param name="p9">= 7, but no idea what it does</param>
		int StartShapeTestCapsule(float x1, float y1, float z1, float x2, float y2, float z2, float radius, int flags, int entity, int p9);
		int StartShapeTestSweptSphere(float x1, float y1, float z1, float x2, float y2, float z2, float radius, int flags, int entity, int p9);
		/// <summary>
		/// In its only usage in game scripts its called with flag set to 511, entity to player_ped_id and flag2 set to 7
		/// </summary>
		/// <returns>Actual name starts with START_SHAPE_TEST_??? and it returns a ShapeTest handle that can be used with GET_SHAPE_TEST_RESULT.</returns>
		int StartShapeTestSurroundingCoords(ref Vector3 pVec1, ref Vector3 pVec2, int flag, int entity, int flag2);
		/// <summary>
		/// Returns the result of a shape test: 0 if the handle is invalid, 1 if the shape test is still pending, or 2 if the shape test has completed, and the handle should be invalidated.
		/// When used with an asynchronous shape test, this native should be looped until returning 0 or 2, after which the handle is invalidated.
		/// </summary>
		int GetShapeTestResult(int shapeTestHandle, ref bool hit, ref Vector3 endCoords, ref Vector3 surfaceNormal, ref int entityHit);
		/// <summary>
		/// Returns the result of a shape test, also returning the material of any touched surface.
		/// When used with an asynchronous shape test, this native should be looped until returning 0 or 2, after which the handle is invalidated.
		/// </summary>
		/// <returns>Unless the return value is 2, the other return values are undefined.</returns>
		int GetShapeTestResultIncludingMaterial(int shapeTestHandle, ref bool hit, ref Vector3 endCoords, ref Vector3 surfaceNormal, ref int materialHash, ref int entityHit);
		/// <summary>
		/// Invalidates the entity handle passed by removing the fwScriptGuid from the entity. This should be used when receiving an ambient entity from shape testing natives, but can also be used for other natives returning an 'irrelevant' entity handle.
		/// </summary>
		void ReleaseScriptGuidFromEntity(int entityHit);
		int ScInboxGetTotalNumMessages();
		int ScInboxGetMessageTypeAtIndex(int msgIndex);
		bool ScInboxGetMessageIsReadAtIndex(int msgIndex);
		bool ScInboxMessagePop(int p0);
		/// <summary>
		/// </summary>
		bool ScInboxMessageGetDataInt(int p0, string context, ref int @out);
		bool ScInboxMessageGetDataBool(int p0, string p1);
		/// <summary>
		/// </summary>
		bool ScInboxMessageGetDataString(int p0, string context, ref string @out);
		bool ScInboxMessageDoApply(int p0);
		string ScInboxMessageGetString(int p0);
		/// <summary>
		/// </summary>
		void ScInboxMessagePushGamerToEventRecipList(ref int gamerHandle);
		/// <summary>
		/// </summary>
		void ScInboxMessageSendUgcStatUpdateEvent(ref int data);
		/// <summary>
		/// </summary>
		bool ScInboxMessageGetUgcdata(int p0, ref int p1);
		/// <summary>
		/// </summary>
		bool ScInboxMessageSendBountyPresenceEvent(ref int data);
		/// <summary>
		/// </summary>
		bool ScInboxMessageGetBountyData(int index, ref int outData);
		void ScInboxGetEmails(int offset, int limit);
		int _0x16DA8172459434AA();
		int _0x7DB18CA8CAD5B098();
		/// <summary>
		/// </summary>
		bool _0x4737980E8A283806(int p0, ref int p1);
		/// <summary>
		/// </summary>
		void _0x44ACA259D67651DB(ref int p0, int p1);
		/// <summary>
		/// </summary>
		void ScEmailMessagePushGamerToRecipList(ref int gamerHandle);
		void ScEmailMessageClearRecipList();
		void _0x116FB94DC4B79F17(string p0);
		int _0x07DBD622D9533857(int p0);
		void SetHandleRockstarMessageViaScript(bool toggle);
		bool IsRockstarMessageReadyForScript();
		string RockstarMessageGetString();
		bool ScPresenceAttrSetInt(int attrHash, int value);
		bool ScPresenceAttrSetFloat(int attrHash, float value);
		bool ScPresenceAttrSetString(int attrHash, string value);
		bool _0x487912FD248EFDDF(int p0, float p1);
		int _0xC85A7127E7AD02AA();
		int _0xA770C8EEC6FB2AC5();
		/// <summary>
		/// sfink: from scripts:
		/// func_720(socialclub::_0x8416FE4E4629D7D7("bIgnoreCheaterOverride"));
		/// func_719(socialclub::_0x8416FE4E4629D7D7("bIgnoreBadSportOverride"));
		/// </summary>
		bool ScGetIsProfileAttributeSet(string name);
		int _0x7FFCBFEE44ECFABF();
		int _0x2D874D4AE612A65F();
		/// <summary>
		/// Starts a task to check an entered string for profanity on the ROS/Social Club services.
		/// See also: 1753344C770358AE, 82E4A58BABC15AE7.
		/// </summary>
		bool ScProfanityCheckString(string @string, ref int token);
		/// <summary>
		/// </summary>
		bool ScProfanityCheckUgcString(string @string, ref int token);
		bool ScProfanityGetCheckIsValid(int token);
		bool ScProfanityGetCheckIsPending(int token);
		bool ScProfanityGetStringPassed(int token);
		int ScProfanityGetStringStatus(int token);
		/// <summary>
		/// </summary>
		bool _0xF6BAAAF762E1BF40(string p0, ref int p1);
		bool _0xF22CA0FD74B80E7A(int p0);
		int _0x9237E334F6E43156(int p0);
		int _0x700569DBA175A77C(int p0);
		int _0x1D4446A62D35B0D0(int p0, int p1);
		int _0x2E89990DDFF670C3(int p0, int p1);
		/// <summary>
		/// </summary>
		bool _0xD0EE05FE193646EA(string p0, string p1, ref int p2);
		/// <summary>
		/// </summary>
		bool _0x1989C6E6F67E76A8(string p0, ref int p1, ref int p2);
		int _0x07C61676E5BB52CD(int p0);
		int _0x8147FFF6A718E1AD(int p0);
		/// <summary>
		/// </summary>
		bool _0x0F73393BAC7E6730(string p0, ref int p1);
		int _0xD302E99EDF0449CF(int p0);
		int _0x5C4EBFFA98BDB41C(int p0);
		bool _0xFF8F3A92B75ED67A();
		int _0x4ED9C8D6DA297639();
		/// <summary>
		/// </summary>
		bool _0x710BCDA8071EDED1(string p0, ref int p1);
		/// <summary>
		/// </summary>
		bool _0x50A8A36201DBF83E(string p0, ref float p1);
		/// <summary>
		/// </summary>
		bool _0x9DE5D2F723575ED0(string p0, ref string p1);
		/// <summary>
		/// </summary>
		bool _0xC2C97EA97711D1AE(ref string p0);
		bool _0x450819D8CF90C416(string p0);
		int _0x4A7D6E727F941747(string p0);
		/// <summary>
		/// </summary>
		bool _0xE75A4A2E5E316D86(string p0, ref int p1, string p2);
		/// <summary>
		/// </summary>
		bool _0x2570E26BE63964E3(string p0, ref float p1, string p2);
		/// <summary>
		/// </summary>
		bool _0x1D12A56FC95BE92E(string p0, ref string p1, string p2);
		/// <summary>
		/// </summary>
		bool _0x33DF47CC0642061B(ref string p0, string p1);
		bool _0xA468E0BE12B12C70(int p0);
		/// <summary>
		/// </summary>
		bool _0x8CC469AB4D349B7C(int p0, string p1, ref int p2);
		/// <summary>
		/// </summary>
		bool _0xC5A35C73B68F3C49(int p0, string p1, ref float p2);
		/// <summary>
		/// </summary>
		bool _0x699E4A5C8C893A18(int p0, string p1, ref string p2);
		/// <summary>
		/// </summary>
		bool _0x19853B5B17D77BCA(int p0, ref string p1);
		bool _0x6BFB12CE158E3DD4(int p0);
		bool _0xFE4C1D0D3B9CC17E(int p0, int p1);
		int _0xD8122C407663B995();
		bool _0x3001BEF2FECA3680();
		/// <summary>
		/// </summary>
		bool _0x92DA6E70EF249BD1(string p0, ref int p1);
		void _0x675721C9F644D161();
		int _0xE4F6E8D07A2F0F51(int p0);
		/// <summary>
		/// Fills some 0x30 sized struct
		/// </summary>
		bool _0x8A4416C0DB05FA66(int p0);
		void _0xEA95C0853A27888E();
		/// <summary>
		/// Returns the nickname of the logged-in Rockstar Social Club account.
		/// </summary>
		string ScGetNickname();
		/// <summary>
		/// </summary>
		bool _0x225798743970412B(ref int p0);
		/// <summary>
		/// Same as HAS_ACHIEVEMENT_BEEN_PASSED
		/// </summary>
		bool ScGetHasAchievementBeenPassed(int achievementId);
		/// <summary>
		/// Example:
		/// for (v_2 = 0; v_2 <= 4; v_2 += 1) {
		/// STATS::STAT_CLEAR_SLOT_FOR_RELOAD(v_2);
		/// }
		/// </summary>
		int StatClearSlotForReload(int statSlot);
		bool StatLoad(int p0);
		bool StatSave(int p0, bool p1, int p2, int p3);
		/// <summary>
		/// STAT_SET_*
		/// </summary>
		void _0x5688585E6D563CD8(int p0);
		bool StatLoadPending(int p0);
		bool StatSavePending();
		bool StatSavePendingOrRequested();
		int StatDeleteSlot(int p0);
		bool StatSlotIsLoaded(int p0);
		bool _0x7F2C4CDF2E82DF4C(int p0);
		int _0xE496A53BA5F50A56(int p0);
		void StatSetBlockSaves(bool toggle);
		bool _0x6A7F19756F1A9016();
		bool _0x7E6946F68A38B74F(int p0);
		void _0xA8733668D1047B51(int p0);
		/// <summary>
		/// STAT_LOAD_*
		/// </summary>
		bool _0xECB41AC6AB754401();
		void _0x9B4BD21D69B1E609();
		int _0xC0E0D686DDFC6EAE();
		/// <summary>
		/// Example:
		/// STATS::STAT_SET_INT(MISC::GET_HASH_KEY("MPPLY_KILLS_PLAYERS"), 1337, true);
		/// </summary>
		bool StatSetInt(int statName, int value, bool save);
		/// <summary>
		/// Example:
		/// STATS::STAT_SET_FLOAT(MISC::GET_HASH_KEY("MP0_WEAPON_ACCURACY"), 66.6f, true);
		/// </summary>
		bool StatSetFloat(int statName, float value, bool save);
		/// <summary>
		/// Example:
		/// STATS::STAT_SET_BOOL(MISC::GET_HASH_KEY("MPPLY_MELEECHLENGECOMPLETED"), trur, true);
		/// </summary>
		bool StatSetBool(int statName, bool value, bool save);
		/// <summary>
		/// The following values have been found in the decompiled scripts:
		/// "RC_ABI1"
		/// "RC_ABI2"
		/// "RC_BA1"
		/// "RC_BA2"
		/// "RC_BA3"
		/// "RC_BA3A"
		/// "RC_BA3C"
		/// "RC_BA4"
		/// See NativeDB for reference: http://natives.altv.mp/#/0x17695002FD8B2AE0
		/// </summary>
		bool StatSetGxtLabel(int statName, string value, bool save);
		/// <summary>
		/// 'value' is a structure to a structure, 'numFields' is how many fields there are in said structure (usually 7).
		/// The structure looks like this:
		/// int year
		/// int month
		/// int day
		/// int hour
		/// int minute
		/// int second
		/// int millisecond
		/// The decompiled scripts use TIME::GET_POSIX_TIME to fill this structure.
		/// </summary>
		bool StatSetDate(int statName, ref int value, int numFields, bool save);
		bool StatSetString(int statName, string value, bool save);
		bool StatSetPos(int statName, float x, float y, float z, bool save);
		bool StatSetMaskedInt(int statName, int p1, int p2, int p3, bool save);
		bool StatSetUserId(int statName, string value, bool save);
		/// <summary>
		/// </summary>
		/// <param name="p1">always true.</param>
		bool StatSetCurrentPosixTime(int statName, bool p1);
		/// <summary>
		/// </summary>
		/// <param name="p2">appears to always be -1</param>
		bool StatGetInt(int statHash, ref int outValue, int p2);
		/// <summary>
		/// </summary>
		bool StatGetFloat(int statHash, ref float outValue, int p2);
		/// <summary>
		/// </summary>
		bool StatGetBool(int statHash, ref bool outValue, int p2);
		/// <summary>
		/// </summary>
		bool StatGetDate(int statHash, ref int p1, int p2, int p3);
		/// <summary>
		/// </summary>
		/// <param name="p1">is always -1 in the script files</param>
		string StatGetString(int statHash, int p1);
		/// <summary>
		/// </summary>
		bool StatGetPos(int p0, ref int p1, ref int p2, ref int p3, int p4);
		/// <summary>
		/// </summary>
		bool StatGetMaskedInt(int p0, ref int p1, int p2, int p3, int p4);
		/// <summary>
		/// </summary>
		/// <returns>Needs more research. Seems to return "STAT_UNKNOWN" if no such user id exists.</returns>
		string StatGetUserId(int p0);
		string StatGetLicensePlate(int statName);
		bool StatSetLicensePlate(int statName, string str);
		void StatIncrement(int statName, float value);
		bool _0x5A556B229A169402();
		bool _0xB1D2BB1E1631F5B1();
		/// <summary>
		/// </summary>
		bool _0xBED9F5693F34ED17(int statName, int p1, ref float outValue);
		/// <summary>
		/// STATS::0x343B27E2(0);
		/// STATS::0x343B27E2(1);
		/// STATS::0x343B27E2(2);
		/// STATS::0x343B27E2(3);
		/// STATS::0x343B27E2(4);
		/// STATS::0x343B27E2(5);
		/// STATS::0x343B27E2(6);
		/// STATS::0x343B27E2(7);
		/// Identical in ingamehud & maintransition.
		/// </summary>
		void _0x26D7399B9587FE89(int p0);
		/// <summary>
		/// STATS::0xE3247582(0);
		/// STATS::0xE3247582(1);
		/// STATS::0xE3247582(2);
		/// STATS::0xE3247582(3);
		/// STATS::0xE3247582(4);
		/// STATS::0xE3247582(5);
		/// STATS::0xE3247582(6);
		/// </summary>
		void _0xA78B8FA58200DA56(int p0);
		int StatGetNumberOfDays(int statName);
		int StatGetNumberOfHours(int statName);
		int StatGetNumberOfMinutes(int statName);
		int StatGetNumberOfSeconds(int statName);
		/// <summary>
		/// Does not take effect immediately, unfortunately.
		/// </summary>
		/// <param name="profileSetting">seems to only be 936, 937 and 938 in scripts</param>
		void StatSetProfileSettingValue(int profileSetting, int value);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void _0xC01D2470F22CDE5A();
		/// <summary>
		/// Needs more research. Possibly used to calculate the "mask" when calling "STAT_SET_BOOL_MASKED"?
		/// </summary>
		int StatGetPackedBoolMask(int p0);
		/// <summary>
		/// Needs more research. Possibly used to calculate the "mask" when calling "STAT_SET_MASKED_INT"?
		/// </summary>
		int StatGetPackedIntMask(int p0);
		int GetPackedBoolStatKey(int index, bool spStat, bool charStat, int character);
		int GetPackedIntStatKey(int index, bool spStat, bool charStat, int character);
		int GetPackedTuBoolStatKey(int index, bool spStat, bool charStat, int character);
		int GetPackedTuIntStatKey(int index, bool spStat, bool charStat, int character);
		/// <summary>
		/// Needs more research. Gets the stat name of a masked bool?
		/// "_NGPSTAT_BOOL"
		/// "_NGTATPSTAT_BOOL"
		/// "_NGDLCPSTAT_BOOL"
		/// "_DLCBIKEPSTAT_BOOL"
		/// "_DLCGUNPSTAT_BOOL"
		/// "_GUNTATPSTAT_BOOL"
		/// "_DLCSMUGCHARPSTAT_BOOL"
		/// "_GANGOPSPSTAT_BOOL"
		/// See NativeDB for reference: http://natives.altv.mp/#/0xBA52FF538ED2BC71
		/// </summary>
		/// <param name="section">- values used in the decompiled scripts:</param>
		int GetNgstatBoolHash(int index, bool spStat, bool charStat, int character, string section);
		/// <summary>
		/// Needs more research. Gets the stat name of a masked int?
		/// "_NGPSTAT_INT"
		/// "_MP_NGPSTAT_INT"
		/// "_MP_LRPSTAT_INT"
		/// "_MP_APAPSTAT_INT"
		/// "_MP_LR2PSTAT_INT"
		/// "_MP_BIKEPSTAT_INT"
		/// "_MP_IMPEXPPSTAT_INT"
		/// "_MP_GUNRPSTAT_INT"
		/// See NativeDB for reference: http://natives.altv.mp/#/0x2B4CDCA6F07FF3DA
		/// </summary>
		/// <param name="section">- values used in the decompiled scripts:</param>
		int GetNgstatIntHash(int index, bool spStat, bool charStat, int character, string section);
		/// <summary>
		/// </summary>
		/// <param name="p2">- Default value? Seems to be -1 most of the time.</param>
		bool StatGetBoolMasked(int statName, int mask, int p2);
		bool StatSetBoolMasked(int statName, bool value, int mask, bool save);
		void PlaystatsBackgroundScriptAction(string action, int value);
		/// <summary>
		/// </summary>
		void PlaystatsNpcInvite(ref int p0);
		void PlaystatsAwardXp(int amount, int type, int category);
		void PlaystatsRankUp(int rank);
		/// <summary>
		/// PLAYSTATS_START_INVITE_DESPAWNING?
		/// </summary>
		void PlaystatsStartOfflineMode();
		void PlaystatsActivityDone(int p0, int p1);
		void PlaystatsLeaveJobChain(int p0, int p1, int p2, int p3, int p4);
		/// <summary>
		/// </summary>
		void PlaystatsMissionStarted(ref int p0, int p1, int p2, bool p3);
		/// <summary>
		/// </summary>
		void PlaystatsMissionOver(ref int p0, int p1, int p2, bool p3, bool p4, bool p5);
		/// <summary>
		/// </summary>
		void PlaystatsMissionCheckpoint(ref int p0, int p1, int p2, int p3);
		void PlaystatsRandomMissionDone(string name, int p1, int p2, int p3);
		void PlaystatsRosBet(int amount, int act, int player, float cm);
		void PlaystatsRaceCheckpoint(int p0, int p1, int p2, int p3, int p4);
		/// <summary>
		/// PLAYSTATS_*
		/// </summary>
		bool _0x6DEE77AFF8C21BD1(ref int playerAccountId, ref int posixTime);
		void PlaystatsMatchStarted(int p0, int p1, int p2);
		void PlaystatsShopItem(int p0, int p1, int p2, int p3, int p4);
		void PlaystatsCrateDropMissionDone(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7);
		void PlaystatsCrateCreatedMissionDone(float p0, float p1, float p2);
		void PlaystatsHoldUpMissionDone(int p0, int p1, int p2, int p3);
		void PlaystatsImportExportMissionDone(int p0, int p1, int p2, int p3);
		void PlaystatsRaceToPointMissionDone(int p0, int p1, int p2, int p3);
		void PlaystatsAcquiredHiddenPackage(int p0);
		void PlaystatsWebsiteVisited(int scaleformHash, int p1);
		void PlaystatsFriendActivity(int p0, int p1);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void PlaystatsOddjobDone(int p0, int p1, int p2);
		void PlaystatsPropChange(int p0, int p1, int p2, int p3);
		void PlaystatsClothChange(int p0, int p1, int p2, int p3, int p4);
		/// <summary>
		/// This is a typo made by R*. It's supposed to be called PLAYSTATS_WEAPON_MOD_CHANGE.
		/// </summary>
		void PlaystatsWeaponModeChange(int weaponHash, int componentHashTo, int componentHashFrom);
		void PlaystatsCheatApplied(string cheat);
		/// <summary>
		/// </summary>
		void _0xF8C54A461C3E11DC(ref int p0, ref int p1, ref int p2, ref int p3);
		/// <summary>
		/// </summary>
		void _0xF5BB8DAC426A52C0(ref int p0, ref int p1, ref int p2, ref int p3);
		/// <summary>
		/// </summary>
		void _0xA736CF7FB7C5BFF4(ref int p0, ref int p1, ref int p2, ref int p3);
		/// <summary>
		/// </summary>
		void _0x14E0B2D1AD1044E0(ref int p0, ref int p1, ref int p2, ref int p3);
		void PlaystatsQuickfixTool(int element, string item);
		/// <summary>
		/// longest time being ilde?
		/// </summary>
		void PlaystatsIdleKick(int time);
		/// <summary>
		/// PLAYSTATS_S*
		/// </summary>
		void _0xD1032E482629049E(int p0);
		void PlaystatsHeistSaveCheat(int hash, int p1);
		/// <summary>
		/// </summary>
		void PlaystatsDirectorMode(ref int p0);
		void PlaystatsAwardBadsport(int id);
		void PlaystatsPegasaircraft(int modelHash);
		void _0x6A60E43998228229(int p0);
		void _0xBFAFDB5FAAA5C5AB(int p0);
		void _0x8C9D11605E59D955(int p0);
		void _0x3DE3AA516FB126A4(int p0);
		void _0xBAA2F0490E146BE8(int p0);
		void _0x1A7CE7CD3E653485(int p0);
		void _0x419615486BBF1956(int p0);
		void _0x84DFC579C2FC214C(int p0);
		void _0x0A9C7F36E5D7B683(int p0);
		void _0x164C5FF663790845(int p0);
		void _0xEDBF6C9B0D2C65C8(int p0);
		void _0x6551B1F7F6CD46EA(int p0);
		void _0x2CD90358F67D0AA8(int p0);
		/// <summary>
		/// </summary>
		void PlaystatsPiMenuHideSettings(ref int data);
		int LeaderboardsGetNumberOfColumns(int p0, int p1);
		int LeaderboardsGetColumnId(int p0, int p1, int p2);
		int LeaderboardsGetColumnType(int p0, int p1, int p2);
		int LeaderboardsReadClearAll();
		int LeaderboardsReadClear(int p0, int p1, int p2);
		bool LeaderboardsReadPending(int p0, int p1, int p2);
		bool LeaderboardsReadAnyPending();
		bool LeaderboardsReadSuccessful(int p0, int p1, int p2);
		/// <summary>
		/// </summary>
		bool Leaderboards2ReadFriendsByRow(ref int p0, ref int p1, int p2, bool p3, int p4, int p5);
		/// <summary>
		/// </summary>
		bool Leaderboards2ReadByHandle(ref int p0, ref int p1);
		/// <summary>
		/// </summary>
		bool Leaderboards2ReadByRow(ref int p0, ref int p1, int p2, ref int p3, int p4, ref int p5, int p6);
		/// <summary>
		/// </summary>
		bool Leaderboards2ReadByRank(ref int p0, int p1, int p2);
		/// <summary>
		/// </summary>
		bool Leaderboards2ReadByRadius(ref int p0, int p1, ref int p2);
		/// <summary>
		/// </summary>
		bool Leaderboards2ReadByScoreInt(ref int p0, int p1, int p2);
		/// <summary>
		/// </summary>
		bool Leaderboards2ReadByScoreFloat(ref int p0, float p1, int p2);
		/// <summary>
		/// </summary>
		bool Leaderboards2ReadRankPrediction(ref int p0, ref int p1, ref int p2);
		/// <summary>
		/// </summary>
		bool Leaderboards2ReadByPlatform(ref int p0, string gamerHandleCsv, string platformName);
		/// <summary>
		/// </summary>
		bool _0xA0F93D5465B3094D(ref int p0);
		void _0x71B008056E5692D6();
		/// <summary>
		/// </summary>
		bool _0x34770B9CE0E03B91(int p0, ref int p1);
		int _0x88578F6EC36B4A3A(int p0, int p1);
		float _0x38491439B6BA7F7D(int p0, int p1);
		/// <summary>
		/// </summary>
		bool Leaderboards2WriteData(ref int p0);
		void LeaderboardsWriteAddColumn(int p0, int p1, float p2);
		void LeaderboardsWriteAddColumnLong(int p0, int p1, int p2);
		/// <summary>
		/// </summary>
		bool LeaderboardsCacheDataRow(ref int p0);
		void LeaderboardsClearCacheData();
		void _0x8EC74CEB042E7CFF(int p0);
		bool LeaderboardsGetCacheExists(int p0);
		int LeaderboardsGetCacheTime(int p0);
		int LeaderboardsGetCacheNumberOfRows(int p0);
		/// <summary>
		/// </summary>
		bool LeaderboardsGetCacheDataRow(int p0, int p1, ref int p2);
		void UpdateStatInt(int statHash, int value, int p2);
		void UpdateStatFloat(int statHash, float value, int p2);
		/// <summary>
		/// </summary>
		void _0x6483C25849031C4F(int p0, int p1, int p2, ref int p3);
		/// <summary>
		/// example from completionpercentage_controller.ysc.c4
		/// if (STATS::_5EAD2BF6484852E4()) {
		/// MISC::SET_BIT(g_17b95._f20df._ff10, 15);
		/// STATS::_11FF1C80276097ED(0xe9ec4dd1, 200, 0);
		/// }
		/// </summary>
		bool _0x5EAD2BF6484852E4();
		void _0xC141B8917E0017EC();
		void SetProfileSettingPrologueComplete();
		/// <summary>
		/// Sets profile setting 939
		/// </summary>
		void _0xC67E2DA1CBE759E2();
		/// <summary>
		/// Sets profile setting 933
		/// </summary>
		void _0xF1A1803D3476F215(int value);
		/// <summary>
		/// Sets profile setting 934
		/// </summary>
		void _0x38BAAA5DD4C9D19F(int value);
		/// <summary>
		/// Sets profile setting 935
		/// </summary>
		void _0x55384438FC55AD8E(int value);
		void _0x723C1CE13FBFDB67(int p0, int p1);
		void _0x0D01D20616FC73FB(int p0, int p1);
		void _0x428EAF89E24F6C36(int p0, float p1);
		void StatSetCheatIsActive();
		/// <summary>
		/// </summary>
		bool Leaderboards2WriteDataForEventType(ref int p0, ref int p1);
		void _0x6F361B8889A792A3();
		void _0xC847B43F369AC0B5();
		/// <summary>
		/// </summary>
		/// <param name="platformName">must be one of the following: ps3, xbox360, ps4, xboxone</param>
		bool StatMigrateSave(string platformName);
		int _0x9A62EC95AE10E011();
		int _0x4C89FE2BDEB3F169();
		int _0xC6E0E2616A7576BB();
		int _0x5BD5F255321C4AAF(int p0);
		/// <summary>
		/// </summary>
		int _0xDEAAF77EB3687E97(int p0, ref int p1);
		/// <summary>
		/// </summary>
		int StatGetSaveMigrationStatus(ref int data);
		bool StatSaveMigrationCancel();
		int StatGetCancelSaveMigrationStatus();
		bool StatSaveMigrationConsumeContentUnlock(int contentId, string srcPlatform, string srcGamerHandle);
		/// <summary>
		/// </summary>
		int StatGetSaveMigrationConsumeContentUnlockStatus(ref int p0);
		void _0x98E2BC1CA26287C3();
		void _0x629526ABA383BCAA();
		int _0xBE3DB208333D9844();
		int _0x33D72899E24C3365(int p0, int p1);
		int _0xA761D4AC6115623D();
		int _0xF11F01D98113536A(int p0);
		int _0x8B9CDBD6C566C38C();
		int _0xE8853FBCE7D8D0D6();
		int _0xA943FD1722E11EFD();
		int _0x84A810B375E69C0E();
		int _0x9EC8858184CD253A();
		int _0xBA9749CC94C1FD85();
		int _0x55A8BECAF28A4EB7();
		int _0x32CAC93C9DE73D32();
		int _0xAFF47709F1D5DCCE();
		int _0x6E0A5253375C4584();
		int _0x1A8EA222F9C67DBB(int p0);
		int _0xF9F2922717B819EC();
		int _0x0B8B7F74BF061C6D();
		/// <summary>
		/// NETWORK_IS_*
		/// </summary>
		/// <returns>This function is hard-coded to always return 1.</returns>
		bool _0xB3DA2606774A8E2D();
		/// <summary>
		/// Sets profile setting 866
		/// SET_*
		/// </summary>
		void SetHasContentUnlocksFlags(int value);
		/// <summary>
		/// Sets profile setting 501
		/// </summary>
		void SetSaveMigrationTransactionId(int transactionId);
		void _0x6BC0ACD0673ACEBE(int p0, int p1, int p2);
		void _0x8D8ADB562F09A245(int p0);
		void _0xD1A1EE3B4FA8E760(int p0);
		void _0x88087EE1F28024AE(int p0);
		void _0xFCC228E07217FCAC(int p0);
		void _0x678F86D8FC040BDB(int p0);
		void _0xA6F54BB2FFCA35EA(int p0);
		void _0x5FF2C33B13A02A11(int p0);
		void _0x282B6739644F4347(int p0);
		void _0xF06A6F41CB445443(int p0);
		void _0x7B18DA61F6BAE9D5(int p0);
		void _0x06EAF70AE066441E(int p0);
		void _0x14EDA9EE27BD1626(int p0);
		void _0x930F504203F561C9(int p0);
		void _0xE3261D791EB44ACB(int p0);
		void _0x73001E34F85137F8(int p0);
		void _0x53CAE13E9B426993(int p0);
		void _0x7D36291161859389(int p0);
		void PlaystatsSpentPiCustomLoadout(int amount);
		/// <summary>
		/// </summary>
		void PlaystatsBuyContraband(ref int data);
		/// <summary>
		/// </summary>
		void PlaystatsSellContraband(ref int data);
		/// <summary>
		/// </summary>
		void PlaystatsDefendContraband(ref int data);
		/// <summary>
		/// </summary>
		void PlaystatsRecoverContraband(ref int data);
		void _0x60EEDC12AF66E846(int p0);
		void _0x3EBEAC6C3F81F6BD(int p0);
		void _0x96E6D5150DBF1C09(int p0, int p1, int p2);
		void _0xA3C53804BDB68ED2(int p0, int p1);
		void _0x6BCCF9948492FD85(int p0, int p1, int p2, int p3, int p4);
		void HiredLimo(int p0, int p1);
		void OrderedBossVehicle(int p0, int p1, int vehicleHash);
		void _0xD1C9B92BDD3F151D(int p0, int p1, int p2);
		void _0x44919CC079BB60BF(int p0);
		void _0x7033EEFD9B28088E(int p0);
		void _0xAA525DFF66BB82F5(int p0, int p1, int p2);
		void _0x015B03EE1C43E6EC(int p0);
		/// <summary>
		/// Allows CEventNetworkStuntPerformed to be triggered.
		/// </summary>
		void PlaystatsStuntPerformedEventAllowTrigger();
		/// <summary>
		/// Disallows CEventNetworkStuntPerformed to be triggered.
		/// </summary>
		void PlaystatsStuntPerformedEventDisallowTrigger();
		void _0xBF371CD2B64212FD(int p0);
		void _0x7D8BA05688AD64C7(int p0);
		void _0x0B565B0AAE56A0E8(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		void _0x28ECB8AC2F607DB2(int p0, int p1, int p2, int p3, int p4);
		void PlaystatsChangeMcEmblem(int p0, int p1, int p2, int p3, int p4);
		void _0xCC25A4553DFBF9EA(int p0, int p1, int p2, int p3, int p4);
		void _0xF534D94DFA2EAD26(int p0, int p1, int p2, int p3, int p4);
		void _0xD558BEC0BBA7E8D2(int p0, int p1, int p2, int p3, int p4);
		void PlaystatsEarnedMcPoints(int p0, int p1, int p2, int p3, int p4, int p5);
		void _0x03C2EEBB04B3FB72(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		void _0x8989CBD7B4E82534(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		void _0x27AA1C973CACFE63(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9);
		void PlaystatsCopyRankIntoNewSlot(int p0, int p1, int p2, int p3, int p4, int p5, int p6);
		/// <summary>
		/// </summary>
		void PlaystatsDupeDetection(ref int data);
		void PlaystatsBanAlert(int p0);
		/// <summary>
		/// </summary>
		void PlaystatsGunrunMissionEnded(ref int data);
		void _0xDAF80797FC534BEC(int p0);
		void _0x316DB59CD14C1774(int p0);
		void _0x2D7A9B577E72385E(int p0);
		void _0x830C3A44EB3F2CF9(int p0);
		void _0xB26F670685631727(int p0, int p1);
		void _0xC14BD9F5337219B2(int p0, int p1);
		/// <summary>
		/// </summary>
		void PlaystatsStoneHatchetEnd(ref int data);
		/// <summary>
		/// </summary>
		void PlaystatsSmugMissionEnded(ref int data);
		/// <summary>
		/// </summary>
		void PlaystatsH2FmprepEnd(ref int data);
		/// <summary>
		/// </summary>
		void PlaystatsH2InstanceEnd(ref int data, int p1, int p2, int p3);
		/// <summary>
		/// </summary>
		void PlaystatsDarMissionEnd(ref int data);
		/// <summary>
		/// </summary>
		void PlaystatsEnterSessionPack(ref int data);
		void PlaystatsDroneUsage(int p0, int p1, int p2);
		void PlaystatsSpectatorWheelSpin(int p0, int p1, int p2, int p3);
		void PlaystatsArenaWarSpectator(int p0, int p1, int p2, int p3, int p4);
		/// <summary>
		/// </summary>
		void PlaystatsArenaWarsEnded(ref int data);
		void PlaystatsPassiveMode(bool p0, int p1, int p2, int p3);
		void PlaystatsCollectible(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9);
		void PlaystatsCasinoStoryMissionEnded(int p0, int p1);
		void PlaystatsCasinoChip(int p0);
		void PlaystatsCasinoRoulette(int p0);
		void PlaystatsCasinoBlackjack(int p0);
		void PlaystatsCasinoThreecardpoker(int p0);
		void PlaystatsCasinoSlotmachine(int p0);
		void PlaystatsCasinoInsidetrack(int p0);
		void PlaystatsCasinoLuckyseven(int p0);
		void PlaystatsCasinoRouletteLight(int p0);
		void PlaystatsCasinoBlackjackLight(int p0);
		void PlaystatsCasinoThreecardpokerLight(int p0);
		void PlaystatsCasinoSlotmachineLight(int p0);
		void PlaystatsCasinoInsidetrackLight(int p0);
		void PlaystatsArcadegame(int p0, int p1, int p2, int p3, int p4, int p5);
		void _0x4FCDBD3F0A813C25(int p0, int p1);
		/// <summary>
		/// </summary>
		void PlaystatsCasinoMissionEnded(ref int data);
		void _0xDFBD93BF2943E29B(int p0);
		void _0x92FC0EEDFAC04A14(int p0, int p1, int p2, int p3, int p4, int p5);
		void _0x0077F15613D36993(int p0, int p1, int p2, int p3);
		void _0xF9096193DF1F99D4(int p0);
		void _0x2E0259BABC27A327(int p0);
		void _0x53C31853EC9531FF(int p0);
		void _0x810B5FCC52EC7FF0(int p0, int p1, int p2, int p3);
		void _0x5BF29846C6527C54(int p0, int p1, int p2, int p3, int p4);
		void _0xC03FAB2C2F92289B(int p0);
		void _0x5CDAED54B34B0ED0(int p0);
		void _0x4AFF7E02E485E92B();
		void _0xDFCDB14317A9B361(int p0);
		void _0xC1E963C58664B556(int p0);
		void _0x2FA3173480008493(int p0, int p1, int p2, int p3, int p4);
		void _0xD4367D310F079DB0(int p0, int p1, int p2, int p3);
		void _0x4DC416F246A41FC8(int p0, int p1, int p2, int p3, int p4);
		void _0x2818FF6638CB09DE(int p0);
		void _0xD6CA58B3B53A0F22(int p0);
		void PlaystatsRobberyPrep(int p0);
		void PlaystatsRobberyFinale(int p0);
		void PlaystatsExtraEvent(int p0);
		void PlaystatsCarclubPoints(int p0);
		void PlaystatsCarclubChallenge(int p0, int p1, int p2, int p3);
		void PlaystatsCarclubPrize(int p0, int p1);
		void LoadAllObjectsNow();
		void LoadScene(float x, float y, float z);
		bool NetworkUpdateLoadScene();
		bool IsNetworkLoadingScene();
		void SetInteriorActive(int interiorID, bool toggle);
		/// <summary>
		/// Request a model to be loaded into memory.
		/// </summary>
		void RequestModel(int model);
		void RequestMenuPedModel(int model);
		/// <summary>
		/// Checks if the specified model has loaded into memory.
		/// </summary>
		bool HasModelLoaded(int model);
		/// <summary>
		/// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BC, "V_FIB01_cur_elev");
		/// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BC, "limbo");
		/// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BB, "V_Office_gnd_lifts");
		/// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BB, "limbo");
		/// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BC, "v_fib01_jan_elev");
		/// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BC, "limbo");
		/// </summary>
		void RequestModelsInRoom(int interior, string roomName);
		/// <summary>
		/// Unloads model from memory
		/// </summary>
		void SetModelAsNoLongerNeeded(int model);
		/// <summary>
		/// Check if model is in cdimage(rpf)
		/// </summary>
		bool IsModelInCdimage(int model);
		/// <summary>
		/// Returns whether the specified model exists in the game.
		/// </summary>
		bool IsModelValid(int model);
		bool IsModelAPed(int model);
		/// <summary>
		/// Returns whether the specified model represents a vehicle.
		/// </summary>
		bool IsModelAVehicle(int model);
		void RequestCollisionAtCoord(float x, float y, float z);
		void RequestCollisionForModel(int model);
		bool HasCollisionForModelLoaded(int model);
		/// <summary>
		/// MulleDK19: Alias of REQUEST_COLLISION_AT_COORD.
		/// </summary>
		void RequestAdditionalCollisionAtCoord(float x, float y, float z);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		bool DoesAnimDictExist(string animDict);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void RequestAnimDict(string animDict);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		bool HasAnimDictLoaded(string animDict);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void RemoveAnimDict(string animDict);
		/// <summary>
		/// Starts loading the specified animation set. An animation set provides movement animations for a ped. See SET_PED_MOVEMENT_CLIPSET.
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
		/// </summary>
		void RequestAnimSet(string animSet);
		/// <summary>
		/// Gets whether the specified animation set has finished loading. An animation set provides movement animations for a ped. See SET_PED_MOVEMENT_CLIPSET.
		/// Animation set and clip set are synonymous.
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
		/// </summary>
		bool HasAnimSetLoaded(string animSet);
		/// <summary>
		/// Unloads the specified animation set. An animation set provides movement animations for a ped. See SET_PED_MOVEMENT_CLIPSET.
		/// Animation set and clip set are synonymous.
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
		/// </summary>
		void RemoveAnimSet(string animSet);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
		/// </summary>
		void RequestClipSet(string clipSet);
		/// <summary>
		/// Alias for HAS_ANIM_SET_LOADED.
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
		/// </summary>
		bool HasClipSetLoaded(string clipSet);
		/// <summary>
		/// Alias for REMOVE_ANIM_SET.
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
		/// </summary>
		void RemoveClipSet(string clipSet);
		/// <summary>
		/// Exemple: REQUEST_IPL("TrevorsTrailerTrash");
		/// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
		/// </summary>
		void RequestIpl(string iplName);
		/// <summary>
		/// Removes an IPL from the map.
		/// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
		/// Example:
		/// C#:
		/// Function.Call(Hash.REMOVE_IPL, "trevorstrailertidy");
		/// C++:
		/// STREAMING::REMOVE_IPL("trevorstrailertidy");
		/// </summary>
		/// <param name="iplName">= Name of IPL you want to remove.</param>
		void RemoveIpl(string iplName);
		/// <summary>
		/// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
		/// </summary>
		bool IsIplActive(string iplName);
		void SetStreaming(bool toggle);
		/// <summary>
		/// 0 - default
		/// 1 - HeistIsland
		/// </summary>
		void LoadGlobalWaterType(int waterType);
		int GetGlobalWaterType();
		void SetGamePausesForStreaming(bool toggle);
		void SetReducePedModelBudget(bool toggle);
		void SetReduceVehicleModelBudget(bool toggle);
		/// <summary>
		/// This is a NOP function. It does nothing at all.
		/// </summary>
		void SetDitchPoliceModels(bool toggle);
		int GetNumberOfStreamingRequests();
		/// <summary>
		/// maps script name (thread + 0xD0) by lookup via scriptfx.dat - does nothing when script name is empty
		/// </summary>
		void RequestPtfxAsset();
		bool HasPtfxAssetLoaded();
		void RemovePtfxAsset();
		/// <summary>
		/// From the b678d decompiled scripts:
		/// STREAMING::REQUEST_NAMED_PTFX_ASSET("core_snow");
		/// STREAMING::REQUEST_NAMED_PTFX_ASSET("fm_mission_controler");
		/// STREAMING::REQUEST_NAMED_PTFX_ASSET("proj_xmas_firework");
		/// STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_apartment_mp");
		/// STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_biolab_heist");
		/// STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_indep_fireworks");
		/// STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_indep_parachute");
		/// STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_indep_wheelsmoke");
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB80D8756B4668AB6
		/// </summary>
		void RequestNamedPtfxAsset(string fxName);
		bool HasNamedPtfxAssetLoaded(string fxName);
		void RemoveNamedPtfxAsset(string fxName);
		void SetVehiclePopulationBudget(int p0);
		/// <summary>
		/// Control how many new (ambient?) peds will spawn in the game world.
		/// Range for p0 seems to be 0-3, where 0 is none and 3 is the normal level.
		/// </summary>
		void SetPedPopulationBudget(int p0);
		void ClearFocus();
		/// <summary>
		/// Override the area where the camera will render the terrain.
		/// p3, p4 and p5 are usually set to 0.0
		/// </summary>
		void SetFocusPosAndVel(float x, float y, float z, float offsetX, float offsetY, float offsetZ);
		/// <summary>
		/// It seems to make the entity's coords mark the point from which LOD-distances are measured. In my testing, setting a vehicle as the focus entity and moving that vehicle more than 300 distance units away from the player will make the level of detail around the player go down drastically (shadows disappear, textures go extremely low res, etc). The player seems to be the default focus entity.
		/// </summary>
		void SetFocusEntity(int entity);
		bool IsEntityFocus(int entity);
		void _0x0811381EF5062FEC(int p0);
		/// <summary>
		/// Possible p0 values:
		/// "prologue"
		/// "Prologue_Main"
		/// </summary>
		void SetMapdatacullboxEnabled(string name, bool toggle);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void _0x4E52E752C76E7E7A(int p0);
		/// <summary>
		/// </summary>
		/// <returns>Always returns zero.</returns>
		int StreamvolCreateSphere(float x, float y, float z, float rad, int p4, int p5);
		/// <summary>
		/// </summary>
		/// <returns>Always returns zero.</returns>
		int StreamvolCreateFrustum(float p0, float p1, float p2, float p3, float p4, float p5, float p6, int p7, int p8);
		/// <summary>
		/// </summary>
		/// <returns>Always returns zero.</returns>
		int StreamvolCreateLine(float p0, float p1, float p2, float p3, float p4, float p5, int p6);
		void StreamvolDelete(int unused);
		bool StreamvolHasLoaded(int unused);
		bool StreamvolIsValid(int unused);
		bool IsStreamvolActive();
		/// <summary>
		/// `radius` value is usually between `3f` and `7000f` in original 1868 scripts.
		/// `p7` is 0, 1, 2, 3 or 4 used in decompiled scripts, 0 is by far the most common.
		/// Returns True if success, used only 7 times in decompiled scripts of 1868
		/// </summary>
		bool NewLoadSceneStart(float posX, float posY, float posZ, float offsetX, float offsetY, float offsetZ, float radius, int p7);
		/// <summary>
		/// if (!sub_8f12("START LOAD SCENE SAFE")) {
		/// if (CUTSCENE::GET_CUTSCENE_TIME() > 4178) {
		/// STREAMING::_ACCFB4ACF53551B0(1973.845458984375, 3818.447265625, 32.43629837036133, 15.0, 2);
		/// sub_8e9e("START LOAD SCENE SAFE", 1);
		/// }
		/// }
		/// (Previously known as STREAMING::_NEW_LOAD_SCENE_START_SAFE)
		/// </summary>
		bool NewLoadSceneStartSphere(float x, float y, float z, float radius, int p4);
		void NewLoadSceneStop();
		bool IsNewLoadSceneActive();
		bool IsNewLoadSceneLoaded();
		int _0x71E7B2E657449AAD();
		/// <summary>
		/// // this enum comes directly from R* so don't edit this
		/// enum ePlayerSwitchTypes
		/// {
		/// SWITCH_TYPE_AUTO,
		/// SWITCH_TYPE_LONG,
		/// SWITCH_TYPE_MEDIUM,
		/// SWITCH_TYPE_SHORT
		/// };
		/// Use GET_IDEAL_PLAYER_SWITCH_TYPE for the best switch type.
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFAA23F2CBA159D67
		/// </summary>
		/// <returns>Note: DO NOT, use SWITCH_TYPE_LONG with flag 513. It leaves you stuck in the clouds. You'll have to call STOP_PLAYER_SWITCH() to return to your ped.</returns>
		void StartPlayerSwitch(int from, int to, int flags, int switchType);
		void StopPlayerSwitch();
		/// <summary>
		/// Returns true if the player is currently switching, false otherwise.
		/// (When the camera is in the sky moving from Trevor to Franklin for example)
		/// </summary>
		bool IsPlayerSwitchInProgress();
		int GetPlayerSwitchType();
		int GetIdealPlayerSwitchType(float x1, float y1, float z1, float x2, float y2, float z2);
		int GetPlayerSwitchState();
		int GetPlayerShortSwitchState();
		/// <summary>
		/// SET_PLAYER_*
		/// </summary>
		void _0x5F2013F8BC24EE69(int p0);
		int GetPlayerSwitchJumpCutIndex();
		void SetPlayerSwitchOutro(float cameraCoordX, float cameraCoordY, float cameraCoordZ, float camRotationX, float camRotationY, float camRotationZ, float camFov, float camFarClip, int rotationOrder);
		/// <summary>
		/// All names can be found in playerswitchestablishingshots.meta
		/// </summary>
		void SetPlayerSwitchEstablishingShot(string name);
		void AllowPlayerSwitchPan();
		void AllowPlayerSwitchOutro();
		void AllowPlayerSwitchAscent();
		void AllowPlayerSwitchDescent();
		bool IsSwitchReadyForDescent();
		void EnableSwitchPauseBeforeDescent();
		void DisableSwitchOutroFx();
		/// <summary>
		/// doesn't act normally when used on mount chilliad
		/// 2^n - Enabled Functionality:
		/// 0 - Skip camera rotate up
		/// 3 - Wait for SET_PLAYER_SWITCH_ESTABLISHING_SHOT / hang at last step. You will still need to run 0x74DE2E8739086740 to exit "properly" and then STOP_PLAYER_SWITCH
		/// 6 - Invert Switch Direction (false = out, true = in)
		/// 8 - Hang above ped
		/// 0: 1 step towards ped
		/// 1: 3 steps out from ped
		/// 2: 1 step out from ped
		/// 3: 1 step towards ped
		/// </summary>
		/// <param name="flags">is a bitflag:</param>
		/// <param name="switchType">0 - 3</param>
		void SwitchOutPlayer(int ped, int flags, int switchType);
		void SwitchInPlayer(int ped);
		/// <summary>
		/// Probably IS_SWITCH_*
		/// </summary>
		bool _0x933BBEEB8C61B5F4();
		int GetPlayerSwitchInterpOutDuration();
		int GetPlayerSwitchInterpOutCurrentTime();
		bool IsSwitchSkippingDescent();
		void _0x1E9057A74FD73E23();
		float GetLodscale();
		/// <summary>
		/// This allows you to override "extended distance scaling" setting. Needs to be called each frame.
		/// Max scaling seems to be 200.0, normal is 1.0
		/// See https://gfycat.com/DetailedHauntingIncatern
		/// </summary>
		void OverrideLodscaleThisFrame(float scaling);
		void _0xBED8CA5FF5E04113(float p0, float p1, float p2, float p3);
		void _0x472397322E92A856();
		void SetRenderHdOnly(bool toggle);
		void _0x03F1A106BDA7DD3E();
		void _0x95A7DABDDBB78AE7(string iplName1, string iplName2);
		void _0x63EB2B972A218CAC();
		bool _0xFB199266061F820A();
		void _0xF4A0DADB70F57FA6();
		int _0x5068F488DDB54DD8();
		/// <summary>
		/// This native is used to attribute the SRL that BEGIN_SRL is going to load. This is usually used for 'in-game' cinematics (not cutscenes but camera stuff) instead of SET_FOCUS_POS_AND_VEL because it loads a specific area of the map which is pretty useful when the camera moves from distant areas.
		/// For instance, GTA:O opening cutscene.
		/// https://pastebin.com/2EeKVeLA : a list of SRL found in srllist.meta
		/// https://pastebin.com/zd9XYUWY here is the content of a SRL file opened with codewalker.
		/// </summary>
		void PrefetchSrl(string srl);
		/// <summary>
		/// Returns true when the srl from BEGIN_SRL is loaded.
		/// </summary>
		bool IsSrlLoaded();
		void BeginSrl();
		/// <summary>
		/// Clear the current srl and stop rendering the area selected by PREFETCH_SRL and started with BEGIN_SRL.
		/// </summary>
		void EndSrl();
		void SetSrlTime(float p0);
		void _0xEF39EE20C537E98C(int p0, int p1, int p2, int p3, int p4, int p5);
		void _0xBEB2D9A1D9A8F55A(int p0, int p1, int p2, int p3);
		void _0x20C6C7E4EB082A7F(bool p0);
		void _0xF8155A7F03DDFC8E(int p0);
		void SetHdArea(float x, float y, float z, float radius);
		void ClearHdArea();
		void InitCreatorBudget();
		void ShutdownCreatorBudget();
		bool AddModelToCreatorBudget(int modelHash);
		void RemoveModelFromCreatorBudget(int modelHash);
		/// <summary>
		/// 0.0 = no memory used
		/// 1.0 = all memory used
		/// Maximum model memory (as defined in common\data\missioncreatordata.meta) is 100 MiB
		/// GET_*
		/// </summary>
		float GetUsedCreatorModelMemoryPercentage();
		/// <summary>
		/// Enables the specified island. For more information, see islandhopper.meta
		/// </summary>
		void SetIslandHopperEnabled(string name, bool toggle);
		/// <summary>
		/// Stand still (?)
		/// </summary>
		void TaskPause(int ped, int ms);
		/// <summary>
		/// Makes the specified ped stand still for (time) milliseconds.
		/// </summary>
		void TaskStandStill(int ped, int time);
		/// <summary>
		/// Definition is wrong. This has 4 parameters (Not sure when they were added. v350 has 2, v678 has 4).
		/// flag1 = super jump, flag2 = do nothing if flag1 is false and doubles super jump height if flag1 is true.
		/// </summary>
		/// <param name="ped">Ped ped, bool unused</param>
		/// <param name="unused">Ped ped, bool unused, bool flag1, bool flag2</param>
		void TaskJump(int ped, bool unused, int p2, int p3);
		void TaskCower(int ped, int duration);
		/// <summary>
		/// In the scripts, p3 was always -1.
		/// Also facingPed can be 0 or -1 so ped will just raise hands up.
		/// </summary>
		/// <param name="p3">seems to be duration or timeout of turn animation.</param>
		void TaskHandsUp(int ped, int duration, int facingPed, int p3, bool p4);
		void UpdateTaskHandsUpDuration(int ped, int duration);
		/// <summary>
		/// The given ped will try to open the nearest door to 'seat'.
		/// Example: telling the ped to open the door for the driver seat does not necessarily mean it will open the driver door, it may choose to open the passenger door instead if that one is closer.
		/// </summary>
		void TaskOpenVehicleDoor(int ped, int vehicle, int timeOut, int seat, float speed);
		/// <summary>
		/// Usage of seat
		/// -1 = driver
		/// 0 = passenger
		/// 1 = left back seat
		/// 2 = right back seat
		/// 3 = outside left
		/// 4 = outside right
		/// </summary>
		/// <param name="vehicle">normal, 3</param>
		/// <param name="speed">1.0 = walk, 2.0 = run</param>
		/// <param name="flag">1 = normal, 3 = teleport to vehicle, 16 = teleport directly into vehicle</param>
		/// <param name="p6">is always 0</param>
		void TaskEnterVehicle(int ped, int vehicle, int timeout, int seat, float speed, int flag, int p6);
		/// <summary>
		/// 0 = normal exit and closes door.
		/// 1 = normal exit and closes door.
		/// 16 = teleports outside, door kept closed.
		/// 64 = normal exit and closes door, maybe a bit slower animation than 0.
		/// 256 = normal exit but does not close the door.
		/// 4160 = ped is throwing himself out, even when the vehicle is still.
		/// 262144 = ped moves to passenger seat first, then exits normally
		/// Others to be tried out: 320, 512, 131072.
		/// </summary>
		/// <param name="flags">from decompiled scripts:</param>
		void TaskLeaveVehicle(int ped, int vehicle, int flags);
		void TaskGetOffBoat(int ped, int boat);
		void TaskSkyDive(int ped, bool p1);
		/// <summary>
		/// Second parameter is unused.
		/// second parameter was for jetpack in the early stages of gta and the hard coded code is now removed
		/// </summary>
		void TaskParachute(int ped, bool p1, bool p2);
		/// <summary>
		/// makes ped parachute to coords x y z. Works well with PATHFIND::GET_SAFE_COORD_FOR_PED
		/// </summary>
		void TaskParachuteToTarget(int ped, float x, float y, float z);
		void SetParachuteTaskTarget(int ped, float x, float y, float z);
		void SetParachuteTaskThrust(int ped, float thrust);
		/// <summary>
		/// Only appears twice in the scripts.
		/// TASK::TASK_RAPPEL_FROM_HELI(PLAYER::PLAYER_PED_ID(), 0x41200000);
		/// TASK::TASK_RAPPEL_FROM_HELI(a_0, 0x41200000);
		/// </summary>
		void TaskRappelFromHeli(int ped, float p1);
		/// <summary>
		/// info about driving modes: HTTP://gtaforums.com/topic/822314-guide-driving-styles/
		/// ---------------------------------------------------------------
		/// Passing P6 value as floating value didn't throw any errors, though unsure what is it exactly, looks like radius or something.
		/// Here the e.g. code I used
		/// Function.Call(Hash.TASK_VEHICLE_DRIVE_TO_COORD, Ped, Vehicle, Cor X, Cor Y, Cor Z, 30f, 1f, Vehicle.GetHashCode(), 16777216, 1f, true);
		/// </summary>
		/// <param name="p10">though, it is mentioned as float, however, I used bool and set it to true, that too worked.</param>
		void TaskVehicleDriveToCoord(int ped, int vehicle, float x, float y, float z, float speed, int p6, int vehicleModel, int drivingMode, float stopRange, float p10);
		void TaskVehicleDriveToCoordLongrange(int ped, int vehicle, float x, float y, float z, float speed, int driveMode, float stopRange);
		void TaskVehicleDriveWander(int ped, int vehicle, float speed, int drivingStyle);
		/// <summary>
		/// </summary>
		/// <param name="timeout">always -1</param>
		/// <param name="stoppingRange">always 10.0</param>
		/// <param name="persistFollowing">always 1</param>
		void TaskFollowToOffsetOfEntity(int ped, int entity, float offsetX, float offsetY, float offsetZ, float movementSpeed, int timeout, float stoppingRange, bool persistFollowing);
		void TaskGoStraightToCoord(int ped, float x, float y, float z, float speed, int timeout, float targetHeading, float distanceToSlide);
		void TaskGoStraightToCoordRelativeToEntity(int entity1, int entity2, float p2, float p3, float p4, float p5, int p6);
		/// <summary>
		/// Makes the specified ped achieve the specified heading.
		/// pedHandle: The handle of the ped to assign the task to.
		/// </summary>
		/// <param name="heading">The desired heading.</param>
		/// <param name="timeout">The time, in milliseconds, to allow the task to complete. If the task times out, it is cancelled, and the ped will stay at the heading it managed to reach in the time.</param>
		void TaskAchieveHeading(int ped, float heading, int timeout);
		/// <summary>
		/// MulleKD19: Clears the current point route. Call this before TASK_EXTEND_ROUTE and TASK_FOLLOW_POINT_ROUTE.
		/// </summary>
		void TaskFlushRoute();
		/// <summary>
		/// MulleKD19: Adds a new point to the current point route. Call TASK_FLUSH_ROUTE before the first call to this. Call TASK_FOLLOW_POINT_ROUTE to make the Ped go the route.
		/// A maximum of 8 points can be added.
		/// </summary>
		void TaskExtendRoute(float x, float y, float z);
		/// <summary>
		/// MulleKD19: Makes the ped go on the created point route.
		/// int: Unknown. Can be 0, 1, 2 or 3.
		/// Example:
		/// TASK_FLUSH_ROUTE();
		/// TASK_EXTEND_ROUTE(0f, 0f, 70f);
		/// TASK_EXTEND_ROUTE(10f, 0f, 70f);
		/// TASK_EXTEND_ROUTE(10f, 10f, 70f);
		/// TASK_FOLLOW_POINT_ROUTE(GET_PLAYER_PED(), 1f, 0);
		/// </summary>
		/// <param name="ped">The ped to give the task to.</param>
		/// <param name="speed">The speed to move at in m/s.</param>
		void TaskFollowPointRoute(int ped, float speed, int unknown);
		/// <summary>
		/// The entity will move towards the target until time is over (duration) or get in target's range (distance). p5 and p6 are unknown, but you could leave p5 = 1073741824 or 100 or even 0 (didn't see any difference but on the decompiled scripts, they use 1073741824 mostly) and p6 = 0
		/// Note: I've only tested it on entity -> ped and target -> vehicle. It could work differently on other entities, didn't try it yet.
		/// Example: TASK::TASK_GO_TO_ENTITY(pedHandle, vehicleHandle, 5000, 4.0, 100, 1073741824, 0)
		/// Ped will run towards the vehicle for 5 seconds and stop when time is over or when he gets 4 meters(?) around the vehicle (with duration = -1, the task duration will be ignored).
		/// </summary>
		void TaskGoToEntity(int entity, int target, int duration, float distance, float speed, float p5, int p6);
		/// <summary>
		/// Makes the specified ped flee the specified distance from the specified position.
		/// </summary>
		void TaskSmartFleeCoord(int ped, float x, float y, float z, float distance, int time, bool p6, bool p7);
		/// <summary>
		/// Makes a ped run away from another ped (fleeTarget).
		/// </summary>
		/// <param name="distance">= ped will flee this distance.</param>
		/// <param name="fleeTime">= ped will flee for this amount of time, set to "-1" to flee forever</param>
		void TaskSmartFleePed(int ped, int fleeTarget, float distance, int fleeTime, bool p4, bool p5);
		void TaskReactAndFleePed(int ped, int fleeTarget);
		void TaskShockingEventReact(int ped, int eventHandle);
		void TaskWanderInArea(int ped, float x, float y, float z, float radius, float minimalLength, float timeBetweenWalks);
		/// <summary>
		/// Makes ped walk around the area.
		/// set p1 to 10.0f and p2 to 10 if you want the ped to walk anywhere without a duration.
		/// </summary>
		void TaskWanderStandard(int ped, float p1, int p2);
		void TaskWanderSpecific(int p0, int p1, int p2, int p3);
		/// <summary>
		/// Modes:
		/// 0 - ignore heading
		/// 1 - park forward
		/// 2 - park backwards
		/// Depending on the angle of approach, the vehicle can park at the specified heading or at its exact opposite (-180) angle.
		/// </summary>
		/// <param name="radius">seems to define how close the vehicle has to be -after parking- to the position for this task considered completed. If the value is too small, the vehicle will try to park again until it's exactly where it should be. 20.0 Works well but lower values don't, like the radius is measured in centimeters or something.</param>
		void TaskVehiclePark(int ped, int vehicle, float x, float y, float z, float heading, int mode, float radius, bool keepEngineOn);
		/// <summary>
		/// known "killTypes" are: "AR_stealth_kill_knife" and "AR_stealth_kill_a".
		/// </summary>
		void TaskStealthKill(int killer, int target, int actionType, float p3, int p4);
		void TaskPlantBomb(int ped, float x, float y, float z, float heading);
		/// <summary>
		/// </summary>
		/// <param name="timeout">1.</param>
		void TaskFollowNavMeshToCoord(int ped, float x, float y, float z, float speed, int timeout, float stoppingRange, bool persistFollowing, float unk);
		void TaskFollowNavMeshToCoordAdvanced(int ped, float x, float y, float z, float speed, int timeout, float unkFloat, int unkInt, float unkX, float unkY, float unkZ, float unk_40000f);
		void SetPedPathCanUseClimbovers(int ped, bool Toggle);
		void SetPedPathCanUseLadders(int ped, bool Toggle);
		void SetPedPathCanDropFromHeight(int ped, bool Toggle);
		/// <summary>
		/// Default modifier is 1.0, minimum is 0.0 and maximum is 10.0.
		/// </summary>
		void SetPedPathClimbCostModifier(int ped, float modifier);
		void SetPedPathMayEnterWater(int ped, bool mayEnterWater);
		void SetPedPathPreferToAvoidWater(int ped, bool avoidWater);
		void SetPedPathAvoidFire(int ped, bool avoidFire);
		/// <summary>
		/// Needs to be looped! And yes, it does work and is not a hash collision.
		/// Birds will try to reach the given height.
		/// </summary>
		void SetGlobalMinBirdFlightHeight(float height);
		/// <summary>
		/// Return value of native is the same as GET_NAVMESH_ROUTE_RESULT
		/// Looks like the native returns an int for the path's state:
		/// 1 - ???
		/// 2 - ???
		/// 3 - Finished Generating
		/// </summary>
		/// <returns>Looks like the last parameter returns true if the path has been calculated, while the first returns the remaining distance to the end of the path.</returns>
		int GetNavmeshRouteDistanceRemaining(int ped, ref float distanceRemaining, ref bool isPathReady);
		/// <summary>
		/// See GET_NAVMESH_ROUTE_DISTANCE_REMAINING for more details.
		/// </summary>
		int GetNavmeshRouteResult(int ped);
		/// <summary>
		/// IS_*
		/// </summary>
		bool _0x3E38E28A1D80DDF6(int ped);
		/// <summary>
		/// example from fm_mission_controller
		/// TASK::TASK_GO_TO_COORD_ANY_MEANS(l_649, sub_f7e86(-1, 0), 1.0, 0, 0, 786603, 0xbf800000);
		/// </summary>
		void TaskGoToCoordAnyMeans(int ped, float x, float y, float z, float speed, int p5, bool p6, int walkingStyle, float p8);
		void TaskGoToCoordAnyMeansExtraParams(int ped, float x, float y, float z, float speed, int p5, bool p6, int walkingStyle, float p8, int p9, int p10, int p11, int p12);
		void TaskGoToCoordAnyMeansExtraParamsWithCruiseSpeed(int ped, float x, float y, float z, float speed, int p5, bool p6, int walkingStyle, float p8, int p9, int p10, int p11, int p12, int p13);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// float speed > normal speed is 8.0f
		/// ----------------------
		/// float speedMultiplier > multiply the playback speed
		/// ----------------------
		/// int duration: time in millisecond
		/// ----------------------
		/// -1 _ _ _ _ _ _ _> Default (see flag)
		/// 0 _ _ _ _ _ _ _ > Not play at all
		/// See NativeDB for reference: http://natives.altv.mp/#/0xEA47FE3719165B94
		/// </summary>
		void TaskPlayAnim(int ped, string animDictionary, string animationName, float blendInSpeed, float blendOutSpeed, int duration, int flag, float playbackRate, bool lockX, bool lockY, bool lockZ);
		/// <summary>
		/// It's similar to TASK_PLAY_ANIM, except the first 6 floats let you specify the initial position and rotation of the task. (Ped gets teleported to the position).
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void TaskPlayAnimAdvanced(int ped, string animDict, string animName, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float animEnterSpeed, float animExitSpeed, int duration, int flag, float animTime, int p14, int p15);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void StopAnimTask(int ped, string animDictionary, string animationName, float p3);
		/// <summary>
		/// From fm_mission_controller.c:
		/// reserve_network_mission_objects(get_num_reserved_mission_objects(0) + 1);
		/// vVar28 = {0.094f, 0.02f, -0.005f};
		/// vVar29 = {-92.24f, 63.64f, 150.24f};
		/// func_253(&uVar30, joaat("prop_ld_case_01"), Global_1592429.imm_34757[iParam1 <268>], 1, 1, 0, 1);
		/// set_entity_lod_dist(net_to_ent(uVar30), 500);
		/// attach_entity_to_entity(net_to_ent(uVar30), iParam0, get_ped_bone_index(iParam0, 28422), vVar28, vVar29, 1, 0, 0, 0, 2, 1);
		/// Var31.imm_4 = 1065353216;
		/// Var31.imm_5 = 1065353216;
		/// See NativeDB for reference: http://natives.altv.mp/#/0x126EF75F1E17ABE5
		/// </summary>
		void TaskScriptedAnimation(int ped, ref int p1, ref int p2, ref int p3, float p4, float p5);
		/// <summary>
		/// </summary>
		void PlayEntityScriptedAnim(int p0, ref int p1, ref int p2, ref int p3, float p4, float p5);
		/// <summary>
		/// Looks like p1 may be a flag, still need to do some research, though.
		/// </summary>
		void StopAnimPlayback(int ped, int p1, bool p2);
		void SetAnimWeight(int p0, float p1, int p2, int p3, bool p4);
		void SetAnimPlaybackTime(int entity, float p1, int p2, bool p3);
		void SetAnimRate(int p0, float p1, int p2, bool p3);
		void SetAnimLooped(int p0, bool p1, int p2, bool p3);
		/// <summary>
		/// Example from the scripts:
		/// TASK::TASK_PLAY_PHONE_GESTURE_ANIMATION(PLAYER::PLAYER_PED_ID(), v_3, v_2, v_4, 0.25, 0.25, 0, 0);
		/// =========================================================
		/// ^^ No offense, but Idk how that would really help anyone.
		/// As for the animDict & animation, they're both store in a global in all 5 scripts. So if anyone would be so kind as to read that global and comment what strings they use. Thanks.
		/// Known boneMaskTypes'
		/// "BONEMASK_HEADONLY"
		/// "BONEMASK_HEAD_NECK_AND_ARMS"
		/// "BONEMASK_HEAD_NECK_AND_L_ARM"
		/// See NativeDB for reference: http://natives.altv.mp/#/0x8FBB6758B3B3E9EC
		/// </summary>
		/// <param name="p4">known args - 0.0f, 0.5f, 0.25f</param>
		/// <param name="p5">known args - 0.0f, 0.25f</param>
		/// <param name="p6">known args - 1 if a global if check is passed.</param>
		/// <param name="p7">known args - 1 if a global if check is passed.</param>
		void TaskPlayPhoneGestureAnimation(int ped, string animDict, string animation, string boneMaskType, float p4, float p5, bool p6, bool p7);
		void TaskStopPhoneGestureAnimation(int ped, int p1);
		bool IsPlayingPhoneGestureAnim(int ped);
		float GetPhoneGestureAnimCurrentTime(int ped);
		float GetPhoneGestureAnimTotalTime(int ped);
		/// <summary>
		/// Most probably plays a specific animation on vehicle. For example getting chop out of van etc...
		/// Here's how its used -
		/// TASK::TASK_VEHICLE_PLAY_ANIM(l_325, "rcmnigel1b", "idle_speedo");
		/// TASK::TASK_VEHICLE_PLAY_ANIM(l_556[01], "missfra0_chop_drhome", "InCar_GetOutofBack_Speedo");
		/// FYI : Speedo is the name of van in which chop was put in the mission.
		/// </summary>
		void TaskVehiclePlayAnim(int vehicle, string animationSet, string animationName);
		/// <summary>
		/// </summary>
		/// <param name="p5">= 0, p6 = 2</param>
		void TaskLookAtCoord(int entity, float x, float y, float z, int duration, int p5, int p6);
		/// <summary>
		/// param3: duration in ms, use -1 to look forever
		/// param4: using 2048 is fine
		/// param5: using 3 is fine
		/// </summary>
		void TaskLookAtEntity(int ped, int lookAt, int duration, int unknown1, int unknown2);
		/// <summary>
		/// Not clear what it actually does, but here's how script uses it -
		/// if (OBJECT::HAS_PICKUP_BEEN_COLLECTED(...)
		/// {
		/// if(ENTITY::DOES_ENTITY_EXIST(PLAYER::PLAYER_PED_ID()))
		/// {
		/// TASK::TASK_CLEAR_LOOK_AT(PLAYER::PLAYER_PED_ID());
		/// }
		/// ...
		/// }
		/// See NativeDB for reference: http://natives.altv.mp/#/0x0F804F1DB19B9689
		/// </summary>
		/// <param name="ped">:_2208438012482A1A(l_3ED, 0, 0);</param>
		void TaskClearLookAt(int ped);
		/// <summary>
		/// </summary>
		void OpenSequenceTask(ref int taskSequenceId);
		void CloseSequenceTask(int taskSequenceId);
		void TaskPerformSequence(int ped, int taskSequenceId);
		void TaskPerformSequenceLocally(int ped, int taskSequenceId);
		/// <summary>
		/// </summary>
		void ClearSequenceTask(ref int taskSequenceId);
		void SetSequenceToRepeat(int taskSequenceId, bool repeat);
		/// <summary>
		/// returned values:
		/// 0 to 7 = task that's currently in progress, 0 meaning the first one.
		/// -1 no task sequence in progress.
		/// </summary>
		int GetSequenceProgress(int ped);
		/// <summary>
		/// Task index enum: https://alloc8or.re/gta5/doc/enums/eTaskTypeIndex.txt
		/// </summary>
		bool GetIsTaskActive(int ped, int taskIndex);
		/// <summary>
		/// Gets the status of a script-assigned task.
		/// </summary>
		/// <param name="taskHash">https://alloc8or.re/gta5/doc/enums/eScriptTaskHash.txt</param>
		int GetScriptTaskStatus(int ped, int taskHash);
		/// <summary>
		/// https://alloc8or.re/gta5/doc/enums/eVehicleMissionType.txt
		/// </summary>
		int GetActiveVehicleMissionType(int vehicle);
		/// <summary>
		/// </summary>
		/// <param name="flags">are the same flags used in TASK_LEAVE_VEHICLE</param>
		void TaskLeaveAnyVehicle(int ped, int p1, int flags);
		void TaskAimGunScripted(int ped, int scriptTask, bool p2, bool p3);
		void TaskAimGunScriptedWithTarget(int p0, int p1, float p2, float p3, float p4, int p5, bool p6, bool p7);
		void UpdateTaskAimGunScriptedTarget(int p0, int p1, float p2, float p3, float p4, bool p5);
		string GetClipSetForScriptedGunTask(int p0);
		/// <summary>
		/// </summary>
		/// <param name="duration">the amount of time in milliseconds to do the task.  -1 will keep the task going until either another task is applied, or CLEAR_ALL_TASKS() is called with the ped</param>
		void TaskAimGunAtEntity(int ped, int entity, int duration, bool p3);
		/// <summary>
		/// </summary>
		/// <param name="duration">the amount of time in milliseconds to do the task. -1 will keep the task going until either another task is applied, or CLEAR_ALL_TASKS() is called with the ped</param>
		void TaskTurnPedToFaceEntity(int ped, int entity, int duration);
		void TaskAimGunAtCoord(int ped, float x, float y, float z, int time, bool p5, bool p6);
		/// <summary>
		/// Firing Pattern Hash Information: https://pastebin.com/Px036isB
		/// </summary>
		void TaskShootAtCoord(int ped, float x, float y, float z, int duration, int firingPattern);
		/// <summary>
		/// Makes the specified ped shuffle to the next vehicle seat.
		/// The ped MUST be in a vehicle and the vehicle parameter MUST be the ped's current vehicle.
		/// </summary>
		void TaskShuffleToNextVehicleSeat(int ped, int vehicle, int p2);
		void ClearPedTasks(int ped);
		void ClearPedSecondaryTask(int ped);
		void TaskEveryoneLeaveVehicle(int vehicle);
		void TaskGotoEntityOffset(int ped, int p1, int p2, float x, float y, float z, int duration);
		void TaskGotoEntityOffsetXy(int p0, int oed, int duration, float p3, float p4, float p5, float p6, bool p7);
		/// <summary>
		/// </summary>
		/// <param name="duration">in milliseconds</param>
		void TaskTurnPedToFaceCoord(int ped, float x, float y, float z, int duration);
		/// <summary>
		/// '1 - brake
		/// '3 - brake + reverse
		/// '4 - turn left 90 + braking
		/// '5 - turn right 90 + braking
		/// '6 - brake strong (handbrake?) until time ends
		/// '7 - turn left + accelerate
		/// '7 - turn right + accelerate
		/// '9 - weak acceleration
		/// '10 - turn left + restore wheel pos to center in the end
		/// See NativeDB for reference: http://natives.altv.mp/#/0xC429DCEEB339E129
		/// </summary>
		void TaskVehicleTempAction(int driver, int vehicle, int action, int time);
		/// <summary>
		/// </summary>
		/// <param name="missionType">https://alloc8or.re/gta5/doc/enums/eVehicleMissionType.txt</param>
		void TaskVehicleMission(int driver, int vehicle, int vehicleTarget, int missionType, float p4, int p5, float p6, float p7, bool DriveAgainstTraffic);
		/// <summary>
		/// See TASK_VEHICLE_MISSION
		/// </summary>
		void TaskVehicleMissionPedTarget(int ped, int vehicle, int pedTarget, int missionType, float maxSpeed, int drivingStyle, float minDistance, float p7, bool DriveAgainstTraffic);
		/// <summary>
		/// See TASK_VEHICLE_MISSION
		/// </summary>
		void TaskVehicleMissionCoorsTarget(int ped, int vehicle, float x, float y, float z, int p5, int p6, int p7, float p8, float p9, bool DriveAgainstTraffic);
		/// <summary>
		/// Makes a ped follow the targetVehicle with <minDistance> in between.
		/// note: minDistance is ignored if drivingstyle is avoiding traffic, but Rushed is fine.
		/// -1 = behind
		/// 0 = ahead
		/// 1 = left
		/// 2 = right
		/// 3 = back left
		/// 4 = back right
		/// if the target is closer than noRoadsDistance, the driver will ignore pathing/roads and follow you directly.
		/// Driving Styles guide: gtaforums.com/topic/822314-guide-driving-styles/
		/// </summary>
		/// <param name="mode">The mode defines the relative position to the targetVehicle. The ped will try to position its vehicle there.</param>
		void TaskVehicleEscort(int ped, int vehicle, int targetVehicle, int mode, float speed, int drivingStyle, float minDistance, int p7, float noRoadsDistance);
		/// <summary>
		/// Makes a ped in a vehicle follow an entity (ped, vehicle, etc.)
		/// </summary>
		/// <param name="drivingStyle">http://gtaforums.com/topic/822314-guide-driving-styles/</param>
		void TaskVehicleFollow(int driver, int vehicle, int targetEntity, float speed, int drivingStyle, int minDistance);
		/// <summary>
		/// chases targetEnt fast and aggressively
		/// --
		/// Makes ped (needs to be in vehicle) chase targetEnt.
		/// </summary>
		void TaskVehicleChase(int driver, int targetEnt);
		/// <summary>
		/// 'targetSpeed':  The pilot will dip the nose AS MUCH AS POSSIBLE so as to reach this value AS FAST AS POSSIBLE.  As such, you'll want to modulate it as opposed to calling it via a hard-wired, constant #.
		/// 'radius' isn't just "stop within radius of X of target" like with ground vehicles.  In this case, the pilot will fly an entire circle around 'radius' and continue to do so.
		/// </summary>
		/// <param name="pilot">explanatory.</param>
		/// <param name="entityToFollow">you can provide a Vehicle entity or a Ped entity, the heli will protect them.</param>
		/// <param name="p4">is unused variable in the function.</param>
		/// <param name="altitude">p7 appears to be a FlyingStyle enum.  Still investigating it as of this writing, but playing around with values here appears to result in different -behavior- as opposed to offsetting coordinates, altitude, target speed, etc.</param>
		/// <returns>NOTE: If the pilot finds enemies, it will engage them until it kills them, but will return to protect the ped/vehicle given shortly thereafter.</returns>
		void TaskVehicleHeliProtect(int pilot, int vehicle, int entityToFollow, float targetSpeed, int p4, float radius, int altitude, int p7);
		/// <summary>
		/// Flag 1: Aggressive ramming of suspect
		/// Flag 2: Ram attempts
		/// Flag 32: Stay back from suspect, no tactical contact. Convoy-like.
		/// Flag 16: Ramming, seems to be slightly less aggressive than 1-2.
		/// </summary>
		/// <param name="flag">8: Medium-aggressive boxing tactic with a bit of PIT</param>
		void SetTaskVehicleChaseBehaviorFlag(int ped, int flag, bool set);
		void SetTaskVehicleChaseIdealPursuitDistance(int ped, float distance);
		/// <summary>
		/// Ped pilot should be in a heli.
		/// NOTE: If the pilot finds enemies, it will engage them, then remain there idle, not continuing to chase the Entity given.
		/// </summary>
		/// <param name="entityToFollow">can be a vehicle or Ped.</param>
		/// <param name="x">5.0, it tries to go below (if the EntityToFollow is a heli or plane)</param>
		/// <param name="y">5.0, it tries to go below (if the EntityToFollow is a heli or plane)</param>
		void TaskHeliChase(int pilot, int entityToFollow, float x, float y, float z);
		void TaskPlaneChase(int pilot, int entityToFollow, float x, float y, float z);
		void TaskPlaneLand(int pilot, int plane, float runwayStartX, float runwayStartY, float runwayStartZ, float runwayEndX, float runwayEndY, float runwayEndZ);
		void _0x6100B3CEFD43452E(int p0);
		/// <summary>
		/// Seems to stop the engine
		/// </summary>
		void ClearVehicleTasks(int vehicle);
		/// <summary>
		/// CLEAR_*
		/// </summary>
		void _0x53DDC75BC3AC0A90(int vehicle);
		void TaskPlaneGotoPreciseVtol(int ped, int vehicle, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9);
		/// <summary>
		/// Used in am_vehicle_spawn.ysc and am_mp_submarine.ysc.
		/// Speed can be set by calling SET_DRIVE_TASK_CRUISE_SPEED after
		/// </summary>
		/// <param name="p0">is always 0, p5 is always 1</param>
		/// <param name="submarine">is the vehicle handle of the submarine. Submarine must have a driver, but the ped handle is not passed to the native.</param>
		void TaskSubmarineGotoAndStop(int p0, int submarine, float x, float y, float z, int p5);
		/// <summary>
		/// Must have targetVehicle, targetPed, OR destination X/Y/Z set
		/// Will follow targeted vehicle/ped, or fly to destination
		/// Set whichever is not being used to 0
		/// Mission mode type:
		/// - 4, 7: Forces heli to snap to the heading if set, flies to destination or tracks specified entity (mode 4 only works for coordinates, 7 works for coordinates OR ped/vehicle)
		/// - 6: Attacks the target ped/vehicle with mounted weapons. If radius is set, will maintain that distance from target.
		/// - 8: Makes the heli flee from the ped/vehicle/coordinate
		/// - 9: Circles around target ped/vehicle, snaps to angle if set. Behavior flag (last parameter) of 2048 switches from counter-clockwise to clockwise circling. Does not work with coordinate destination.
		/// - 10, 11: Follows ped/vehicle target and imitates target heading. Only works with ped/vehicle target, not coord target
		/// See NativeDB for reference: http://natives.altv.mp/#/0xDAD029E187A2BEB4
		/// </summary>
		/// <param name="radius">affects how closely the heli will follow tracked ped/vehicle, and when circling (mission type 9) sets the radius (in meters) that it will circle the target from</param>
		/// <param name="unk3">is a float value, you may see -1082130432 for this value in decompiled native scripts, this is the equivalent to -1.0f. Seems to affect acceleration/aggressiveness, but not sure exactly how it works. Higher value seems to result in lower acceleration/less aggressive flying. Almost always -1.0 in native scripts, occasionally 20.0 or 50.0. Setting to 400.0 seems to work well for making the pilot not overshoot the destination when using coordinate destination.</param>
		void TaskHeliMission(int pilot, int aircraft, int targetVehicle, int targetPed, float destinationX, float destinationY, float destinationZ, int missionFlag, float maxSpeed, float radius, float targetHeading, int maxHeight, int minHeight, float unk3, int behaviorFlags);
		void TaskHeliEscortHeli(int pilot, int heli1, int heli2, float p3, float p4, float p5);
		/// <summary>
		/// EXAMPLE USAGE:
		/// Fly around target (Precautiously, keeps high altitude):
		/// Function.Call(Hash.TASK_PLANE_MISSION, pilot, selectedAirplane, 0, 0, Target.X, Target.Y, Target.Z, 4, 100f, 0f, 90f, 0, 200f);
		/// Fly around target (Dangerously, keeps VERY low altitude):
		/// Fly directly into target:
		/// Function.Call(Hash.TASK_PLANE_MISSION, pilot, selectedAirplane, 0, 0, Target.X, Target.Y, Target.Z, 4, 100f, 0f, 90f, 0, -5000f);
		/// EXPANDED INFORMATION FOR ADVANCED USAGE (custom pilot)
		/// 'physicsSpeed': (THIS IS NOT YOUR ORDINARY SPEED PARAMETER: READ!!)
		/// Think of this -first- as a radius value, not a true speed value.  The ACTUAL effective speed of the plane will be that of the maximum speed permissible to successfully fly in a -circle- with a radius of 'physicsSpeed'.  This also means that the plane must complete a circle before it can begin its "bombing run", its straight line pass towards the target.  p9 appears to influence the angle at which a "bombing run" begins, although I can't confirm yet.
		/// See NativeDB for reference: http://natives.altv.mp/#/0x23703CD154E83B88
		/// </summary>
		/// <param name="pilot">500f);</param>
		void TaskPlaneMission(int pilot, int aircraft, int targetVehicle, int targetPed, float destinationX, float destinationY, float destinationZ, int missionFlag, float angularDrag, float unk, float targetHeading, float maxZ, float minZ, int p13);
		void TaskPlaneTaxi(int pilot, int aircraft, int p2, int p3, int p4, int p5, int p6);
		/// <summary>
		/// You need to call PED::SET_BLOCKING_OF_NON_TEMPORARY_EVENTS after TASK_BOAT_MISSION in order for the task to execute.
		/// Working example
		/// float vehicleMaxSpeed = VEHICLE::_GET_VEHICLE_MAX_SPEED(ENTITY::GET_ENTITY_MODEL(pedVehicle));
		/// PED::SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(pedDriver, 1);
		/// P8 appears to be driving style flag - see gtaforums.com/topic/822314-guide-driving-styles/ for documentation
		/// </summary>
		void TaskBoatMission(int pedDriver, int boat, int p2, int p3, float x, float y, float z, int p7, float maxSpeed, int drivingStyle, float p10, int p11);
		/// <summary>
		/// Example:
		/// TASK::TASK_DRIVE_BY(l_467[122], PLAYER::PLAYER_PED_ID(), 0, 0.0, 0.0, 2.0, 300.0, 100, 0, ${firing_pattern_burst_fire_driveby});
		/// Needs working example. Doesn't seem to do anything.
		/// I marked p2 as targetVehicle as all these shooting related tasks seem to have that in common.
		/// I marked p6 as distanceToShoot as if you think of GTA's Logic with the native SET_VEHICLE_SHOOT natives, it won't shoot till it gets within a certain distance of the target.
		/// I marked p7 as pedAccuracy as it seems it's mostly 100 (Completely Accurate), 75, 90, etc. Although this could be the ammo count within the gun, but I highly doubt it. I will change this comment once I find out if it's ammo count or not.
		/// </summary>
		void TaskDriveBy(int driverPed, int targetPed, int targetVehicle, float targetX, float targetY, float targetZ, float distanceToShoot, int pedAccuracy, bool p8, int firingPattern);
		/// <summary>
		/// For p1 & p2 (Ped, Vehicle). I could be wrong, as the only time this native is called in scripts is once and both are 0, but I assume this native will work like SET_MOUNTED_WEAPON_TARGET in which has the same exact amount of parameters and the 1st and last 3 parameters are right and the same for both natives.
		/// </summary>
		void SetDrivebyTaskTarget(int shootingPed, int targetPed, int targetVehicle, float x, float y, float z);
		void ClearDrivebyTaskUnderneathDrivingTask(int ped);
		bool IsDrivebyTaskUnderneathDrivingTask(int ped);
		/// <summary>
		/// Forces the ped to use the mounted weapon.
		/// Returns false if task is not possible.
		/// </summary>
		bool ControlMountedWeapon(int ped);
		/// <summary>
		/// Note: Look in decompiled scripts and the times that p1 and p2 aren't 0. They are filled with vars. If you look through out that script what other natives those vars are used in, you can tell p1 is a ped and p2 is a vehicle. Which most likely means if you want the mounted weapon to target a ped set targetVehicle to 0 or vice-versa.
		/// </summary>
		void SetMountedWeaponTarget(int shootingPed, int targetPed, int targetVehicle, float x, float y, float z, int p6, int p7);
		bool IsMountedWeaponTaskUnderneathDrivingTask(int ped);
		/// <summary>
		/// Actually has 3 params, not 2.
		/// </summary>
		/// <param name="ped">Ped</param>
		/// <param name="p1">int (or bool?)</param>
		/// <param name="p2">int</param>
		void TaskUseMobilePhone(int ped, int p1, int p2);
		void TaskUseMobilePhoneTimed(int ped, int duration);
		/// <summary>
		/// </summary>
		/// <param name="p2">tend to be 16, 17 or 1</param>
		/// <param name="p3">to p7 tend to be 0.0</param>
		void TaskChatToPed(int ped, int target, int p2, float p3, float p4, float p5, float p6, float p7);
		/// <summary>
		/// -------------------------------
		/// Driver = -1
		/// Any = -2
		/// Left-Rear = 1
		/// Right-Front = 0
		/// Right-Rear = 2
		/// Extra seats = 3-14(This may differ from vehicle type e.g. Firetruck Rear Stand, Ambulance Rear)
		/// </summary>
		/// <param name="seat">Numbers</param>
		void TaskWarpPedIntoVehicle(int ped, int vehicle, int seat);
		/// <summary>
		/// //this part of the code is to determine at which entity the player is aiming, for example if you want to create a mod where you give orders to peds
		/// Player player = PLAYER::PLAYER_ID();
		/// PLAYER::_GET_AIMED_ENTITY(player, &aimedentity);
		/// //bg is an array of peds
		/// TASK::TASK_SHOOT_AT_ENTITY(bg[i], aimedentity, 5000, MISC::GET_HASH_KEY("FIRING_PATTERN_FULL_AUTO"));
		/// in practical usage, getting the entity the player is aiming at and then task the peds to shoot at the entity, at a button press event would be better.
		/// Firing Pattern Hash Information: https://pastebin.com/Px036isB
		/// </summary>
		/// <param name="entity">aimedentity;</param>
		void TaskShootAtEntity(int entity, int target, int duration, int firingPattern);
		/// <summary>
		/// Climbs or vaults the nearest thing.
		/// </summary>
		void TaskClimb(int ped, bool unused);
		void TaskClimbLadder(int ped, int p1);
		void TaskRappelDownWall(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10);
		int _0x9D252648778160DF(int p0);
		/// <summary>
		/// Immediately stops the pedestrian from whatever it's doing. They stop fighting, animations, etc. they forget what they were doing.
		/// </summary>
		void ClearPedTasksImmediately(int ped);
		void TaskPerformSequenceFromProgress(int p0, int p1, int p2, int p3);
		/// <summary>
		/// This native does absolutely nothing, just a nullsub
		/// </summary>
		void SetNextDesiredMoveState(float p0);
		void SetPedDesiredMoveBlendRatio(int ped, float p1);
		float GetPedDesiredMoveBlendRatio(int ped);
		/// <summary>
		/// eg
		/// TASK::TASK_GOTO_ENTITY_AIMING(v_2, PLAYER::PLAYER_PED_ID(), 5.0, 25.0);
		/// </summary>
		/// <param name="ped">= Ped you want to perform this task.</param>
		/// <param name="target">= the Entity they should aim at.</param>
		/// <param name="distanceToStopAt">= distance from the target, where the ped should stop to aim.</param>
		/// <param name="StartAimingDist">= distance where the ped should start to aim.</param>
		void TaskGotoEntityAiming(int ped, int target, float distanceToStopAt, float StartAimingDist);
		/// <summary>
		/// </summary>
		/// <param name="p1">is always GET_HASH_KEY("empty") in scripts, for the rare times this is used</param>
		void TaskSetDecisionMaker(int ped, int p1);
		void TaskSetSphereDefensiveArea(int p0, float p1, float p2, float p3, float p4);
		void TaskClearDefensiveArea(int p0);
		void TaskPedSlideToCoord(int ped, float x, float y, float z, float heading, float p5);
		void TaskPedSlideToCoordHdgRate(int ped, float x, float y, float z, float heading, float p5, float p6);
		int AddCoverPoint(float p0, float p1, float p2, float p3, int p4, int p5, int p6, bool p7);
		void RemoveCoverPoint(int coverpoint);
		/// <summary>
		/// Checks if there is a cover point at position
		/// </summary>
		bool DoesScriptedCoverPointExistAtCoords(float x, float y, float z);
		Vector3 GetScriptedCoverPointCoords(int coverpoint);
		/// <summary>
		/// Makes the specified ped attack the target ped.
		/// </summary>
		/// <param name="p2">should be 0</param>
		/// <param name="p3">should be 16</param>
		void TaskCombatPed(int ped, int targetPed, int p2, int p3);
		void TaskCombatPedTimed(int p0, int ped, int p2, int p3);
		void TaskSeekCoverFromPos(int ped, float x, float y, float z, int duration, bool p5);
		void TaskSeekCoverFromPed(int ped, int target, int duration, bool p3);
		void TaskSeekCoverToCoverPoint(int p0, int p1, float p2, float p3, float p4, int p5, bool p6);
		/// <summary>
		/// from michael2:
		/// appears to be shorter variation
		/// from michael3:
		/// TASK::TASK_SEEK_COVER_TO_COORDS(ped, -2231.011474609375, 263.6326599121094, 173.60195922851562, -1, 0);
		/// </summary>
		void TaskSeekCoverToCoords(int ped, float x1, float y1, float z1, float x2, float y2, float z2, int p7, bool p8);
		void TaskPutPedDirectlyIntoCover(int ped, float x, float y, float z, int timeout, bool p5, float p6, bool p7, bool p8, int p9, bool p10);
		void TaskExitCover(int p0, int p1, float p2, float p3, float p4);
		/// <summary>
		/// from armenian3.c4
		/// </summary>
		void TaskPutPedDirectlyIntoMelee(int ped, int meleeTarget, float p2, float p3, float p4, bool p5);
		/// <summary>
		/// used in sequence task
		/// both parameters seems to be always 0
		/// </summary>
		void TaskToggleDuck(bool p0, bool p1);
		/// <summary>
		/// From re_prisonvanbreak:
		/// TASK::TASK_GUARD_CURRENT_POSITION(l_DD, 35.0, 35.0, 1);
		/// </summary>
		void TaskGuardCurrentPosition(int p0, float p1, float p2, bool p3);
		void TaskGuardAssignedDefensiveArea(int p0, float p1, float p2, float p3, float p4, float p5, int p6);
		/// <summary>
		/// </summary>
		/// <param name="p0">- Guessing PedID</param>
		/// <param name="p1">XYZ?</param>
		/// <param name="p2">XYZ?</param>
		/// <param name="p4">- ???</param>
		/// <param name="p5">- Maybe the size of sphere from XYZ?</param>
		/// <param name="p6">- ???</param>
		/// <param name="p7">XYZ again?</param>
		/// <param name="p8">XYZ again?</param>
		/// <param name="p10">- Maybe the size of sphere from second XYZ?</param>
		void TaskGuardSphereDefensiveArea(int p0, float p1, float p2, float p3, float p4, float p5, int p6, float p7, float p8, float p9, float p10);
		/// <summary>
		/// </summary>
		/// <param name="scenarioName">example: "WORLD_HUMAN_GUARD_STAND"</param>
		void TaskStandGuard(int ped, float x, float y, float z, float heading, string scenarioName);
		void SetDriveTaskCruiseSpeed(int driver, float cruiseSpeed);
		void SetDriveTaskMaxCruiseSpeed(int p0, float p1);
		/// <summary>
		/// This native is used to set the driving style for specific ped.
		/// Driving styles id seems to be:
		/// 786468
		/// 262144
		/// 786469
		/// http://gtaforums.com/topic/822314-guide-driving-styles/
		/// </summary>
		void SetDriveTaskDrivingStyle(int ped, int drivingStyle);
		void AddCoverBlockingArea(float playerX, float playerY, float playerZ, float radiusX, float radiusY, float radiusZ, bool p6, bool p7, bool p8, bool p9);
		void RemoveAllCoverBlockingAreas();
		/// <summary>
		/// REMOVE_*
		/// </summary>
		void _0xFA83CA6776038F64(float x, float y, float z);
		void _0x1F351CF1C6475734(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9);
		/// <summary>
		/// Plays a scenario on a Ped at their current location.
		/// ----
		/// From "am_hold_up.ysc.c4" at line 339:
		/// TASK::TASK_START_SCENARIO_IN_PLACE(NETWORK::NET_TO_PED(l_8D._f4), sub_adf(), 0, 1);
		/// WORLD_HUMAN_SMOKING
		/// WORLD_HUMAN_HANG_OUT_STREET
		/// WORLD_HUMAN_STAND_MOBILE
		/// This makes sense, as these are what I commonly see when going by a liquor store.
		/// -------------------------
		/// See NativeDB for reference: http://natives.altv.mp/#/0x142A02425FF02BD9
		/// </summary>
		/// <param name="unkDelay">- Usually 0 or -1, doesn't seem to have any effect. Might be a delay between sequences.</param>
		/// <param name="playEnterAnim">- Plays the "Enter" anim if true, otherwise plays the "Exit" anim. Scenarios that don't have any "Enter" anims won't play if this is set to true.</param>
		/// <returns>I'm unsure of what the last two parameters are, however sub_adf() randomly returns 1 of 3 scenarios, those being:</returns>
		void TaskStartScenarioInPlace(int ped, string scenarioName, int unkDelay, bool playEnterAnim);
		/// <summary>
		/// Full list of ped scenarios by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenariosCompact.json
		/// Also a few more listed at TASK::TASK_START_SCENARIO_IN_PLACE just above.
		/// ---------------
		/// The first parameter in every scenario has always been a Ped of some sort. The second like TASK_START_SCENARIO_IN_PLACE is the name of the scenario.
		/// The next 4 parameters were harder to decipher. After viewing "hairdo_shop_mp.ysc.c4", and being confused from seeing the case in other scripts, they passed the first three of the arguments as one array from a function, and it looked like it was obviously x, y, and z.
		/// I haven't seen the sixth parameter go to or over 360, making me believe that it is rotation, but I really can't confirm anything.
		/// I have no idea what the last 3 parameters are, but I'll try to find out.
		/// -going on the last 3 parameters, they appear to always be "0, 0, 1"
		/// </summary>
		/// <param name="duration">-1 also used in scrips</param>
		/// <param name="sittingScenario">used for sitting scenarios</param>
		/// <param name="teleport">teleports ped to position</param>
		void TaskStartScenarioAtPosition(int ped, string scenarioName, float x, float y, float z, float heading, int duration, bool sittingScenario, bool teleport);
		/// <summary>
		/// Updated variables
		/// An alternative to TASK::TASK_USE_NEAREST_SCENARIO_TO_COORD_WARP. Makes the ped walk to the scenario instead.
		/// </summary>
		void TaskUseNearestScenarioToCoord(int ped, float x, float y, float z, float distance, int duration);
		void TaskUseNearestScenarioToCoordWarp(int ped, float x, float y, float z, float radius, int p5);
		void TaskUseNearestScenarioChainToCoord(int p0, float p1, float p2, float p3, float p4, int p5);
		void TaskUseNearestScenarioChainToCoordWarp(int p0, float p1, float p2, float p3, float p4, int p5);
		bool DoesScenarioExistInArea(float x, float y, float z, float radius, bool b);
		/// <summary>
		/// </summary>
		bool DoesScenarioOfTypeExistInArea(float p0, float p1, float p2, ref int p3, float p4, bool p5);
		bool IsScenarioOccupied(float p0, float p1, float p2, float p3, bool p4);
		bool PedHasUseScenarioTask(int ped);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void PlayAnimOnRunningScenario(int ped, string animDict, string animName);
		/// <summary>
		/// Occurrences in the b617d scripts:
		/// "ARMY_GUARD",
		/// "ARMY_HELI",
		/// "Cinema_Downtown",
		/// "Cinema_Morningwood",
		/// "Cinema_Textile",
		/// "City_Banks",
		/// "Countryside_Banks",
		/// "DEALERSHIP",
		/// See NativeDB for reference: http://natives.altv.mp/#/0xF9034C136C9E00D3
		/// </summary>
		bool DoesScenarioGroupExist(string scenarioGroup);
		/// <summary>
		/// Occurrences in the b617d scripts:
		/// "ARMY_GUARD",
		/// "ARMY_HELI",
		/// "BLIMP",
		/// "Cinema_Downtown",
		/// "Cinema_Morningwood",
		/// "Cinema_Textile",
		/// "City_Banks",
		/// "Countryside_Banks",
		/// See NativeDB for reference: http://natives.altv.mp/#/0x367A09DED4E05B99
		/// </summary>
		bool IsScenarioGroupEnabled(string scenarioGroup);
		/// <summary>
		/// Occurrences in the b617d scripts: pastebin.com/Tvg2PRHU
		/// </summary>
		void SetScenarioGroupEnabled(string scenarioGroup, bool p1);
		void ResetScenarioGroupsEnabled();
		/// <summary>
		/// Groups found in the scripts used with this native:
		/// "AMMUNATION",
		/// "QUARRY",
		/// "Triathlon_1",
		/// "Triathlon_2",
		/// "Triathlon_3"
		/// </summary>
		void SetExclusiveScenarioGroup(string scenarioGroup);
		void ResetExclusiveScenarioGroup();
		/// <summary>
		/// Occurrences in the b617d scripts:
		/// "PROP_HUMAN_SEAT_CHAIR",
		/// "WORLD_HUMAN_DRINKING",
		/// "WORLD_HUMAN_HANG_OUT_STREET",
		/// "WORLD_HUMAN_SMOKING",
		/// "WORLD_MOUNTAIN_LION_WANDER",
		/// "WORLD_HUMAN_DRINKING"
		/// Sometimes used together with MISC::IS_STRING_NULL_OR_EMPTY in the scripts.
		/// </summary>
		/// <param name="scenarioType">could be the same as scenarioName, used in for example TASK::TASK_START_SCENARIO_AT_POSITION.</param>
		bool IsScenarioTypeEnabled(string scenarioType);
		/// <summary>
		/// seems to enable/disable specific scenario-types from happening in the game world.
		/// Here are some scenario types from the scripts:
		/// "WORLD_MOUNTAIN_LION_REST"
		/// "WORLD_MOUNTAIN_LION_WANDER"
		/// "DRIVE"
		/// "WORLD_VEHICLE_POLICE_BIKE"
		/// "WORLD_VEHICLE_POLICE_CAR"
		/// "WORLD_VEHICLE_POLICE_NEXT_TO_CAR"
		/// "WORLD_VEHICLE_DRIVE_SOLO"
		/// See NativeDB for reference: http://natives.altv.mp/#/0xEB47EC4E34FB7EE1
		/// </summary>
		/// <param name="scenarioType">could be the same as scenarioName, used in for example TASK::TASK_START_SCENARIO_AT_POSITION.</param>
		void SetScenarioTypeEnabled(string scenarioType, bool toggle);
		void ResetScenarioTypesEnabled();
		bool IsPedActiveInScenario(int ped);
		/// <summary>
		/// Used only once (am_mp_property_int)
		/// Related to CTaskAmbientClips.
		/// </summary>
		/// <param name="ped">was PLAYER_PED_ID()</param>
		bool IsPedPlayingBaseClipInScenario(int ped);
		/// <summary>
		/// Appears only in fm_mission_controller and used only 3 times.
		/// </summary>
		/// <param name="ped">was always PLAYER_PED_ID()</param>
		/// <param name="p1">was always true</param>
		/// <param name="p2">was always true</param>
		void SetPedCanPlayAmbientIdles(int ped, bool p1, bool p2);
		/// <summary>
		/// Despite its name, it only attacks ONE hated target. The one closest to the specified position.
		/// </summary>
		void TaskCombatHatedTargetsInArea(int ped, float x, float y, float z, float radius, int p5);
		/// <summary>
		/// Despite its name, it only attacks ONE hated target. The one closest hated target.
		/// </summary>
		/// <param name="p2">seems to be always 0</param>
		void TaskCombatHatedTargetsAroundPed(int ped, float radius, int p2);
		void TaskCombatHatedTargetsAroundPedTimed(int p0, float p1, int p2, int p3);
		/// <summary>
		/// In every case of this native, I've only seen the first parameter passed as 0, although I believe it's a Ped after seeing tasks around it using 0. That's because it's used in a Sequence Task.
		/// The last 3 parameters are definitely coordinates after seeing them passed in other scripts, and even being used straight from the player's coordinates.
		/// ---
		/// It seems that - in the decompiled scripts - this native was used on a ped who was in a vehicle to throw a projectile out the window at the player. This is something any ped will naturally do if they have a throwable and they are doing driveby-combat (although not very accurately).
		/// It is possible, however, that this is how SWAT throws smoke grenades at the player when in cover.
		/// ----------------------------------------------------
		/// The first comment is right it definately is the ped as if you look in script finale_heist2b.c line 59628 in Xbox Scripts atleast you will see task_throw_projectile and the first param is Local_559[2 <14>] if you look above it a little bit line 59622 give_weapon_to_ped uses the same exact param Local_559[2 <14>] and we all know the first param of that native is ped. So it guaranteed has to be ped. 0 just may mean to use your ped by default for some reason.
		/// </summary>
		void TaskThrowProjectile(int ped, float x, float y, float z, int p4, int p5);
		void TaskSwapWeapon(int ped, bool p1);
		/// <summary>
		/// The 2nd param (unused) is not implemented.
		/// -----------------------------------------------------------------------
		/// The only occurrence I found in a R* script ("assassin_construction.ysc.c4"):
		/// if (((v_3 < v_4) && (TASK::GET_SCRIPT_TASK_STATUS(PLAYER::PLAYER_PED_ID(), 0x6a67a5cc) != 1)) && (v_5 > v_3)) {
		/// TASK::TASK_RELOAD_WEAPON(PLAYER::PLAYER_PED_ID(), 1);
		/// }
		/// </summary>
		void TaskReloadWeapon(int ped, bool unused);
		bool IsPedGettingUp(int ped);
		/// <summary>
		/// The last parameter is always 0 for some reason I do not know. The first parameter is the pedestrian who will writhe to the pedestrian in the other parameter. The third paremeter is how long until the Writhe task ends. When the task ends, the ped will die. If set to -1, he will not die automatically, and the task will continue until something causes it to end. This can be being touched by an entity, being shot, explosion, going into ragdoll, having task cleared. Anything that ends the current task will kill the ped at this point.
		/// MulleDK19: Third parameter does not appear to be time. The last parameter is not implemented (It's not used, regardless of value).
		/// </summary>
		/// <param name="time">Function.Call(Ped1, Ped2, Time, 0);</param>
		void TaskWrithe(int ped, int target, int time, int p3, int p4, int p5);
		/// <summary>
		/// This native checks if a ped is on the ground, in pain from a (gunshot) wound.
		/// Returns `true` if the ped is in writhe, `false` otherwise.
		/// </summary>
		bool IsPedInWrithe(int ped);
		/// <summary>
		/// patrolRoutes found in the b617d scripts:
		/// "miss_Ass0",
		/// "miss_Ass1",
		/// "miss_Ass2",
		/// "miss_Ass3",
		/// "miss_Ass4",
		/// "miss_Ass5",
		/// "miss_Ass6",
		/// "MISS_PATROL_6",
		/// See NativeDB for reference: http://natives.altv.mp/#/0xA36BFB5EE89F3D82
		/// </summary>
		void OpenPatrolRoute(string patrolRoute);
		void ClosePatrolRoute();
		/// <summary>
		/// Example:
		/// TASK::ADD_PATROL_ROUTE_NODE(2, "WORLD_HUMAN_GUARD_STAND", -193.4915, -2378.864990234375, 10.9719, -193.4915, -2378.864990234375, 10.9719, 3000);
		/// p2, p3 and p4 is only one parameter sometimes in the scripts. Most likely a Vector3 hence p2, p3 and p4 are coordinates.
		/// Examples:
		/// TASK::ADD_PATROL_ROUTE_NODE(1, "WORLD_HUMAN_GUARD_STAND", l_739[73], 0.0, 0.0, 0.0, 0);
		/// TASK::ADD_PATROL_ROUTE_NODE(1, "WORLD_HUMAN_GUARD_STAND", l_B0[1744]._f3, l_B0[1744]._f3, 2000);
		/// p5, p6 and p7 are for example set to: 1599.0406494140625, 2713.392578125, 44.4309.
		/// </summary>
		/// <param name="p0">is between 0 and 4 in the scripts.</param>
		/// <param name="p1">is "WORLD_HUMAN_GUARD_STAND" or "StandGuard".</param>
		/// <param name="p8">is an int, often random set to for example: MISC::GET_RANDOM_INT_IN_RANGE(5000, 10000).</param>
		void AddPatrolRouteNode(int p0, string p1, float x1, float y1, float z1, float x2, float y2, float z2, int p8);
		void AddPatrolRouteLink(int p0, int p1);
		void CreatePatrolRoute();
		/// <summary>
		/// From the b617d scripts:
		/// TASK::DELETE_PATROL_ROUTE("miss_merc0");
		/// TASK::DELETE_PATROL_ROUTE("miss_merc1");
		/// TASK::DELETE_PATROL_ROUTE("miss_merc2");
		/// TASK::DELETE_PATROL_ROUTE("miss_dock");
		/// </summary>
		void DeletePatrolRoute(string patrolRoute);
		/// <summary>
		/// After looking at some scripts the second parameter seems to be an id of some kind. Here are some I found from some R* scripts:
		/// "miss_Tower_01" (this went from 01 - 10)
		/// "miss_Ass0" (0, 4, 6, 3)
		/// "MISS_PATROL_8"
		/// I think they're patrol routes, but I'm not sure. And I believe the 3rd parameter is a BOOL, but I can't confirm other than only seeing 0 and 1 being passed.
		/// As far as I can see the patrol routes names such as "miss_Ass0" have been defined earlier in the scripts. This leads me to believe we can defined our own new patrol routes by following the same approach.
		/// From the scripts
		/// TASK::OPEN_PATROL_ROUTE("miss_Ass0");
		/// TASK::ADD_PATROL_ROUTE_NODE(0, "WORLD_HUMAN_GUARD_STAND", l_738[03], -139.4076690673828, -993.4732055664062, 26.2754, MISC::GET_RANDOM_INT_IN_RANGE(5000, 10000));
		/// See NativeDB for reference: http://natives.altv.mp/#/0xBDA5DF49D080FE4E
		/// </summary>
		void TaskPatrol(int ped, string p1, int p2, bool p3, bool p4);
		/// <summary>
		/// Makes the ped run to take cover
		/// </summary>
		void TaskStayInCover(int ped);
		/// <summary>
		/// </summary>
		/// <param name="x">offset in world coords from some entity.</param>
		/// <param name="y">offset in world coords from some entity.</param>
		void AddVehicleSubtaskAttackCoord(int ped, float x, float y, float z);
		void AddVehicleSubtaskAttackPed(int ped, int ped2);
		void TaskVehicleShootAtPed(int ped, int target, float p2);
		void TaskVehicleAimAtPed(int ped, int target);
		void TaskVehicleShootAtCoord(int ped, float x, float y, float z, float p4);
		void TaskVehicleAimAtCoord(int ped, float x, float y, float z);
		/// <summary>
		/// Differs from TASK_VEHICLE_DRIVE_TO_COORDS in that it will pick the shortest possible road route without taking one-way streets and other "road laws" into consideration.
		/// WARNING:
		/// A behaviorFlag value of 0 will result in a clunky, stupid driver!
		/// Recommended settings:
		/// If you simply want to have your driver move to a fixed location, call it only once, or, when necessary in the event of interruption.
		/// If using this to continually follow a Ped who is on foot:  You will need to run this in a tick loop.  Call it in with the Ped's updated coordinates every 20 ticks or so and you will have one hell of a smart, fast-reacting NPC driver -- provided he doesn't get stuck.  If your update frequency is too fast, the Ped may not have enough time to figure his way out of being stuck, and thus, remain stuck.  One way around this would be to implement an "anti-stuck" mechanism, which allows the driver to realize he's stuck, temporarily pause the tick, unstuck, then resume the tick.
		/// EDIT:  This is being discussed in more detail at http://gtaforums.com/topic/818504-any-idea-on-how-to-make-peds-clever-and-insanely-fast-c/
		/// </summary>
		/// <param name="speed">= 30.0f,</param>
		/// <param name="behaviorFlag">= 156,</param>
		/// <param name="stoppingRange">= 5.0f;</param>
		void TaskVehicleGotoNavmesh(int ped, int vehicle, float x, float y, float z, float speed, int behaviorFlag, float stoppingRange);
		/// <summary>
		/// movement_speed: mostly 2f, but also 1/1.2f, etc.
		/// firing_pattern: ${firing_pattern_full_auto}, 0xC6EE6B4C
		/// </summary>
		/// <param name="p8">always false</param>
		/// <param name="p9">2f</param>
		/// <param name="p10">0.5f</param>
		/// <param name="p11">true</param>
		/// <param name="flags">0 / 512 / 513, etc.</param>
		/// <param name="p13">0</param>
		void TaskGoToCoordWhileAimingAtCoord(int ped, float x, float y, float z, float aimAtX, float aimAtY, float aimAtZ, float moveSpeed, bool p8, float p9, float p10, bool p11, int flags, bool p13, int firingPattern);
		void TaskGoToCoordWhileAimingAtEntity(int p0, float p1, float p2, float p3, int p4, float p5, bool p6, float p7, float p8, bool p9, int p10, bool p11, int p12, int p13);
		/// <summary>
		/// The ped will walk or run towards goToLocation, aiming towards goToLocation or focusLocation (depending on the aimingFlag) and shooting if shootAtEnemies = true to any enemy in his path.
		/// If the ped is closer than noRoadsDistance, the ped will ignore pathing/navmesh and go towards goToLocation directly. This could cause the ped to get stuck behind tall walls if the goToLocation is on the other side. To avoid this, use 0.0f and the ped will always use pathing/navmesh to reach his destination.
		/// If the speed is set to 0.0f, the ped will just stand there while aiming, if set to 1.0f he will walk while aiming, 2.0f will run while aiming.
		/// The ped will stop aiming when he is closer than distanceToStopAt to goToLocation.
		/// I still can't figure out what unkTrue is used for. I don't notice any difference if I set it to false but in the decompiled scripts is always true.
		/// Note: After some testing, using unkFlag = 16 (0x10) enables the use of sidewalks while moving towards goToLocation.
		/// The aimingFlag takes 2 values: 0 to aim at the focusLocation, 1 to aim at where the ped is heading (goToLocation).
		/// Example:
		/// enum AimFlag
		/// See NativeDB for reference: http://natives.altv.mp/#/0xA55547801EB331FC
		/// </summary>
		/// <param name="unkFlag">0, 1, 5 (101 in binary) and 4097 (4096 + 1 or 1000000000001 in binary). For now, I don't know what behavior enable or disable this possible flag so I leave it at 0.</param>
		void TaskGoToCoordAndAimAtHatedEntitiesNearCoord(int pedHandle, float goToLocationX, float goToLocationY, float goToLocationZ, float focusLocationX, float focusLocationY, float focusLocationZ, float speed, bool shootAtEnemies, float distanceToStopAt, float noRoadsDistance, bool unkTrue, int unkFlag, int aimingFlag, int firingPattern);
		void TaskGoToEntityWhileAimingAtCoord(int p0, int p1, float p2, float p3, float p4, float p5, bool p6, float p7, float p8, bool p9, bool p10, int p11);
		/// <summary>
		/// If true, peds will shoot at Entity till it is dead.
		/// If false, peds will just walk till they reach the entity and will cease shooting.
		/// </summary>
		void TaskGoToEntityWhileAimingAtEntity(int ped, int entityToWalkTo, int entityToAimAt, float speed, bool shootatEntity, float p5, float p6, bool p7, bool p8, int firingPattern);
		/// <summary>
		/// Makes the ped ragdoll like when falling from a great height
		/// </summary>
		void SetHighFallTask(int ped, int p1, int p2, int p3);
		/// <summary>
		/// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
		/// For a full list of the points, see here: goo.gl/wIH0vn
		/// Max number of loaded recordings is 32.
		/// </summary>
		void RequestWaypointRecording(string name);
		/// <summary>
		/// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
		/// </summary>
		bool GetIsWaypointRecordingLoaded(string name);
		/// <summary>
		/// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
		/// </summary>
		void RemoveWaypointRecording(string name);
		/// <summary>
		/// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
		/// </summary>
		/// <param name="points">goo.gl/wIH0vn</param>
		bool WaypointRecordingGetNumPoints(string name, ref int points);
		/// <summary>
		/// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
		/// For a full list of the points, see here: goo.gl/wIH0vn
		/// </summary>
		bool WaypointRecordingGetCoord(string name, int point, ref Vector3 coord);
		/// <summary>
		/// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
		/// </summary>
		float WaypointRecordingGetSpeedAtPoint(string name, int point);
		/// <summary>
		/// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
		/// For a full list of the points, see here: goo.gl/wIH0vn
		/// </summary>
		bool WaypointRecordingGetClosestWaypoint(string name, float x, float y, float z, ref int point);
		void TaskFollowWaypointRecording(int p0, int p1, int p2, int p3, int p4);
		bool IsWaypointPlaybackGoingOnForPed(int p0);
		int GetPedWaypointProgress(int ped);
		float GetPedWaypointDistance(int p0);
		int SetPedWaypointRouteOffset(int p0, int p1, int p2, int p3);
		float GetWaypointDistanceAlongRoute(string p0, int p1);
		bool WaypointPlaybackGetIsPaused(int p0);
		void WaypointPlaybackPause(int p0, bool p1, bool p2);
		void WaypointPlaybackResume(int p0, bool p1, int p2, int p3);
		void WaypointPlaybackOverrideSpeed(int p0, float p1, bool p2);
		void WaypointPlaybackUseDefaultSpeed(int p0);
		void UseWaypointRecordingAsAssistedMovementRoute(string name, bool p1, float p2, float p3);
		void WaypointPlaybackStartAimingAtPed(int p0, int p1, bool p2);
		void WaypointPlaybackStartAimingAtCoord(int p0, float p1, float p2, float p3, bool p4);
		void WaypointPlaybackStartShootingAtPed(int p0, int p1, bool p2, int p3);
		void WaypointPlaybackStartShootingAtCoord(int p0, float p1, float p2, float p3, bool p4, int p5);
		void WaypointPlaybackStopAimingOrShooting(int p0);
		/// <summary>
		/// Routes: "1_FIBStairs", "2_FIBStairs", "3_FIBStairs", "4_FIBStairs", "5_FIBStairs", "5_TowardsFire", "6a_FIBStairs", "7_FIBStairs", "8_FIBStairs", "Aprtmnt_1", "AssAfterLift", "ATM_1", "coroner2", "coroner_stairs", "f5_jimmy1", "fame1", "family5b", "family5c", "Family5d", "family5d", "FIB_Glass1", "FIB_Glass2", "FIB_Glass3", "finaBroute1A", "finalb1st", "finalB1sta", "finalbround", "finalbroute2", "Hairdresser1", "jan_foyet_ft_door", "Jo_3", "Lemar1", "Lemar2", "mansion_1", "Mansion_1", "pols_1", "pols_2", "pols_3", "pols_4", "pols_5", "pols_6", "pols_7", "pols_8", "Pro_S1", "Pro_S1a", "Pro_S2", "Towards_case", "trev_steps", "tunrs1", "tunrs2", "tunrs3", "Wave01457s"
		/// </summary>
		void AssistedMovementRequestRoute(string route);
		void AssistedMovementRemoveRoute(string route);
		bool AssistedMovementIsRouteLoaded(string route);
		void AssistedMovementSetRouteProperties(string route, int props);
		void AssistedMovementOverrideLoadDistanceThisFrame(float dist);
		/// <summary>
		/// task_vehicle_follow_waypoint_recording(Ped p0, Vehicle p1, string p2, int p3, int p4, int p5, int p6, float.x p7, float.Y p8, float.Z p9, bool p10, int p11)
		/// p10 = bool (repeat?)
		/// p11 = 1073741824
		/// -khorio
		/// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
		/// </summary>
		/// <param name="WPRecording">= Waypoint recording string (found in update\update.rpf\x64\levels\gta5\waypointrec.rpf</param>
		/// <param name="p3">= 786468</param>
		/// <param name="p4">= 0</param>
		/// <param name="p5">= 16</param>
		/// <param name="p6">= -1 (angle?)</param>
		/// <param name="p7">usually v3.zero</param>
		void TaskVehicleFollowWaypointRecording(int ped, int vehicle, string WPRecording, int p3, int p4, int p5, int p6, float p7, bool p8, float p9);
		bool IsWaypointPlaybackGoingOnForVehicle(int vehicle);
		int GetVehicleWaypointProgress(int vehicle);
		int GetVehicleWaypointTargetPoint(int vehicle);
		void VehicleWaypointPlaybackPause(int vehicle);
		void VehicleWaypointPlaybackResume(int vehicle);
		void VehicleWaypointPlaybackUseDefaultSpeed(int vehicle);
		void VehicleWaypointPlaybackOverrideSpeed(int vehicle, float speed);
		/// <summary>
		/// I cant believe I have to define this, this is one of the best natives.
		/// It makes the ped ignore basically all shocking events around it. Occasionally the ped may comment or gesture, but other than that they just continue their daily activities. This includes shooting and wounding the ped. And - most importantly - they do not flee.
		/// Since it is a task, every time the native is called the ped will stop for a moment.
		/// </summary>
		void TaskSetBlockingOfNonTemporaryEvents(int ped, bool toggle);
		/// <summary>
		/// [30/03/2017] ins1de :
		/// See FORCE_PED_MOTION_STATE
		/// </summary>
		/// <param name="p2">always false</param>
		void TaskForceMotionState(int ped, int state, bool p2);
		/// <summary>
		/// Example:
		/// </summary>
		/// <param name="task">:TASK_MOVE_NETWORK_BY_NAME(PLAYER::PLAYER_PED_ID(), "arm_wrestling_sweep_paired_a_rev3", 0.0f, true, "mini@arm_wrestling", 0);</param>
		void TaskMoveNetworkByName(int ped, string task, float multiplier, bool p3, string animDict, int flags);
		/// <summary>
		/// Example:
		/// TASK::TASK_MOVE_NETWORK_ADVANCED_BY_NAME(PLAYER::PLAYER_PED_ID(), "minigame_tattoo_michael_parts", 324.13f, 181.29f, 102.6f, 0.0f, 0.0f, 22.32f, 2, 0, false, 0, 0);
		/// </summary>
		void TaskMoveNetworkAdvancedByName(int ped, string p1, float p2, float p3, float p4, float p5, float p6, float p7, int p8, float p9, bool p10, string animDict, int flags);
		/// <summary>
		/// Used only once in the scripts (am_mp_nightclub)
		/// </summary>
		void TaskMoveNetworkByNameWithInitParams(int ped, string p1, ref int data, float p3, bool p4, string animDict, int flags);
		void _0x29682E2CCF21E9B5(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8, int p9, int p10, int p11, int p12, int p13);
		bool IsTaskMoveNetworkActive(int ped);
		bool IsTaskMoveNetworkReadyForTransition(int ped);
		bool RequestTaskMoveNetworkStateTransition(int ped, string name);
		/// <summary>
		/// Used only once in the scripts (fm_mission_controller) like so:
		/// TASK::_0xAB13A5565480B6D9(iLocal_3160, "Cutting");
		/// SET_*
		/// </summary>
		int _0xAB13A5565480B6D9(int ped, string p1);
		string GetTaskMoveNetworkState(int ped);
		void _0x8423541E8B3A1589(int p0, int p1, int p2);
		/// <summary>
		/// -LcGamingHD
		/// Example: TASK::_D5BB4025AE449A4E(PLAYER::PLAYER_PED_ID(), "Phase", 0.5);
		/// </summary>
		/// <param name="ped">- PLAYER::PLAYER_PED_ID();</param>
		/// <param name="signalName">- "Phase", "Wobble", "x_axis","y_axis","introphase","speed".</param>
		/// <param name="value">- From what i can see it goes up to 1f (maybe).</param>
		void SetTaskMoveNetworkSignalFloat(int ped, string signalName, float value);
		void SetTaskMoveNetworkSignalFloat2(int ped, string signalName, float value);
		void _0x8634CEF2522D987B(int ped, string p1, float value);
		void SetTaskMoveNetworkSignalBool(int ped, string signalName, bool value);
		float GetTaskMoveNetworkSignalFloat(int ped, string signalName);
		bool GetTaskMoveNetworkSignalBool(int ped, string signalName);
		bool GetTaskMoveNetworkEvent(int ped, string eventName);
		/// <summary>
		/// </summary>
		/// <returns>Doesn't actually return anything.</returns>
		int _0x0FFB3C758E8C07B9(int ped, bool p1);
		bool IsMoveBlendRatioStill(int ped);
		bool IsMoveBlendRatioWalking(int ped);
		bool IsMoveBlendRatioRunning(int ped);
		bool IsMoveBlendRatioSprinting(int ped);
		bool IsPedStill(int ped);
		bool IsPedWalking(int ped);
		bool IsPedRunning(int ped);
		bool IsPedSprinting(int ped);
		/// <summary>
		/// What's strafing?
		/// </summary>
		bool IsPedStrafing(int ped);
		/// <summary>
		/// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
		/// </summary>
		void TaskSynchronizedScene(int ped, int scene, string animDictionary, string animationName, float speed, float speedMultiplier, int duration, int flag, float playbackRate, int p9);
		void TaskAgitatedAction(int ped, int ped2);
		/// <summary>
		/// This function is called on peds in vehicles.
		/// </summary>
		/// <param name="anim">animation name</param>
		/// <param name="p2">"sweep_low", "sweep_med" or "sweep_high"</param>
		/// <param name="p3">"sweep_low", "sweep_med" or "sweep_high"</param>
		/// <param name="p5">no idea what it does but is usually -1</param>
		void TaskSweepAimEntity(int ped, string anim, string p2, string p3, string p4, int p5, int vehicle, float p7, float p8);
		void UpdateTaskSweepAimEntity(int ped, int entity);
		/// <summary>
		/// </summary>
		void TaskSweepAimPosition(int p0, ref int p1, ref int p2, ref int p3, ref int p4, int p5, float p6, float p7, float p8, float p9, float p10);
		void UpdateTaskSweepAimPosition(int p0, float p1, float p2, float p3);
		/// <summary>
		/// Example from "me_amanda1.ysc.c4":
		/// TASK::TASK_ARREST_PED(l_19F  This is a Ped  , PLAYER::PLAYER_PED_ID());
		/// Example from "armenian1.ysc.c4":
		/// if (!PED::IS_PED_INJURED(l_B18[01])) {
		/// TASK::TASK_ARREST_PED(l_B18[01], PLAYER::PLAYER_PED_ID());
		/// }
		/// I would love to have time to experiment to see if a player Ped can arrest another Ped. Might make for a good cop mod.
		/// Looks like only the player can be arrested this way. Peds react and try to arrest you if you task them, but the player charater doesn't do anything if tasked to arrest another ped.
		/// </summary>
		void TaskArrestPed(int ped, int target);
		bool IsPedRunningArrestTask(int ped);
		/// <summary>
		/// </summary>
		/// <returns>This function is hard-coded to always return 0.</returns>
		bool IsPedBeingArrested(int ped);
		void UncuffPed(int ped);
		bool IsPedCuffed(int ped);
		/// <summary>
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		/// <param name="p7">when set to true allows you to spawn vehicles under -100 z.</param>
		int CreateVehicle(int modelHash, float x, float y, float z, float heading, bool isNetwork, bool bScriptHostVeh, bool p7);
		/// <summary>
		/// Deletes a vehicle.
		/// eg how to use:
		/// SET_ENTITY_AS_MISSION_ENTITY(vehicle, true, true);
		/// DELETE_VEHICLE(&vehicle);
		/// Deletes the specified vehicle, then sets the handle pointed to by the pointer to NULL.
		/// </summary>
		/// <param name="vehicle">SET_ENTITY_AS_MISSION_ENTITY(vehicle, true, true);</param>
		void DeleteVehicle(ref int vehicle);
		/// <summary>
		/// SET_VEHICLE_AL*
		/// </summary>
		void _0x7D6F9A3EF26136A0(int vehicle, bool toggle, bool p2);
		/// <summary>
		/// SET_VEHICLE_AL*
		/// </summary>
		void SetVehicleCanBeLockedOn(int vehicle, bool canBeLockedOn, bool unk);
		/// <summary>
		/// Makes the vehicle accept no passengers.
		/// </summary>
		void SetVehicleAllowNoPassengersLockon(int veh, bool toggle);
		/// <summary>
		/// Returns a value depending on the lock-on state of vehicle weapons.
		/// 0: not locked on
		/// 1: locking on
		/// 2: locked on
		/// </summary>
		int GetVehicleHomingLockonState(int vehicle);
		int _0x6EAAEFC76ACC311F(int p0);
		void _0x407DC5E97DB1A4D3(int p0, int p1);
		bool IsVehicleModel(int vehicle, int model);
		bool DoesScriptVehicleGeneratorExist(int vehicleGenerator);
		/// <summary>
		/// Creates a script vehicle generator at the given coordinates. Most parameters after the model hash are unknown.
		/// Parameters:
		/// </summary>
		/// <param name="x">Generator position</param>
		/// <param name="y">Generator position</param>
		/// <param name="z">GET_ENTITY_COORDS(PLAYER_PED_ID(), 0);    CREATE_SCRIPT_VEHICLE_GENERATOR(coords.x, coords.y, coords.z, 1.0f, 5.0f, 3.0f, GET_HASH_KEY("adder"), -1. -1, -1, -1, -1, true, false, false, false, true, -1);</param>
		/// <param name="heading">- Generator heading</param>
		/// <param name="p4">- Unknown (always 5.0)</param>
		/// <param name="p5">- Unknown (always 3.0)</param>
		/// <param name="modelHash">- Vehicle model hash</param>
		/// <param name="p7">Unknown (always</param>
		/// <param name="p11">- Unknown (usually TRUE, only one instance of FALSE)</param>
		/// <param name="p12">Unknown (always FALSE)</param>
		/// <param name="p14">- Unknown (usally FALSE, only two instances of TRUE)</param>
		/// <param name="p15">- Unknown (always TRUE)</param>
		/// <param name="p16">- Unknown (always -1)</param>
		int CreateScriptVehicleGenerator(float x, float y, float z, float heading, float p4, float p5, int modelHash, int p7, int p8, int p9, int p10, bool p11, bool p12, bool p13, bool p14, bool p15, int p16);
		void DeleteScriptVehicleGenerator(int vehicleGenerator);
		/// <summary>
		/// Only called once in the decompiled scripts. Presumably activates the specified generator.
		/// </summary>
		void SetScriptVehicleGenerator(int vehicleGenerator, bool enabled);
		void SetAllVehicleGeneratorsActiveInArea(float x1, float y1, float z1, float x2, float y2, float z2, bool p6, bool p7);
		void SetAllVehicleGeneratorsActive();
		void SetAllLowPriorityVehicleGeneratorsActive(bool active);
		/// <summary>
		/// Related to car generators & CPlayerSwitchMgrLong
		/// SET_VEHICLE_*
		/// SET_VEHICLE_GENERATORS_EXPECTED_GAMEPLAY_PT ?
		/// </summary>
		void _0x9A75585FB2E54FAD(float x, float y, float z, float radius);
		/// <summary>
		/// CLEAR_VEHICLE_*
		/// </summary>
		void _0x0A436B8643716D14();
		/// <summary>
		/// </summary>
		/// <param name="vehicle">This has an additional param(Vehicle vehicle, float p1) which is always set to 5.0f in the b944 scripts.</param>
		/// <returns>Sets a vehicle on the ground on all wheels.  Returns whether or not the operation was successful.</returns>
		bool SetVehicleOnGroundProperly(int vehicle, float p1);
		int SetVehicleUseCutsceneWheelCompression(int p0, bool p1, bool p2, bool p3);
		bool IsVehicleStuckOnRoof(int vehicle);
		void AddVehicleUpsidedownCheck(int vehicle);
		void RemoveVehicleUpsidedownCheck(int vehicle);
		/// <summary>
		/// Returns true if the vehicle's current speed is less than, or equal to 0.0025f.
		/// </summary>
		/// <returns>For some vehicles it returns true if the current speed is <= 0.00039999999.</returns>
		bool IsVehicleStopped(int vehicle);
		/// <summary>
		/// </summary>
		/// <param name="vehicle">1) to also check for the driver</param>
		int GetVehicleNumberOfPassengers(int vehicle);
		int GetVehicleMaxNumberOfPassengers(int vehicle);
		/// <summary>
		/// Returns max number of passengers (including the driver) for the specified vehicle model.
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		int GetVehicleModelNumberOfSeats(int modelHash);
		bool IsSeatWarpOnly(int vehicle, int seatIndex);
		bool IsTurretSeat(int vehicle, int seatIndex);
		/// <summary>
		/// Returns true if the vehicle has the FLAG_ALLOWS_RAPPEL flag set.
		/// </summary>
		bool DoesVehicleAllowRappel(int vehicle);
		/// <summary>
		/// Use this native inside a looped function.
		/// Values:
		/// - `0.0` = no vehicles on streets
		/// - `1.0` = normal vehicles on streets
		/// </summary>
		void SetVehicleDensityMultiplierThisFrame(float multiplier);
		void SetRandomVehicleDensityMultiplierThisFrame(float multiplier);
		void SetParkedVehicleDensityMultiplierThisFrame(float multiplier);
		void SetDisableRandomTrainsThisFrame(bool toggle);
		void SetAmbientVehicleRangeMultiplierThisFrame(float value);
		void SetFarDrawVehicles(bool toggle);
		void SetNumberOfParkedVehicles(int value);
		/// <summary>
		/// 0 - CARLOCK_NONE
		/// 1 - CARLOCK_UNLOCKED
		/// 2 - CARLOCK_LOCKED (locked)
		/// 3 - CARLOCK_LOCKOUT_PLAYER_ONLY
		/// 4 - CARLOCK_LOCKED_PLAYER_INSIDE (can get in, can't leave)
		/// (maybe, these are leftovers from GTA:VC)
		/// 5 - CARLOCK_LOCKED_INITIALLY
		/// 6 - CARLOCK_FORCE_SHUT_DOORS
		/// 7 - CARLOCK_LOCKED_BUT_CAN_BE_DAMAGED
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB664292EAECF7FA6
		/// </summary>
		void SetVehicleDoorsLocked(int vehicle, int doorLockStatus);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		void SetVehicleIndividualDoorsLocked(int vehicle, int doorId, int doorLockStatus);
		/// <summary>
		/// if set to true, prevents vehicle sirens from having sound, leaving only the lights.
		/// </summary>
		void SetVehicleHasMutedSirens(int vehicle, bool toggle);
		void SetVehicleDoorsLockedForPlayer(int vehicle, int player, bool toggle);
		bool GetVehicleDoorsLockedForPlayer(int vehicle, int player);
		/// <summary>
		/// After some analysis, I've decided that these are what the parameters are.
		/// We can see this being used in R* scripts such as "am_mp_property_int.ysc.c4":
		/// l_11A1 = PED::GET_VEHICLE_PED_IS_IN(PLAYER::PLAYER_PED_ID(), 1);
		/// ...
		/// </summary>
		/// <param name="vehicle">:SET_VEHICLE_DOORS_LOCKED_FOR_ALL_PLAYERS(l_11A1, 1);</param>
		void SetVehicleDoorsLockedForAllPlayers(int vehicle, bool toggle);
		void SetVehicleDoorsLockedForNonScriptPlayers(int vehicle, bool toggle);
		void SetVehicleDoorsLockedForTeam(int vehicle, int team, bool toggle);
		void SetVehicleDoorsLockedForUnk(int vehicle, bool toggle);
		/// <summary>
		/// SET_VEHICLE_*
		/// </summary>
		void _0x76D26A22750E849E(int vehicle);
		/// <summary>
		/// Explodes a selected vehicle.
		/// BOOL isAudible = If explosion makes a sound.
		/// BOOL isInvisible = If the explosion is invisible or not.
		/// First BOOL does not give any visual explosion, the vehicle just falls apart completely but slowly and starts to burn.
		/// </summary>
		/// <param name="vehicle">vehicle = Vehicle you want to explode.</param>
		void ExplodeVehicle(int vehicle, bool isAudible, bool isInvisible);
		/// <summary>
		/// Tested on the player's current vehicle. Unless you kill the driver, the vehicle doesn't loose control, however, if enabled, explodeOnImpact is still active. The moment you crash, boom.
		/// </summary>
		void SetVehicleOutOfControl(int vehicle, bool killDriver, bool explodeOnImpact);
		void SetVehicleTimedExplosion(int vehicle, int ped, bool toggle);
		void AddVehiclePhoneExplosiveDevice(int vehicle);
		void ClearVehiclePhoneExplosiveDevice();
		bool HasVehiclePhoneExplosiveDevice();
		void DetonateVehiclePhoneExplosiveDevice();
		/// <summary>
		/// This is not tested - it's just an assumption.
		/// - Nac
		/// Doesn't seem to work.  I'll try with an int instead. --JT
		/// Read the scripts, im dumpass.
		/// if (!VEHICLE::IS_TAXI_LIGHT_ON(l_115)) {
		/// VEHICLE::SET_TAXI_LIGHTS(l_115, 1);
		/// }
		/// </summary>
		void SetTaxiLights(int vehicle, bool state);
		bool IsTaxiLightOn(int vehicle);
		/// <summary>
		/// Full list of garages by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/garages.json
		/// </summary>
		/// <param name="garageName">example "Michael - Beverly Hills"</param>
		bool IsVehicleInGarageArea(string garageName, int vehicle);
		/// <summary>
		/// For a list of valid paint indexes, view: pastebin.com/pwHci0xK
		/// -------------------------------------------------------------------------
		/// Use this to get the number of color indices: pastebin.com/RQEeqTSM
		/// Note: minimum color index is 0, maximum color index is (numColorIndices - 1)
		/// Full list of vehicle colors by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicleColors.json
		/// </summary>
		/// <param name="colorPrimary">& colorSecondary are the paint index for the vehicle.</param>
		void SetVehicleColours(int vehicle, int colorPrimary, int colorSecondary);
		/// <summary>
		/// It switch to highbeam when p1 is set to true.
		/// </summary>
		void SetVehicleFullbeam(int vehicle, bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="toggle">(toggle) was always 1 (true) except in one case in the b678 scripts.</param>
		void SetVehicleIsRacing(int vehicle, bool toggle);
		/// <summary>
		/// p1, p2, p3 are RGB values for color (255,0,0 for Red, ect)
		/// </summary>
		void SetVehicleCustomPrimaryColour(int vehicle, int r, int g, int b);
		/// <summary>
		/// </summary>
		void GetVehicleCustomPrimaryColour(int vehicle, ref int r, ref int g, ref int b);
		void ClearVehicleCustomPrimaryColour(int vehicle);
		bool GetIsVehiclePrimaryColourCustom(int vehicle);
		/// <summary>
		/// p1, p2, p3 are RGB values for color (255,0,0 for Red, ect)
		/// </summary>
		void SetVehicleCustomSecondaryColour(int vehicle, int r, int g, int b);
		/// <summary>
		/// </summary>
		void GetVehicleCustomSecondaryColour(int vehicle, ref int r, ref int g, ref int b);
		void ClearVehicleCustomSecondaryColour(int vehicle);
		/// <summary>
		/// Check if Vehicle Secondary is avaliable for customize
		/// </summary>
		bool GetIsVehicleSecondaryColourCustom(int vehicle);
		/// <summary>
		/// formerly known as _SET_VEHICLE_PAINT_FADE
		/// The parameter fade is a value from 0-1, where 0 is fresh paint.
		/// </summary>
		void SetVehicleEnveffScale(int vehicle, float fade);
		/// <summary>
		/// formerly known as _GET_VEHICLE_PAINT_FADE
		/// The result is a value from 0-1, where 0 is fresh paint.
		/// </summary>
		float GetVehicleEnveffScale(int vehicle);
		/// <summary>
		/// Hardcoded to not work in multiplayer.
		/// </summary>
		void SetCanResprayVehicle(int vehicle, bool state);
		void _0xAB31EF4DE6800CE9(int p0, int p1);
		/// <summary>
		/// Sets a value that appears to affect door opening behavior when damaged.
		/// SET_*
		/// </summary>
		void _0x1B212B26DD3C04DF(int vehicle, bool toggle);
		void ForceSubmarineSurfaceMode(int vehicle, bool toggle);
		void _0xC67DB108A9ADE3BE(int p0, int p1);
		void SetSubmarineCrushDepths(int vehicle, bool p1, float depth1, float depth2, float depth3);
		bool GetSubmarineIsBelowFirstCrushDepth(int submarine);
		int GetSubmarineCrushDepthWarningState(int submarine);
		void _0xED5EDE9E676643C9(int p0, int p1);
		void SetBoatAnchor(int vehicle, bool toggle);
		bool CanAnchorBoatHere(int vehicle);
		bool CanAnchorBoatHere2(int vehicle);
		void SetBoatFrozenWhenAnchored(int vehicle, bool toggle);
		/// <summary>
		/// No observed effect.
		/// </summary>
		void _0xB28B1FE5BFADD7F5(int vehicle, bool p1);
		void SetBoatMovementResistance(int vehicle, float value);
		/// <summary>
		/// IS_*
		/// </summary>
		bool IsBoatAnchoredAndFrozen(int vehicle);
		void SetBoatSinksWhenWrecked(int vehicle, bool toggle);
		void SetBoatIsSinking(int p0);
		/// <summary>
		/// Activate siren on vehicle (Only works if the vehicle has a siren).
		/// </summary>
		void SetVehicleSiren(int vehicle, bool toggle);
		bool IsVehicleSirenOn(int vehicle);
		bool IsVehicleSirenAudioOn(int vehicle);
		/// <summary>
		/// If set to true, vehicle will not take crash damage, but is still susceptible to damage from bullets and explosives
		/// </summary>
		void SetVehicleStrong(int vehicle, bool toggle);
		void RemoveVehicleStuckCheck(int vehicle);
		/// <summary>
		/// </summary>
		void GetVehicleColours(int vehicle, ref int colorPrimary, ref int colorSecondary);
		/// <summary>
		/// Check if a vehicle seat is free.
		/// Use GET_VEHICLE_MAX_NUMBER_OF_PASSENGERS(vehicle) - 1 for last seat index.
		/// </summary>
		/// <param name="vehicle">on true the function returns already false while a task on the target seat is running (TASK_ENTER_VEHICLE/TASK_SHUFFLE_TO_NEXT_VEHICLE_SEAT) - on false only when a ped is finally sitting in the seat.</param>
		/// <param name="seatIndex">= -1 being the driver seat.</param>
		/// <param name="isTaskRunning">= on true the function returns already false while a task on the target seat is running (TASK_ENTER_VEHICLE/TASK_SHUFFLE_TO_NEXT_VEHICLE_SEAT) - on false only when a ped is finally sitting in the seat.</param>
		/// <returns>isTaskRunning = on true the function returns already false while a task on the target seat is running (TASK_ENTER_VEHICLE/TASK_SHUFFLE_TO_NEXT_VEHICLE_SEAT) - on false only when a ped is finally sitting in the seat.</returns>
		bool IsVehicleSeatFree(int vehicle, int seatIndex, bool isTaskRunning);
		/// <summary>
		/// If there is no ped in the seat, and the game considers the vehicle as ambient population, this will create a random occupant ped in the seat, which may be cleaned up by the game fairly soon if not marked as script-owned mission entity.
		/// Seat indexes:
		/// -1 = Driver
		/// 0 = Front Right Passenger
		/// 1 = Back Left Passenger
		/// 2 = Back Right Passenger
		/// 3 = Further Back Left Passenger (vehicles > 4 seats)
		/// 4 = Further Back Right Passenger (vehicles > 4 seats)
		/// etc.
		/// If p2 is true it uses a different GetOccupant function.
		/// </summary>
		int GetPedInVehicleSeat(int vehicle, int seatIndex, bool p2);
		int GetLastPedInVehicleSeat(int vehicle, int seatIndex);
		/// <summary>
		/// </summary>
		bool GetVehicleLightsState(int vehicle, ref bool lightsOn, ref bool highbeamsOn);
		/// <summary>
		/// '0 = wheel_lf / bike, plane or jet front
		/// '1 = wheel_rf
		/// '2 = wheel_lm / in 6 wheels trailer, plane or jet is first one on left
		/// '3 = wheel_rm / in 6 wheels trailer, plane or jet is first one on right
		/// '4 = wheel_lr / bike rear / in 6 wheels trailer, plane or jet is last one on left
		/// '5 = wheel_rr / in 6 wheels trailer, plane or jet is last one on right
		/// '45 = 6 wheels trailer mid wheel left
		/// '47 = 6 wheels trailer mid wheel right
		/// </summary>
		/// <param name="wheelID">used for 4 wheelers seem to be (0, 1, 4, 5)</param>
		/// <param name="completely">- is to check if tire completely gone from rim.</param>
		bool IsVehicleTyreBurst(int vehicle, int wheelID, bool completely);
		/// <summary>
		/// SCALE: Setting the speed to 30 would result in a speed of roughly 60mph, according to speedometer.
		/// You can convert meters/s to mph here:
		/// http://www.calculateme.com/Speed/MetersperSecond/ToMilesperHour.htm
		/// </summary>
		/// <param name="speed">is in meters per second</param>
		void SetVehicleForwardSpeed(int vehicle, float speed);
		void _0x6501129C9E0FFA05(int p0, int p1);
		/// <summary>
		/// This native makes the vehicle stop immediately, as happens when we enter a MP garage.
		/// . distance defines how far it will travel until stopping. Garage doors use 3.0.
		/// . If killEngine is set to 1, you cannot resume driving the vehicle once it stops. This looks like is a bitmapped integer.
		/// </summary>
		void BringVehicleToHalt(int vehicle, float distance, int duration, bool unknown);
		void _0xDCE97BDF8A0EABC8(int vehicle, int p1);
		/// <summary>
		/// Sets some bit of vehicle.
		/// _SET_VEHICLE_*
		/// </summary>
		void _0x9849DE24FCF23CCC(int vehicle, bool toggle);
		void _0x8664170EF165C4A6(int p0, int p1);
		/// <summary>
		/// Stops CTaskBringVehicleToHalt
		/// </summary>
		void StopBringVehicleToHalt(int vehicle);
		/// <summary>
		/// Returns true if vehicle is halted by BRING_VEHICLE_TO_HALT
		/// _IS_VEHICLE_*
		/// </summary>
		bool IsVehicleBeingHalted(int vehicle);
		/// <summary>
		/// 0.0 = Lowest 1.0 = Highest. This is best to be used if you wanna pick-up a car since un-realistically on GTA V forklifts can't pick up much of anything due to vehicle mass. If you put this under a car then set it above 0.0 to a 'lifted-value' it will raise the car with no issue lol
		/// </summary>
		void SetForkliftForkHeight(int vehicle, float height);
		bool IsEntityAttachedToHandlerFrame(int vehicle, int entity);
		bool IsAnyEntityAttachedToHandlerFrame(int vehicle);
		/// <summary>
		/// Finds the vehicle that is carrying this entity with a handler frame.
		/// </summary>
		/// <returns>The model of the entity must be prop_contr_03b_ld or the function will return 0.</returns>
		int FindVehicleCarryingThisEntity(int entity);
		bool IsHandlerFrameAboveContainer(int vehicle, int entity);
		void _0x6A98C2ECF57FA5D4(int vehicle, int entity);
		void DetachContainerFromHandlerFrame(int vehicle);
		void _0x8AA9180DE2FEDD45(int vehicle, bool p1);
		void SetBoatDisableAvoidance(int vehicle, bool p1);
		bool IsHeliLandingAreaBlocked(int vehicle);
		/// <summary>
		/// Used on helicopters and blimps during the CTaskVehicleLand task. Sets a value on the task to 10f
		/// </summary>
		void _0x107A473D7A6647A9(int vehicle);
		void SetHeliTurbulenceScalar(int vehicle, float p1);
		/// <summary>
		/// Initially used in Max Payne 3, that's why we know the name.
		/// </summary>
		void SetCarBootOpen(int vehicle);
		/// <summary>
		/// to burst all tyres type it 8 times where p1 = 0 to 7.
		/// '0 = wheel_lf / bike, plane or jet front
		/// '1 = wheel_rf
		/// '2 = wheel_lm / in 6 wheels trailer, plane or jet is first one on left
		/// '3 = wheel_rm / in 6 wheels trailer, plane or jet is first one on right
		/// '4 = wheel_lr / bike rear / in 6 wheels trailer, plane or jet is last one on left
		/// '5 = wheel_rr / in 6 wheels trailer, plane or jet is last one on right
		/// '45 = 6 wheels trailer mid wheel left
		/// '47 = 6 wheels trailer mid wheel right
		/// </summary>
		/// <param name="p3">seems to be how much damage it has taken. 0 doesn't deflate them, 1000 completely deflates them.</param>
		void SetVehicleTyreBurst(int vehicle, int index, bool onRim, float p3);
		/// <summary>
		/// Closes all doors of a vehicle:
		/// </summary>
		void SetVehicleDoorsShut(int vehicle, bool closeInstantly);
		/// <summary>
		/// Allows you to toggle bulletproof tires.
		/// </summary>
		void SetVehicleTyresCanBurst(int vehicle, bool toggle);
		bool GetVehicleTyresCanBurst(int vehicle);
		void SetVehicleWheelsCanBreak(int vehicle, bool enabled);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		void SetVehicleDoorOpen(int vehicle, int doorId, bool loose, bool openInstantly);
		/// <summary>
		/// Usually used alongside other vehicle door natives.
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		void _0x3B458DDB57038F08(int vehicle, int doorId, bool toggle);
		void _0xA247F9EF01D8082E(int p0);
		/// <summary>
		/// 0 = Front Right Window
		/// 1 = Front Left Window
		/// 2 = Back Right Window
		/// 3 = Back Left Window
		/// 4 = Unknown
		/// 5 = Unknown
		/// 6 = Windscreen
		/// 7 = Rear Windscreen
		/// </summary>
		void RemoveVehicleWindow(int vehicle, int windowIndex);
		/// <summary>
		/// Roll down all the windows of the vehicle passed through the first parameter.
		/// </summary>
		void RollDownWindows(int vehicle);
		/// <summary>
		/// 0 = Front Right Window
		/// 1 = Front Left Window
		/// 2 = Back Right Window
		/// 3 = Back Left Window
		/// </summary>
		void RollDownWindow(int vehicle, int windowIndex);
		/// <summary>
		/// Window indexes:
		/// 0 = Front Left Window
		/// 1 = Front Right Window
		/// 2 = Back Left Window
		/// 3 = Back Right Window
		/// </summary>
		void RollUpWindow(int vehicle, int windowIndex);
		/// <summary>
		/// `index` = 0 to 13
		/// 0 = front right window
		/// 1 = front left window
		/// 2 = rear right window
		/// 3 = rear left window
		/// 4 = unsure
		/// 5 = unsure
		/// 6 = windowscreen
		/// 7 = rear windowscreen
		/// See NativeDB for reference: http://natives.altv.mp/#/0x9E5B5E4D2CCD2259
		/// </summary>
		void SmashVehicleWindow(int vehicle, int index);
		/// <summary>
		/// `index` = 0 to 13
		/// 0 = front right window
		/// 1 = front left window
		/// 2 = rear right window
		/// 3 = rear left window
		/// 4 = unsure
		/// 5 = unsure
		/// 6 = windowscreen
		/// 7 = rear windowscreen
		/// See NativeDB for reference: http://natives.altv.mp/#/0x772282EBEB95E682
		/// </summary>
		void FixVehicleWindow(int vehicle, int index);
		/// <summary>
		/// Detaches the vehicle's windscreen.
		/// For further information, see : gtaforums.com/topic/859570-glass/#entry1068894566
		/// </summary>
		void PopOutVehicleWindscreen(int vehicle);
		void EjectJb700Roof(int vehicle, float x, float y, float z);
		/// <summary>
		/// set's if the vehicle has lights or not.
		/// not an on off toggle.
		/// p1 = 1 ;vehicle doesn't have lights, always off
		/// p1 = 2 ;vehicle has always on lights
		/// p1 = 3 ;or even larger like 4,5,... normal lights like =1
		/// note1: when using =2 on day it's lowbeam,highbeam
		/// but at night it's lowbeam,lowbeam,highbeam
		/// note2: when using =0 it's affected by day or night for highbeams don't exist in daytime.
		/// </summary>
		/// <param name="state">= 0 ;vehicle normal lights, off then lowbeams, then highbeams</param>
		void SetVehicleLights(int vehicle, int state);
		void SetVehicleUsePlayerLightSettings(int vehicle, bool toggle);
		/// <summary>
		/// Determines how vehicle lights behave when toggled.
		/// 0 = Default (Lights can be toggled between off, normal and high beams)
		/// 1 = Lights Disabled (Lights are fully disabled, cannot be toggled)
		/// 2 = Always On (Lights can be toggled between normal and high beams)
		/// </summary>
		/// <param name="p1">can be either 0, 1 or 2.</param>
		void SetVehicleLightsMode(int vehicle, int p1);
		void SetVehicleAlarm(int vehicle, bool state);
		void StartVehicleAlarm(int vehicle);
		bool IsVehicleAlarmActivated(int vehicle);
		void SetVehicleInteriorlight(int vehicle, bool toggle);
		/// <summary>
		/// Sets some bit of vehicle
		/// _SET_VEHICLE_*
		/// </summary>
		void _0x8821196D91FA2DE5(int vehicle, bool toggle);
		/// <summary>
		/// this value isn't capped afaik.
		/// multiplier = 0.0 no lights
		/// multiplier = 1.0 default game value
		/// </summary>
		/// <param name="multiplier">= brightness of head lights.</param>
		void SetVehicleLightMultiplier(int vehicle, float multiplier);
		void AttachVehicleToTrailer(int vehicle, int trailer, float radius);
		/// <summary>
		/// This is the proper way of attaching vehicles to the car carrier, it's what Rockstar uses. Video Demo: https://www.youtube.com/watch?v=2lVEIzf7bgo
		/// </summary>
		void AttachVehicleOnToTrailer(int vehicle, int trailer, float offsetX, float offsetY, float offsetZ, float coordsX, float coordsY, float coordsZ, float rotationX, float rotationY, float rotationZ, float disableCollisions);
		void StabiliseEntityAttachedToHeli(int vehicle, int entity, float p2);
		void DetachVehicleFromTrailer(int vehicle);
		bool IsVehicleAttachedToTrailer(int vehicle);
		void SetTrailerInverseMassScale(int vehicle, float p1);
		/// <summary>
		/// in the decompiled scripts, seems to be always called on the vehicle right after being attached to a trailer.
		/// </summary>
		void SetTrailerLegsRaised(int vehicle);
		void SetTrailerLegsLowered(int p0);
		/// <summary>
		/// '0 = wheel_lf / bike, plane or jet front
		/// '1 = wheel_rf
		/// '2 = wheel_lm / in 6 wheels trailer, plane or jet is first one on left
		/// '3 = wheel_rm / in 6 wheels trailer, plane or jet is first one on right
		/// '4 = wheel_lr / bike rear / in 6 wheels trailer, plane or jet is last one on left
		/// '5 = wheel_rr / in 6 wheels trailer, plane or jet is last one on right
		/// '45 = 6 wheels trailer mid wheel left
		/// '47 = 6 wheels trailer mid wheel right
		/// </summary>
		/// <param name="tyreIndex">= 0 to 4 on normal vehicles</param>
		void SetVehicleTyreFixed(int vehicle, int tyreIndex);
		/// <summary>
		/// Sets a vehicle's license plate text.  8 chars maximum.
		/// Example:
		/// Ped playerPed = PLAYER::PLAYER_PED_ID();
		/// char *plateText = "KING";
		/// VEHICLE::SET_VEHICLE_NUMBER_PLATE_TEXT(veh, plateText);
		/// </summary>
		/// <param name="vehicle">veh = PED::GET_VEHICLE_PED_IS_USING(playerPed);</param>
		void SetVehicleNumberPlateText(int vehicle, string plateText);
		/// <summary>
		/// Returns the license plate text from a vehicle.  8 chars maximum.
		/// </summary>
		string GetVehicleNumberPlateText(int vehicle);
		/// <summary>
		/// Returns the number of *types* of licence plates, enumerated below in SET_VEHICLE_NUMBER_PLATE_TEXT_INDEX.
		/// </summary>
		int GetNumberOfVehicleNumberPlates();
		/// <summary>
		/// Plates:
		/// Blue/White - 0
		/// Yellow/black - 1
		/// Yellow/Blue - 2
		/// Blue/White2 - 3
		/// Blue/White3 - 4
		/// Yankton - 5
		/// </summary>
		void SetVehicleNumberPlateTextIndex(int vehicle, int plateIndex);
		/// <summary>
		/// Returns the PlateType of a vehicle
		/// Blue_on_White_1 = 3,
		/// Blue_on_White_2 = 0,
		/// Blue_on_White_3 = 4,
		/// Yellow_on_Blue = 2,
		/// Yellow_on_Black = 1,
		/// North_Yankton = 5,
		/// </summary>
		int GetVehicleNumberPlateTextIndex(int vehicle);
		void SetRandomTrains(bool toggle);
		/// <summary>
		/// Train models HAVE TO be loaded (requested) before you use this.
		/// For variation 15 - request:
		/// freight
		/// freightcar
		/// freightgrain
		/// freightcont1
		/// freightcont2
		/// freighttrailer
		/// </summary>
		int CreateMissionTrain(int unkVariation, float x, float y, float z, bool direction, int p5, int p6);
		/// <summary>
		/// Toggles whether ambient trains can spawn on the specified track or not
		/// `trackId` is the internal id of the train track to switch.
		/// `state` is whether ambient trains can spawn or not
		/// trackIds
		/// 0 (`trains1.dat`) Main track around SA
		/// 1 (`trains2.dat`) Davis Quartz Quarry branch
		/// 2 (`trains3.dat`) Second track alongside live track along Roy Lewenstein Blv.
		/// 3 (`trains4.dat`) Metro track circuit
		/// 4 (`trains5.dat`) Branch in Mirror Park Railyard
		/// See NativeDB for reference: http://natives.altv.mp/#/0xFD813BB7DB977F20
		/// </summary>
		void SwitchTrainTrack(int trackId, bool state);
		/// <summary>
		/// Only called once inside main_persitant with the parameters p0 = 0, p1 = 120000
		/// </summary>
		/// <param name="trackIndex">0 - 26</param>
		void SetTrainTrackSpawnFrequency(int trackIndex, int frequency);
		void _0x2310A8F9421EBF43(int p0);
		void DeleteAllTrains();
		void SetTrainSpeed(int train, float speed);
		void SetTrainCruiseSpeed(int train, float speed);
		void SetRandomBoats(bool toggle);
		void SetRandomBoatsInMp(bool toggle);
		void SetGarbageTrucks(bool toggle);
		/// <summary>
		/// Maximum amount of vehicles with vehicle stuck check appears to be 16.
		/// </summary>
		bool DoesVehicleHaveStuckVehicleCheck(int vehicle);
		/// <summary>
		/// See REQUEST_VEHICLE_RECORDING
		/// </summary>
		int GetVehicleRecordingId(int recording, string script);
		/// <summary>
		/// Request the vehicle recording defined by the lowercase format string "%s%03d.yvr". For example, REQUEST_VEHICLE_RECORDING(1, "FBIs1UBER") corresponds to fbis1uber001.yvr.
		/// For all vehicle recording/playback natives, "script" is a common prefix that usually corresponds to the script/mission the recording is used in, "recording" is its int suffix, and "id" (e.g., in native GET_TOTAL_DURATION_OF_VEHICLE_RECORDING_ID) corresponds to a unique identifier within the recording streaming module.
		/// Note that only 24 recordings (hardcoded in multiple places) can ever active at a given time before clobbering begins.
		/// </summary>
		void RequestVehicleRecording(int recording, string script);
		/// <summary>
		/// See REQUEST_VEHICLE_RECORDING
		/// </summary>
		bool HasVehicleRecordingBeenLoaded(int recording, string script);
		/// <summary>
		/// See REQUEST_VEHICLE_RECORDING
		/// </summary>
		void RemoveVehicleRecording(int recording, string script);
		Vector3 GetPositionOfVehicleRecordingIdAtTime(int id, float time);
		/// <summary>
		/// This native does no interpolation between pathpoints. The same position will be returned for all times up to the next pathpoint in the recording.
		/// See REQUEST_VEHICLE_RECORDING
		/// </summary>
		Vector3 GetPositionOfVehicleRecordingAtTime(int recording, float time, string script);
		Vector3 GetRotationOfVehicleRecordingIdAtTime(int id, float time);
		/// <summary>
		/// This native does no interpolation between pathpoints. The same rotation will be returned for all times up to the next pathpoint in the recording.
		/// See REQUEST_VEHICLE_RECORDING
		/// </summary>
		Vector3 GetRotationOfVehicleRecordingAtTime(int recording, float time, string script);
		float GetTotalDurationOfVehicleRecordingId(int id);
		/// <summary>
		/// See REQUEST_VEHICLE_RECORDING
		/// </summary>
		float GetTotalDurationOfVehicleRecording(int recording, string script);
		/// <summary>
		/// Distance traveled in the vehicles current recording.
		/// </summary>
		float GetPositionInRecording(int vehicle);
		/// <summary>
		/// Can be used with GET_TOTAL_DURATION_OF_VEHICLE_RECORDING{_ID} to compute a percentage.
		/// </summary>
		float GetTimePositionInRecording(int vehicle);
		/// <summary>
		/// See REQUEST_VEHICLE_RECORDING
		/// </summary>
		/// <param name="p3">is some flag related to 'trailers' (invokes CVehicle::GetTrailer).</param>
		void StartPlaybackRecordedVehicle(int vehicle, int recording, string script, bool p3);
		/// <summary>
		/// time, often zero and capped at 500, is related to SET_PLAYBACK_TO_USE_AI_TRY_TO_REVERT_BACK_LATER
		/// </summary>
		/// <param name="flags">requires further research, e.g., 0x4/0x8 are related to the AI driving task and 0x20 is internally set and interacts with dynamic entity components.</param>
		void StartPlaybackRecordedVehicleWithFlags(int vehicle, int recording, string script, int flags, int time, int drivingStyle);
		/// <summary>
		/// Often called after START_PLAYBACK_RECORDED_VEHICLE and SKIP_TIME_IN_PLAYBACK_RECORDED_VEHICLE; similar in use to FORCE_ENTITY_AI_AND_ANIMATION_UPDATE.
		/// </summary>
		void ForcePlaybackRecordedVehicleUpdate(int vehicle, bool p1);
		void StopPlaybackRecordedVehicle(int vehicle);
		void PausePlaybackRecordedVehicle(int vehicle);
		void UnpausePlaybackRecordedVehicle(int vehicle);
		bool IsPlaybackGoingOnForVehicle(int vehicle);
		bool IsPlaybackUsingAiGoingOnForVehicle(int vehicle);
		int GetCurrentPlaybackForVehicle(int vehicle);
		void SkipToEndAndStopPlaybackRecordedVehicle(int vehicle);
		void SetPlaybackSpeed(int vehicle, float speed);
		/// <summary>
		/// AI abides by the provided driving style (e.g., stopping at red lights or waiting behind traffic) while executing the specificed vehicle recording.
		/// 0x1F2E4E06DEA8992B is a related native that deals with the AI physics for such recordings.
		/// </summary>
		void StartPlaybackRecordedVehicleUsingAi(int vehicle, int recording, string script, float speed, int drivingStyle);
		/// <summary>
		/// SET_TIME_POSITION_IN_RECORDING can be emulated by: desired_time - GET_TIME_POSITION_IN_RECORDING(vehicle)
		/// </summary>
		void SkipTimeInPlaybackRecordedVehicle(int vehicle, float time);
		/// <summary>
		/// Identical to SET_PLAYBACK_TO_USE_AI_TRY_TO_REVERT_BACK_LATER with 0 as arguments for p1 and p3.
		/// </summary>
		void SetPlaybackToUseAi(int vehicle, int drivingStyle);
		/// <summary>
		/// </summary>
		/// <param name="time">is number of milliseconds before reverting, zero for indefinitely.</param>
		void SetPlaybackToUseAiTryToRevertBackLater(int vehicle, int time, int drivingStyle, bool p3);
		void _0x5845066D8A1EA7F7(int vehicle, float x, float y, float z, int p4);
		void _0x796A877E459B99EA(int p0, float p1, float p2, float p3);
		void _0xFAF2A78061FD9EF4(int p0, float p1, float p2, float p3);
		/// <summary>
		/// A vehicle recording playback flag only used in jewelry_heist
		/// </summary>
		void _0x063AE2B2CC273588(int vehicle, bool p1);
		void ExplodeVehicleInCutscene(int vehicle, bool p1);
		void AddVehicleStuckCheckWithWarp(int p0, float p1, int p2, bool p3, bool p4, bool p5, int p6);
		/// <summary>
		/// seems to make the vehicle stop spawning naturally in traffic. Here's an essential example:
		/// VEHICLE::SET_VEHICLE_MODEL_IS_SUPPRESSED(MISC::GET_HASH_KEY("taco"), true);
		/// god I hate taco vans
		/// Confirmed to work? Needs to be looped? Can not get it to work.
		/// </summary>
		void SetVehicleModelIsSuppressed(int model, bool suppressed);
		/// <summary>
		/// Gets a random vehicle in a sphere at the specified position, of the specified radius.
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		/// <param name="x">The X-component of the position of the sphere.</param>
		/// <param name="y">The Y-component of the position of the sphere.</param>
		/// <param name="z">The Z-component of the position of the sphere.</param>
		/// <param name="radius">The radius of the sphere. Max is 9999.9004.</param>
		/// <param name="modelHash">The vehicle model to limit the selection to. Pass 0 for any model.</param>
		/// <param name="flags">The bitwise flags that modifies the behaviour of this function.</param>
		int GetRandomVehicleInSphere(float x, float y, float z, float radius, int modelHash, int flags);
		int GetRandomVehicleFrontBumperInSphere(float p0, float p1, float p2, float p3, int p4, int p5, int p6);
		int GetRandomVehicleBackBumperInSphere(float p0, float p1, float p2, float p3, int p4, int p5, int p6);
		/// <summary>
		/// Example usage
		/// x, y, z: Position to get closest vehicle to.
		/// radius: Max radius to get a vehicle.
		/// It seems to return police cars for me, does not seem to return helicopters, planes or boats for some reason
		/// Only returns non police cars and motorbikes with the flag set to 70 and modelHash to 0. ModelHash seems to always be 0 when not a modelHash in the scripts, as stated above.
		/// These flags were found in the b617d scripts: 0,2,4,6,7,23,127,260,2146,2175,12294,16384,16386,20503,32768,67590,67711,98309,100359.
		/// Converted to binary, each bit probably represents a flag as explained regarding another native here: gtaforums.com/topic/822314-guide-driving-styles
		/// Conversion of found flags to binary: pastebin.com/kghNFkRi
		/// At exactly 16384 which is 0100000000000000 in binary and 4000 in hexadecimal only planes are returned.
		/// See NativeDB for reference: http://natives.altv.mp/#/0xF73EB622C4F1689B
		/// </summary>
		/// <param name="modelHash">Limit to vehicles with this model. 0 for any.</param>
		/// <param name="flags">The bitwise flags altering the function's behaviour.</param>
		/// <returns>Does not return police cars or helicopters.</returns>
		int GetClosestVehicle(float x, float y, float z, float radius, int modelHash, int flags);
		/// <summary>
		/// Corrected p1. it's basically the 'carriage/trailer number'. So if the train has 3 trailers you'd call the native once with a var or 3 times with 1, 2, 3.
		/// </summary>
		int GetTrainCarriage(int train, int trailerNumber);
		bool IsMissionTrain(int vehicle);
		/// <summary>
		/// </summary>
		void DeleteMissionTrain(ref int train);
		/// <summary>
		/// </summary>
		/// <param name="p1">is always 0</param>
		void SetMissionTrainAsNoLongerNeeded(ref int train, bool p1);
		void SetMissionTrainCoords(int train, float x, float y, float z);
		bool IsThisModelABoat(int model);
		/// <summary>
		/// Checks if model is a boat, then checks for FLAG_IS_JETSKI.
		/// </summary>
		bool IsThisModelAJetski(int model);
		bool IsThisModelAPlane(int model);
		bool IsThisModelAHeli(int model);
		/// <summary>
		/// To check if the model is an amphibious car, see gtaforums.com/topic/717612-v-scriptnative-documentation-and-research/page-33#entry1069317363 (for build 944 and above only!)
		/// </summary>
		bool IsThisModelACar(int model);
		bool IsThisModelATrain(int model);
		bool IsThisModelABike(int model);
		bool IsThisModelABicycle(int model);
		bool IsThisModelAQuadbike(int model);
		bool IsThisModelAnAmphibiousCar(int model);
		bool IsThisModelAnAmphibiousQuadbike(int model);
		/// <summary>
		/// Equivalent of SET_HELI_BLADES_SPEED(vehicleHandle, 1.0f);
		/// this native works on planes to?
		/// </summary>
		void SetHeliBladesFullSpeed(int vehicle);
		/// <summary>
		/// Sets the speed of the helicopter blades in percentage of the full speed.
		/// vehicleHandle: The helicopter.
		/// </summary>
		/// <param name="speed">The speed in percentage, 0.0f being 0% and 1.0f being 100%.</param>
		void SetHeliBladesSpeed(int vehicle, float speed);
		void _0x99CAD8E7AFDB60FA(int vehicle, float p1, float p2);
		/// <summary>
		/// This has not yet been tested - it's just an assumption of what the types could be.
		/// </summary>
		void SetVehicleCanBeTargetted(int vehicle, bool state);
		/// <summary>
		/// Related to locking the vehicle or something similar.
		/// In the decompiled scripts, its always called after
		/// VEHICLE::SET_VEHICLE_DOORS_LOCKED_FOR_ALL_PLAYERS(a_0, 1);
		/// VEHICLE::SET_VEHICLE_DOORS_LOCKED_FOR_PLAYER(a_0, PLAYER::PLAYER_ID(), 0);
		/// -->VEHICLE::_DBC631F109350B8C(a_0, 1);
		/// </summary>
		/// <param name="vehicle">:_SET_EXCLUSIVE_DRIVER(a_0, 0, 0);</param>
		void _0xDBC631F109350B8C(int vehicle, bool p1);
		void SetVehicleCanBeVisiblyDamaged(int vehicle, bool state);
		void SetVehicleHasUnbreakableLights(int vehicle, bool p1);
		void _0x2311DD7159F00582(int vehicle, bool p1);
		void _0x065D03A9D6B2C6B5(int p0, int p1);
		/// <summary>
		/// Dirt level 0..15
		/// </summary>
		float GetVehicleDirtLevel(int vehicle);
		/// <summary>
		/// You can't use values greater than 15.0
		/// You can see why here: pastebin.com/Wbn34fGD
		/// Also, R* does (float)(rand() % 15) to get a random dirt level when generating a vehicle.
		/// </summary>
		void SetVehicleDirtLevel(int vehicle, float dirtLevel);
		/// <summary>
		/// GET_*
		/// </summary>
		/// <returns>Appears to return true if the vehicle has any damage, including cosmetically.</returns>
		bool IsVehicleDamaged(int vehicle);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		bool IsVehicleDoorFullyOpen(int vehicle, int doorId);
		/// <summary>
		/// Starts or stops the engine on the specified vehicle.
		/// from what I've tested when I do this to a helicopter the propellers turn off after the engine has started. so is there any way to keep the heli propellers on?
		/// </summary>
		/// <param name="vehicle">The vehicle to start or stop the engine on.</param>
		/// <param name="value">true to turn the vehicle on; false to turn it off.</param>
		/// <param name="instantly">if true, the vehicle will be set to the state immediately; otherwise, the current driver will physically turn on or off the engine.</param>
		/// <param name="disableAutoStart">If true, the system will prevent the engine from starting when the player got into it.</param>
		void SetVehicleEngineOn(int vehicle, bool value, bool instantly, bool disableAutoStart);
		void SetVehicleUndriveable(int vehicle, bool toggle);
		void SetVehicleProvidesCover(int vehicle, bool toggle);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		void SetVehicleDoorControl(int vehicle, int doorId, int speed, float angle);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		void SetVehicleDoorLatched(int vehicle, int doorId, bool p2, bool p3, bool p4);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		float GetVehicleDoorAngleRatio(int vehicle, int doorId);
		/// <summary>
		/// doorId: see SET_VEHICLE_DOOR_SHUT
		/// </summary>
		int GetPedUsingVehicleDoor(int vehicle, int doord);
		/// <summary>
		/// enum eDoorId
		/// {
		/// VEH_EXT_DOOR_INVALID_ID = -1,
		/// VEH_EXT_DOOR_DSIDE_F,
		/// VEH_EXT_DOOR_DSIDE_R,
		/// VEH_EXT_DOOR_PSIDE_F,
		/// VEH_EXT_DOOR_PSIDE_R,
		/// VEH_EXT_BONNET,
		/// VEH_EXT_BOOT
		/// };
		/// </summary>
		void SetVehicleDoorShut(int vehicle, int doorId, bool closeInstantly);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		void SetVehicleDoorBroken(int vehicle, int doorId, bool deleteDoor);
		void SetVehicleCanBreak(int vehicle, bool toggle);
		bool DoesVehicleHaveRoof(int vehicle);
		void _0xC4B3347BD68BD609(int p0);
		void _0xD3301660A57C9272(int p0);
		void _0xB9562064627FF9DB(int p0, int p1);
		bool IsBigVehicle(int vehicle);
		/// <summary>
		/// Actually number of color combinations
		/// </summary>
		int GetNumberOfVehicleColours(int vehicle);
		/// <summary>
		/// Sets the selected vehicle's colors to their default value (specific variant specified using the colorCombination parameter).
		/// Range of possible values for colorCombination is currently unknown, I couldn't find where these values are stored either (Disquse's guess was vehicles.meta but I haven't seen it in there.)
		/// </summary>
		void SetVehicleColourCombination(int vehicle, int colorCombination);
		int GetVehicleColourCombination(int vehicle);
		/// <summary>
		/// `color`: is the paint index for the vehicle.
		/// Paint index goes from 0 to 12.
		/// Be aware that it only works on xenon lights. Example: https://i.imgur.com/yV3cpG9.png
		/// </summary>
		void SetVehicleXenonLightsColor(int vehicle, int colorIndex);
		/// <summary>
		/// Returns the headlight color index from the vehicle. Value between 0, 12.
		/// Use _SET_VEHICLE_HEADLIGHTS_COLOUR to set the headlights color for the vehicle.
		/// Must enable xenon headlights before it'll take affect.
		/// Returns an int, value between 0-12 or 255 if no color is set.
		/// </summary>
		int GetVehicleXenonLightsColor(int vehicle);
		/// <summary>
		/// Setting this to false, makes the specified vehicle to where if you press Y your character doesn't even attempt the animation to enter the vehicle. Hence it's not considered aka ignored.
		/// </summary>
		void SetVehicleIsConsideredByPlayer(int vehicle, bool toggle);
		void _0xBE5C1255A1830FF5(int vehicle, bool toggle);
		void _0x9BECD4B9FEF3F8A6(int vehicle, bool p1);
		void _0x88BC673CA9E0AE99(int vehicle, bool p1);
		void _0xE851E480B814D4BA(int vehicle, bool p1);
		/// <summary>
		/// Not present in the retail version! It's just a nullsub.
		/// </summary>
		/// <param name="p0">always true (except in one case)</param>
		/// <param name="successIndicator">0 if success, -1 if failed</param>
		void GetRandomVehicleModelInMemory(bool p0, ref int modelHash, ref int successIndicator);
		/// <summary>
		/// enum VehicleLockStatus = {
		/// None = 0,
		/// Unlocked = 1,
		/// Locked = 2,
		/// LockedForPlayer = 3,
		/// StickPlayerInside = 4, -- Doesn't allow players to exit the vehicle with the exit vehicle key.
		/// CanBeBrokenInto = 7, -- Can be broken into the car. If the glass is broken, the value will be set to 1
		/// CanBeBrokenIntoPersist = 8, -- Can be broken into persist
		/// CannotBeTriedToEnter = 10, -- Cannot be tried to enter (Nothing happens when you press the vehicle enter key).
		/// }
		/// </summary>
		int GetVehicleDoorLockStatus(int vehicle);
		/// <summary>
		/// Returns vehicle door destroy type previously set with _SET_VEHICLE_DOOR_DESTROY_TYPE
		/// </summary>
		int GetVehicleDoorDestroyType(int vehicle, int doorId);
		/// <summary>
		/// </summary>
		/// <param name="doorID">starts at 0, not seeming to skip any numbers. Four door vehicles intuitively range from 0 to 3.</param>
		bool IsVehicleDoorDamaged(int veh, int doorID);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		void SetVehicleDoorCanBreak(int vehicle, int doorId, bool isBreakable);
		bool IsVehicleBumperBouncing(int vehicle, bool frontBumper);
		bool IsVehicleBumperBrokenOff(int vehicle, bool front);
		/// <summary>
		/// Usage:
		/// public bool isCopInRange(Vector3 Location, float Range)
		/// {
		/// }
		/// </summary>
		/// <returns>            return Function.Call<bool>(Hash.IS_COP_PED_IN_AREA_3D, Location.X - Range, Location.Y - Range, Location.Z - Range, Location.X + Range, Location.Y + Range, Location.Z + Range);</returns>
		bool IsCopVehicleInArea3d(float x1, float x2, float y1, float y2, float z1, float z2);
		/// <summary>
		/// Public Function isVehicleOnAllWheels(vh As Vehicle) As Boolean
		/// End Function
		/// </summary>
		/// <returns>        Return Native.Function.Call(Of Boolean)(Hash.IS_VEHICLE_ON_ALL_WHEELS, vh)</returns>
		bool IsVehicleOnAllWheels(int vehicle);
		/// <summary>
		/// Returns `nMonetaryValue` from handling.meta for specific model.
		/// </summary>
		int GetVehicleModelMonetaryValue(int vehicleModel);
		int GetVehicleLayoutHash(int vehicle);
		int _0xA01BC64DD4BFBBAC(int vehicle, int p1);
		/// <summary>
		/// makes the train all jumbled up and derailed as it moves on the tracks (though that wont stop it from its normal operations)
		/// </summary>
		void SetRenderTrainAsDerailed(int train, bool toggle);
		/// <summary>
		/// They use the same color indexs as SET_VEHICLE_COLOURS.
		/// </summary>
		void SetVehicleExtraColours(int vehicle, int pearlescentColor, int wheelColor);
		/// <summary>
		/// </summary>
		void GetVehicleExtraColours(int vehicle, ref int pearlescentColor, ref int wheelColor);
		void SetVehicleInteriorColor(int vehicle, int color);
		/// <summary>
		/// </summary>
		void GetVehicleInteriorColor(int vehicle, ref int color);
		void SetVehicleDashboardColor(int vehicle, int color);
		/// <summary>
		/// </summary>
		void GetVehicleDashboardColor(int vehicle, ref int color);
		void StopAllGarageActivity();
		/// <summary>
		/// This fixes a vehicle.
		/// If the vehicle's engine's broken then you cannot fix it with this native.
		/// </summary>
		void SetVehicleFixed(int vehicle);
		/// <summary>
		/// This fixes the deformation of a vehicle but the vehicle health doesn't improve
		/// </summary>
		void SetVehicleDeformationFixed(int vehicle);
		void SetVehicleCanEngineOperateOnFire(int vehicle, bool toggle);
		void SetVehicleCanLeakOil(int vehicle, bool toggle);
		void SetVehicleCanLeakPetrol(int vehicle, bool toggle);
		void SetDisableVehiclePetrolTankFires(int vehicle, bool toggle);
		void SetDisableVehiclePetrolTankDamage(int vehicle, bool toggle);
		void SetDisableVehicleEngineFires(int vehicle, bool toggle);
		/// <summary>
		/// SET_VEHICLE_LI*
		/// </summary>
		void _0xC50CE861B55EAB8B(int vehicle, bool p1);
		/// <summary>
		/// sfink: sets bit in vehicle's structure, used by maintransition, fm_mission_controller, mission_race and a couple of other scripts. see dissassembly:
		/// CVehicle *__fastcall sub_140CDAA10(signed int a1, char a2)
		/// {
		/// CVehicle *result; // rax@1
		/// result = EntityAsCVehicle(a1);
		/// if ( result )
		/// {
		/// result->field_886 &= 0xEFu;
		/// result->field_886 |= 16 * (a2 & 1);
		/// See NativeDB for reference: http://natives.altv.mp/#/0x6EBFB22D646FFC18
		/// </summary>
		/// <returns>    return result;</returns>
		void _0x6EBFB22D646FFC18(int vehicle, bool p1);
		void SetDisablePretendOccupants(int vehicle, bool toggle);
		void RemoveVehiclesFromGeneratorsInArea(float x1, float y1, float z1, float x2, float y2, float z2, int unk);
		/// <summary>
		/// Locks the vehicle's steering to the desired angle, explained below.
		/// Requires to be called onTick. Steering is unlocked the moment the function stops being called on the vehicle.
		/// Steer bias:
		/// -1.0 = full right
		/// 0.0 = centered steering
		/// 1.0 = full left
		/// </summary>
		void SetVehicleSteerBias(int vehicle, float value);
		bool IsVehicleExtraTurnedOn(int vehicle, int extraId);
		/// <summary>
		/// Note: only some vehicle have extras
		/// extra ids are from 1 - 9 depending on the vehicle
		/// -------------------------------------------------
		/// ^ not sure if outdated or simply wrong. Max extra ID for b944 is 14
		/// -------------------------------------------------
		/// not sure if it really should be a BOOL.
		/// </summary>
		/// <param name="disable">is not a on/off toggle. mostly 0 means on and 1 means off.</param>
		void SetVehicleExtra(int vehicle, int extraId, bool disable);
		/// <summary>
		/// Checks via CVehicleModelInfo
		/// </summary>
		bool DoesExtraExist(int vehicle, int extraId);
		/// <summary>
		/// </summary>
		/// <returns>Checks if vehicle tyre at index exists. Also returns false if tyre was removed.</returns>
		bool DoesVehicleTyreExist(int vehicle, int tyreIndex);
		void SetConvertibleRoof(int vehicle, bool p1);
		void LowerConvertibleRoof(int vehicle, bool instantlyLower);
		void RaiseConvertibleRoof(int vehicle, bool instantlyRaise);
		/// <summary>
		/// 0 -> up
		/// 1 -> lowering down
		/// 2 -> down
		/// 3 -> raising up
		/// </summary>
		int GetConvertibleRoofState(int vehicle);
		/// <summary>
		/// However, in launcher_carwash/carwash1/carwash2 scripts, p1 is true and is accompanied by DOES_VEHICLE_HAVE_ROOF
		/// </summary>
		/// <param name="p1">is false almost always.</param>
		bool IsVehicleAConvertible(int vehicle, bool p1);
		/// <summary>
		/// Transforms the `stormberg` to its "water vehicle" variant. If the vehicle is already in that state then the vehicle transformation audio will still play, but the vehicle won't change at all.
		/// </summary>
		void TransformVehicleToSubmarine(int vehicle, bool noAnimation);
		/// <summary>
		/// Transforms the `stormberg` to its "road vehicle" variant. If the vehicle is already in that state then the vehicle transformation audio will still play, but the vehicle won't change at all.
		/// </summary>
		void TransformSubmarineToVehicle(int vehicle, bool noAnimation);
		bool GetIsSubmarineVehicleTransformed(int vehicle);
		/// <summary>
		/// Is this for red lights only?  more testing required.
		/// </summary>
		bool IsVehicleStoppedAtTrafficLights(int vehicle);
		/// <summary>
		/// Apply damage to vehicle at a location. Location is relative to vehicle model (not world).
		/// When `focusOnModel` set to `true`, the damage sphere will travel towards the vehicle from the given point, thus guaranteeing an impact
		/// </summary>
		/// <param name="radius">of effect damage applied in a sphere at impact location</param>
		void SetVehicleDamage(int vehicle, float xOffset, float yOffset, float zOffset, float damage, float radius, bool focusOnModel);
		void _0x35BB21DE06784373(int p0, int p1);
		/// <summary>
		/// Returns 1000.0 if the function is unable to get the address of the specified vehicle or if it's not a vehicle.
		/// Minimum: -4000
		/// Maximum: 1000
		/// -4000: Engine is destroyed
		/// 0 and below: Engine catches fire and health rapidly declines
		/// 300: Engine is smoking and losing functionality
		/// 1000: Engine is perfect
		/// </summary>
		float GetVehicleEngineHealth(int vehicle);
		/// <summary>
		/// 1000 is max health
		/// Begins leaking gas at around 650 health
		/// -------------------------
		/// Minimum: -4000
		/// Maximum: 1000
		/// -4000: Engine is destroyed
		/// 0 and below: Engine catches fire and health rapidly declines
		/// 300: Engine is smoking and losing functionality
		/// 1000: Engine is perfect
		/// </summary>
		/// <param name="health">999.90002441406 appears to be minimum health, although nothing special occurs <</param>
		void SetVehicleEngineHealth(int vehicle, float health);
		/// <summary>
		/// Works just like SET_VEHICLE_ENGINE_HEALTH, didn't saw any difference. But this native works only for planes.
		/// </summary>
		void SetPlaneEngineHealth(int vehicle, float health);
		/// <summary>
		/// 1000 is max health
		/// Begins leaking gas at around 650 health
		/// -999.90002441406 appears to be minimum health, although nothing special occurs
		/// </summary>
		float GetVehiclePetrolTankHealth(int vehicle);
		/// <summary>
		/// 1000 is max health
		/// Begins leaking gas at around 650 health
		/// </summary>
		/// <param name="health">999.90002441406 appears to be minimum health, although nothing special occurs</param>
		void SetVehiclePetrolTankHealth(int vehicle, float health);
		/// <summary>
		/// </summary>
		/// <param name="p1">can be anywhere from 0 to 3 in the scripts. p2 is generally somewhere in the 1000 to 10000 range.</param>
		bool IsVehicleStuckTimerUp(int vehicle, int p1, int p2);
		/// <summary>
		/// The inner function has a switch on the second parameter. It's the stuck timer index.
		/// Here's some pseudo code I wrote for the inner function:
		/// void __fastcall NATIVE_RESET_VEHICLE_STUCK_TIMER_INNER(CUnknown* unknownClassInVehicle, int timerIndex)
		/// {
		/// switch (timerIndex)
		/// {
		/// case 0:
		/// unknownClassInVehicle->FirstStuckTimer = (WORD)0u;
		/// case 1:
		/// See NativeDB for reference: http://natives.altv.mp/#/0xD7591B0065AFAA7A
		/// </summary>
		void ResetVehicleStuckTimer(int vehicle, int nullAttributes);
		/// <summary>
		/// p1 = check if vehicle is on fire
		/// </summary>
		/// <param name="isOnFireCheck">is always 0 in the scripts.</param>
		bool IsVehicleDriveable(int vehicle, bool isOnFireCheck);
		void SetVehicleHasBeenOwnedByPlayer(int vehicle, bool owned);
		void SetVehicleNeedsToBeHotwired(int vehicle, bool toggle);
		void _0x9F3F689B814F2599(int vehicle, bool p1);
		void _0x4E74E62E0A97E901(int vehicle, bool p1);
		/// <summary>
		/// Sounds the horn for the specified vehicle.
		/// Note: If a player is in the vehicle, it will only sound briefly.
		/// </summary>
		/// <param name="vehicle">The vehicle to activate the horn for.</param>
		/// <param name="duration">The duration to sound the horn, in milliseconds.</param>
		/// <param name="mode">The hash of "NORMAL" or "HELDDOWN". Can be 0.</param>
		void StartVehicleHorn(int vehicle, int duration, int mode, bool forever);
		/// <summary>
		/// If set to TRUE, it seems to suppress door noises and doesn't allow the horn to be continuous.
		/// -Doesn't seem to suppress door noises for me, at least with the vehicle add-on I tried
		/// </summary>
		void SetVehicleSilent(int vehicle, bool toggle);
		/// <summary>
		/// if true, axles won't bend.
		/// </summary>
		void SetVehicleHasStrongAxles(int vehicle, bool toggle);
		/// <summary>
		/// Returns model name of vehicle in all caps. Needs to be displayed through localizing text natives to get proper display name.
		/// -----------------------------------------------------------------------------------------------------------------------------------------
		/// -----------------------------------------------------------------------------------------------------------------------------------------
		/// Returns "CARNOTFOUND" if the hash doesn't match a vehicle hash.
		/// Using HUD::_GET_LABEL_TEXT, you can get the localized name.
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		/// <returns>While often the case, this does not simply return the model name of the vehicle (which could be hashed to return the model hash). Variations of the same vehicle may also use the same display name.</returns>
		string GetDisplayNameFromVehicleModel(int modelHash);
		/// <summary>
		/// Returns "CARNOTFOUND" if the hash doesn't match a vehicle hash.
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		/// <returns>Will return a vehicle's manufacturer display label.</returns>
		string GetMakeNameFromVehicleModel(int modelHash);
		/// <summary>
		/// The only example I can find of this function in the scripts, is this:
		/// struct _s = VEHICLE::GET_VEHICLE_DEFORMATION_AT_POS(rPtr((A_0) + 4), 1.21f, 6.15f, 0.3f);
		/// -----------------------------------------------------------------------------------------------------------------------------------------
		/// PC scripts:
		/// v_5{3} = VEHICLE::GET_VEHICLE_DEFORMATION_AT_POS(a_0._f1, 1.21, 6.15, 0.3);
		/// </summary>
		Vector3 GetVehicleDeformationAtPos(int vehicle, float offsetX, float offsetY, float offsetZ);
		void SetVehicleLivery(int vehicle, int livery);
		/// <summary>
		/// -1 = no livery
		/// </summary>
		int GetVehicleLivery(int vehicle);
		/// <summary>
		/// Returns -1 if the vehicle has no livery
		/// </summary>
		int GetVehicleLiveryCount(int vehicle);
		/// <summary>
		/// Used to set the tornado custom (convertible) rooftop livery.
		/// Might work on other custom vehicles but im not sure what those might be, only confirmed it working with the tornado custom.
		/// </summary>
		/// <param name="livery">value that works for tornado custom is between 0 and 9 from what i can tell. Maybe 0-8 even.</param>
		void SetVehicleRoofLivery(int vehicle, int livery);
		/// <summary>
		/// Returns index of the current vehicle's rooftop livery. A getter for _SET_VEHICLE_ROOF_LIVERY.
		/// </summary>
		int GetVehicleRoofLivery(int vehicle);
		/// <summary>
		/// Returns a number of available rooftop liveries, or -1 if vehicle has no rooftop liveries available.
		/// </summary>
		int GetVehicleRoofLiveryCount(int vehicle);
		/// <summary>
		/// Window indexes:
		/// 0 = Front Right Window
		/// 1 = Front Left Window
		/// 2 = Back Right Window
		/// 3 = Back Left Window
		/// Those numbers go on for vehicles that have more than 4 doors with windows.
		/// </summary>
		/// <returns>This will return false if the window is broken, or rolled down.</returns>
		bool IsVehicleWindowIntact(int vehicle, int windowIndex);
		/// <summary>
		/// </summary>
		/// <returns>Appears to return false if any window is broken.</returns>
		bool AreAllVehicleWindowsIntact(int vehicle);
		/// <summary>
		/// Returns false if every seat is occupied.
		/// </summary>
		bool AreAnyVehicleSeatsFree(int vehicle);
		void ResetVehicleWheels(int vehicle, bool toggle);
		bool IsHeliPartBroken(int vehicle, bool p1, bool p2, bool p3);
		/// <summary>
		/// Max 1000.
		/// At 0 the main rotor will stall.
		/// </summary>
		float GetHeliMainRotorHealth(int vehicle);
		/// <summary>
		/// Max 1000.
		/// At 0 the tail rotor will stall.
		/// </summary>
		float GetHeliTailRotorHealth(int vehicle);
		/// <summary>
		/// Max 1000.
		/// At -100 both helicopter rotors will stall.
		/// </summary>
		float GetHeliTailBoomHealth(int vehicle);
		void SetHeliMainRotorHealth(int vehicle, float health);
		void SetHeliTailRotorHealth(int vehicle, float health);
		void SetHeliTailExplodeThrowDashboard(int vehicle, bool p1);
		/// <summary>
		/// NOTE: Debugging functions are not present in the retail version of the game.
		/// </summary>
		void SetVehicleNameDebug(int vehicle, string name);
		/// <summary>
		/// Sets a vehicle to be strongly resistant to explosions. p0 is the vehicle; set p1 to false to toggle the effect on/off.
		/// </summary>
		void SetVehicleExplodesOnHighExplosionDamage(int vehicle, bool toggle);
		void _0xD565F438137F0E10(int p0, int p1);
		void _0x3441CAD2F2231923(int vehicle, bool p1);
		void SetVehicleDisableTowing(int vehicle, bool toggle);
		bool DoesVehicleHaveLandingGear(int vehicle);
		/// <summary>
		/// Works for vehicles with a retractable landing gear
		/// landing gear states:
		/// 0: Deployed
		/// 1: Closing
		/// 2: Opening
		/// 3: Retracted
		/// what can I use to make the hydra thing forward?
		/// </summary>
		void ControlLandingGear(int vehicle, int state);
		/// <summary>
		/// Landing gear states:
		/// 0: Deployed
		/// 1: Closing (Retracting)
		/// 2:(Landing gear state 2 is never used.)
		/// 3: Opening (Deploying)
		/// 4: Retracted
		/// Returns the current state of the vehicles landing gear.
		/// </summary>
		int GetLandingGearState(int vehicle);
		bool IsAnyVehicleNearPoint(float x, float y, float z, float radius);
		void RequestVehicleHighDetailModel(int vehicle);
		void RemoveVehicleHighDetailModel(int vehicle);
		bool IsVehicleHighDetail(int vehicle);
		/// <summary>
		/// REQUEST_VEHICLE_ASSET(GET_HASH_KEY(cargobob3), 3);
		/// vehicle found that have asset's:
		/// cargobob3
		/// submersible
		/// blazer
		/// </summary>
		void RequestVehicleAsset(int vehicleHash, int vehicleAsset);
		bool HasVehicleAssetLoaded(int vehicleAsset);
		void RemoveVehicleAsset(int vehicleAsset);
		/// <summary>
		/// Sets how much the crane on the tow truck is raised, where 0.0 is fully lowered and 1.0 is fully raised.
		/// </summary>
		void SetVehicleTowTruckArmPosition(int vehicle, float position);
		/// <summary>
		/// HookOffset defines where the hook is attached. leave at 0 for default attachment.
		/// </summary>
		void AttachVehicleToTowTruck(int towTruck, int vehicle, bool rear, float hookOffsetX, float hookOffsetY, float hookOffsetZ);
		/// <summary>
		/// First two parameters swapped. Scripts verify that towTruck is the first parameter, not the second.
		/// </summary>
		void DetachVehicleFromTowTruck(int towTruck, int vehicle);
		bool DetachVehicleFromAnyTowTruck(int vehicle);
		/// <summary>
		/// Scripts verify that towTruck is the first parameter, not the second.
		/// </summary>
		bool IsVehicleAttachedToTowTruck(int towTruck, int vehicle);
		int GetEntityAttachedToTowTruck(int towTruck);
		int SetVehicleAutomaticallyAttaches(int vehicle, bool p1, int p2);
		/// <summary>
		/// Sets the arm position of a bulldozer. Position must be a value between 0.0 and 1.0. Ignored when `p2` is set to false, instead incrementing arm position by 0.1 (or 10%).
		/// </summary>
		void SetVehicleBulldozerArmPosition(int vehicle, float position, bool p2);
		void SetVehicleTankTurretPosition(int vehicle, float position, bool p2);
		void _0x0581730AB9380412(int p0, int p1, int p2, int p3, int p4, int p5);
		void _0x737E398138550FFF(int p0, int p1);
		void SetVehicleTurretSpeedThisFrame(int vehicle, float speed);
		void DisableVehicleTurretMovementThisFrame(int vehicle);
		void SetVehicleFlightNozzlePosition(int vehicle, float angleRatio);
		void SetVehicleFlightNozzlePositionImmediate(int vehicle, float angle);
		float GetVehicleFlightNozzlePosition(int plane);
		/// <summary>
		/// True stops vtols from switching modes. Doesn't stop the sound though.
		/// </summary>
		void SetDisableVehicleFlightNozzlePosition(int vehicle, bool toggle);
		/// <summary>
		/// </summary>
		bool _0xA4822F1CF23F4810(ref Vector3 outVec, int p1, ref Vector3 outVec1, int p3, int p4, int p5, int p6, int p7, int p8);
		/// <summary>
		/// On accelerating, spins the driven wheels with the others braked, so you don't go anywhere.
		/// </summary>
		void SetVehicleBurnout(int vehicle, bool toggle);
		/// <summary>
		/// Returns whether the specified vehicle is currently in a burnout.
		/// vb.net
		/// Public Function isVehicleInBurnout(vh As Vehicle) As Boolean
		/// End Function
		/// </summary>
		/// <returns>        Return Native.Function.Call(Of Boolean)(Hash.IS_VEHICLE_IN_BURNOUT, vh)</returns>
		bool IsVehicleInBurnout(int vehicle);
		/// <summary>
		/// Reduces grip significantly so it's hard to go anywhere.
		/// </summary>
		void SetVehicleReduceGrip(int vehicle, bool toggle);
		/// <summary>
		/// Often used in conjunction with: SET_VEHICLE_REDUCE_GRIP
		/// </summary>
		/// <param name="val">is 0-3</param>
		void SetVehicleReduceTraction(int vehicle, int val);
		/// <summary>
		/// Sets the turn signal enabled for a vehicle.
		/// Set turnSignal to 1 for left light, 0 for right light.
		/// </summary>
		void SetVehicleIndicatorLights(int vehicle, int turnSignal, bool toggle);
		void SetVehicleBrakeLights(int vehicle, bool toggle);
		void SetVehicleHandbrake(int vehicle, bool toggle);
		void SetVehicleBrake(int vehicle, bool toggle);
		void InstantlyFillVehiclePopulation();
		/// <summary>
		/// HAS_*
		/// </summary>
		bool HasFilledVehiclePopulation();
		void _0x51DB102F4A3BA5E0(bool toggle);
		/// <summary>
		/// Default:1000||This sets a value which is used when _0x51db102f4a3ba5e0(true) is called each frame.
		/// </summary>
		void _0xA4A9A4C40E615885(int p0);
		/// <summary>
		/// Gets the trailer of a vehicle and puts it into the trailer parameter.
		/// </summary>
		bool GetVehicleTrailerVehicle(int vehicle, ref int trailer);
		/// <summary>
		/// </summary>
		/// <param name="vehicle">must be a plane</param>
		void SetVehicleUsesLargeRearRamp(int vehicle, bool toggle);
		void SetVehicleRudderBroken(int vehicle, bool toggle);
		void SetConvertibleRoofLatchState(int vehicle, bool state);
		float GetVehicleEstimatedMaxSpeed(int vehicle);
		float GetVehicleMaxBraking(int vehicle);
		float GetVehicleMaxTraction(int vehicle);
		/// <summary>
		/// static - max acceleration
		/// </summary>
		float GetVehicleAcceleration(int vehicle);
		/// <summary>
		/// Returns max speed (without mods) of the specified vehicle model in m/s.
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		float GetVehicleModelEstimatedMaxSpeed(int modelHash);
		/// <summary>
		/// Returns max braking of the specified vehicle model.
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		float GetVehicleModelMaxBraking(int modelHash);
		/// <summary>
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		float GetVehicleModelMaxBrakingMaxMods(int modelHash);
		/// <summary>
		/// Returns max traction of the specified vehicle model.
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		float GetVehicleModelMaxTraction(int modelHash);
		/// <summary>
		/// Returns the acceleration of the specified model.
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		float GetVehicleModelAcceleration(int modelHash);
		/// <summary>
		/// GET_VEHICLE_MODEL_*
		/// 9.8 * thrust if air vehicle, else 0.38 + drive force?
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		float GetVehicleModelEstimatedAgility(int modelHash);
		/// <summary>
		/// GET_VEHICLE_MODEL_*
		/// Function pertains only to aviation vehicles.
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		float GetVehicleModelMaxKnots(int modelHash);
		/// <summary>
		/// GET_VEHICLE_MODEL_*
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		/// <returns>called if the vehicle is a boat -- returns vecMoveResistanceX?</returns>
		float GetVehicleModelMoveResistance(int modelHash);
		float GetVehicleClassEstimatedMaxSpeed(int vehicleClass);
		float GetVehicleClassMaxTraction(int vehicleClass);
		float GetVehicleClassMaxAgility(int vehicleClass);
		float GetVehicleClassMaxAcceleration(int vehicleClass);
		float GetVehicleClassMaxBraking(int vehicleClass);
		int AddRoadNodeSpeedZone(float x, float y, float z, float radius, float speed, bool p5);
		bool RemoveRoadNodeSpeedZone(int speedzone);
		void OpenBombBayDoors(int vehicle);
		void CloseBombBayDoors(int vehicle);
		/// <summary>
		/// Returns true when the bomb bay doors of this plane are open. False if they're closed.
		/// </summary>
		bool AreBombBayDoorsOpen(int aircraft);
		/// <summary>
		/// @Author Nac
		/// </summary>
		/// <returns>Possibly: Returns whether the searchlight (found on police vehicles) is toggled on.</returns>
		bool IsVehicleSearchlightOn(int vehicle);
		/// <summary>
		/// Only works during nighttime.
		/// </summary>
		void SetVehicleSearchlight(int heli, bool toggle, bool canBeUsedByAI);
		bool DoesVehicleHaveSearchlight(int vehicle);
		/// <summary>
		/// Use GET_VEHICLE_MAX_NUMBER_OF_PASSENGERS(vehicle) - 1 for last seat index.
		/// </summary>
		/// <param name="seatIndex">= -1 being the driver seat.</param>
		/// <param name="side">= only relevant for bikes/motorcycles to check if the left (false)/right (true) side is blocked.</param>
		/// <param name="onEnter">= check if you can enter (true) or exit (false) a vehicle.</param>
		/// <returns>Check if a vehicle seat is accessible. If you park your vehicle near a wall and the ped cannot enter/exit this side, the return value toggles from true (not blocked) to false (blocked).</returns>
		bool IsVehicleSeatAccessible(int ped, int vehicle, int seatIndex, bool side, bool onEnter);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		Vector3 GetEntryPositionOfDoor(int vehicle, int doorId);
		bool CanShuffleSeat(int vehicle, int seatIndex);
		int GetNumModKits(int vehicle);
		/// <summary>
		/// Set modKit to 0 if you plan to call SET_VEHICLE_MOD. That's what the game does. Most body modifications through SET_VEHICLE_MOD will not take effect until this is set to 0.
		/// Full list of vehicle mod kits and mods by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicleModKits.json
		/// </summary>
		void SetVehicleModKit(int vehicle, int modKit);
		int GetVehicleModKit(int vehicle);
		int GetVehicleModKitType(int vehicle);
		/// <summary>
		/// Returns an int
		/// Wheel Types:
		/// 0: Sport
		/// 1: Muscle
		/// 2: Lowrider
		/// 3: SUV
		/// 4: Offroad
		/// 5: Tuner
		/// 6: Bike Wheels
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB3ED1BFB4BE636DC
		/// </summary>
		int GetVehicleWheelType(int vehicle);
		/// <summary>
		/// 0: Sport
		/// 1: Muscle
		/// 2: Lowrider
		/// 3: SUV
		/// 4: Offroad
		/// 5: Tuner
		/// 6: Bike Wheels
		/// 7: High End
		/// </summary>
		void SetVehicleWheelType(int vehicle, int WheelType);
		/// <summary>
		/// 0: Normal
		/// 1: Metallic
		/// 2: Pearl
		/// 3: Matte
		/// 4: Metal
		/// 5: Chrome
		/// </summary>
		int GetNumModColors(int paintType, bool p1);
		/// <summary>
		/// 0: Normal
		/// 1: Metallic
		/// 2: Pearl
		/// 3: Matte
		/// 4: Metal
		/// 5: Chrome
		/// color: number of the color.
		/// </summary>
		/// <param name="color">https</param>
		/// <param name="pearlescentColor">seems to always be 0.</param>
		void SetVehicleModColor1(int vehicle, int paintType, int color, int pearlescentColor);
		/// <summary>
		/// Changes the secondary paint type and color
		/// 0: Normal
		/// 1: Metallic
		/// 2: Pearl
		/// 3: Matte
		/// 4: Metal
		/// 5: Chrome
		/// color: number of the color
		/// </summary>
		/// <param name="color">https</param>
		void SetVehicleModColor2(int vehicle, int paintType, int color);
		/// <summary>
		/// </summary>
		void GetVehicleModColor1(int vehicle, ref int paintType, ref int color, ref int pearlescentColor);
		/// <summary>
		/// </summary>
		void GetVehicleModColor2(int vehicle, ref int paintType, ref int color);
		/// <summary>
		/// returns a string which is the codename of the vehicle's currently selected primary color
		/// </summary>
		/// <param name="p1">is always 0</param>
		string GetVehicleModColor1Name(int vehicle, bool p1);
		/// <summary>
		/// returns a string which is the codename of the vehicle's currently selected secondary color
		/// </summary>
		string GetVehicleModColor2Name(int vehicle);
		bool HaveVehicleModsStreamedIn(int vehicle);
		/// <summary>
		/// In b944, there are 50 (0 - 49) mod types.
		/// Sets the vehicle mod.
		/// The vehicle must have a mod kit first.
		/// Any out of range ModIndex is stock.
		/// #Mod Type
		/// Spoilers - 0
		/// Front Bumper - 1
		/// Rear Bumper - 2
		/// Side Skirt - 3
		/// See NativeDB for reference: http://natives.altv.mp/#/0x6AF0636DDEDCB6DD
		/// </summary>
		void SetVehicleMod(int vehicle, int modType, int modIndex, bool customTires);
		/// <summary>
		/// In b944, there are 50 (0 - 49) mod types.
		/// Returns -1 if the vehicle mod is stock
		/// </summary>
		int GetVehicleMod(int vehicle, int modType);
		/// <summary>
		/// </summary>
		/// <returns>Only used for wheels(ModType = 23/24) Returns true if the wheels are custom wheels</returns>
		bool GetVehicleModVariation(int vehicle, int modType);
		/// <summary>
		/// Returns how many possible mods a vehicle has for a given mod type
		/// </summary>
		int GetNumVehicleMods(int vehicle, int modType);
		void RemoveVehicleMod(int vehicle, int modType);
		/// <summary>
		/// Toggles:
		/// UNK17 - 17
		/// Turbo - 18
		/// UNK19 - 19
		/// Tire Smoke - 20
		/// UNK21 - 21
		/// Xenon Headlights - 22
		/// </summary>
		void ToggleVehicleMod(int vehicle, int modType, bool toggle);
		bool IsToggleModOn(int vehicle, int modType);
		/// <summary>
		/// Returns the text label of a mod type for a given vehicle
		/// Use _GET_LABEL_TEXT to get the part name in the game's language
		/// </summary>
		string GetModTextLabel(int vehicle, int modType, int modValue);
		/// <summary>
		/// Returns the name for the type of vehicle mod(Armour, engine etc)
		/// </summary>
		string GetModSlotName(int vehicle, int modType);
		/// <summary>
		/// Second Param = LiveryIndex
		/// example
		/// int count = VEHICLE::GET_VEHICLE_LIVERY_COUNT(veh);
		/// for (int i = 0; i < count; i++)
		/// {
		/// const char* LiveryName = VEHICLE::GET_LIVERY_NAME(veh, i);
		/// }
		/// this example will work fine to fetch all names
		/// for example for Sanchez we get
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB4C7A93837C91A1F
		/// </summary>
		string GetLiveryName(int vehicle, int liveryIndex);
		int GetVehicleModModifierValue(int vehicle, int modType, int modIndex);
		/// <summary>
		/// Can be used for IS_DLC_VEHICLE_MOD and _0xC098810437312FFF
		/// </summary>
		int GetVehicleModIdentifierHash(int vehicle, int modType, int modIndex);
		void PreloadVehicleMod(int p0, int modType, int p2);
		bool HasPreloadModsFinished(int p0);
		void ReleasePreloadMods(int vehicle);
		/// <summary>
		/// Sets the tire smoke's color of this vehicle.
		/// Note:
		/// setting r,g,b to 0 will give the car independance day tyre smoke
		/// </summary>
		/// <param name="vehicle">The vehicle that is the target of this method.</param>
		/// <param name="r">The red level in the RGB color code.</param>
		/// <param name="g">The green level in the RGB color code.</param>
		/// <param name="b">The blue level in the RGB color code.</param>
		void SetVehicleTyreSmokeColor(int vehicle, int r, int g, int b);
		/// <summary>
		/// </summary>
		void GetVehicleTyreSmokeColor(int vehicle, ref int r, ref int g, ref int b);
		/// <summary>
		/// enum WindowTints
		/// {
		/// WINDOWTINT_NONE,
		/// WINDOWTINT_PURE_BLACK,
		/// WINDOWTINT_DARKSMOKE,
		/// WINDOWTINT_LIGHTSMOKE,
		/// WINDOWTINT_STOCK,
		/// WINDOWTINT_LIMO,
		/// WINDOWTINT_GREEN
		/// };
		/// </summary>
		void SetVehicleWindowTint(int vehicle, int tint);
		int GetVehicleWindowTint(int vehicle);
		int GetNumVehicleWindowTints();
		/// <summary>
		/// What's this for? Primary and Secondary RGB have their own natives and this one doesn't seem specific.
		/// </summary>
		void GetVehicleColor(int vehicle, ref int r, ref int g, ref int b);
		/// <summary>
		/// Some kind of flags.
		/// </summary>
		int _0xEEBFC7A7EFDC35B4(int vehicle);
		/// <summary>
		/// iVar3 = get_vehicle_cause_of_destruction(uLocal_248[iVar2]);
		/// if (iVar3 == joaat("weapon_stickybomb"))
		/// {
		/// func_171(726);
		/// iLocal_260 = 1;
		/// }
		/// </summary>
		int GetVehicleCauseOfDestruction(int vehicle);
		/// <summary>
		/// Sets some health value. Looks like it's used for helis.
		/// </summary>
		void _0x5EE5632F47AE9695(int vehicle, float health);
		/// <summary>
		/// From the driver's perspective, is the left headlight broken.
		/// </summary>
		bool GetIsLeftVehicleHeadlightDamaged(int vehicle);
		/// <summary>
		/// From the driver's perspective, is the right headlight broken.
		/// </summary>
		bool GetIsRightVehicleHeadlightDamaged(int vehicle);
		/// <summary>
		/// Only ever used once in decompiled scripts: **am_pi_menu**:
		/// Returns true if the engine is on fire, or if the vehicle engine health is < 0 and it **has been** on fire.
		/// This usually returns true even if there are no visible flames yet (engine health > 0). However if you monitor engine health you'll see that it starts decreasing as soon as this returns true.
		/// </summary>
		/// <returns>It sometimes doesn't return true when the vehicle engine has been on fire, and has since been fixed. I'm not really sure what the exact conditions are.</returns>
		bool IsVehicleEngineOnFire(int vehicle);
		void ModifyVehicleTopSpeed(int vehicle, float value);
		/// <summary>
		/// To reset the max speed, set the `speed` value to `0.0` or lower.
		/// </summary>
		void SetVehicleMaxSpeed(int vehicle, float speed);
		/// <summary>
		/// Has something to do with trains. Always precedes SET_MISSION_TRAIN_AS_NO_LONGER_NEEDED.
		/// May be true that it can be used with trains not sure, but not specifically for trains. Go find Xbox360 decompiled scripts and search for 'func_1333' in freemode.c it isn't used just for trains. Thanks for the info tho.
		/// </summary>
		void _0x1CF38D529D7441D9(int vehicle, bool toggle);
		void _0x1F9FB66F3A3842D2(int vehicle, bool p1);
		/// <summary>
		/// Sets some bit and float of vehicle. float is >= 0
		/// SET_VEHICLE_*
		/// </summary>
		void _0x59C3757B3B7408E8(int vehicle, bool toggle, float p2);
		int AddVehicleCombatAngledAvoidanceArea(float p0, float p1, float p2, float p3, float p4, float p5, float p6);
		void RemoveVehicleCombatAvoidanceArea(int p0);
		bool IsAnyPedRappellingFromHeli(int vehicle);
		/// <summary>
		/// <1.0 - Decreased torque
		/// =1.0 - Default torque
		/// >1.0 - Increased torque
		/// Negative values will cause the vehicle to go backwards instead of forwards while accelerating.
		/// This needs to be called every frame to take effect.
		/// </summary>
		/// <param name="value">- is between 0.2 and 1.8 in the decompiled scripts.</param>
		void SetVehicleCheatPowerIncrease(int vehicle, float value);
		void _0x0AD9E8F87FF7C16F(int p0, bool p1);
		/// <summary>
		/// Sets the wanted state of this vehicle.
		/// </summary>
		void SetVehicleIsWanted(int vehicle, bool state);
		/// <summary>
		/// Sets the boat boom position for the `TR3` trailer.
		/// To get the current boom position ratio, use GET_BOAT_BOOM_POSITION_RATIO
		/// </summary>
		/// <param name="ratio">value is between `0.0` and `1.0`, where `0.0` is 90 degrees to the left of the boat, and `1.0` is just slightly to the right/back of the boat.</param>
		void SetBoatBoomPositionRatio(int vehicle, float ratio);
		/// <summary>
		/// Same call as VEHICLE::_0x0F3B4D4E43177236
		/// </summary>
		void GetBoatBoomPositionRatio2(int vehicle, bool p1);
		void GetBoatBoomPositionRatio3(int vehicle, bool p1);
		float GetBoatBoomPositionRatio(int vehicle);
		void DisablePlaneAileron(int vehicle, bool p1, bool p2);
		/// <summary>
		/// Returns true when in a vehicle, false whilst entering/exiting.
		/// </summary>
		bool GetIsVehicleEngineRunning(int vehicle);
		void SetVehicleUseAlternateHandling(int vehicle, bool toggle);
		/// <summary>
		/// Only works on bikes, both X and Y work in the -1 - 1 range.
		/// Example with X -1/Y 1
		/// http://i.imgur.com/TgIuAPJ.jpg
		/// </summary>
		/// <param name="x">forces the bike to turn left or right (-1, 1)</param>
		/// <param name="y">forces the bike to lean to the left or to the right (-1, 1)</param>
		void SetBikeOnStand(int vehicle, float x, float y);
		void _0xAB04325045427AAE(int vehicle, bool p1);
		/// <summary>
		/// what does this do?
		/// </summary>
		void _0xCFD778E7904C255E(int vehicle);
		void SetLastDrivenVehicle(int vehicle);
		int GetLastDrivenVehicle();
		void ClearLastDrivenVehicle();
		void SetVehicleHasBeenDrivenFlag(int vehicle, bool toggle);
		void SetTaskVehicleGotoPlaneMinHeightAboveTerrain(int plane, int height);
		void SetVehicleLodMultiplier(int vehicle, float multiplier);
		void SetVehicleCanSaveInGarage(int vehicle, bool toggle);
		/// <summary>
		/// Also includes some "turnOffBones" when vehicle mods are installed.
		/// </summary>
		int GetVehicleNumberOfBrokenOffBones(int vehicle);
		int GetVehicleNumberOfBrokenBones(int vehicle);
		void _0x4D9D109F63FEE1D4(int p0, bool p1);
		/// <summary>
		/// Allows creation of CEventShockingPlaneFlyby, CEventShockingHelicopterOverhead, and other(?) Shocking events
		/// </summary>
		void SetVehicleGeneratesEngineShockingEvents(int vehicle, bool toggle);
		/// <summary>
		/// Copies sourceVehicle's damage (broken bumpers, broken lights, etc.) to targetVehicle.
		/// </summary>
		void CopyVehicleDamages(int sourceVehicle, int targetVehicle);
		void _0xF25E02CB9C5818F8();
		void SetLightsCutoffDistanceTweak(float distance);
		/// <summary>
		/// Commands the driver of an armed vehicle (p0) to shoot its weapon at a target (p1). p3, p4 and p5 are the coordinates of the target. Example:
		/// WEAPON::SET_CURRENT_PED_VEHICLE_WEAPON(pilot,MISC::GET_HASH_KEY("VEHICLE_WEAPON_PLANE_ROCKET"));                        VEHICLE::SET_VEHICLE_SHOOT_AT_TARGET(pilot, target, targPos.x, targPos.y, targPos.z);
		/// </summary>
		void SetVehicleShootAtTarget(int driver, int entity, float xTarget, float yTarget, float zTarget);
		/// <summary>
		/// </summary>
		bool GetVehicleLockOnTarget(int vehicle, ref int entity);
		void SetForceHdVehicle(int vehicle, bool toggle);
		void _0x182F266C2D9E2BEB(int vehicle, float p1);
		int GetVehiclePlateType(int vehicle);
		/// <summary>
		/// in script hook .net
		/// Function.Call(Hash.TRACK_VEHICLE_VISIBILITY, v.Handle);
		/// </summary>
		/// <param name="vehicle">v = ...;</param>
		void TrackVehicleVisibility(int vehicle);
		/// <summary>
		/// must be called after TRACK_VEHICLE_VISIBILITY
		/// it's not instant so probabilly must pass an 'update' to see correct result.
		/// </summary>
		bool IsVehicleVisible(int vehicle);
		void SetVehicleGravity(int vehicle, bool toggle);
		/// <summary>
		/// Enable/Disables global slipstream physics
		/// </summary>
		void SetEnableVehicleSlipstreaming(bool toggle);
		void _0xF051D9BFB6BA39C0(int p0);
		/// <summary>
		/// Returns a float value between 0.0 and 3.0 related to its slipstream draft (boost/speedup).
		/// GET_VEHICLE_*
		/// </summary>
		float GetVehicleCurrentSlipstreamDraft(int vehicle);
		/// <summary>
		/// Returns true if the vehicle is being slipstreamed by another vehicle
		/// </summary>
		bool IsVehicleSlipstreamLeader(int vehicle);
		void SetVehicleInactiveDuringPlayback(int vehicle, bool toggle);
		void SetVehicleActiveDuringPlayback(int p0, bool p1);
		/// <summary>
		/// Returns false if the vehicle has the FLAG_NO_RESPRAY flag set.
		/// </summary>
		bool IsVehicleSprayable(int vehicle);
		void SetVehicleEngineCanDegrade(int vehicle, bool toggle);
		/// <summary>
		/// Adds some kind of shadow to the vehicle.
		/// -1 disables the effect.
		/// DISABLE_*
		/// </summary>
		void SetVehicleShadowEffect(int vehicle, int p1, int p2);
		/// <summary>
		/// Remove the weird shadow applied by _SET_VEHICLE_SHADOW_EFFECT.
		/// ENABLE_*
		/// </summary>
		void RemoveVehicleShadowEffect(int vehicle);
		bool IsPlaneLandingGearIntact(int plane);
		bool ArePlanePropellersIntact(int plane);
		void SetPlanePropellersHealth(int plane, float health);
		void SetVehicleCanDeformWheels(int vehicle, bool toggle);
		bool IsVehicleStolen(int vehicle);
		void SetVehicleIsStolen(int vehicle, bool isStolen);
		/// <summary>
		/// This native sets the turbulence multiplier. It only works for planes.
		/// 0.0 = no turbulence at all.
		/// 1.0 = heavy turbulence.
		/// Works by just calling it once, does not need to be called every tick.
		/// </summary>
		void SetPlaneTurbulenceMultiplier(int vehicle, float multiplier);
		/// <summary>
		/// ADD_A_MARKER_OVER_VEHICLE was a hash collision!!!
		/// Can be used for planes only!
		/// </summary>
		bool ArePlaneWingsIntact(int plane);
		/// <summary>
		/// This native doesn't seem to do anything, might be a debug-only native.
		/// Confirmed, it is a debug native.
		/// </summary>
		void _0xB264C4D2F2B0A78B(int vehicle);
		void DetachVehicleFromCargobob(int vehicle, int cargobob);
		bool DetachVehicleFromAnyCargobob(int vehicle);
		int DetachEntityFromCargobob(int cargobob, int entity);
		bool IsVehicleAttachedToCargobob(int cargobob, int vehicleAttached);
		/// <summary>
		/// Returns attached vehicle (Vehicle in parameter must be cargobob)
		/// </summary>
		int GetVehicleAttachedToCargobob(int cargobob);
		int GetEntityAttachedToCargobob(int p0);
		void AttachVehicleToCargobob(int vehicle, int cargobob, int p2, float x, float y, float z);
		void AttachEntityToCargobob(int p0, int p1, int p2, int p3, int p4, int p5);
		/// <summary>
		/// Stops cargobob from beeing able to detach the attached vehicle.
		/// </summary>
		void SetCargobobHookCanDetach(int cargobob, bool toggle);
		void _0x1F34B0626C594380(int p0, int p1);
		int _0x2C1D8B3B19E517CC(int p0, int p1);
		/// <summary>
		/// Gets the position of the cargobob hook, in world coords.
		/// </summary>
		Vector3 GetCargobobHookPosition(int cargobob);
		/// <summary>
		/// </summary>
		/// <returns>Returns true only when the hook is active, will return false if the magnet is active</returns>
		bool DoesCargobobHavePickUpRope(int cargobob);
		/// <summary>
		/// Drops the Hook/Magnet on a cargobob
		/// state
		/// enum eCargobobHook
		/// {
		/// CARGOBOB_HOOK = 0,
		/// CARGOBOB_MAGNET = 1,
		/// };
		/// </summary>
		void CreatePickUpRopeForCargobob(int cargobob, int state);
		/// <summary>
		/// Retracts the hook on the cargobob.
		/// Note: after you retract it the natives for dropping the hook no longer work
		/// </summary>
		void RemovePickUpRopeForCargobob(int cargobob);
		/// <summary>
		/// min: 1.9f, max: 100.0f
		/// </summary>
		void SetPickupRopeLengthForCargobob(int cargobob, float length1, float length2, bool p3);
		void _0xC0ED6438E6D39BA8(int p0, int p1, int p2);
		void SetCargobobPickupRopeDampingMultiplier(int p0, int p1);
		void SetCargobobPickupRopeType(int p0, int p1);
		/// <summary>
		/// </summary>
		/// <returns>Returns true only when the magnet is active, will return false if the hook is active</returns>
		bool DoesCargobobHavePickupMagnet(int cargobob);
		/// <summary>
		/// Won't attract or magnetize to any helicopters or planes of course, but that's common sense.
		/// </summary>
		void SetCargobobPickupMagnetActive(int cargobob, bool isActive);
		void SetCargobobPickupMagnetStrength(int cargobob, float strength);
		void SetCargobobPickupMagnetEffectRadius(int cargobob, float p1);
		void SetCargobobPickupMagnetReducedFalloff(int cargobob, float p1);
		void SetCargobobPickupMagnetPullRopeLength(int cargobob, float p1);
		void SetCargobobPickupMagnetPullStrength(int cargobob, float p1);
		void SetCargobobPickupMagnetFalloff(int vehicle, float p1);
		void SetCargobobPickupMagnetReducedStrength(int vehicle, int cargobob);
		void _0x9BDDC73CC6A115D4(int vehicle, bool p1, bool p2);
		void _0x56EB5E94318D3FB6(int vehicle, bool p1);
		bool DoesVehicleHaveWeapons(int vehicle);
		/// <summary>
		/// SET_VEHICLE_W* (next character is either H or I)
		/// </summary>
		void _0x2C4A1590ABF43E8B(int vehicle, bool p1);
		/// <summary>
		/// how does this work?
		/// </summary>
		void DisableVehicleWeapon(bool disabled, int weaponHash, int vehicle, int owner);
		bool IsVehicleWeaponDisabled(int weaponHash, int vehicle, int owner);
		void _0xE05DD0E9707003A3(int p0, bool p1);
		void SetVehicleActiveForPedNavigation(int vehicle, bool toggle);
		/// <summary>
		/// Returns an int
		/// 0: Compacts
		/// 1: Sedans
		/// 2: SUVs
		/// 3: Coupes
		/// 4: Muscle
		/// 5: Sports Classics
		/// 6: Sports
		/// 7: Super
		/// See NativeDB for reference: http://natives.altv.mp/#/0x29439776AAA00A62
		/// </summary>
		/// <param name="vehicle">Classes:</param>
		int GetVehicleClass(int vehicle);
		/// <summary>
		/// For a full enum, see here : pastebin.com/i2GGAjY0
		/// char buffer[128];
		/// std::sprintf(buffer, "VEH_CLASS_%i", VEHICLE::GET_VEHICLE_CLASS_FROM_NAME (hash));
		/// const char* className = HUD::_GET_LABEL_TEXT(buffer);
		/// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
		/// </summary>
		int GetVehicleClassFromName(int modelHash);
		void SetPlayersLastVehicle(int vehicle);
		void SetVehicleCanBeUsedByFleeingPeds(int vehicle, bool toggle);
		void _0xE5810AC70602F2F5(int vehicle, float p1);
		/// <summary>
		/// Money pickups are created around cars when they explode. Only works when the vehicle model is a car. A single pickup is between 1 and 18 dollars in size. All car models seem to give the same amount of money.
		/// youtu.be/3arlUxzHl5Y
		/// i.imgur.com/WrNpYFs.jpg
		/// </summary>
		void SetVehicleDropsMoneyWhenBlownUp(int vehicle, bool toggle);
		/// <summary>
		/// i.imgur.com/7XA14pX.png
		/// Certain planes got jet engines.
		/// </summary>
		/// <param name="vehicle">:SET_VEHICLE_ENGINE_ON is not enough to start jet engines when not inside the vehicle. But with this native set to true it works: youtu.be/OK0ps2fDpxs</param>
		void SetVehicleJetEngineOn(int vehicle, bool toggle);
		/// <summary>
		/// Seems to copy some values in vehicle
		/// </summary>
		void _0x6A973569BA094650(int vehicle, int p1);
		/// <summary>
		/// Use the "AIHandling" string found in handling.meta
		/// </summary>
		void SetVehicleHandlingHashForAi(int vehicle, int hash);
		/// <summary>
		/// Max value is 32767
		/// </summary>
		void SetVehicleExtendedRemovalRange(int vehicle, int range);
		void SetVehicleSteeringBiasScalar(int p0, float p1);
		/// <summary>
		/// value between 0.0 and 1.0
		/// </summary>
		void SetHelicopterRollPitchYawMult(int helicopter, float multiplier);
		/// <summary>
		/// Seems to be related to the metal parts, not tyres (like i was expecting lol)
		/// </summary>
		void SetVehicleFrictionOverride(int vehicle, float friction);
		void SetVehicleWheelsCanBreakOffWhenBlowUp(int vehicle, bool toggle);
		bool _0xF78F94D60248C737(int vehicle, bool p1);
		void SetVehicleCeilingHeight(int vehicle, float height);
		void _0x5E569EC46EC21CAE(int vehicle, bool toggle);
		void ClearVehicleRouteHistory(int vehicle);
		bool DoesVehicleExistWithDecorator(string decorator);
		/// <summary>
		/// Used to be incorrectly named SET_VEHICLE_EXCLUSIVE_DRIVER
		/// Likely SET_VEHICLE_ALLOW_*
		/// Jenkins hash may be wrong, unsure at this time.
		/// Toggles a flag related to SET_VEHICLE_EXCLUSIVE_DRIVER, however, doesn't enable that feature (or trigger script events related to it).
		/// </summary>
		void _0x41062318F23ED854(int vehicle, bool toggle);
		/// <summary>
		/// Used to be incorrectly named _SET_VEHICLE_EXCLUSIVE_DRIVER_2
		/// </summary>
		/// <param name="index">0 - 1</param>
		void SetVehicleExclusiveDriver(int vehicle, int ped, int index);
		/// <summary>
		/// </summary>
		bool IsPedExclusiveDriverOfVehicle(int ped, int vehicle, ref int outIndex);
		void DisableIndividualPlanePropeller(int vehicle, int propeller);
		void SetVehicleForceAfterburner(int vehicle, bool toggle);
		/// <summary>
		/// R* used it to "remove" vehicle windows when "nightshark" had some mod, which adding some kind of armored windows. When enabled, you can't break vehicles glass. All your bullets wiil shoot through glass. You also will not able to break the glass with any other way (hitting and etc)
		/// </summary>
		void SetDisableVehicleWindowCollisions(int vehicle, bool toggle);
		void _0x4AD280EB48B2D8E6(int vehicle, bool togle);
		/// <summary>
		/// Sets value for vehicle. Vehicle is a helicopter?
		/// _SET_HELICOPTER_*
		/// </summary>
		void _0xB68CFAF83A02768D(int vehicle, bool toggle);
		/// <summary>
		/// Sets some float for vehicle (def -1f)
		/// SET_VEHICLE_*
		/// </summary>
		void _0x0205F5365292D2EB(int vehicle, float p1);
		void _0xCF9159024555488C(int p0);
		/// <summary>
		/// Toggles to render distant vehicles. They may not be vehicles but images to look like vehicles.
		/// </summary>
		void SetDistantCarsEnabled(bool toggle);
		/// <summary>
		/// Sets the color of the neon lights of the specified vehicle.
		/// More info: pastebin.com/G49gqy8b
		/// </summary>
		void SetVehicleNeonLightsColour(int vehicle, int r, int g, int b);
		/// <summary>
		/// Sets some value for vehicle from array based on index
		/// _SET_VEHICLE_*
		/// </summary>
		void _0xB93B2867F7B479D1(int vehicle, int index);
		/// <summary>
		/// Gets the color of the neon lights of the specified vehicle.
		/// See _SET_VEHICLE_NEON_LIGHTS_COLOUR (0x8E0A582209A62695) for more information
		/// </summary>
		void GetVehicleNeonLightsColour(int vehicle, ref int r, ref int g, ref int b);
		/// <summary>
		/// Sets the neon lights of the specified vehicle on/off.
		/// Indices:
		/// 0 = Left
		/// 1 = Right
		/// 2 = Front
		/// 3 = Back
		/// </summary>
		void SetVehicleNeonLightEnabled(int vehicle, int index, bool toggle);
		/// <summary>
		/// indices:
		/// 0 = Left
		/// 1 = Right
		/// 2 = Front
		/// 3 = Back
		/// </summary>
		bool IsVehicleNeonLightEnabled(int vehicle, int index);
		void _0x35E0654F4BAD7971(bool p0);
		void DisableVehicleNeonLights(int vehicle, bool toggle);
		void SetDisableSuperdummyMode(int vehicle, bool p1);
		/// <summary>
		/// REQUEST_VEHICLE_*
		/// </summary>
		void RequestVehicleDashboardScaleformMovie(int vehicle);
		/// <summary>
		/// Seems related to vehicle health, like the one in IV.
		/// Max 1000, min 0.
		/// </summary>
		/// <param name="vehicle">does not necessarily explode or become undrivable at 0.</param>
		float GetVehicleBodyHealth(int vehicle);
		/// <summary>
		/// p2 often set to 1000.0 in the decompiled scripts.
		/// </summary>
		void SetVehicleBodyHealth(int vehicle, float value);
		/// <summary>
		/// Outputs 2 Vector3's.
		/// Scripts check if out2.x - out1.x > someshit.x
		/// Could be suspension related, as in max suspension height and min suspension height, considering the natives location.
		/// </summary>
		void GetVehicleSuspensionBounds(int vehicle, ref Vector3 out1, ref Vector3 out2);
		/// <summary>
		/// Gets the height of the vehicle's suspension.
		/// The higher the value the lower the suspension. Each 0.002 corresponds with one more level lowered.
		/// 0.000 is the stock suspension.
		/// 0.008 is Ultra Suspension.
		/// </summary>
		float GetVehicleSuspensionHeight(int vehicle);
		/// <summary>
		/// Something to do with "high speed bump severity"?
		/// if (!sub_87a46("SET_CAR_HIGH_SPEED_BUMP_SEVERITY_MULTIPLIER")) {
		/// VEHICLE::_84FD40F56075E816(0.0);
		/// sub_8795b("SET_CAR_HIGH_SPEED_BUMP_SEVERITY_MULTIPLIER", 1);
		/// }
		/// </summary>
		void SetCarHighSpeedBumpSeverityMultiplier(float multiplier);
		int GetNumberOfVehicleDoors(int vehicle);
		void SetHydraulicRaised(int p0, int p1);
		void _0xA7DCDF4DED40A8F4(int vehicle, bool p1);
		/// <summary>
		/// 0 min 100 max
		/// starts at 100
		/// Seams to have health zones
		/// Front of vehicle when damaged goes from 100-50 and stops at 50.
		/// Rear can be damaged from 100-0
		/// Only tested with two cars.
		/// any idea how this differs from the first one?
		/// --
		/// example:
		/// See NativeDB for reference: http://natives.altv.mp/#/0xB8EF61207C2393A9
		/// </summary>
		/// <returns>May return the vehicle health on a scale of 0.0 - 100.0 (needs to be confirmed)</returns>
		float GetVehicleBodyHealth2(int vehicle, float maxEngineHealth, float maxPetrolTankHealth, float maxBodyHealth, float maxMainRotorHealth, float maxTailRotorHealth, float maxUnkHealth);
		/// <summary>
		/// Only used like this:
		/// if (VEHICLE::_D4C4642CB7F50B5D(ENTITY::GET_VEHICLE_INDEX_FROM_ENTITY_INDEX(v_3))) {
		/// sub_157e9c(g_40001._f1868, 0);
		/// }
		/// </summary>
		bool _0xD4C4642CB7F50B5D(int vehicle);
		void _0xC361AA040D6637A8(int vehicle, bool p1);
		void SetVehicleKersAllowed(int vehicle, bool toggle);
		/// <summary>
		/// Returns true if the vehicle has a kers boost (for instance the lectro or the vindicator)
		/// </summary>
		bool GetVehicleHasKers(int vehicle);
		void _0xE16142B94664DEFD(int vehicle, bool p1);
		void _0x26D99D5A82FD18E8(int p0);
		/// <summary>
		/// Works only on vehicles that support hydraulic.
		/// </summary>
		void SetHydraulicWheelValue(int vehicle, int wheelId, float value);
		float GetHydraulicWheelValue(int vehicle, int wheelId);
		void SetCamberedWheelsDisabled(int p0, int p1);
		void SetHydraulicWheelState(int p0, int p1);
		/// <summary>
		/// Sets vehicle wheel hydraulic states transition. Known states:
		/// 0 - reset
		/// 1 - raise wheel (uses value arg, works just like _SET_VEHICLE_HYDRAULIC_WHEEL_VALUE)
		/// 2 - jump using wheel
		/// </summary>
		void SetHydraulicWheelStateTransition(int vehicle, int wheelId, int state, float value, int p4);
		int _0x5BA68A0840D546AC(int p0, int p1);
		/// <summary>
		/// CLEAR_VEHICLE_*
		/// </summary>
		void _0x4419966C9936071A(int vehicle);
		void _0x870B8B7A766615C8(int p0, int p1, int p2);
		int _0x8533CAFDE1F0F336(int p0);
		/// <summary>
		/// SET_VEHICLE_D*
		/// </summary>
		int SetVehicleDamageModifier(int vehicle, float p1);
		void SetVehicleUnkDamageMultiplier(int vehicle, float multiplier);
		int _0xD4196117AF7BB974(int p0, int p1);
		void _0xBB2333BB87DDD87F(int p0, int p1);
		void _0x73561D4425A021A2(int p0, int p1);
		/// <summary>
		/// Inverts vehicle's controls. So INPUT_VEH_ACCELERATE will be INPUT_VEH_BRAKE and vise versa (same for A/D controls)
		/// Doesn't work for planes/helis.
		/// </summary>
		void SetVehicleControlsInverted(int vehicle, bool state);
		void _0x7BBE7FF626A591FE(int p0);
		void _0x65B080555EA48149(int p0);
		/// <summary>
		/// SET_*
		/// </summary>
		void _0x428AD3E26C8D9EB0(int vehicle, float x, float y, float z, float p4);
		/// <summary>
		/// RESET_*
		/// Resets the effect of 0x428AD3E26C8D9EB0
		/// </summary>
		void _0xE2F53F172B45EDE1();
		bool _0xBA91D045575699AD(int vehicle);
		void _0x80E3357FDEF45C21(int p0, int p1);
		void SetVehicleRampLaunchModifier(int p0, int p1);
		/// <summary>
		/// </summary>
		/// <param name="doorId">see SET_VEHICLE_DOOR_SHUT</param>
		bool GetIsDoorValid(int vehicle, int doorId);
		void SetVehicleRocketBoostRefillTime(int vehicle, float seconds);
		bool GetHasRocketBoost(int vehicle);
		bool IsVehicleRocketBoostActive(int vehicle);
		void SetVehicleRocketBoostActive(int vehicle, bool active);
		bool GetHasRetractableWheels(int vehicle);
		bool GetIsWheelsLoweredStateActive(int vehicle);
		void RaiseRetractableWheels(int vehicle);
		void LowerRetractableWheels(int vehicle);
		/// <summary>
		/// Returns true if the vehicle has the FLAG_JUMPING_CAR flag set.
		/// </summary>
		bool GetCanVehicleJump(int vehicle);
		/// <summary>
		/// Allows vehicles with the FLAG_JUMPING_CAR flag to jump higher (i.e. Ruiner 2000).
		/// </summary>
		void SetUseHigherVehicleJumpForce(int vehicle, bool toggle);
		/// <summary>
		/// SET_C*
		/// </summary>
		void _0xB2E0C0D6922D31F2(int vehicle, bool toggle);
		/// <summary>
		/// Set vehicle's primary mounted weapon 2 ammo. For example, use it on APC.
		/// For example, you can "remove" any vehicle weapon from any vehicle.
		/// ammoAmount -1 = infinite ammo (default value for any spawned vehicle tho)
		/// </summary>
		void SetVehicleWeaponCapacity(int vehicle, int weaponIndex, int capacity);
		int GetVehicleWeaponCapacity(int vehicle, int weaponIndex);
		bool GetVehicleHasParachute(int vehicle);
		bool GetVehicleCanActivateParachute(int vehicle);
		void SetVehicleParachuteActive(int vehicle, bool active);
		int _0x3DE51E9C80B116CF(int p0);
		void SetVehicleReceivesRampDamage(int vehicle, bool toggle);
		void SetVehicleRampSidewaysLaunchMotion(int p0, int p1);
		void SetVehicleRampUpwardsLaunchMotion(int p0, int p1);
		void _0x9D30687C57BAA0BB(int p0);
		void SetVehicleWeaponsDisabled(int p0, int p1);
		void _0x41290B40FA63E6DA(int p0);
		/// <summary>
		/// Parachute models:
		/// - sr_prop_specraces_para_s_01
		/// - imp_prop_impexp_para_s (SecuroServ; Default)
		/// Plus, many more props can be used as vehicle parachutes, like umbrellas (prop_beach_parasol_03), and unlike SET_PLAYER_PARACHUTE_MODEL_OVERRIDE, you won't get stuck mid-air when using an umbrella.
		/// </summary>
		void SetVehicleParachuteModel(int vehicle, int modelHash);
		/// <summary>
		/// Variations available for the generic parachute (sr_prop_specraces_para_s_01):
		/// - 0: Rainbow
		/// - 1: Red
		/// - 2: White, blue, yellow
		/// - 3: Black, red, white
		/// - 4: Red, white, blue
		/// - 5: Blue
		/// - 6: Black
		/// - 7: Black, yellow
		/// </summary>
		void SetVehicleParachuteTextureVariation(int vehicle, int textureVariation);
		int _0x0419B167EE128F33(int p0, int p1);
		int _0xF3B0E0AED097A3F5(int p0, int p1);
		int _0xD3E51C0AB8C26EEE(int p0, int p1);
		/// <summary>
		/// </summary>
		int GetAllVehicles(ref int vehsStruct);
		void _0x72BECCF4B829522E(int p0, int p1);
		void _0x66E3AAFACE2D1EB8(int p0, int p1, int p2);
		void _0x1312DDD8385AEE4E(int p0, int p1);
		void _0xEDBC8405B3895CC9(int p0, int p1);
		void _0x26E13D440E7F6064(int vehicle, float value);
		void _0x2FA2494B47FDD009(int p0, int p1);
		void SetVehicleRocketBoostPercentage(int vehicle, float percentage);
		/// <summary>
		/// Set state to true to extend the wings, false to retract them.
		/// </summary>
		void SetOppressorTransformState(int vehicle, bool state);
		void _0x78CEEE41F49F421F(int p0, int p1);
		void _0xAF60E6A2936F982A(int p0, int p1);
		void _0x430A7631A84C9BE7(int p0);
		/// <summary>
		/// Disables collision for this vehicle (maybe it also supports other entities, not sure).
		/// Only world/building/fixed world objects will have their collisions disabled, props, peds, or any other entity still collides with the vehicle.
		/// Example: https://streamable.com/6n45d5
		/// Not sure if there is a native (and if so, which one) that resets the collisions.
		/// </summary>
		void DisableVehicleWorldCollision(int vehicle);
		/// <summary>
		/// Sets some value for vehicle
		/// SET_VEHICLE_*
		/// </summary>
		void _0x8235F1BEAD557629(int vehicle, bool toggle);
		void _0x9640E30A7F395E4B(int vehicle, int p1, int p2, int p3, int p4);
		void _0x0BBB9A7A8FFE931B(int p0, int p1, int p2);
		/// <summary>
		/// Stops the cargobob from being able to attach any vehicle
		/// </summary>
		void SetCargobobHookCanAttach(int vehicle, bool toggle);
		/// <summary>
		/// Sets the amount of bombs that this vehicle has. As far as I know, this does _not_ impact vehicle weapons or the ammo of those weapons in any way, it is just a way to keep track of the amount of bombs in a specific plane.
		/// </summary>
		void SetVehicleBombCount(int vehicle, int bombCount);
		/// <summary>
		/// Gets the amount of bombs that this vehicle has. As far as I know, this does _not_ impact vehicle weapons or the ammo of those weapons in any way, it is just a way to keep track of the amount of bombs in a specific plane.
		/// </summary>
		int GetVehicleBombCount(int vehicle);
		/// <summary>
		/// Similar to 0xF4B2ED59DEB5D774, this sets the amount of countermeasures that are present on this vehicle.
		/// Use 0xF846AA63DF56B804 to get the current amount.
		/// </summary>
		void SetVehicleCountermeasureCount(int vehicle, int counterMeasureCount);
		/// <summary>
		/// Similar to `0xEA12BD130D7569A1`, this gets the amount of countermeasures that are present on this vehicle.
		/// Use 0x9BDA23BF666F0855 to set the current amount.
		/// </summary>
		int GetVehicleCountermeasureCount(int vehicle);
		/// <summary>
		/// Used on helicopters
		/// SET_HELICOPTER_??
		/// </summary>
		void _0x0A3F820A9A9A9AC5(int vehicle, float x, float y, float z);
		/// <summary>
		/// Used in decompiled scripts in combination with _GET_VEHICLE_SUSPENSION_BOUNDS
		/// </summary>
		/// <param name="p7">is usually 2</param>
		/// <param name="p8">is usually 1</param>
		bool _0x51F30DB60626A20E(int vehicle, float x, float y, float z, float rotX, float rotY, float rotZ, int p7, int p8);
		/// <summary>
		/// Sets a flag on heli and another vehicle type.
		/// _SET_VEHICLE_??
		/// </summary>
		void _0x97841634EF7DF1D6(int vehicle, bool toggle);
		void SetVehicleHoverTransformRatio(int vehicle, float ratio);
		/// <summary>
		/// According to decompiled scripts this should work with the `deluxo` and `oppressor2` vehicles.
		/// I've only seen this work for `deluxo` though, can't figure out what it's supposed to do on `oppressor2`.
		/// For the deluxo:
		/// - Set `state` to `0.0`: Fully transform to a 'road' vehicle (non-hover mode).
		/// - Set `state` to `1.0`: Fully transform to a 'flying' vehicle (hover mode).
		/// If you set it to something like 0.5, then something [weird happens](https://streamable.com/p6wmr), you end up in some 50% hover mode, 50% not hover mode.
		/// This doesn't need to be called every tick, just once and the vehicle will transform to that state at the usual transform speed. It'll just stop transforming when it reaches the state you provided.
		/// Once this native is used then players will just be able to hit the vehicle transform key to toggle the transformation cycle; it won't block users from using the key.
		/// </summary>
		void SetVehicleHoverTransformPercentage(int vehicle, float percentage);
		/// <summary>
		/// It will override the ability to transform deluxo. For oppressor it will work just like 0x2D55FE374D5FDB91
		/// </summary>
		void SetVehicleHoverTransformEnabled(int vehicle, bool toggle);
		/// <summary>
		/// Disables "wings" for some flying vehicles. Works only for oppressor _2_ and deluxo.
		/// For deluxo it just immediately removes vehicle's "wings" and you will be not able to fly up.
		/// For oppressor 2 it will remove wings right after you land. And you will not able to fly up anymore too.
		/// But for opressor 2 you still can fly if you somehow get back in the air.
		/// </summary>
		void SetVehicleHoverTransformActive(int vehicle, bool toggle);
		int _0x3A9128352EAC9E85(int p0);
		/// <summary>
		/// Native is significantly more complicated than simply generating a random vector & length.
		/// The 'point' is either 400.0 or 250.0 units away from the Ped's current coordinates; and paths into functions like rage::grcViewport___IsSphereVisible
		/// </summary>
		Vector3 FindRandomPointInSpace(int ped);
		/// <summary>
		/// Only used with the "akula" and "annihilator2" in the decompiled native scripts.
		/// </summary>
		void SetDeployHeliStubWings(int vehicle, bool deploy, bool p2);
		/// <summary>
		/// Only used with the "akula" and "annihilator2" in the decompiled native scripts.
		/// </summary>
		bool AreHeliStubWingsDeployed(int vehicle);
		/// <summary>
		/// Sets some vehicle value
		/// _SET_VEHICLE_?
		/// </summary>
		void _0xAA653AE61924B0A0(int vehicle, bool toggle);
		/// <summary>
		/// Toggles specific flag on turret
		/// </summary>
		void SetVehicleTurretUnk(int vehicle, int index, bool toggle);
		void SetSpecialflightWingRatio(int vehicle, float ratio);
		/// <summary>
		/// Disables turret movement when called in a loop. You can still fire and aim. You cannot shoot backwards though.
		/// </summary>
		void SetDisableTurretMovementThisFrame(int vehicle, int turretId);
		/// <summary>
		/// Sets some vehicle value to 1
		/// SET_VEHICLE_??
		/// </summary>
		void _0x887FA38787DE8C72(int vehicle);
		void SetUnkFloat0x104ForSubmarineVehicleTask(int vehicle, float value);
		void SetUnkBool0x102ForSubmarineVehicleTask(int vehicle, bool value);
		/// <summary>
		/// Does nothing. It's a nullsub.
		/// </summary>
		void _0x36DE109527A2C0C4(bool toggle);
		/// <summary>
		/// Does nothing. It's a nullsub.
		/// </summary>
		void _0x82E0AC411E41A5B4(bool toggle);
		/// <summary>
		/// Does nothing. It's a nullsub.
		/// </summary>
		void _0x99A05839C46CE316(bool toggle);
		bool GetIsVehicleShuntBoostActive(int vehicle);
		/// <summary>
		/// GET_H*
		/// </summary>
		bool _0xE8718FAF591FD224(int vehicle);
		/// <summary>
		/// Returns last vehicle that was rammed by the given vehicle using the shunt boost.
		/// </summary>
		int GetLastRammedVehicle(int vehicle);
		void SetDisableVehicleUnk(bool toggle);
		void SetVehicleNitroEnabled(int vehicle, bool toggle, float level, float power, float rechargeTime, bool disableSound);
		void SetVehicleWheelsDealDamage(int vehicle, bool toggle);
		/// <summary>
		/// Sets some global vehicle related bool
		/// </summary>
		void SetDisableVehicleUnk2(bool toggle);
		void _0x5BBCF35BF6E456F7(bool toggle);
		bool GetDoesVehicleHaveTombstone(int vehicle);
		/// <summary>
		/// Disables detachable bumber from domnator4, dominator5, dominator6, see https://gfycat.com/SecondUnluckyGosling
		/// </summary>
		void HideVehicleTombstone(int vehicle, bool toggle);
		/// <summary>
		/// Returns whether this vehicle is currently disabled by an EMP mine.
		/// </summary>
		bool GetIsVehicleEmpDisabled(int vehicle);
		void _0x8F0D5BA1C2CC91D7(bool toggle);
		/// <summary>
		/// Usable wheels:
		/// 0: wheel_lf
		/// 1: wheel_rf
		/// 2: wheel_lm1
		/// 3: wheel_rm1
		/// 4: wheel_lr
		/// 5: wheel_rr
		/// </summary>
		float GetTyreHealth(int vehicle, int wheelIndex);
		/// <summary>
		/// _SET_TYRE_WEAR_MULTIPLIER must be active, otherwise values set to <1000.0f will default to 350.0f
		/// Usable wheels:
		/// 0: wheel_lf
		/// 1: wheel_rf
		/// 2: wheel_lm1
		/// 3: wheel_rm1
		/// 4: wheel_lr
		/// 5: wheel_rr
		/// </summary>
		void SetTyreHealth(int vehicle, int wheelIndex, float health);
		/// <summary>
		/// Returns the multiplier value from _SET_TYRE_WEAR_MULTIPLIER
		/// Usable wheels:
		/// 0: wheel_lf
		/// 1: wheel_rf
		/// 2: wheel_lm1
		/// 3: wheel_rm1
		/// 4: wheel_lr
		/// 5: wheel_rr
		/// </summary>
		float GetTyreWearMultiplier(int vehicle, int wheelIndex);
		/// <summary>
		/// Needs to be run for tire wear to work. Multiplier affects the downforce and how fast the tires will wear out, higher values essentially make the vehicle slower on straights and its tires will wear down quicker when cornering. Value must be >0f.
		/// Default value in Rockstar's Open Wheel Race JSON's ("owrtws", "owrtwm", "owrtwh") is 1.0
		/// Usable wheels:
		/// 0: wheel_lf
		/// 1: wheel_rf
		/// 2: wheel_lm1
		/// 3: wheel_rm1
		/// 4: wheel_lr
		/// 5: wheel_rr
		/// </summary>
		void SetTyreWearMultiplier(int vehicle, int wheelIndex, float multiplier);
		/// <summary>
		/// Controls how much traction the wheel loses.
		/// Default values from Rockstar's Open Wheel Race JSON's:
		/// "owrtds" (Soft): 0.05
		/// "owrtdm" (Medium): 0.45
		/// "owrtdh" (Hard): 0.8
		/// Usable wheels:
		/// 0: wheel_lf
		/// 1: wheel_rf
		/// 2: wheel_lm1
		/// See NativeDB for reference: http://natives.altv.mp/#/0xC970D0E0FC31D768
		/// </summary>
		void SetTyreTractionLossMultiplier(int vehicle, int wheelIndex, float multiplier);
		void _0xF8B49F5BA7F850E7(int vehicle, int p1);
		/// <summary>
		/// Lowers the vehicle's stance. Only works for vehicles that support this feature.
		/// </summary>
		void SetReduceDriftVehicleSuspension(int vehicle, bool enable);
		void SetDriftTyresEnabled(int vehicle, bool toggle);
		bool GetDriftTyresEnabled(int vehicle);
		/// <summary>
		/// Implemented only for trains.
		/// </summary>
		void NetworkUseHighPrecisionVehicleBlending(int vehicle, bool toggle);
		/// <summary>
		/// This function set height to the value of z-axis of the water surface.
		/// note: seems to return true when you are in water
		/// </summary>
		/// <returns>This function works with sea and lake. However it does not work with shallow rivers (e.g. raton canyon will return -100000.0f)</returns>
		bool GetWaterHeight(float x, float y, float z, ref float height);
		/// <summary>
		/// </summary>
		bool GetWaterHeightNoWaves(float x, float y, float z, ref float height);
		/// <summary>
		/// </summary>
		bool TestProbeAgainstWater(float x1, float y1, float z1, float x2, float y2, float z2, ref Vector3 result);
		bool TestProbeAgainstAllWater(int p0, int p1, int p2, int p3, int p4, int p5, int p6, int p7);
		/// <summary>
		/// </summary>
		bool TestVerticalProbeAgainstAllWater(float x, float y, float z, int p3, ref float height);
		/// <summary>
		/// Sets the water height for a given position and radius.
		/// </summary>
		void ModifyWater(float x, float y, float radius, float height);
		/// <summary>
		/// Most likely ADD_CURRENT_*
		/// </summary>
		int AddCurrentRise(float xLow, float yLow, float xHigh, float yHigh, float height);
		/// <summary>
		/// Most likely REMOVE_CURRENT_*
		/// </summary>
		/// <param name="p0">is the handle returned from _0xFDBF4CDBC07E1706</param>
		void RemoveCurrentRise(int p0);
		/// <summary>
		/// Sets a value that determines how aggressive the ocean waves will be. Values of 2.0 or more make for very aggressive waves like you see during a thunderstorm.
		/// Works only ~200 meters around the player.
		/// </summary>
		void SetDeepOceanScaler(float intensity);
		/// <summary>
		/// Gets the aggressiveness factor of the ocean waves.
		/// </summary>
		float GetDeepOceanScaler();
		void _0x547237AA71AB44DE(float p0);
		/// <summary>
		/// Sets the waves intensity back to original (1.0 in most cases).
		/// </summary>
		void ResetDeepOceanScaler();
		/// <summary>
		/// Enables laser sight on any weapon.
		/// It doesn't work. Neither on tick nor OnKeyDown
		/// </summary>
		void EnableLaserSightRendering(bool toggle);
		int GetWeaponComponentTypeModel(int componentHash);
		/// <summary>
		/// Returns the model of any weapon.
		/// Can also take an ammo hash?
		/// sub_6663a(&l_115B, WEAPON::GET_WEAPONTYPE_MODEL(${ammo_rpg}));
		/// </summary>
		int GetWeapontypeModel(int weaponHash);
		int GetWeapontypeSlot(int weaponHash);
		int GetWeapontypeGroup(int weaponHash);
		/// <summary>
		/// Returns the amount of extra components the specified component has.
		/// Returns -1 if the component isn't of type CWeaponComponentVariantModel.
		/// </summary>
		int GetWeaponComponentVariantExtraComponentCount(int componentHash);
		/// <summary>
		/// Returns the model hash of the extra component at specified index.
		/// </summary>
		int GetWeaponComponentVariantExtraComponentModel(int componentHash, int extraComponentIndex);
		void SetCurrentPedWeapon(int ped, int weaponHash, bool bForceInHand);
		/// <summary>
		/// p2 is not implemented
		/// disassembly said that?
		/// </summary>
		/// <param name="p2">seems to be 1 most of the time.</param>
		/// <returns>The return value seems to indicate returns true if the hash of the weapon object weapon equals the weapon hash.</returns>
		bool GetCurrentPedWeapon(int ped, ref int weaponHash, bool p2);
		int GetCurrentPedWeaponEntityIndex(int ped, int p1);
		/// <summary>
		/// </summary>
		/// <param name="p1">is always 0 in the scripts.</param>
		int GetBestPedWeapon(int ped, bool p1);
		bool SetCurrentPedVehicleWeapon(int ped, int weaponHash);
		/// <summary>
		/// Example in VB
		/// Public Shared Function GetVehicleCurrentWeapon(Ped As Ped) As Integer
		/// Dim arg As New OutputArgument()
		/// Native.Function.Call(Hash.GET_CURRENT_PED_VEHICLE_WEAPON, Ped, arg)
		/// End Function
		/// Usage:
		/// If GetVehicleCurrentWeapon(Game.Player.Character) = -821520672 Then ...Do something
		/// Note: -821520672 = VEHICLE_WEAPON_PLANE_ROCKET
		/// </summary>
		/// <returns>        Return arg.GetResult(Of Integer)()</returns>
		bool GetCurrentPedVehicleWeapon(int ped, ref int weaponHash);
		/// <summary>
		/// SET_PED_*
		/// </summary>
		void _0x50276EF8172F5F12(int ped);
		/// <summary>
		/// Checks if the ped is currently equipped with a weapon matching a bit specified using a bitwise-or in typeFlags.
		/// Type flag bit values:
		/// 1 = Melee weapons
		/// 2 = Explosive weapons
		/// 4 = Any other weapons
		/// Not specifying any bit will lead to the native *always* returning 'false', and for example specifying '4 | 2' will check for any weapon except fists and melee weapons.
		/// 6 returns true if you are equipped with any weapon except melee weapons.
		/// 5 returns true if you are equipped with any weapon except the Explosives weapon group.
		/// 4 returns true if you are equipped with any weapon except Explosives weapon group AND melee weapons.
		/// See NativeDB for reference: http://natives.altv.mp/#/0x475768A975D5AD17
		/// </summary>
		/// <returns>7 returns true if you are equipped with any weapon except your fists.</returns>
		bool IsPedArmed(int ped, int typeFlags);
		bool IsWeaponValid(int weaponHash);
		/// <summary>
		/// Bool does not check if the weapon is current equipped, unfortunately.
		/// </summary>
		/// <param name="p2">should be FALSE, otherwise it seems to always return FALSE</param>
		/// <returns>p2 should be FALSE, otherwise it seems to always return FALSE</returns>
		bool HasPedGotWeapon(int ped, int weaponHash, bool p2);
		bool IsPedWeaponReadyToShoot(int ped);
		int GetPedWeapontypeInSlot(int ped, int weaponSlot);
		/// <summary>
		/// WEAPON::GET_AMMO_IN_PED_WEAPON(PLAYER::PLAYER_PED_ID(), a_0)
		/// From decompiled scripts
		/// Returns total ammo in weapon
		/// GTALua Example :
		/// natives.WEAPON.GET_AMMO_IN_PED_WEAPON(plyPed, WeaponHash)
		/// </summary>
		int GetAmmoInPedWeapon(int ped, int weaponhash);
		void AddAmmoToPed(int ped, int weaponHash, int ammo);
		void SetPedAmmo(int ped, int weaponHash, int ammo, bool p3);
		void SetPedInfiniteAmmo(int ped, bool toggle, int weaponHash);
		void SetPedInfiniteAmmoClip(int ped, bool toggle);
		void _0x24C024BA8379A70A(int p0, int p1);
		void GiveWeaponToPed(int ped, int weaponHash, int ammoCount, bool isHidden, bool bForceInHand);
		/// <summary>
		/// Gives a weapon to PED with a delay, example:
		/// WEAPON::GIVE_DELAYED_WEAPON_TO_PED(PED::PLAYER_PED_ID(), MISC::GET_HASH_KEY("WEAPON_PISTOL"), 1000, false)
		/// </summary>
		void GiveDelayedWeaponToPed(int ped, int weaponHash, int ammoCount, bool bForceInHand);
		/// <summary>
		/// setting the last params to false it does that same so I would suggest its not a toggle
		/// </summary>
		void RemoveAllPedWeapons(int ped, bool p1);
		/// <summary>
		/// This native removes a specified weapon from your selected ped.
		/// Weapon Hashes: pastebin.com/0wwDZgkF
		/// Example:
		/// C#:
		/// Function.Call(Hash.REMOVE_WEAPON_FROM_PED, Game.Player.Character, 0x99B507EA);
		/// C++:
		/// WEAPON::REMOVE_WEAPON_FROM_PED(PLAYER::PLAYER_PED_ID(), 0x99B507EA);
		/// The code above removes the knife from the player.
		/// </summary>
		void RemoveWeaponFromPed(int ped, int weaponHash);
		/// <summary>
		/// Hides the players weapon during a cutscene.
		/// </summary>
		void HidePedWeaponForScriptedCutscene(int ped, bool toggle);
		/// <summary>
		/// Has 5 parameters since latest patches.
		/// </summary>
		void SetPedCurrentWeaponVisible(int ped, bool visible, bool deselectWeapon, bool p3, bool p4);
		void SetPedDropsWeaponsWhenDead(int ped, bool toggle);
		/// <summary>
		/// It determines what weapons caused damage:
		/// If you want to define only a specific weapon, second parameter=weapon hash code, third parameter=0
		/// If you want to define any melee weapon, second parameter=0, third parameter=1.
		/// If you want to identify any weapon (firearms, melee, rockets, etc.), second parameter=0, third parameter=2.
		/// </summary>
		bool HasPedBeenDamagedByWeapon(int ped, int weaponHash, int weaponType);
		/// <summary>
		/// Does NOT seem to work with HAS_PED_BEEN_DAMAGED_BY_WEAPON. Use CLEAR_ENTITY_LAST_WEAPON_DAMAGE and HAS_ENTITY_BEEN_DAMAGED_BY_WEAPON instead.
		/// </summary>
		void ClearPedLastWeaponDamage(int ped);
		/// <summary>
		/// It determines what weapons caused damage:
		/// If you want to define only a specific weapon, second parameter=weapon hash code, third parameter=0
		/// If you want to define any melee weapon, second parameter=0, third parameter=1.
		/// If you want to identify any weapon (firearms, melee, rockets, etc.), second parameter=0, third parameter=2.
		/// </summary>
		bool HasEntityBeenDamagedByWeapon(int entity, int weaponHash, int weaponType);
		void ClearEntityLastWeaponDamage(int entity);
		void SetPedDropsWeapon(int ped);
		void SetPedDropsInventoryWeapon(int ped, int weaponHash, float xOffset, float yOffset, float zOffset, int ammoCount);
		/// <summary>
		/// </summary>
		/// <param name="p2">is mostly 1 in the scripts.</param>
		int GetMaxAmmoInClip(int ped, int weaponHash, bool p2);
		/// <summary>
		/// </summary>
		bool GetAmmoInClip(int ped, int weaponHash, ref int ammo);
		bool SetAmmoInClip(int ped, int weaponHash, int ammo);
		/// <summary>
		/// </summary>
		bool GetMaxAmmo(int ped, int weaponHash, ref int ammo);
		/// <summary>
		/// Returns the max ammo for an ammo type. Ammo types: https://gist.github.com/root-cause/faf41f59f7a6d818b7db0b839bd147c1
		/// </summary>
		bool GetMaxAmmoByType(int ped, int ammoTypeHash, ref int ammo);
		/// <summary>
		/// </summary>
		/// <param name="ammo">types: https://gist.github.com/root-cause/faf41f59f7a6d818b7db0b839bd147c1</param>
		void AddAmmoToPedByType(int ped, int ammoTypeHash, int ammo);
		/// <summary>
		/// </summary>
		/// <param name="ammo">types: https://gist.github.com/root-cause/faf41f59f7a6d818b7db0b839bd147c1</param>
		void SetPedAmmoByType(int ped, int ammoTypeHash, int ammo);
		int GetPedAmmoByType(int ped, int ammoTypeHash);
		void SetPedAmmoToDrop(int ped, int p1);
		void SetPickupAmmoAmountScaler(float p0);
		/// <summary>
		/// Returns the current ammo type of the specified ped's specified weapon.
		/// Use 0xF489B44DD5AF4BD9 if you always want AMMO_PISTOL.
		/// </summary>
		/// <returns>MkII magazines will change the return value, like Pistol MkII returning AMMO_PISTOL without any components and returning AMMO_PISTOL_TRACER after Tracer Rounds component is attached.</returns>
		int GetPedAmmoTypeFromWeapon(int ped, int weaponHash);
		/// <summary>
		/// Returns the base/default ammo type of the specified ped's specified weapon.
		/// Use GET_PED_AMMO_TYPE_FROM_WEAPON if you want current ammo type (like AMMO_MG_INCENDIARY/AMMO_MG_TRACER while using MkII magazines) and use this if you want base ammo type. (AMMO_MG)
		/// </summary>
		int GetPedAmmoTypeFromWeapon2(int ped, int weaponHash);
		/// <summary>
		/// Pass ped. Pass address of Vector3.
		/// The coord will be put into the Vector3.
		/// </summary>
		/// <returns>The return will determine whether there was a coord found or not.</returns>
		bool GetPedLastWeaponImpactCoord(int ped, ref Vector3 coords);
		/// <summary>
		/// p1/gadgetHash was always 0xFBAB5776 ("GADGET_PARACHUTE").
		/// </summary>
		/// <param name="p2">is always true.</param>
		void SetPedGadget(int ped, int gadgetHash, bool p2);
		/// <summary>
		/// </summary>
		/// <param name="gadgetHash">- was always 0xFBAB5776 ("GADGET_PARACHUTE").</param>
		bool GetIsPedGadgetEquipped(int ped, int gadgetHash);
		/// <summary>
		/// Returns the hash of the weapon.
		/// var num7 = WEAPON::GET_SELECTED_PED_WEAPON(num4);
		/// sub_27D3(num7);
		/// switch (num7)
		/// {
		/// case 0x24B17070:
		/// Also see WEAPON::GET_CURRENT_PED_WEAPON. Difference?
		/// -------------------------------------------------------------------------
		/// </summary>
		/// <returns>The difference is that GET_SELECTED_PED_WEAPON simply returns the ped's current weapon hash but GET_CURRENT_PED_WEAPON also checks the weapon object and returns true if the hash of the weapon object equals the weapon hash</returns>
		int GetSelectedPedWeapon(int ped);
		/// <summary>
		/// WEAPON::EXPLODE_PROJECTILES(PLAYER::PLAYER_PED_ID(), func_221(0x00000003), 0x00000001);
		/// </summary>
		void ExplodeProjectiles(int ped, int weaponHash, bool p2);
		/// <summary>
		/// If `explode` true, then removal is done through exploding the projectile. Basically the same as EXPLODE_PROJECTILES but without defining the owner ped.
		/// </summary>
		void RemoveAllProjectilesOfType(int weaponHash, bool explode);
		float GetLockonDistanceOfCurrentPedWeapon(int ped);
		float GetMaxRangeOfCurrentPedWeapon(int ped);
		/// <summary>
		/// Third Parameter = unsure, but pretty sure it is weapon hash
		/// --> get_hash_key("weapon_stickybomb")
		/// Fourth Parameter = unsure, almost always -1
		/// </summary>
		bool HasVehicleGotProjectileAttached(int driver, int vehicle, int weaponHash, int p3);
		void GiveWeaponComponentToPed(int ped, int weaponHash, int componentHash);
		void RemoveWeaponComponentFromPed(int ped, int weaponHash, int componentHash);
		bool HasPedGotWeaponComponent(int ped, int weaponHash, int componentHash);
		bool IsPedWeaponComponentActive(int ped, int weaponHash, int componentHash);
		bool RefillAmmoInstantly(int ped);
		/// <summary>
		/// Forces a ped to reload only if they are able to; if they have a full magazine, they will not reload.
		/// </summary>
		bool MakePedReload(int ped);
		/// <summary>
		/// Nearly every instance of p1 I found was 31. Nearly every instance of p2 I found was 0.
		/// REQUEST_WEAPON_ASSET(iLocal_1888, 31, 26);
		/// </summary>
		void RequestWeaponAsset(int weaponHash, int p1, int p2);
		bool HasWeaponAssetLoaded(int weaponHash);
		void RemoveWeaponAsset(int weaponHash);
		/// <summary>
		/// Now has 8 params.
		/// </summary>
		int CreateWeaponObject(int weaponHash, int ammoCount, float x, float y, float z, bool showWorldModel, float scale, int p7, int p8, int p9);
		/// <summary>
		/// (use WEAPON::GET_WEAPON_COMPONENT_TYPE_MODEL() to get hash value)
		/// ${component_at_ar_flsh}, ${component_at_ar_supp}, ${component_at_pi_flsh}, ${component_at_scope_large}, ${component_at_ar_supp_02}
		/// </summary>
		void GiveWeaponComponentToWeaponObject(int weaponObject, int addonHash);
		void RemoveWeaponComponentFromWeaponObject(int p0, int p1);
		bool HasWeaponGotWeaponComponent(int weapon, int addonHash);
		void GiveWeaponObjectToPed(int weaponObject, int ped);
		bool DoesWeaponTakeWeaponComponent(int weaponHash, int componentHash);
		/// <summary>
		/// Unknown behavior when unarmed.
		/// </summary>
		/// <returns>Drops the current weapon and returns the object</returns>
		int GetWeaponObjectFromPed(int ped, bool p1);
		/// <summary>
		/// GIVE_*
		/// </summary>
		void GiveLoadoutToPed(int ped, int loadoutHash);
		/// <summary>
		/// 0 - Normal
		/// 1 - Green
		/// 2 - Gold
		/// 3 - Pink
		/// 4 - Army
		/// 5 - LSPD
		/// 6 - Orange
		/// 7 - Platinum
		/// </summary>
		/// <param name="tintIndex">can be the following:</param>
		void SetPedWeaponTintIndex(int ped, int weaponHash, int tintIndex);
		int GetPedWeaponTintIndex(int ped, int weaponHash);
		void SetWeaponObjectTintIndex(int weapon, int tintIndex);
		int GetWeaponObjectTintIndex(int weapon);
		int GetWeaponTintCount(int weaponHash);
		/// <summary>
		/// Colors:
		/// 0 = Gray
		/// 1 = Dark Gray
		/// 2 = Black
		/// 3 = White
		/// 4 = Blue
		/// 5 = Cyan
		/// 6 = Aqua
		/// 7 = Cool Blue
		/// See NativeDB for reference: http://natives.altv.mp/#/0x9FE5633880ECD8ED
		/// </summary>
		void SetPedWeaponLiveryColor(int ped, int weaponHash, int camoComponentHash, int colorIndex);
		/// <summary>
		/// Returns -1 if camoComponentHash is invalid/not attached to the weapon.
		/// </summary>
		int GetPedWeaponLiveryColor(int ped, int weaponHash, int camoComponentHash);
		/// <summary>
		/// Colors:
		/// 0 = Gray
		/// 1 = Dark Gray
		/// 2 = Black
		/// 3 = White
		/// 4 = Blue
		/// 5 = Cyan
		/// 6 = Aqua
		/// 7 = Cool Blue
		/// See NativeDB for reference: http://natives.altv.mp/#/0x5DA825A85D0EA6E6
		/// </summary>
		void SetWeaponObjectLiveryColor(int weaponObject, int camoComponentHash, int colorIndex);
		/// <summary>
		/// Returns -1 if camoComponentHash is invalid/not attached to the weapon object.
		/// </summary>
		int GetWeaponObjectLiveryColor(int weaponObject, int camoComponentHash);
		/// <summary>
		/// GET_PED_WEAPON_*
		/// </summary>
		int _0xA2C9AC24B4061285(int ped, int weaponHash);
		/// <summary>
		/// SET_WEAPON_OBJECT_*
		/// </summary>
		void _0x977CA98939E82E4B(int weaponObject, int p1);
		/// <summary>
		/// struct WeaponHudStatsData
		/// {
		/// BYTE hudDamage; // 0x0000
		/// char _0x0001[0x7]; // 0x0001
		/// BYTE hudSpeed; // 0x0008
		/// char _0x0009[0x7]; // 0x0009
		/// BYTE hudCapacity; // 0x0010
		/// char _0x0011[0x7]; // 0x0011
		/// BYTE hudAccuracy; // 0x0018
		/// See NativeDB for reference: http://natives.altv.mp/#/0xD92C739EE34C9EBA
		/// </summary>
		bool GetWeaponHudStats(int weaponHash, ref int outData);
		/// <summary>
		/// </summary>
		bool GetWeaponComponentHudStats(int componentHash, ref int outData);
		/// <summary>
		/// </summary>
		/// <returns>This native does not return damages of weapons from the melee and explosive group.</returns>
		float GetWeaponDamage(int weaponHash, int componentHash);
		/// <summary>
		/// Use it like this:
		/// char cClipSize[32];
		/// Hash cur;
		/// if (WEAPON::GET_CURRENT_PED_WEAPON(playerPed, &cur, 1))
		/// {
		/// if (WEAPON::IS_WEAPON_VALID(cur))
		/// {
		/// int iClipSize = WEAPON::GET_WEAPON_CLIP_SIZE(cur);
		/// sprintf_s(cClipSize, "ClipSize: %.d", iClipSize);
		/// See NativeDB for reference: http://natives.altv.mp/#/0x583BE370B1EC6EB4
		/// </summary>
		/// <returns>// Returns the size of the default weapon component clip.</returns>
		int GetWeaponClipSize(int weaponHash);
		float GetWeaponTimeBetweenShots(int weaponHash);
		void SetPedChanceOfFiringBlanks(int ped, float xBias, float yBias);
		/// <summary>
		/// Returns handle of the projectile.
		/// </summary>
		int SetPedShootOrdnanceWeapon(int ped, float p1);
		void RequestWeaponHighDetailModel(int weaponObject);
		/// <summary>
		/// Changes the weapon damage output by the given multiplier value. Must be run every frame.
		/// </summary>
		void SetWeaponDamageModifierThisFrame(int weaponHash, float damageMultiplier);
		void SetWeaponExplosionRadiusMultiplier(int weaponHash, float multiplier);
		void _0xE6D2CEDD370FF98E(int p0, int p1);
		/// <summary>
		/// </summary>
		/// <param name="ped">ped = The ped whose weapon you want to check.</param>
		/// <returns>This native returns a true or false value.</returns>
		bool IsPedCurrentWeaponSilenced(int ped);
		bool IsFlashLightOn(int ped);
		int SetFlashLightFadeDistance(float distance);
		/// <summary>
		/// Enables/disables flashlight on ped's weapon.
		/// </summary>
		void SetFlashLightEnabled(int ped, bool toggle);
		/// <summary>
		/// Changes the selected ped aiming animation style.
		/// Note : You must use GET_HASH_KEY!
		/// Strings to use with GET_HASH_KEY :
		/// "Ballistic",
		/// "Default",
		/// "Fat",
		/// "Female",
		/// "FirstPerson",
		/// "FirstPersonAiming",
		/// See NativeDB for reference: http://natives.altv.mp/#/0x1055AC3A667F09D9
		/// </summary>
		void SetWeaponAnimationOverride(int ped, int animStyle);
		/// <summary>
		/// 0=unknown (or incorrect weaponHash)
		/// 1= no damage (flare,snowball, petrolcan)
		/// 2=melee
		/// 3=bullet
		/// 4=force ragdoll fall
		/// 5=explosive (RPG, Railgun, grenade)
		/// 6=fire(molotov)
		/// 8=fall(WEAPON_HELI_CRASH)
		/// 10=electric
		/// See NativeDB for reference: http://natives.altv.mp/#/0x3BE0BB12D25FB305
		/// </summary>
		int GetWeaponDamageType(int weaponHash);
		void _0xE4DCEC7FD5B739A5(int ped);
		/// <summary>
		/// </summary>
		/// <returns>this returns if you can use the weapon while using a parachute</returns>
		bool CanUseWeaponOnParachute(int weaponHash);
		/// <summary>
		/// Both coordinates are from objects in the decompiled scripts. Native related to 0xECDC202B25E5CF48 p1 value. The only weapon hash used in the decompiled scripts is weapon_air_defence_gun. These two natives are used by the yacht script, decompiled scripts suggest it and the weapon hash used (valkyrie's rockets) are also used by yachts.
		/// </summary>
		int CreateAirDefenseSphere(float x, float y, float z, float radius, float p4, float p5, float p6, int weaponHash);
		int CreateAirDefenseArea(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, int weaponHash);
		bool RemoveAirDefenseZone(int zoneId);
		void RemoveAllAirDefenseZones();
		void SetPlayerAirDefenseZoneFlag(int player, int zoneId, bool enable);
		/// <summary>
		/// </summary>
		bool IsAnyAirDefenseZoneInsideSphere(float x, float y, float z, float radius, ref int outZoneId);
		void FireAirDefenseWeapon(int zoneId, float x, float y, float z);
		bool DoesAirDefenseZoneExist(int zoneId);
		/// <summary>
		/// Disables selecting the given weapon. Ped isn't forced to put the gun away. However you can't reselect the weapon if you holster then unholster. Weapon is also grayed out on the weapon wheel.
		/// </summary>
		void SetCanPedEquipWeapon(int ped, int weaponHash, bool toggle);
		/// <summary>
		/// Disable all weapons. Does the same as 0xB4771B9AAF4E68E4 except for all weapons.
		/// </summary>
		void SetCanPedEquipAllWeapons(int ped, bool toggle);
		int GetZoneAtCoords(float x, float y, float z);
		/// <summary>
		/// 'zoneName' corresponds to an entry in 'popzone.ipl'.
		/// AIRP = Los Santos International Airport
		/// ALAMO = Alamo Sea
		/// ALTA = Alta
		/// ARMYB = Fort Zancudo
		/// BANHAMC = Banham Canyon Dr
		/// BANNING = Banning
		/// BEACH = Vespucci Beach
		/// BHAMCA = Banham Canyon
		/// See NativeDB for reference: http://natives.altv.mp/#/0x98CD1D2934B76CC1
		/// </summary>
		int GetZoneFromNameId(string zoneName);
		int GetZonePopschedule(int zoneId);
		/// <summary>
		/// AIRP = Los Santos International Airport
		/// ALAMO = Alamo Sea
		/// ALTA = Alta
		/// ARMYB = Fort Zancudo
		/// BANHAMC = Banham Canyon Dr
		/// BANNING = Banning
		/// BEACH = Vespucci Beach
		/// BHAMCA = Banham Canyon
		/// BRADP = Braddock Pass
		/// See NativeDB for reference: http://natives.altv.mp/#/0xCD90657D4C30E1CA
		/// </summary>
		string GetNameOfZone(float x, float y, float z);
		void SetZoneEnabled(int zoneId, bool toggle);
		/// <summary>
		/// cellphone range 1- 5 used for signal bar in iFruit phone
		/// </summary>
		int GetZoneScumminess(int zoneId);
		/// <summary>
		/// Only used once in the decompiled scripts. Seems to be related to scripted vehicle generators.
		/// Modified example from "am_imp_exp.c4", line 6406:
		/// popSchedules[0] = ZONE::GET_ZONE_POPSCHEDULE(ZONE::GET_ZONE_AT_COORDS(891.3, 807.9, 188.1));
		/// etc.
		/// 
		/// ZONE::OVERRIDE_POPSCHEDULE_VEHICLE_MODEL(popSchedules[index], vehicleHash);
		/// STREAMING::REQUEST_MODEL(vehicleHash);
		/// </summary>
		void OverridePopscheduleVehicleModel(int scheduleId, int vehicleHash);
		/// <summary>
		/// Only used once in the decompiled scripts. Seems to be related to scripted vehicle generators.
		/// Modified example from "am_imp_exp.c4", line 6418:
		/// popSchedules[0] = ZONE::GET_ZONE_POPSCHEDULE(ZONE::GET_ZONE_AT_COORDS(891.3, 807.9, 188.1));
		/// etc.
		/// 
		/// STREAMING::SET_MODEL_AS_NO_LONGER_NEEDED(vehicleHash);
		/// ZONE::CLEAR_POPSCHEDULE_OVERRIDE_VEHICLE_MODEL(popSchedules[index]);
		/// </summary>
		void ClearPopscheduleOverrideVehicleModel(int scheduleId);
		/// <summary>
		/// Returns a hash representing which part of the map the given coords are located.
		/// (Hash of) city -> -289320599
		/// (Hash of) countryside -> 2072609373
		/// C# Example :
		/// Ped player = Game.Player.Character;
		/// </summary>
		/// <param name="x">Function.Call<Hash>(Hash.GET_HASH_OF_MAP_AREA_AT_COORDS, player.Position.X, player.Position.Y, player.Position.Z);</param>
		/// <param name="y">Function.Call<Hash>(Hash.GET_HASH_OF_MAP_AREA_AT_COORDS, player.Position.X, player.Position.Y, player.Position.Z);</param>
		/// <returns>Possible return values:</returns>
		int GetHashOfMapAreaAtCoords(float x, float y, float z);
	}

	public unsafe class Natives : INatives
	{
		private IntPtr handle;
		private delegate* unmanaged[Cdecl]<nint, void> freeString;
		private delegate* unmanaged[Cdecl]<int, void> fn__wait;
		private delegate* unmanaged[Cdecl]<nint, int, int> fn__startNewScript;
		private delegate* unmanaged[Cdecl]<nint, int*, int, int, int> fn__startNewScriptWithArgs;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__startNewScriptWithNameHash;
		private delegate* unmanaged[Cdecl]<int, int*, int, int, int> fn__startNewScriptWithNameHashAndArgs;
		private delegate* unmanaged[Cdecl]<int> fn__timera;
		private delegate* unmanaged[Cdecl]<int> fn__timerb;
		private delegate* unmanaged[Cdecl]<int, void> fn__settimera;
		private delegate* unmanaged[Cdecl]<int, void> fn__settimerb;
		private delegate* unmanaged[Cdecl]<float> fn__timestep;
		private delegate* unmanaged[Cdecl]<float, float> fn__sin;
		private delegate* unmanaged[Cdecl]<float, float> fn__cos;
		private delegate* unmanaged[Cdecl]<float, float> fn__sqrt;
		private delegate* unmanaged[Cdecl]<float, float, float> fn__pow;
		private delegate* unmanaged[Cdecl]<float, float> fn__log10;
		private delegate* unmanaged[Cdecl]<float, float, float, float> fn__vmag;
		private delegate* unmanaged[Cdecl]<float, float, float, float> fn__vmag2;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float> fn__vdist;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float> fn__vdist2;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__shiftLeft;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__shiftRight;
		private delegate* unmanaged[Cdecl]<float, int> fn__floor;
		private delegate* unmanaged[Cdecl]<float, int> fn__ceil;
		private delegate* unmanaged[Cdecl]<float, int> fn__round;
		private delegate* unmanaged[Cdecl]<int, float> fn__toFloat;
		private delegate* unmanaged[Cdecl]<int, void> fn__setThreadPriority;
		private delegate* unmanaged[Cdecl]<bool> fn__appDataValid;
		private delegate* unmanaged[Cdecl]<nint, int> fn__appGetInt;
		private delegate* unmanaged[Cdecl]<nint, float> fn__appGetFloat;
		private delegate* unmanaged[Cdecl]<nint, nint> fn__appGetString;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__appSetInt;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__appSetFloat;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__appSetString;
		private delegate* unmanaged[Cdecl]<nint, void> fn__appSetApp;
		private delegate* unmanaged[Cdecl]<nint, void> fn__appSetBlock;
		private delegate* unmanaged[Cdecl]<void> fn__appClearBlock;
		private delegate* unmanaged[Cdecl]<void> fn__appCloseApp;
		private delegate* unmanaged[Cdecl]<void> fn__appCloseBlock;
		private delegate* unmanaged[Cdecl]<bool> fn__appHasLinkedSocialClubAccount;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__appHasSyncedData;
		private delegate* unmanaged[Cdecl]<void> fn__appSaveData;
		private delegate* unmanaged[Cdecl]<int> fn__appGetDeletedFileStatus;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__appDeleteAppData;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setDebugLinesAndSpheresDrawingActive;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void> fn__drawDebugLine;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int, int, int, int, int, void> fn__drawDebugLineWithTwoColours;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int, void> fn__drawDebugSphere;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void> fn__drawDebugBox;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int, void> fn__drawDebugCross;
		private delegate* unmanaged[Cdecl]<nint, float, float, float, int, int, int, int, void> fn__drawDebugText;
		private delegate* unmanaged[Cdecl]<nint, float, float, float, int, int, int, int, void> fn__drawDebugText2d;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int, void> fn__drawLine;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, int, int, int, int, void> fn__drawPoly;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, int, int, int, int, nint, nint, float, float, float, float, float, float, float, float, float, void> fn__drawSpritePoly;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, int, float, float, float, int, float, float, float, int, nint, nint, float, float, float, float, float, float, float, float, float, void> fn__drawSpritePoly2;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int, void> fn__drawBox;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setBackfaceculling;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC5C8F970D4EDFF71;
		private delegate* unmanaged[Cdecl]<int> fn__beginTakeMissionCreatorPhoto;
		private delegate* unmanaged[Cdecl]<int> fn__getStatusOfTakeMissionCreatorPhoto;
		private delegate* unmanaged[Cdecl]<void> fn__freeMemoryForMissionCreatorPhoto;
		private delegate* unmanaged[Cdecl]<int*, int, int, int, bool> fn__loadMissionCreatorPhoto;
		private delegate* unmanaged[Cdecl]<int*, int> fn__getStatusOfLoadMissionCreatorPhoto;
		private delegate* unmanaged[Cdecl]<int> fn__0x7FA5D82B8F58EC06;
		private delegate* unmanaged[Cdecl]<int> fn__0x5B0316762AFD4A64;
		private delegate* unmanaged[Cdecl]<void> fn__0x346EF3ECAAAB149E;
		private delegate* unmanaged[Cdecl]<bool> fn__beginTakeHighQualityPhoto;
		private delegate* unmanaged[Cdecl]<int> fn__getStatusOfTakeHighQualityPhoto;
		private delegate* unmanaged[Cdecl]<void> fn__freeMemoryForHighQualityPhoto;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x1BBC135A4D25EDDE;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xF3F776ADA161E47D;
		private delegate* unmanaged[Cdecl]<int, bool> fn__saveHighQualityPhoto;
		private delegate* unmanaged[Cdecl]<int> fn__getStatusOfSaveHighQualityPhoto;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x759650634F07B6B4;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xCB82A0BF0E3E3265;
		private delegate* unmanaged[Cdecl]<void> fn__freeMemoryForLowQualityPhoto;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__drawLowQualityPhotoToPhone;
		private delegate* unmanaged[Cdecl]<int> fn__getMaximumNumberOfPhotos;
		private delegate* unmanaged[Cdecl]<int> fn__getMaximumNumberOfCloudPhotos;
		private delegate* unmanaged[Cdecl]<int> fn__getCurrentNumberOfCloudPhotos;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x2A893980E96B659A;
		private delegate* unmanaged[Cdecl]<int, int> fn__getStatusOfSortedListOperation;
		private delegate* unmanaged[Cdecl]<void> fn__0x4AF92ACD3141D96C;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xE791DF1F73ED2C8B;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xEC72C258667BE5EA;
		private delegate* unmanaged[Cdecl]<int, int> fn__returnTwo;
		private delegate* unmanaged[Cdecl]<float, float, float, int, int, int, float, float, float, void> fn__drawLightWithRangeAndShadow;
		private delegate* unmanaged[Cdecl]<float, float, float, int, int, int, float, float, void> fn__drawLightWithRange;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, float, float, float, float, float, void> fn__drawSpotLight;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, float, float, float, float, float, int, void> fn__drawSpotLightWithShadow;
		private delegate* unmanaged[Cdecl]<float, void> fn__fadeUpPedLight;
		private delegate* unmanaged[Cdecl]<int, void> fn__updateLightsOnEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x9641588DAB93B4B5;
		private delegate* unmanaged[Cdecl]<int> fn__0x393BD2275CEB7793;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, int, int, int, int, bool, bool, int, bool, nint, nint, bool, void> fn__drawMarker;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, int, int, int, int, bool, bool, int, bool, nint, nint, bool, bool, bool, void> fn__drawMarker2;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, float, void> fn__drawSphere;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int, int, int, int, int, int> fn__createCheckpoint;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCheckpointScale;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCheckpointIconScale;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setCheckpointCylinderHeight;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setCheckpointRgba;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setCheckpointRgba2;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, void> fn__0xF51D36185993515D;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xFCF6788FC4860CD4;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x615D3925E87A3B26;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xDB1EA9411C8911EC;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x3C788E7F6438754D;
		private delegate* unmanaged[Cdecl]<int, void> fn__deleteCheckpoint;
		private delegate* unmanaged[Cdecl]<bool, void> fn__dontRenderInGameUi;
		private delegate* unmanaged[Cdecl]<bool, void> fn__forceRenderInGameUi;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__requestStreamedTextureDict;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasStreamedTextureDictLoaded;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setStreamedTextureDictAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int, bool, void> fn__drawRect;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setScriptGfxDrawBehindPausemenu;
		private delegate* unmanaged[Cdecl]<int, void> fn__setScriptGfxDrawOrder;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setScriptGfxAlign;
		private delegate* unmanaged[Cdecl]<void> fn__resetScriptGfxAlign;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__setScriptGfxAlignParams;
		private delegate* unmanaged[Cdecl]<float, float, float*, float*, void> fn__getScriptGfxPosition;
		private delegate* unmanaged[Cdecl]<float> fn__getSafeZoneSize;
		private delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, int, int, int, int, bool, void> fn__drawSprite;
		private delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, int, int, int, int, int, void> fn__0x2D3B147AFAD49DE0;
		private delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, int, int, int, int, void> fn__drawInteractiveSprite;
		private delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, float, float, float, float, int, int, int, int, void> fn__drawSpriteUv;
		private delegate* unmanaged[Cdecl]<int, nint, int> fn__addEntityIcon;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityIconVisibility;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setEntityIconColor;
		private delegate* unmanaged[Cdecl]<float, float, float, int, void> fn__setDrawOrigin;
		private delegate* unmanaged[Cdecl]<void> fn__clearDrawOrigin;
		private delegate* unmanaged[Cdecl]<nint, int> fn__setBinkMovie;
		private delegate* unmanaged[Cdecl]<int, void> fn__playBinkMovie;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopBinkMovie;
		private delegate* unmanaged[Cdecl]<int, void> fn__releaseBinkMovie;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, int, int, int, int, void> fn__drawBinkMovie;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setBinkMovieTime;
		private delegate* unmanaged[Cdecl]<int, float> fn__getBinkMovieTime;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setBinkMovieVolume;
		private delegate* unmanaged[Cdecl]<int, void> fn__attachTvAudioToEntity;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBinkMovieUnk2;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setTvAudioFrontend;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBinkShouldSkip;
		private delegate* unmanaged[Cdecl]<nint, int> fn__loadMovieMeshSet;
		private delegate* unmanaged[Cdecl]<int, void> fn__releaseMovieMeshSet;
		private delegate* unmanaged[Cdecl]<int, int> fn__queryMovieMeshSetState;
		private delegate* unmanaged[Cdecl]<int*, int*, void> fn__getScreenResolution;
		private delegate* unmanaged[Cdecl]<int*, int*, void> fn__getActiveScreenResolution;
		private delegate* unmanaged[Cdecl]<bool, float> fn__getAspectRatio;
		private delegate* unmanaged[Cdecl]<int> fn__0xB2EBE8CBC58B90E9;
		private delegate* unmanaged[Cdecl]<bool> fn__getIsWidescreen;
		private delegate* unmanaged[Cdecl]<bool> fn__getIsHidef;
		private delegate* unmanaged[Cdecl]<void> fn__0xEFABC7722293DA7C;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setNightvision;
		private delegate* unmanaged[Cdecl]<bool> fn__getRequestingnightvision;
		private delegate* unmanaged[Cdecl]<bool> fn__getUsingnightvision;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xEF398BEEE4EF45F9;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x814AF7DCAACC597B;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x43FA7CBE20DAB219;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setNoiseoveride;
		private delegate* unmanaged[Cdecl]<float, void> fn__setNoisinessoveride;
		private delegate* unmanaged[Cdecl]<float, float, float, float*, float*, bool> fn__getScreenCoordFromWorldCoord;
		private delegate* unmanaged[Cdecl]<nint, nint, Vector3> fn__getTextureResolution;
		private delegate* unmanaged[Cdecl]<int, nint, nint, bool> fn__overridePedBadgeTexture;
		private delegate* unmanaged[Cdecl]<float, void> fn__0xE2892E7E55D7073A;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, void> fn__setFlash;
		private delegate* unmanaged[Cdecl]<void> fn__disableOcclusionThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setArtificialLightsState;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setArtificialLightsStateAffectsVehicles;
		private delegate* unmanaged[Cdecl]<void> fn__0xC35A6D07C93802B2;
		private delegate* unmanaged[Cdecl]<int> fn__createTrackedPoint;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, void> fn__setTrackedPointInfo;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isTrackedPointVisible;
		private delegate* unmanaged[Cdecl]<int, void> fn__destroyTrackedPoint;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__0xBE197EAA669238F4;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x61F95E5BB3E0A8C6;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, void> fn__0xAE51BC858F32BA66;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x649C97D52332341A;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x2C42340F916C5930;
		private delegate* unmanaged[Cdecl]<void> fn__0x14FC5833464340A8;
		private delegate* unmanaged[Cdecl]<void> fn__0x0218BA067D249DEA;
		private delegate* unmanaged[Cdecl]<void> fn__0x1612C45F9E3E0D44;
		private delegate* unmanaged[Cdecl]<void> fn__0x5DEBD9C4DC995692;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, void> fn__0xAAE9BE70EC7C69AB;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, void> fn__grassLodShrinkScriptAreas;
		private delegate* unmanaged[Cdecl]<void> fn__grassLodResetScriptAreas;
		private delegate* unmanaged[Cdecl]<void> fn__cascadeShadowsInitSession;
		private delegate* unmanaged[Cdecl]<int, bool, float, float, float, float, bool, float, void> fn__cascadeShadowsSetCascadeBounds;
		private delegate* unmanaged[Cdecl]<float, void> fn__cascadeShadowsSetCascadeBoundsScale;
		private delegate* unmanaged[Cdecl]<float, void> fn__cascadeShadowsSetEntityTrackerScale;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x36F6626459D91457;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x259BA6D4E6F808F1;
		private delegate* unmanaged[Cdecl]<bool, void> fn__cascadeShadowsEnableEntityTracker;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x25FC3E33A31AD0C9;
		private delegate* unmanaged[Cdecl]<nint, void> fn__cascadeShadowsSetShadowSampleType;
		private delegate* unmanaged[Cdecl]<void> fn__cascadeShadowsClearShadowSampleType;
		private delegate* unmanaged[Cdecl]<bool, void> fn__cascadeShadowsSetAircraftMode;
		private delegate* unmanaged[Cdecl]<bool, void> fn__cascadeShadowsSetDynamicDepthMode;
		private delegate* unmanaged[Cdecl]<float, void> fn__cascadeShadowsSetDynamicDepthValue;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x0AE73D8DF3A762B2;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xCA465D9CC0D231BA;
		private delegate* unmanaged[Cdecl]<bool, void> fn__golfTrailSetEnabled;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, bool, void> fn__golfTrailSetPath;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__golfTrailSetRadius;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, void> fn__golfTrailSetColour;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__golfTrailSetTessellation;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xC0416B061F2B7E5E;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, int, int, int, void> fn__golfTrailSetFixedControlPoint;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, void> fn__golfTrailSetShaderParams;
		private delegate* unmanaged[Cdecl]<bool, void> fn__golfTrailSetFacing;
		private delegate* unmanaged[Cdecl]<float> fn__golfTrailGetMaxHeight;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__golfTrailGetVisualControlPoint;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setSeethrough;
		private delegate* unmanaged[Cdecl]<bool> fn__getUsingseethrough;
		private delegate* unmanaged[Cdecl]<void> fn__seethroughReset;
		private delegate* unmanaged[Cdecl]<float, void> fn__seethroughSetFadeStartDistance;
		private delegate* unmanaged[Cdecl]<float, void> fn__seethroughSetFadeEndDistance;
		private delegate* unmanaged[Cdecl]<float> fn__seethroughGetMaxThickness;
		private delegate* unmanaged[Cdecl]<float, void> fn__seethroughSetMaxThickness;
		private delegate* unmanaged[Cdecl]<float, void> fn__seethroughSetNoiseAmountMin;
		private delegate* unmanaged[Cdecl]<float, void> fn__seethroughSetNoiseAmountMax;
		private delegate* unmanaged[Cdecl]<float, void> fn__seethroughSetHiLightIntensity;
		private delegate* unmanaged[Cdecl]<float, void> fn__seethroughSetHiLightNoise;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__seethroughSetHeatscale;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__seethroughSetColorNear;
		private delegate* unmanaged[Cdecl]<float, void> fn__0xB3C641F3630BF6DA;
		private delegate* unmanaged[Cdecl]<float> fn__0xE59343E9E96529E7;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x6A51F78772175A51;
		private delegate* unmanaged[Cdecl]<bool, void> fn__togglePlayerDamageOverlay;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xE3E2C1B4C59DBC77;
		private delegate* unmanaged[Cdecl]<float, bool> fn__triggerScreenblurFadeIn;
		private delegate* unmanaged[Cdecl]<float, bool> fn__triggerScreenblurFadeOut;
		private delegate* unmanaged[Cdecl]<void> fn__disableScreenblurFade;
		private delegate* unmanaged[Cdecl]<float> fn__getScreenblurFadeCurrentTime;
		private delegate* unmanaged[Cdecl]<bool> fn__isScreenblurFadeRunning;
		private delegate* unmanaged[Cdecl]<bool, void> fn__togglePausedRenderphases;
		private delegate* unmanaged[Cdecl]<bool> fn__getTogglePausedRenderphasesStatus;
		private delegate* unmanaged[Cdecl]<void> fn__resetPausedRenderphases;
		private delegate* unmanaged[Cdecl]<void> fn__0x851CD923176EBA7C;
		private delegate* unmanaged[Cdecl]<bool, bool, float, float, float, float, void> fn__setHidofEnvBlurParams;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xB569F41F3E7E83A4;
		private delegate* unmanaged[Cdecl]<bool, bool> fn__0x7AC24EAB6D74118D;
		private delegate* unmanaged[Cdecl]<int> fn__0xBCEDB009461DA156;
		private delegate* unmanaged[Cdecl]<nint, bool, bool> fn__0x27FEB5254759CDE3;
		private delegate* unmanaged[Cdecl]<nint, float, float, float, float, float, float, float, bool, bool, bool, int> fn__startParticleFxNonLoopedAtCoord;
		private delegate* unmanaged[Cdecl]<nint, float, float, float, float, float, float, float, bool, bool, bool, bool, bool> fn__startNetworkedParticleFxNonLoopedAtCoord;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, bool> fn__startParticleFxNonLoopedOnPedBone;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, bool> fn__startNetworkedParticleFxNonLoopedOnPedBone;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, float, bool, bool, bool, bool> fn__startParticleFxNonLoopedOnEntity;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, float, bool, bool, bool, bool> fn__startNetworkedParticleFxNonLoopedOnEntity;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, bool> fn__startNetworkedParticleFxNonLoopedOnEntityBone;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__setParticleFxNonLoopedColour;
		private delegate* unmanaged[Cdecl]<float, void> fn__setParticleFxNonLoopedAlpha;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x8CDE909A0370BB3A;
		private delegate* unmanaged[Cdecl]<nint, float, float, float, float, float, float, float, bool, bool, bool, bool, int> fn__startParticleFxLoopedAtCoord;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, int> fn__startParticleFxLoopedOnPedBone;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, float, bool, bool, bool, int> fn__startParticleFxLoopedOnEntity;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, int> fn__startParticleFxLoopedOnEntityBone;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, float, bool, bool, bool, int, int, int, int, int> fn__startNetworkedParticleFxLoopedOnEntity;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, int, int, int, int, int> fn__startNetworkedParticleFxLoopedOnEntityBone;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__stopParticleFxLooped;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removeParticleFx;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeParticleFxFromEntity;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__removeParticleFxInRange;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xBA0127DA25FD54C9;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesParticleFxLoopedExist;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, void> fn__setParticleFxLoopedOffsets;
		private delegate* unmanaged[Cdecl]<int, nint, float, bool, void> fn__setParticleFxLoopedEvolution;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, void> fn__setParticleFxLoopedColour;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setParticleFxLoopedAlpha;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setParticleFxLoopedScale;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setParticleFxLoopedFarClipDist;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setParticleFxCamInsideVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setParticleFxCamInsideNonplayerVehicle;
		private delegate* unmanaged[Cdecl]<int, void> fn__setParticleFxShootoutBoat;
		private delegate* unmanaged[Cdecl]<void> fn__0x2A251AA48B2B46DB;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x908311265D42A820;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xCFD16F0DB5A3535C;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x5F6DF3D92271E8A1;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x2B40A97646381508;
		private delegate* unmanaged[Cdecl]<bool, void> fn__enableClownBloodVfx;
		private delegate* unmanaged[Cdecl]<bool, void> fn__enableAlienBloodVfx;
		private delegate* unmanaged[Cdecl]<float, void> fn__setParticleFxBulletImpactScale;
		private delegate* unmanaged[Cdecl]<float, void> fn__0xBB90E12CAC1DAB25;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xCA4AE345A153D573;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x54E22EA2C1956A8D;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x949F397A288B28B3;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0xBA3D194057C79A7B;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x5DBF05DB5926D089;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x9B079E5221D984D3;
		private delegate* unmanaged[Cdecl]<nint, void> fn__useParticleFxAsset;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__setParticleFxOverride;
		private delegate* unmanaged[Cdecl]<nint, void> fn__resetParticleFxOverride;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xA46B73FAA3460AE1;
		private delegate* unmanaged[Cdecl]<float, void> fn__0xF78B803082D4386F;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__washDecalsInRange;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__washDecalsFromVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__fadeDecalsInRange;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__removeDecalsInRange;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeDecalsFromObject;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__removeDecalsFromObjectFacing;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeDecalsFromVehicle;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, bool, bool, bool, int> fn__addDecal;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int> fn__addPetrolDecal;
		private delegate* unmanaged[Cdecl]<float, void> fn__startPetrolTrailDecals;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__addPetrolTrailDecalInfo;
		private delegate* unmanaged[Cdecl]<void> fn__endPetrolTrailDecals;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeDecal;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isDecalAlive;
		private delegate* unmanaged[Cdecl]<int, float> fn__getDecalWashLevel;
		private delegate* unmanaged[Cdecl]<void> fn__0xD9454B5752C857DC;
		private delegate* unmanaged[Cdecl]<void> fn__0x27CFB1B1E078CB2D;
		private delegate* unmanaged[Cdecl]<void> fn__setDisableDecalRenderingThisFrame;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool> fn__getIsPetrolDecalInRange;
		private delegate* unmanaged[Cdecl]<int, nint, nint, void> fn__patchDecalDiffuseMap;
		private delegate* unmanaged[Cdecl]<int, void> fn__unpatchDecalDiffuseMap;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__moveVehicleDecals;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, float, float, float, float, float, int, int, bool> fn__addVehicleCrewEmblem;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x82ACC484FFA3B05F;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__removeVehicleCrewEmblem;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getVehicleCrewEmblemRequestState;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__doesVehicleHaveCrewEmblem;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x0E4299C549F0D1F1;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x02369D5C8A51FDCF;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x46D1A61A21F566FC;
		private delegate* unmanaged[Cdecl]<nint, void> fn__overrideInteriorSmokeName;
		private delegate* unmanaged[Cdecl]<float, void> fn__overrideInteriorSmokeLevel;
		private delegate* unmanaged[Cdecl]<void> fn__overrideInteriorSmokeEnd;
		private delegate* unmanaged[Cdecl]<void> fn__registerNoirScreenEffectThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__disableVehicleDistantlights;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x03300B57FCAC6DDB;
		private delegate* unmanaged[Cdecl]<void> fn__0x98EDF76A7271E4F2;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setForcePedFootstepsTracks;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setForceVehicleTrails;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableScriptAmbientEffects;
		private delegate* unmanaged[Cdecl]<nint, void> fn__presetInteriorAmbientCache;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setTimecycleModifier;
		private delegate* unmanaged[Cdecl]<float, void> fn__setTimecycleModifierStrength;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__setTransitionTimecycleModifier;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x1CBA05AE7BD7EE05;
		private delegate* unmanaged[Cdecl]<void> fn__clearTimecycleModifier;
		private delegate* unmanaged[Cdecl]<int> fn__getTimecycleModifierIndex;
		private delegate* unmanaged[Cdecl]<int> fn__getTimecycleTransitionModifierIndex;
		private delegate* unmanaged[Cdecl]<int> fn__0x98D18905BF723B99;
		private delegate* unmanaged[Cdecl]<void> fn__pushTimecycleModifier;
		private delegate* unmanaged[Cdecl]<void> fn__popTimecycleModifier;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setCurrentPlayerTcmodifier;
		private delegate* unmanaged[Cdecl]<float, void> fn__setPlayerTcmodifierTransition;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setNextPlayerTcmodifier;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__addTcmodifierOverride;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeTcmodifierOverride;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setExtraTimecycleModifier;
		private delegate* unmanaged[Cdecl]<void> fn__clearExtraTimecycleModifier;
		private delegate* unmanaged[Cdecl]<int> fn__getExtraTimecycleModifierIndex;
		private delegate* unmanaged[Cdecl]<float, void> fn__setExtraTimecycleModifierStrength;
		private delegate* unmanaged[Cdecl]<void> fn__resetExtraTimecycleModifierStrength;
		private delegate* unmanaged[Cdecl]<nint, int> fn__requestScaleformMovie;
		private delegate* unmanaged[Cdecl]<nint, int> fn__requestScaleformMovieInstance;
		private delegate* unmanaged[Cdecl]<nint, int> fn__requestScaleformMovieInteractive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasScaleformMovieLoaded;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x2FCB133CA50A49EB;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x86255B1FC929E33E;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasScaleformMovieFilenameLoaded;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasScaleformContainerMovieLoadedIntoParent;
		private delegate* unmanaged[Cdecl]<int*, void> fn__setScaleformMovieAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setScaleformMovieToUseSystemTime;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x32F34FF7F617643B;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setScaleformFitRendertarget;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, int, int, int, int, void> fn__drawScaleformMovie;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__drawScaleformMovieFullscreen;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__drawScaleformMovieFullscreenMasked;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, int, void> fn__drawScaleformMovie3d;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, int, void> fn__drawScaleformMovie3dSolid;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__callScaleformMovieMethod;
		private delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, float, void> fn__callScaleformMovieMethodWithNumber;
		private delegate* unmanaged[Cdecl]<int, nint, nint, nint, nint, nint, nint, void> fn__callScaleformMovieMethodWithString;
		private delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, float, nint, nint, nint, nint, nint, void> fn__callScaleformMovieMethodWithNumberAndString;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__beginScaleformScriptHudMovieMethod;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__beginScaleformMovieMethod;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__beginScaleformMovieMethodOnFrontend;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__beginScaleformMovieMethodOnFrontendHeader;
		private delegate* unmanaged[Cdecl]<void> fn__endScaleformMovieMethod;
		private delegate* unmanaged[Cdecl]<int> fn__endScaleformMovieMethodReturnValue;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isScaleformMovieMethodReturnValueReady;
		private delegate* unmanaged[Cdecl]<int, int> fn__getScaleformMovieMethodReturnValueInt;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getScaleformMovieMethodReturnValueBool;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getScaleformMovieMethodReturnValueString;
		private delegate* unmanaged[Cdecl]<int, void> fn__scaleformMovieMethodAddParamInt;
		private delegate* unmanaged[Cdecl]<float, void> fn__scaleformMovieMethodAddParamFloat;
		private delegate* unmanaged[Cdecl]<bool, void> fn__scaleformMovieMethodAddParamBool;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandScaleformString;
		private delegate* unmanaged[Cdecl]<void> fn__endTextCommandScaleformString;
		private delegate* unmanaged[Cdecl]<void> fn__endTextCommandScaleformString2;
		private delegate* unmanaged[Cdecl]<nint, void> fn__scaleformMovieMethodAddParamTextureNameString2;
		private delegate* unmanaged[Cdecl]<nint, void> fn__scaleformMovieMethodAddParamTextureNameString;
		private delegate* unmanaged[Cdecl]<nint, void> fn__scaleformMovieMethodAddParamPlayerNameString;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesLatestBriefStringExist;
		private delegate* unmanaged[Cdecl]<int, void> fn__scaleformMovieMethodAddParamLatestBriefString;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestScaleformScriptHudMovie;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasScaleformScriptHudMovieLoaded;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeScaleformScriptHudMovie;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xD1C7CB175E012964;
		private delegate* unmanaged[Cdecl]<int, void> fn__setTvChannel;
		private delegate* unmanaged[Cdecl]<int> fn__getTvChannel;
		private delegate* unmanaged[Cdecl]<float, void> fn__setTvVolume;
		private delegate* unmanaged[Cdecl]<float> fn__getTvVolume;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, int, int, int, int, void> fn__drawTvChannel;
		private delegate* unmanaged[Cdecl]<int, nint, bool, void> fn__setTvChannelPlaylist;
		private delegate* unmanaged[Cdecl]<int, nint, int, void> fn__setTvChannelPlaylistAtHour;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearTvChannelPlaylist;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPlaylistUnk;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isTvPlaylistItemPlaying;
		private delegate* unmanaged[Cdecl]<bool, void> fn__enableMovieKeyframeWait;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xD1C55B110E4DF534;
		private delegate* unmanaged[Cdecl]<int> fn__0x30432A0118736E00;
		private delegate* unmanaged[Cdecl]<bool, void> fn__enableMovieSubtitles;
		private delegate* unmanaged[Cdecl]<bool> fn__ui3dsceneIsAvailable;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__ui3dscenePushPreset;
		private delegate* unmanaged[Cdecl]<nint, int, int, float, float, float, bool> fn__0x98C4FE6EC34154CA;
		private delegate* unmanaged[Cdecl]<void> fn__0x7A42B2E236E71415;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x108BE26959A9D9BB;
		private delegate* unmanaged[Cdecl]<bool, void> fn__terraingridActivate;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, float, void> fn__terraingridSetParams;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, void> fn__terraingridSetColours;
		private delegate* unmanaged[Cdecl]<nint, int, bool, void> fn__animpostfxPlay;
		private delegate* unmanaged[Cdecl]<nint, void> fn__animpostfxStop;
		private delegate* unmanaged[Cdecl]<nint, float> fn__animpostfxGetUnk;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__animpostfxIsRunning;
		private delegate* unmanaged[Cdecl]<void> fn__animpostfxStopAll;
		private delegate* unmanaged[Cdecl]<nint, void> fn__animpostfxStopAndDoUnk;
		private delegate* unmanaged[Cdecl]<nint, int, bool, void> fn__playPedRingtone;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedRingtonePlaying;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopPedRingtone;
		private delegate* unmanaged[Cdecl]<bool> fn__isMobilePhoneCallOngoing;
		private delegate* unmanaged[Cdecl]<bool> fn__0xC8B1B2425604CDD0;
		private delegate* unmanaged[Cdecl]<void> fn__createNewScriptedConversation;
		private delegate* unmanaged[Cdecl]<int, nint, nint, int, int, bool, bool, bool, bool, int, bool, bool, bool, void> fn__addLineToConversation;
		private delegate* unmanaged[Cdecl]<int, int, nint, void> fn__addPedToConversation;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__0x33E3C6C6F2F0B506;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x892B6AB8F33606F5;
		private delegate* unmanaged[Cdecl]<bool, float, float, float, float, float, float, float, float, float, void> fn__setMicrophonePosition;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x0B568201DD99F0EB;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x61631F5DF50D1C34;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__startScriptPhoneConversation;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__preloadScriptPhoneConversation;
		private delegate* unmanaged[Cdecl]<bool, bool, bool, bool, void> fn__startScriptConversation;
		private delegate* unmanaged[Cdecl]<bool, bool, bool, bool, void> fn__preloadScriptConversation;
		private delegate* unmanaged[Cdecl]<void> fn__startPreloadedConversation;
		private delegate* unmanaged[Cdecl]<bool> fn__getIsPreloadedConversationReady;
		private delegate* unmanaged[Cdecl]<bool> fn__isScriptedConversationOngoing;
		private delegate* unmanaged[Cdecl]<bool> fn__isScriptedConversationLoaded;
		private delegate* unmanaged[Cdecl]<int> fn__getCurrentScriptedConversationLine;
		private delegate* unmanaged[Cdecl]<bool, void> fn__pauseScriptedConversation;
		private delegate* unmanaged[Cdecl]<void> fn__restartScriptedConversation;
		private delegate* unmanaged[Cdecl]<bool, int> fn__stopScriptedConversation;
		private delegate* unmanaged[Cdecl]<void> fn__skipToNextScriptedConversationLine;
		private delegate* unmanaged[Cdecl]<int, int*, int*, void> fn__interruptConversation;
		private delegate* unmanaged[Cdecl]<int, nint, nint, void> fn__interruptConversationAndPause;
		private delegate* unmanaged[Cdecl]<int*, int> fn__0xAA19F5572C38B564;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xB542DE8C3D1CB210;
		private delegate* unmanaged[Cdecl]<int, void> fn__registerScriptWithAudio;
		private delegate* unmanaged[Cdecl]<void> fn__unregisterScriptWithAudio;
		private delegate* unmanaged[Cdecl]<nint, bool, int, bool> fn__requestMissionAudioBank;
		private delegate* unmanaged[Cdecl]<nint, bool, int, bool> fn__requestAmbientAudioBank;
		private delegate* unmanaged[Cdecl]<nint, bool, int, bool> fn__requestScriptAudioBank;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__0x40763EA7B9B783E7;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__hintAmbientAudioBank;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__hintScriptAudioBank;
		private delegate* unmanaged[Cdecl]<void> fn__releaseMissionAudioBank;
		private delegate* unmanaged[Cdecl]<void> fn__releaseAmbientAudioBank;
		private delegate* unmanaged[Cdecl]<nint, void> fn__releaseNamedScriptAudioBank;
		private delegate* unmanaged[Cdecl]<void> fn__releaseScriptAudioBank;
		private delegate* unmanaged[Cdecl]<void> fn__0x19AF7ED9B9D23058;
		private delegate* unmanaged[Cdecl]<void> fn__0x9AC92EED5E4793AB;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x11579D940949C49E;
		private delegate* unmanaged[Cdecl]<int> fn__getSoundId;
		private delegate* unmanaged[Cdecl]<int, void> fn__releaseSoundId;
		private delegate* unmanaged[Cdecl]<int, nint, nint, bool, int, bool, void> fn__playSound;
		private delegate* unmanaged[Cdecl]<int, nint, nint, bool, void> fn__playSoundFrontend;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__playDeferredSoundFrontend;
		private delegate* unmanaged[Cdecl]<int, nint, int, nint, bool, int, void> fn__playSoundFromEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__0x5B9853296731E88D;
		private delegate* unmanaged[Cdecl]<int, nint, float, float, float, nint, bool, int, bool, void> fn__playSoundFromCoord;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x7EC3C679D0E7E46B;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopSound;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNetworkIdFromSoundId;
		private delegate* unmanaged[Cdecl]<int, int> fn__getSoundIdFromNetworkId;
		private delegate* unmanaged[Cdecl]<int, int*, float, void> fn__setVariableOnSound;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__setVariableOnStream;
		private delegate* unmanaged[Cdecl]<int*, bool, void> fn__overrideUnderwaterStream;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__setVariableOnUnderWaterStream;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasSoundFinished;
		private delegate* unmanaged[Cdecl]<int, nint, nint, int, void> fn__playPedAmbientSpeechNative;
		private delegate* unmanaged[Cdecl]<int, nint, nint, int, void> fn__playPedAmbientSpeechAndCloneNative;
		private delegate* unmanaged[Cdecl]<int, nint, nint, nint, bool, void> fn__playPedAmbientSpeechWithVoiceNative;
		private delegate* unmanaged[Cdecl]<nint, nint, float, float, float, nint, void> fn__playAmbientSpeechFromPositionNative;
		private delegate* unmanaged[Cdecl]<nint, void> fn__overrideTrevorRage;
		private delegate* unmanaged[Cdecl]<void> fn__resetTrevorRage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerAngry;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__playPain;
		private delegate* unmanaged[Cdecl]<void> fn__releaseWeaponAudio;
		private delegate* unmanaged[Cdecl]<nint, void> fn__activateAudioSlowmoMode;
		private delegate* unmanaged[Cdecl]<nint, void> fn__deactivateAudioSlowmoMode;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setAmbientVoiceName;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setAmbientVoiceNameHash;
		private delegate* unmanaged[Cdecl]<int, int> fn__getAmbientVoiceNameHash;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedScream;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x1B7ABE26CBCBF8C7;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedVoiceGroup;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAudioGender;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopCurrentPlayingSpeech;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopCurrentPlayingAmbientSpeech;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isAmbientSpeechPlaying;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isScriptedSpeechPlaying;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isAnySpeechPlaying;
		private delegate* unmanaged[Cdecl]<int> fn__0x30CA2EF91D15ADF8;
		private delegate* unmanaged[Cdecl]<int, nint, bool, bool> fn__canPedSpeak;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInCurrentConversation;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedIsDrunk;
		private delegate* unmanaged[Cdecl]<int, int, nint, void> fn__playAnimalVocalization;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isAnimalVocalizationPlaying;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setAnimalMood;
		private delegate* unmanaged[Cdecl]<bool> fn__isMobilePhoneRadioActive;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMobilePhoneRadioState;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayerRadioStationIndex;
		private delegate* unmanaged[Cdecl]<nint> fn__getPlayerRadioStationName;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getRadioStationName;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayerRadioStationGenre;
		private delegate* unmanaged[Cdecl]<bool> fn__isRadioRetuning;
		private delegate* unmanaged[Cdecl]<bool> fn__isRadioFadedOut;
		private delegate* unmanaged[Cdecl]<void> fn__0xFF266D1D0EB1195D;
		private delegate* unmanaged[Cdecl]<void> fn__0xDD6BCF9E94425DF9;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setRadioToStationName;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setVehRadioStation;
		private delegate* unmanaged[Cdecl]<int, void> fn__setVehHasRadioOverride;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleRadioEnabled;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC1805D05E6D4FE10;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__setEmitterRadioStation;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__setStaticEmitterEnabled;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__linkStaticEmitterToEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__setRadioToStationIndex;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setFrontendRadioActive;
		private delegate* unmanaged[Cdecl]<int, void> fn__unlockMissionNewsStory;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMissionNewsStoryUnlocked;
		private delegate* unmanaged[Cdecl]<int> fn__getAudibleMusicTrackTextId;
		private delegate* unmanaged[Cdecl]<bool, void> fn__playEndCreditsMusic;
		private delegate* unmanaged[Cdecl]<void> fn__skipRadioForward;
		private delegate* unmanaged[Cdecl]<nint, void> fn__freezeRadioStation;
		private delegate* unmanaged[Cdecl]<nint, void> fn__unfreezeRadioStation;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setRadioAutoUnfreeze;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setInitialPlayerStation;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setUserRadioControlEnabled;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__setRadioTrack;
		private delegate* unmanaged[Cdecl]<nint, nint, int, void> fn__setRadioTrackMix;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x55ECF4D13D9903B0;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleRadioLoud;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleRadioLoud;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMobileRadioEnabledDuringGameplay;
		private delegate* unmanaged[Cdecl]<bool> fn__doesPlayerVehHaveRadio;
		private delegate* unmanaged[Cdecl]<bool> fn__isPlayerVehRadioEnable;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleRadioEnabled;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xDA07819E452FFE8F;
		private delegate* unmanaged[Cdecl]<nint, nint, bool, void> fn__setCustomRadioTrackList;
		private delegate* unmanaged[Cdecl]<nint, void> fn__clearCustomRadioTrackList;
		private delegate* unmanaged[Cdecl]<int> fn__getNumUnlockedRadioStations;
		private delegate* unmanaged[Cdecl]<int, int> fn__findRadioStationIndex;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__setRadioStationMusicOnly;
		private delegate* unmanaged[Cdecl]<float, void> fn__setRadioFrontendFadeTime;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__unlockRadioStationTrackList;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__lockRadioStationTrackList;
		private delegate* unmanaged[Cdecl]<bool, void> fn__updateLsur;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__lockRadioStation;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__setRadioStationIsVisible;
		private delegate* unmanaged[Cdecl]<float*, float*, int*, bool> fn__0xC64A06D939F826F5;
		private delegate* unmanaged[Cdecl]<nint, nint, int, void> fn__forceRadioTrackListPosition;
		private delegate* unmanaged[Cdecl]<nint, int> fn__getCurrentRadioStationHash;
		private delegate* unmanaged[Cdecl]<nint, int> fn__0x34D66BC058019CE0;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xF3365489E0DD50F9;
		private delegate* unmanaged[Cdecl]<nint, bool, bool, void> fn__setAmbientZoneState;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__clearAmbientZoneState;
		private delegate* unmanaged[Cdecl]<int*, bool, bool, void> fn__setAmbientZoneListState;
		private delegate* unmanaged[Cdecl]<int*, bool, void> fn__clearAmbientZoneListState;
		private delegate* unmanaged[Cdecl]<nint, bool, bool, void> fn__setAmbientZoneStatePersistent;
		private delegate* unmanaged[Cdecl]<nint, bool, bool, void> fn__setAmbientZoneListStatePersistent;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isAmbientZoneEnabled;
		private delegate* unmanaged[Cdecl]<void> fn__0x5D2BFAAB8D956E0E;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setCutsceneAudioOverride;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__setVariableOnCutsceneAudio;
		private delegate* unmanaged[Cdecl]<nint, float, int> fn__playPoliceReport;
		private delegate* unmanaged[Cdecl]<void> fn__cancelCurrentPoliceReport;
		private delegate* unmanaged[Cdecl]<int, void> fn__blipSiren;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__overrideVehHorn;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isHornActive;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setAggressiveHorns;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x02E93C796ABD3A97;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__0x58BB377BEC7CD5F4;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x9BD7BD55E4533183;
		private delegate* unmanaged[Cdecl]<bool> fn__isStreamPlaying;
		private delegate* unmanaged[Cdecl]<int> fn__getStreamPlayTime;
		private delegate* unmanaged[Cdecl]<nint, nint, bool> fn__loadStream;
		private delegate* unmanaged[Cdecl]<nint, int, nint, bool> fn__loadStreamWithStartOffset;
		private delegate* unmanaged[Cdecl]<int, void> fn__playStreamFromPed;
		private delegate* unmanaged[Cdecl]<int, void> fn__playStreamFromVehicle;
		private delegate* unmanaged[Cdecl]<int, void> fn__playStreamFromObject;
		private delegate* unmanaged[Cdecl]<void> fn__playStreamFrontend;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__playStreamFromPosition;
		private delegate* unmanaged[Cdecl]<void> fn__stopStream;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__stopPedSpeaking;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__0xF8AD2EED7C47E8FE;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xAB6781A5F3101470;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__disablePedPainAudio;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isAmbientSpeechDisabled;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__0xA8A7D434AFB4B97B;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0x2ACABED337622DF2;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setSirenWithNoDriver;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setSirenKeepOn;
		private delegate* unmanaged[Cdecl]<int, void> fn__triggerSiren;
		private delegate* unmanaged[Cdecl]<int, void> fn__soundVehicleHornThisFrame;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setHornEnabled;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setAudioVehiclePriority;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x9D3AF56E94C9AE98;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__useSirenAsHorn;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__forceVehicleEngineAudio;
		private delegate* unmanaged[Cdecl]<int, void> fn__preloadVehicleAudio;
		private delegate* unmanaged[Cdecl]<int, nint, nint, void> fn__setVehicleStartupRevSound;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetVehicleStartupRevSound;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x97FFB4ADEED08066;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleAudiblyDamaged;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleAudioEngineDamageFactor;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleAudioBodyDamageFactor;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__enableVehicleFanbeltDamage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__enableVehicleExhaustPops;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleBoostActive;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x6FDDAD856E36988A;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setScriptUpdateDoorAudio;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__playVehicleDoorOpenSound;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__playVehicleDoorCloseSound;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__enableStallWarningSounds;
		private delegate* unmanaged[Cdecl]<bool> fn__isGameInControlOfMusic;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setGpsActive;
		private delegate* unmanaged[Cdecl]<nint, void> fn__playMissionCompleteAudio;
		private delegate* unmanaged[Cdecl]<bool> fn__isMissionCompletePlaying;
		private delegate* unmanaged[Cdecl]<bool> fn__isMissionCompleteReadyForUi;
		private delegate* unmanaged[Cdecl]<bool, void> fn__blockDeathJingle;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__startAudioScene;
		private delegate* unmanaged[Cdecl]<nint, void> fn__stopAudioScene;
		private delegate* unmanaged[Cdecl]<void> fn__stopAudioScenes;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isAudioSceneActive;
		private delegate* unmanaged[Cdecl]<nint, nint, float, void> fn__setAudioSceneVariable;
		private delegate* unmanaged[Cdecl]<int, void> fn__setAudioScriptCleanupTime;
		private delegate* unmanaged[Cdecl]<int, nint, float, void> fn__addEntityToAudioMixGroup;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__removeEntityFromAudioMixGroup;
		private delegate* unmanaged[Cdecl]<bool> fn__audioIsScriptedMusicPlaying;
		private delegate* unmanaged[Cdecl]<int> fn__0x2DD39BF3E2F9C47F;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__prepareMusicEvent;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__cancelMusicEvent;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__triggerMusicEvent;
		private delegate* unmanaged[Cdecl]<bool> fn__isMusicOneshotPlaying;
		private delegate* unmanaged[Cdecl]<int> fn__getMusicPlaytime;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x159B7318403A1CD8;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__recordBrokenGlass;
		private delegate* unmanaged[Cdecl]<void> fn__clearAllBrokenGlass;
		private delegate* unmanaged[Cdecl]<bool, int, void> fn__0x70B8EC8FC108A634;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__0x149AEE66F0CB3A99;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__0x8BF907833BE275DE;
		private delegate* unmanaged[Cdecl]<void> fn__forcePedPanicWalla;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__prepareAlarm;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__startAlarm;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__stopAlarm;
		private delegate* unmanaged[Cdecl]<bool, void> fn__stopAllAlarms;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isAlarmPlaying;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleDefaultHorn;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleDefaultHornIgnoreMods;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPedAudioFlags;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAudioFootstepLoud;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAudioFootstepQuiet;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__overridePlayerGroundMaterial;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__0xBF4DC1784BE94DFA;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__overrideMicrophoneSettings;
		private delegate* unmanaged[Cdecl]<void> fn__freezeMicrophone;
		private delegate* unmanaged[Cdecl]<bool, void> fn__distantCopCarSirens;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x43FA0DFC5DF87815;
		private delegate* unmanaged[Cdecl]<void> fn__0xB81CF134AEB56FFB;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__setAudioFlag;
		private delegate* unmanaged[Cdecl]<nint, int, int> fn__prepareSynchronizedAudioEvent;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__prepareSynchronizedAudioEventForScene;
		private delegate* unmanaged[Cdecl]<int, bool> fn__playSynchronizedAudioEvent;
		private delegate* unmanaged[Cdecl]<int, bool> fn__stopSynchronizedAudioEvent;
		private delegate* unmanaged[Cdecl]<int*, float, float, float, void> fn__0xC8EDE9BDBCCBA6D4;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__setSynchronizedAudioEventPositionThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__setAudioSpecialEffectMode;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__setPortalSettingsOverride;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removePortalSettingsOverride;
		private delegate* unmanaged[Cdecl]<void> fn__0xE4E6DD5566D28C82;
		private delegate* unmanaged[Cdecl]<int> fn__getMusicVolSlider;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestTennisBanks;
		private delegate* unmanaged[Cdecl]<void> fn__unrequestTennisBanks;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xBEF34B1D9624D5DD;
		private delegate* unmanaged[Cdecl]<void> fn__stopCutsceneAudio;
		private delegate* unmanaged[Cdecl]<bool> fn__hasMultiplayerAudioDataLoaded;
		private delegate* unmanaged[Cdecl]<bool> fn__hasMultiplayerAudioDataUnloaded;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleDefaultHornVariation;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleHornVariation;
		private delegate* unmanaged[Cdecl]<nint, int, float, float, void> fn__addScriptToRandomPed;
		private delegate* unmanaged[Cdecl]<nint, int, int, float, int, int, void> fn__registerObjectScriptBrain;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isObjectWithinBrainActivationRange;
		private delegate* unmanaged[Cdecl]<nint, float, int, void> fn__registerWorldPointScriptBrain;
		private delegate* unmanaged[Cdecl]<bool> fn__isWorldPointWithinBrainActivationRange;
		private delegate* unmanaged[Cdecl]<int, void> fn__enableScriptBrainSet;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableScriptBrainSet;
		private delegate* unmanaged[Cdecl]<void> fn__0x0B40ED49D7D6FF84;
		private delegate* unmanaged[Cdecl]<void> fn__0x4D953DF78EBF8158;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0x6D6840CEE8845831;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0x6E91B04E08773030;
		private delegate* unmanaged[Cdecl]<bool, bool, int, bool, bool, int, void> fn__renderScriptCams;
		private delegate* unmanaged[Cdecl]<bool, float, int, int, void> fn__stopRenderingScriptCamsUsingCatchUp;
		private delegate* unmanaged[Cdecl]<nint, bool, int> fn__createCam;
		private delegate* unmanaged[Cdecl]<nint, float, float, float, float, float, float, float, bool, int, int> fn__createCamWithParams;
		private delegate* unmanaged[Cdecl]<int, bool, int> fn__createCamera;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, int, int> fn__createCameraWithParams;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__destroyCam;
		private delegate* unmanaged[Cdecl]<bool, void> fn__destroyAllCams;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesCamExist;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCamActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isCamActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isCamRendering;
		private delegate* unmanaged[Cdecl]<int> fn__getRenderingCam;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getCamCoord;
		private delegate* unmanaged[Cdecl]<int, int, Vector3> fn__getCamRot;
		private delegate* unmanaged[Cdecl]<int, float> fn__getCamFov;
		private delegate* unmanaged[Cdecl]<int, float> fn__getCamNearClip;
		private delegate* unmanaged[Cdecl]<int, float> fn__getCamFarClip;
		private delegate* unmanaged[Cdecl]<int, float> fn__getCamFarDof;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int, int, int, int, void> fn__setCamParams;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setCamCoord;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, void> fn__setCamRot;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamFov;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamNearClip;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamFarClip;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xAABD62873FFB1A33;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamMotionBlurStrength;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamNearDof;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamFarDof;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamDofStrength;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, void> fn__setCamDofPlanes;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCamUseShallowDofMode;
		private delegate* unmanaged[Cdecl]<void> fn__setUseHiDof;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0xF55E4046F6F831DC;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0xE111A7C0D200CBC5;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamDofFnumberOfLens;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamDofFocalLengthMultiplier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamDofFocusDistanceBias;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamDofMaxNearInFocusDistance;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamDofMaxNearInFocusDistanceBlendLevel;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void> fn__attachCamToEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, bool, void> fn__attachCamToPedBone;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, float, bool, void> fn__attachCamToPedBone2;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, void> fn__0x202A5ED9CE01D6E7;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, float, float, float, float, float, float, bool, void> fn__attachCamToVehicleBone;
		private delegate* unmanaged[Cdecl]<int, void> fn__detachCam;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCamInheritRollVehicle;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__pointCamAtCoord;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void> fn__pointCamAtEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, bool, void> fn__pointCamAtPedBone;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopCamPointing;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCamAffectsAiming;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x661B5C8654ADD825;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xA2767257A320FC82;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x271017B9BA825366;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setCamDebugName;
		private delegate* unmanaged[Cdecl]<int> fn__getDebugCamera;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, int, int, int, void> fn__addCamSplineNode;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__addCamSplineNodeUsingCameraFrame;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__addCamSplineNodeUsingCamera;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__addCamSplineNodeUsingGameplayFrame;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamSplinePhase;
		private delegate* unmanaged[Cdecl]<int, float> fn__getCamSplinePhase;
		private delegate* unmanaged[Cdecl]<int, float> fn__getCamSplineNodePhase;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setCamSplineDuration;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setCamSplineSmoothingStyle;
		private delegate* unmanaged[Cdecl]<int, int> fn__getCamSplineNodeIndex;
		private delegate* unmanaged[Cdecl]<int, int, int, float, void> fn__setCamSplineNodeEase;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__setCamSplineNodeVelocityScale;
		private delegate* unmanaged[Cdecl]<int, int, float, float, void> fn__overrideCamSplineVelocity;
		private delegate* unmanaged[Cdecl]<int, int, float, float, void> fn__overrideCamSplineMotionBlur;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setCamSplineNodeExtraFlags;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isCamSplinePaused;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setCamActiveWithInterp;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isCamInterpolating;
		private delegate* unmanaged[Cdecl]<int, nint, float, void> fn__shakeCam;
		private delegate* unmanaged[Cdecl]<int, nint, nint, nint, float, void> fn__animatedShakeCam;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isCamShaking;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamShakeAmplitude;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__stopCamShaking;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__shakeScriptGlobal;
		private delegate* unmanaged[Cdecl]<nint, nint, nint, float, void> fn__animatedShakeScriptGlobal;
		private delegate* unmanaged[Cdecl]<bool> fn__isScriptGlobalShaking;
		private delegate* unmanaged[Cdecl]<bool, void> fn__stopScriptGlobalShaking;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__0x5D96CFB59DA076A0;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, float, float, float, float, float, bool, int, bool> fn__playCamAnim;
		private delegate* unmanaged[Cdecl]<int, nint, nint, bool> fn__isCamPlayingAnim;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCamAnimCurrentPhase;
		private delegate* unmanaged[Cdecl]<int, float> fn__getCamAnimCurrentPhase;
		private delegate* unmanaged[Cdecl]<int, int, nint, nint, bool> fn__playSynchronizedCamAnim;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setFlyCamHorizontalResponse;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setFlyCamVerticalSpeedMultiplier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setFlyCamMaxHeight;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setFlyCamCoordAndConstrain;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC8B5C4A79CC18B94;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x5C48A1D6E3B33179;
		private delegate* unmanaged[Cdecl]<bool> fn__isScreenFadedOut;
		private delegate* unmanaged[Cdecl]<bool> fn__isScreenFadedIn;
		private delegate* unmanaged[Cdecl]<bool> fn__isScreenFadingOut;
		private delegate* unmanaged[Cdecl]<bool> fn__isScreenFadingIn;
		private delegate* unmanaged[Cdecl]<int, void> fn__doScreenFadeIn;
		private delegate* unmanaged[Cdecl]<int, void> fn__doScreenFadeOut;
		private delegate* unmanaged[Cdecl]<bool, int, void> fn__setWidescreenBorders;
		private delegate* unmanaged[Cdecl]<bool> fn__0x4879E4FE39074CDF;
		private delegate* unmanaged[Cdecl]<Vector3> fn__getGameplayCamCoord;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getGameplayCamRot;
		private delegate* unmanaged[Cdecl]<float> fn__getGameplayCamFov;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x487A82C650EB7799;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x0225778816FDC28C;
		private delegate* unmanaged[Cdecl]<float> fn__getGameplayCamRelativeHeading;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGameplayCamRelativeHeading;
		private delegate* unmanaged[Cdecl]<float> fn__getGameplayCamRelativePitch;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__setGameplayCamRelativePitch;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__setGameplayCamRelativeRotation;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__0x28B022A17B068A3A;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGameplayCamRawYaw;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGameplayCamRawPitch;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x469F2ECDEC046337;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__shakeGameplayCam;
		private delegate* unmanaged[Cdecl]<bool> fn__isGameplayCamShaking;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGameplayCamShakeAmplitude;
		private delegate* unmanaged[Cdecl]<bool, void> fn__stopGameplayCamShaking;
		private delegate* unmanaged[Cdecl]<int, void> fn__setGameplayCamFollowPedThisUpdate;
		private delegate* unmanaged[Cdecl]<bool> fn__isGameplayCamRendering;
		private delegate* unmanaged[Cdecl]<bool> fn__0x3044240D2E0FA842;
		private delegate* unmanaged[Cdecl]<bool> fn__0x705A276EBFF3133D;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xDB90C6CCA48940F1;
		private delegate* unmanaged[Cdecl]<void> fn__enableCrosshairThisFrame;
		private delegate* unmanaged[Cdecl]<bool> fn__isGameplayCamLookingBehind;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableCamCollisionForEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableCamCollisionForObject;
		private delegate* unmanaged[Cdecl]<void> fn__0xA7092AFE81944852;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xFD3151CD37EA2245;
		private delegate* unmanaged[Cdecl]<void> fn__0xB1381B97F70C7B30;
		private delegate* unmanaged[Cdecl]<void> fn__0xDD79DF9F4D26E1C9;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool> fn__isSphereVisible;
		private delegate* unmanaged[Cdecl]<bool> fn__isFollowPedCamActive;
		private delegate* unmanaged[Cdecl]<nint, int, bool> fn__setFollowPedCamThisUpdate;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__0x271401846BD26E92;
		private delegate* unmanaged[Cdecl]<void> fn__0xC8391C309684595A;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__clampGameplayCamYaw;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__clampGameplayCamPitch;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__animateGameplayCamZoom;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setInVehicleCamStateThisUpdate;
		private delegate* unmanaged[Cdecl]<void> fn__disableFirstPersonCamThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__0x59424BD75174C9B1;
		private delegate* unmanaged[Cdecl]<void> fn__0x9F97DA93681F87EA;
		private delegate* unmanaged[Cdecl]<int> fn__getFollowPedCamZoomLevel;
		private delegate* unmanaged[Cdecl]<int> fn__getFollowPedCamViewMode;
		private delegate* unmanaged[Cdecl]<int, void> fn__setFollowPedCamViewMode;
		private delegate* unmanaged[Cdecl]<bool> fn__isFollowVehicleCamActive;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x91EF6EE6419E5B97;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__0x9DFE13ECDC1EC196;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x79C0E43EB9B944E2;
		private delegate* unmanaged[Cdecl]<int> fn__getFollowVehicleCamZoomLevel;
		private delegate* unmanaged[Cdecl]<int, void> fn__setFollowVehicleCamZoomLevel;
		private delegate* unmanaged[Cdecl]<int> fn__getFollowVehicleCamViewMode;
		private delegate* unmanaged[Cdecl]<int, void> fn__setFollowVehicleCamViewMode;
		private delegate* unmanaged[Cdecl]<int, int> fn__getCamViewModeForContext;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setCamViewModeForContext;
		private delegate* unmanaged[Cdecl]<int> fn__getCamActiveViewModeContext;
		private delegate* unmanaged[Cdecl]<void> fn__useStuntCameraThisFrame;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setGameplayCamHash;
		private delegate* unmanaged[Cdecl]<void> fn__0x0AA27680A0BD43FA;
		private delegate* unmanaged[Cdecl]<int, void> fn__setFollowTurretSeatCam;
		private delegate* unmanaged[Cdecl]<bool> fn__isAimCamActive;
		private delegate* unmanaged[Cdecl]<bool> fn__isAimCamThirdPersonActive;
		private delegate* unmanaged[Cdecl]<bool> fn__isFirstPersonAimCamActive;
		private delegate* unmanaged[Cdecl]<void> fn__disableAimCamThisUpdate;
		private delegate* unmanaged[Cdecl]<float> fn__getFirstPersonAimCamZoomFactor;
		private delegate* unmanaged[Cdecl]<float, void> fn__setFirstPersonAimCamZoomFactor;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__0xCED08CBE8EBB97C7;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__0x2F7F2B26DD3F18EE;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__setFirstPersonCamPitchRange;
		private delegate* unmanaged[Cdecl]<float, void> fn__setFirstPersonAimCamNearClipThisUpdate;
		private delegate* unmanaged[Cdecl]<float, void> fn__setThirdPersonAimCamNearClipThisUpdate;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x4008EDF7D6E48175;
		private delegate* unmanaged[Cdecl]<void> fn__0x380B4968D1E09E55;
		private delegate* unmanaged[Cdecl]<Vector3> fn__getFinalRenderedCamCoord;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getFinalRenderedCamRot;
		private delegate* unmanaged[Cdecl]<int, int, Vector3> fn__getFinalRenderedInWhenFriendlyRot;
		private delegate* unmanaged[Cdecl]<float> fn__getFinalRenderedCamFov;
		private delegate* unmanaged[Cdecl]<int, float> fn__getFinalRenderedInWhenFriendlyFov;
		private delegate* unmanaged[Cdecl]<float> fn__getFinalRenderedCamNearClip;
		private delegate* unmanaged[Cdecl]<float> fn__getFinalRenderedCamFarClip;
		private delegate* unmanaged[Cdecl]<float> fn__getFinalRenderedCamNearDof;
		private delegate* unmanaged[Cdecl]<float> fn__getFinalRenderedCamFarDof;
		private delegate* unmanaged[Cdecl]<float> fn__getFinalRenderedCamMotionBlurStrength;
		private delegate* unmanaged[Cdecl]<float, float, float, int, int, int, int, void> fn__setGameplayCoordHint;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int, void> fn__setGameplayPedHint;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int, void> fn__setGameplayVehicleHint;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int, void> fn__setGameplayObjectHint;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int, int, void> fn__setGameplayEntityHint;
		private delegate* unmanaged[Cdecl]<bool> fn__isGameplayHintActive;
		private delegate* unmanaged[Cdecl]<bool, void> fn__stopGameplayHint;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xCCD078C2665D2973;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x247ACBC4ABBC9D1C;
		private delegate* unmanaged[Cdecl]<int> fn__0xBF72910D0F26F025;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGameplayHintFov;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGameplayHintFollowDistanceScalar;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGameplayHintBaseOrbitPitchOffset;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGameplayHintAnimOffsetx;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGameplayHintAnimOffsety;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setGameplayHintAnimCloseup;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setCinematicButtonActive;
		private delegate* unmanaged[Cdecl]<bool> fn__isCinematicCamRendering;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__shakeCinematicCam;
		private delegate* unmanaged[Cdecl]<bool> fn__isCinematicCamShaking;
		private delegate* unmanaged[Cdecl]<float, void> fn__setCinematicCamShakeAmplitude;
		private delegate* unmanaged[Cdecl]<bool, void> fn__stopCinematicCamShaking;
		private delegate* unmanaged[Cdecl]<void> fn__disableVehicleFirstPersonCamThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__0x62ECFCFDEE7885D6;
		private delegate* unmanaged[Cdecl]<void> fn__invalidateVehicleIdleCam;
		private delegate* unmanaged[Cdecl]<void> fn__invalidateIdleCam;
		private delegate* unmanaged[Cdecl]<bool> fn__isCinematicIdleCamRendering;
		private delegate* unmanaged[Cdecl]<bool> fn__isInVehicleCamDisabled;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__createCinematicShot;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isCinematicShotActive;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopCinematicShot;
		private delegate* unmanaged[Cdecl]<bool, void> fn__forceCinematicRenderingThisUpdate;
		private delegate* unmanaged[Cdecl]<void> fn__0xDC9DA9E8789F5246;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setCinematicModeActive;
		private delegate* unmanaged[Cdecl]<int> fn__0x1F2300CB7FA7B7F6;
		private delegate* unmanaged[Cdecl]<int> fn__0x17FCA7199A530203;
		private delegate* unmanaged[Cdecl]<int> fn__0xD7360051C885628B;
		private delegate* unmanaged[Cdecl]<bool> fn__isCinematicCamActive;
		private delegate* unmanaged[Cdecl]<void> fn__0x7B8A361C1813FBEF;
		private delegate* unmanaged[Cdecl]<void> fn__stopCutsceneCamShaking;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x324C5AA411DA7737;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x12DED8CA53D47EA5;
		private delegate* unmanaged[Cdecl]<float, int, float, float, float, float, float, int, int, int> fn__getFocusPedOnScreen;
		private delegate* unmanaged[Cdecl]<void> fn__0x5A43C76F7FC7BA5F;
		private delegate* unmanaged[Cdecl]<int, void> fn__setCamEffect;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x5C41E6BABC9E2112;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setGameplayCamVehicleCamera;
		private delegate* unmanaged[Cdecl]<int, void> fn__setGameplayCamVehicleCameraName;
		private delegate* unmanaged[Cdecl]<int> fn__0xEAF0FA793D05C592;
		private delegate* unmanaged[Cdecl]<void> fn__0x62374889A4D59F72;
		private delegate* unmanaged[Cdecl]<float> fn__replayFreeCamGetMaxRange;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setClockTime;
		private delegate* unmanaged[Cdecl]<bool, void> fn__pauseClock;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__advanceClockTimeTo;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__addToClockTime;
		private delegate* unmanaged[Cdecl]<int> fn__getClockHours;
		private delegate* unmanaged[Cdecl]<int> fn__getClockMinutes;
		private delegate* unmanaged[Cdecl]<int> fn__getClockSeconds;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setClockDate;
		private delegate* unmanaged[Cdecl]<int> fn__getClockDayOfWeek;
		private delegate* unmanaged[Cdecl]<int> fn__getClockDayOfMonth;
		private delegate* unmanaged[Cdecl]<int> fn__getClockMonth;
		private delegate* unmanaged[Cdecl]<int> fn__getClockYear;
		private delegate* unmanaged[Cdecl]<int> fn__getMillisecondsPerGameMinute;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, int*, int*, int*, void> fn__getPosixTime;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, int*, int*, int*, void> fn__getUtcTime;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, int*, int*, int*, void> fn__getLocalTime;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__requestCutscene;
		private delegate* unmanaged[Cdecl]<nint, int, int, void> fn__requestCutsceneWithPlaybackList;
		private delegate* unmanaged[Cdecl]<void> fn__removeCutscene;
		private delegate* unmanaged[Cdecl]<bool> fn__hasCutsceneLoaded;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasThisCutsceneLoaded;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x8D9DF6ECA8768583;
		private delegate* unmanaged[Cdecl]<bool> fn__canRequestAssetsForCutsceneEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isCutscenePlaybackFlagSet;
		private delegate* unmanaged[Cdecl]<nint, int, int, void> fn__setCutsceneEntityStreamingFlags;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestCutFile;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasCutFileLoaded;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeCutFile;
		private delegate* unmanaged[Cdecl]<nint, int> fn__getCutFileNumSections;
		private delegate* unmanaged[Cdecl]<int, void> fn__startCutscene;
		private delegate* unmanaged[Cdecl]<float, float, float, int, void> fn__startCutsceneAtCoords;
		private delegate* unmanaged[Cdecl]<bool, void> fn__stopCutscene;
		private delegate* unmanaged[Cdecl]<void> fn__stopCutsceneImmediately;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, void> fn__setCutsceneOrigin;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, void> fn__0x011883F41211432A;
		private delegate* unmanaged[Cdecl]<int> fn__getCutsceneTime;
		private delegate* unmanaged[Cdecl]<int> fn__getCutsceneTotalDuration;
		private delegate* unmanaged[Cdecl]<int> fn__0x971D7B15BCDBEF99;
		private delegate* unmanaged[Cdecl]<bool> fn__wasCutsceneSkipped;
		private delegate* unmanaged[Cdecl]<bool> fn__hasCutsceneFinished;
		private delegate* unmanaged[Cdecl]<bool> fn__isCutsceneActive;
		private delegate* unmanaged[Cdecl]<bool> fn__isCutscenePlaying;
		private delegate* unmanaged[Cdecl]<int> fn__getCutsceneSectionPlaying;
		private delegate* unmanaged[Cdecl]<nint, int, int> fn__getEntityIndexOfCutsceneEntity;
		private delegate* unmanaged[Cdecl]<int> fn__0x583DF8E3D4AFBD98;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__0x4CEBC1ED31E8925E;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x4FCD976DA686580C;
		private delegate* unmanaged[Cdecl]<int, nint, int, int, int, void> fn__registerEntityForCutscene;
		private delegate* unmanaged[Cdecl]<nint, int, int> fn__getEntityIndexOfRegisteredEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x7F96F23FA9B73327;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void> fn__setCutsceneTriggerArea;
		private delegate* unmanaged[Cdecl]<nint, int, bool> fn__canSetEnterStateForRegisteredEntity;
		private delegate* unmanaged[Cdecl]<nint, int, bool> fn__canSetExitStateForRegisteredEntity;
		private delegate* unmanaged[Cdecl]<bool, bool> fn__canSetExitStateForCamera;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xC61B86C9F61EB404;
		private delegate* unmanaged[Cdecl]<bool, bool, bool, bool, void> fn__setCutsceneFadeValues;
		private delegate* unmanaged[Cdecl]<bool, bool, bool, bool, void> fn__0x20746F7B1032A3C7;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x06EE9048FD080382;
		private delegate* unmanaged[Cdecl]<int> fn__0xA0FE76168A189DDB;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x2F137B508DE238F2;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xE36A98D8AB3D3C66;
		private delegate* unmanaged[Cdecl]<int> fn__0x5EDEF0CF8C1DAB3C;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setCutsceneCanBeSkipped;
		private delegate* unmanaged[Cdecl]<void> fn__registerSynchronisedScriptSpeech;
		private delegate* unmanaged[Cdecl]<nint, int, int, int, int, void> fn__setCutscenePedComponentVariation;
		private delegate* unmanaged[Cdecl]<nint, int, int, void> fn__setCutscenePedComponentVariationFromPed;
		private delegate* unmanaged[Cdecl]<nint, int, bool> fn__doesCutsceneEntityExist;
		private delegate* unmanaged[Cdecl]<nint, int, int, int, int, void> fn__setCutscenePedPropVariation;
		private delegate* unmanaged[Cdecl]<bool> fn__hasCutsceneCutThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__datafileWatchRequestId;
		private delegate* unmanaged[Cdecl]<void> fn__datafileClearWatchList;
		private delegate* unmanaged[Cdecl]<int, bool> fn__datafileIsValidRequestId;
		private delegate* unmanaged[Cdecl]<int, bool> fn__datafileHasLoadedFileData;
		private delegate* unmanaged[Cdecl]<int, bool> fn__datafileHasValidFileData;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__datafileSelectActiveFile;
		private delegate* unmanaged[Cdecl]<int, bool> fn__datafileDeleteRequestedFile;
		private delegate* unmanaged[Cdecl]<int*, int, nint, nint, nint, nint, bool, int, bool> fn__ugcCreateContent;
		private delegate* unmanaged[Cdecl]<nint, nint, nint, nint, bool, int, bool> fn__ugcCreateMission;
		private delegate* unmanaged[Cdecl]<nint, int*, int, nint, nint, nint, nint, int, bool> fn__ugcUpdateContent;
		private delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int, bool> fn__ugcUpdateMission;
		private delegate* unmanaged[Cdecl]<nint, float, nint, int, bool> fn__ugcSetPlayerData;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__datafileSelectUgcData;
		private delegate* unmanaged[Cdecl]<int, bool, int, bool> fn__datafileSelectUgcStats;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__datafileSelectUgcPlayerData;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__datafileSelectCreatorStats;
		private delegate* unmanaged[Cdecl]<nint, int, bool> fn__datafileLoadOfflineUgc;
		private delegate* unmanaged[Cdecl]<int, void> fn__datafileCreate;
		private delegate* unmanaged[Cdecl]<int, void> fn__datafileDelete;
		private delegate* unmanaged[Cdecl]<int, void> fn__datafileStoreMissionHeader;
		private delegate* unmanaged[Cdecl]<void> fn__datafileFlushMissionHeader;
		private delegate* unmanaged[Cdecl]<int, nint> fn__datafileGetFileDict;
		private delegate* unmanaged[Cdecl]<nint, int, bool> fn__datafileStartSaveToCloud;
		private delegate* unmanaged[Cdecl]<bool*, bool> fn__datafileUpdateSaveToCloud;
		private delegate* unmanaged[Cdecl]<bool> fn__datafileIsSavePending;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0xA6EEF01087181EDD;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x6AD0BD5E087866CB;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xDBF860CF1DB8E599;
		private delegate* unmanaged[Cdecl]<int*, nint, bool, void> fn__datadictSetBool;
		private delegate* unmanaged[Cdecl]<int*, nint, int, void> fn__datadictSetInt;
		private delegate* unmanaged[Cdecl]<int*, nint, float, void> fn__datadictSetFloat;
		private delegate* unmanaged[Cdecl]<int*, nint, nint, void> fn__datadictSetString;
		private delegate* unmanaged[Cdecl]<int*, nint, float, float, float, void> fn__datadictSetVector;
		private delegate* unmanaged[Cdecl]<int*, nint, int> fn__datadictCreateDict;
		private delegate* unmanaged[Cdecl]<int*, nint, int> fn__datadictCreateArray;
		private delegate* unmanaged[Cdecl]<int*, nint, bool> fn__datadictGetBool;
		private delegate* unmanaged[Cdecl]<int*, nint, int> fn__datadictGetInt;
		private delegate* unmanaged[Cdecl]<int*, nint, float> fn__datadictGetFloat;
		private delegate* unmanaged[Cdecl]<int*, nint, nint> fn__datadictGetString;
		private delegate* unmanaged[Cdecl]<int*, nint, Vector3> fn__datadictGetVector;
		private delegate* unmanaged[Cdecl]<int*, nint, int> fn__datadictGetDict;
		private delegate* unmanaged[Cdecl]<int*, nint, int> fn__datadictGetArray;
		private delegate* unmanaged[Cdecl]<int*, nint, int> fn__datadictGetType;
		private delegate* unmanaged[Cdecl]<int*, bool, void> fn__dataarrayAddBool;
		private delegate* unmanaged[Cdecl]<int*, int, void> fn__dataarrayAddInt;
		private delegate* unmanaged[Cdecl]<int*, float, void> fn__dataarrayAddFloat;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__dataarrayAddString;
		private delegate* unmanaged[Cdecl]<int*, float, float, float, void> fn__dataarrayAddVector;
		private delegate* unmanaged[Cdecl]<int*, int> fn__dataarrayAddDict;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__dataarrayGetBool;
		private delegate* unmanaged[Cdecl]<int*, int, int> fn__dataarrayGetInt;
		private delegate* unmanaged[Cdecl]<int*, int, float> fn__dataarrayGetFloat;
		private delegate* unmanaged[Cdecl]<int*, int, nint> fn__dataarrayGetString;
		private delegate* unmanaged[Cdecl]<int*, int, Vector3> fn__dataarrayGetVector;
		private delegate* unmanaged[Cdecl]<int*, int, int> fn__dataarrayGetDict;
		private delegate* unmanaged[Cdecl]<int*, int> fn__dataarrayGetCount;
		private delegate* unmanaged[Cdecl]<int*, int, int> fn__dataarrayGetType;
		private delegate* unmanaged[Cdecl]<int, nint, int, bool> fn__decorSetTime;
		private delegate* unmanaged[Cdecl]<int, nint, bool, bool> fn__decorSetBool;
		private delegate* unmanaged[Cdecl]<int, nint, float, bool> fn__decorSetFloat;
		private delegate* unmanaged[Cdecl]<int, nint, int, bool> fn__decorSetInt;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__decorGetBool;
		private delegate* unmanaged[Cdecl]<int, nint, float> fn__decorGetFloat;
		private delegate* unmanaged[Cdecl]<int, nint, int> fn__decorGetInt;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__decorExistOn;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__decorRemove;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__decorRegister;
		private delegate* unmanaged[Cdecl]<nint, int, bool> fn__decorIsRegisteredAsType;
		private delegate* unmanaged[Cdecl]<void> fn__decorRegisterLock;
		private delegate* unmanaged[Cdecl]<bool> fn__0x241FCA5B1AA14F75;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isDlcPresent;
		private delegate* unmanaged[Cdecl]<bool> fn__0xF2E07819EF1A5289;
		private delegate* unmanaged[Cdecl]<bool> fn__0x9489659372A81585;
		private delegate* unmanaged[Cdecl]<bool> fn__0xA213B11DFF526300;
		private delegate* unmanaged[Cdecl]<bool> fn__getExtraContentPackHasBeenInstalled;
		private delegate* unmanaged[Cdecl]<bool> fn__getIsLoadingScreenActive;
		private delegate* unmanaged[Cdecl]<bool> fn__0xC4637A6D03C24CC3;
		private delegate* unmanaged[Cdecl]<bool*, int, bool> fn__hasCloudRequestsFinished;
		private delegate* unmanaged[Cdecl]<void> fn__onEnterSp;
		private delegate* unmanaged[Cdecl]<void> fn__onEnterMp;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesEntityExist;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__doesEntityBelongToThisScript;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesEntityHaveDrawable;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesEntityHavePhysics;
		private delegate* unmanaged[Cdecl]<int, nint, nint, int, bool> fn__hasEntityAnimFinished;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasEntityBeenDamagedByAnyObject;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasEntityBeenDamagedByAnyPed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasEntityBeenDamagedByAnyVehicle;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__hasEntityBeenDamagedByEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__hasEntityClearLosToEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__hasEntityClearLosToEntity2;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__hasEntityClearLosToEntityInFront;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasEntityCollidedWithAnything;
		private delegate* unmanaged[Cdecl]<int, int> fn__getLastMaterialHitByEntity;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getCollisionNormalOfLastHitForEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__forceEntityAiAndAnimationUpdate;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float> fn__getEntityAnimCurrentTime;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float> fn__getEntityAnimTotalTime;
		private delegate* unmanaged[Cdecl]<nint, nint, float> fn__getAnimDuration;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityAttachedTo;
		private delegate* unmanaged[Cdecl]<int, bool, Vector3> fn__getEntityCoords;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getEntityForwardVector;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntityForwardX;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntityForwardY;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntityHeading;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntityPhysicsHeading;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityHealth;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityMaxHealth;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setEntityMaxHealth;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, float> fn__getEntityHeight;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntityHeightAboveGround;
		private delegate* unmanaged[Cdecl]<int, Vector3*, Vector3*, Vector3*, Vector3*, void> fn__getEntityMatrix;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityModel;
		private delegate* unmanaged[Cdecl]<int, float, float, float, Vector3> fn__getOffsetFromEntityGivenWorldCoords;
		private delegate* unmanaged[Cdecl]<int, float, float, float, Vector3> fn__getOffsetFromEntityInWorldCoords;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntityPitch;
		private delegate* unmanaged[Cdecl]<int, float*, float*, float*, float*, void> fn__getEntityQuaternion;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntityRoll;
		private delegate* unmanaged[Cdecl]<int, int, Vector3> fn__getEntityRotation;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getEntityRotationVelocity;
		private delegate* unmanaged[Cdecl]<int, int*, nint> fn__getEntityScript;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntitySpeed;
		private delegate* unmanaged[Cdecl]<int, bool, Vector3> fn__getEntitySpeedVector;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntityUprightValue;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getEntityVelocity;
		private delegate* unmanaged[Cdecl]<int, int> fn__getObjectIndexFromEntityIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedIndexFromEntityIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleIndexFromEntityIndex;
		private delegate* unmanaged[Cdecl]<int, int, Vector3> fn__getWorldPositionOfEntityBone;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNearestPlayerToEntity;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getNearestPlayerToEntityOnTeam;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityType;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityPopulationType;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isAnEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityAPed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityAMissionEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityAVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityAnObject;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, bool, int, bool> fn__isEntityAtCoord;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, bool, int, bool> fn__isEntityAtEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityAttached;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityAttachedToAnyObject;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityAttachedToAnyPed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityAttachedToAnyVehicle;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isEntityAttachedToEntity;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isEntityDead;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityInAir;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, bool, int, bool> fn__isEntityInAngledArea;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, bool, int, bool> fn__isEntityInArea;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__isEntityInZone;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityInWater;
		private delegate* unmanaged[Cdecl]<int, float> fn__getEntitySubmergedLevel;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x694E00132F2823ED;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityOnScreen;
		private delegate* unmanaged[Cdecl]<int, nint, nint, int, bool> fn__isEntityPlayingAnim;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityStatic;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isEntityTouchingEntity;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isEntityTouchingModel;
		private delegate* unmanaged[Cdecl]<int, float, bool> fn__isEntityUpright;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityUpsidedown;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityVisible;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityVisibleToScript;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityOccluded;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool> fn__wouldEntityBeOccluded;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityWaitingForWorldCollision;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, bool, bool, bool, void> fn__applyForceToEntityCenterOfMass;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, int, bool, bool, bool, bool, bool, void> fn__applyForceToEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, float, bool, bool, bool, bool, int, bool, void> fn__attachEntityToEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool, void> fn__attachEntityBoneToEntityBone;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool, void> fn__attachEntityBoneToEntityBonePhysically;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, float, float, float, float, float, float, float, bool, bool, bool, bool, int, void> fn__attachEntityToEntityPhysically;
		private delegate* unmanaged[Cdecl]<int, void> fn__processEntityAttachments;
		private delegate* unmanaged[Cdecl]<int, nint, int> fn__getEntityBoneIndexByName;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearEntityLastDamageEntity;
		private delegate* unmanaged[Cdecl]<int*, void> fn__deleteEntity;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__detachEntity;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__freezeEntityPosition;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityCleanupByEngine;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, bool, bool, bool, float, int, bool> fn__playEntityAnim;
		private delegate* unmanaged[Cdecl]<int, int, nint, nint, float, float, int, float, bool> fn__playSynchronizedEntityAnim;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int*, int*, float, float, int, float, bool> fn__playSynchronizedMapEntityAnim;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, float, bool> fn__stopSynchronizedMapEntityAnim;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, int> fn__stopEntityAnim;
		private delegate* unmanaged[Cdecl]<int, float, bool, bool> fn__stopSynchronizedEntityAnim;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__hasAnimEventFired;
		private delegate* unmanaged[Cdecl]<nint, nint, nint, int*, int*, bool> fn__findAnimEventPhase;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, void> fn__setEntityAnimCurrentTime;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, void> fn__setEntityAnimSpeed;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setEntityAsMissionEntity;
		private delegate* unmanaged[Cdecl]<int*, void> fn__setEntityAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<int*, void> fn__setPedAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<int*, void> fn__setVehicleAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<int*, void> fn__setObjectAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityCanBeDamaged;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getEntityCanBeDamaged;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__setEntityCanBeDamagedByRelationshipGroup;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x352E2B5CF420BF3B;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityCanBeTargetedWithoutLos;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setEntityCollision;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getEntityCollisionDisabled;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setEntityCompletelyDisableCollision;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, bool, void> fn__setEntityCoords;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, bool, void> fn__setEntityCoordsWithoutPlantsReset;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, void> fn__setEntityCoordsNoOffset;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityDynamic;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setEntityHeading;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setEntityHealth;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityInvincible;
		private delegate* unmanaged[Cdecl]<int, bool, float, void> fn__setEntityIsTargetPriority;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityLights;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__setEntityLoadCollisionFlag;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasCollisionLoadedAroundEntity;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setEntityMaxSpeed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityOnlyDamagedByPlayer;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__setEntityOnlyDamagedByRelationshipGroup;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, bool, bool, bool, bool, void> fn__setEntityProofs;
		private delegate* unmanaged[Cdecl]<int, bool*, bool*, bool*, bool*, bool*, bool*, bool*, bool*, bool> fn__getEntityProofs;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, void> fn__setEntityQuaternion;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityRecordsCollisions;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, bool, void> fn__setEntityRotation;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setEntityVisible;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xC34BC448DA29F5E9;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xE66377CDDADA4810;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setEntityVelocity;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setEntityAngularVelocity;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityHasGravity;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setEntityLodDist;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityLodDist;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setEntityAlpha;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityAlpha;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetEntityAlpha;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x490861B88F4FD846;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xCEA7C8E1B48FF68C;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x5C3B791D580E0BC2;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityAlwaysPrerender;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityRenderScorched;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setEntityTrafficlightOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x78E8E3A640178255;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, bool, void> fn__createModelSwap;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, bool, void> fn__removeModelSwap;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, void> fn__createModelHide;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, void> fn__createModelHideExcludingScriptObjects;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, void> fn__removeModelHide;
		private delegate* unmanaged[Cdecl]<float, float, float, int, int, bool, void> fn__createForcedObject;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__removeForcedObject;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setEntityNoCollisionEntity;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityMotionBlur;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCanAutoVaultOnEntity;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCanClimbOnEntity;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xDC6F8601FAF2E893;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityDecalsDisabled;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x1A092BB0C3808B96;
		private delegate* unmanaged[Cdecl]<int, int, Vector3> fn__getEntityBoneRotation;
		private delegate* unmanaged[Cdecl]<int, int, Vector3> fn__getEntityBonePosition2;
		private delegate* unmanaged[Cdecl]<int, int, Vector3> fn__getEntityBoneRotationLocal;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityBoneCount;
		private delegate* unmanaged[Cdecl]<int, void> fn__enableEntityUnk;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xB17BC6453F6CF5AC;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x68B562E124CC0AEF;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x36F32DE87082343E;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getEntityPickup;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xD7B80E7C3BEFC396;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setDecisionMaker;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__clearDecisionMakerEventResponse;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__blockDecisionMakerEvent;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__unblockDecisionMakerEvent;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int> fn__addShockingEventAtPosition;
		private delegate* unmanaged[Cdecl]<int, int, float, int> fn__addShockingEventForEntity;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool> fn__isShockingEventInSphere;
		private delegate* unmanaged[Cdecl]<int, bool> fn__removeShockingEvent;
		private delegate* unmanaged[Cdecl]<bool, void> fn__removeAllShockingEvents;
		private delegate* unmanaged[Cdecl]<void> fn__removeShockingEventSpawnBlockingAreas;
		private delegate* unmanaged[Cdecl]<void> fn__suppressShockingEventsNextFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__suppressShockingEventTypeNextFrame;
		private delegate* unmanaged[Cdecl]<void> fn__suppressAgitationEventsNextFrame;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumTattooShopDlcItems;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__getTattooShopDlcItemData;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__0x10144267DD22866C;
		private delegate* unmanaged[Cdecl]<int*, void> fn__initShopPedComponent;
		private delegate* unmanaged[Cdecl]<int*, void> fn__initShopPedProp;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__setupShopPedApparelQuery;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, int, int, int> fn__setupShopPedApparelQueryTu;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getShopPedQueryComponent;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x96E2929292A4DB77;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getShopPedComponent;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getShopPedQueryProp;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x6CEBE002E58DEE97;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getShopPedProp;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__getHashNameForComponent;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__getHashNameForProp;
		private delegate* unmanaged[Cdecl]<int, int> fn__getItemVariantsCount;
		private delegate* unmanaged[Cdecl]<int, int> fn__getShopPedApparelVariantPropCount;
		private delegate* unmanaged[Cdecl]<int, int, int*, int*, int*, void> fn__getVariantComponent;
		private delegate* unmanaged[Cdecl]<int, int, int*, int*, int*, void> fn__getVariantProp;
		private delegate* unmanaged[Cdecl]<int, int> fn__getShopPedApparelForcedComponentCount;
		private delegate* unmanaged[Cdecl]<int, int> fn__getShopPedApparelForcedPropCount;
		private delegate* unmanaged[Cdecl]<int, int, int*, int*, int*, void> fn__getForcedComponent;
		private delegate* unmanaged[Cdecl]<int, int, int*, int*, int*, void> fn__getForcedProp;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__isTagRestricted;
		private delegate* unmanaged[Cdecl]<int, bool, int> fn__setupShopPedOutfitQuery;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getShopPedQueryOutfit;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getShopPedOutfit;
		private delegate* unmanaged[Cdecl]<int, int> fn__getShopPedOutfitLocate;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__getShopPedOutfitPropVariant;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__getShopPedOutfitComponentVariant;
		private delegate* unmanaged[Cdecl]<int> fn__getNumDlcVehicles;
		private delegate* unmanaged[Cdecl]<int, int> fn__getDlcVehicleModel;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getDlcVehicleData;
		private delegate* unmanaged[Cdecl]<int, int> fn__getDlcVehicleFlags;
		private delegate* unmanaged[Cdecl]<int> fn__getNumDlcWeapons;
		private delegate* unmanaged[Cdecl]<int> fn__getNumDlcWeaponsSp;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getDlcWeaponData;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getDlcWeaponDataSp;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumDlcWeaponComponents;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumDlcWeaponComponentsSp;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__getDlcWeaponComponentData;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__getDlcWeaponComponentDataSp;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isContentItemLocked;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isDlcVehicleMod;
		private delegate* unmanaged[Cdecl]<int, int> fn__getDlcVehicleModLockHash;
		private delegate* unmanaged[Cdecl]<int, void> fn__loadContentChangeSetGroup;
		private delegate* unmanaged[Cdecl]<int, void> fn__unloadContentChangeSetGroup;
		private delegate* unmanaged[Cdecl]<float, float, float, int, bool, int> fn__startScriptFire;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeScriptFire;
		private delegate* unmanaged[Cdecl]<int, int> fn__startEntityFire;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopEntityFire;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityOnFire;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int> fn__getNumberOfFiresInRange;
		private delegate* unmanaged[Cdecl]<float, void> fn__setFireSpreadRate;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__stopFireInRange;
		private delegate* unmanaged[Cdecl]<Vector3*, float, float, float, bool> fn__getClosestFirePos;
		private delegate* unmanaged[Cdecl]<float, float, float, int, float, bool, bool, float, bool, void> fn__addExplosion;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, float, bool, bool, float, void> fn__addOwnedExplosion;
		private delegate* unmanaged[Cdecl]<float, float, float, int, int, float, bool, bool, float, void> fn__addExplosionWithUserVfx;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool> fn__isExplosionInArea;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool> fn__isExplosionActiveInArea;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool> fn__isExplosionInSphere;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int> fn__getEntityInsideExplosionSphere;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool> fn__isExplosionInAngledArea;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int> fn__getEntityInsideExplosionArea;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandBusyspinnerOn;
		private delegate* unmanaged[Cdecl]<int, void> fn__endTextCommandBusyspinnerOn;
		private delegate* unmanaged[Cdecl]<void> fn__busyspinnerOff;
		private delegate* unmanaged[Cdecl]<void> fn__preloadBusyspinner;
		private delegate* unmanaged[Cdecl]<bool> fn__busyspinnerIsOn;
		private delegate* unmanaged[Cdecl]<bool> fn__busyspinnerIsDisplaying;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x9245E81072704B8A;
		private delegate* unmanaged[Cdecl]<void> fn__setMouseCursorActiveThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__setMouseCursorSprite;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMouseCursorVisibleInMenus;
		private delegate* unmanaged[Cdecl]<int> fn__0x3D9ACB1EB139E702;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, bool> fn__0x632B2940C67F4EA9;
		private delegate* unmanaged[Cdecl]<bool, void> fn__thefeedOnlyShowTooltips;
		private delegate* unmanaged[Cdecl]<float, void> fn__thefeedSetScriptedMenuHeight;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedDisableLoadingScreenTips;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedHideThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedDisplayLoadingScreenTips;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedFlushQueue;
		private delegate* unmanaged[Cdecl]<int, void> fn__thefeedRemoveItem;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedForceRenderOn;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedForceRenderOff;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedPause;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedResume;
		private delegate* unmanaged[Cdecl]<bool> fn__thefeedIsPaused;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedSpsExtendWidescreenOn;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedSpsExtendWidescreenOff;
		private delegate* unmanaged[Cdecl]<int> fn__thefeedGetFirstVisibleDeleteRemaining;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedCommentTeleportPoolOn;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedCommentTeleportPoolOff;
		private delegate* unmanaged[Cdecl]<int, void> fn__thefeedSetNextPostBackgroundColor;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__thefeedSetAnimpostfxColor;
		private delegate* unmanaged[Cdecl]<int, void> fn__thefeedSetAnimpostfxCount;
		private delegate* unmanaged[Cdecl]<bool, void> fn__thefeedSetAnimpostfxSound;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedResetAllParameters;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedFreezeNextPost;
		private delegate* unmanaged[Cdecl]<void> fn__thefeedClearFrozenPost;
		private delegate* unmanaged[Cdecl]<bool, void> fn__thefeedSetFlushAnimpostfx;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void> fn__thefeedAddTxdRef;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandThefeedPost;
		private delegate* unmanaged[Cdecl]<nint, int, bool, int, bool, nint, nint, int> fn__endTextCommandThefeedPostStats;
		private delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, int> fn__endTextCommandThefeedPostMessagetext;
		private delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, int> fn__endTextCommandThefeedPostMessagetextGxtEntry;
		private delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, float, int> fn__endTextCommandThefeedPostMessagetextTu;
		private delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, float, nint, int> fn__endTextCommandThefeedPostMessagetextWithCrewTag;
		private delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, float, nint, int, int, int> fn__endTextCommandThefeedPostMessagetextWithCrewTagAndAdditionalIcon;
		private delegate* unmanaged[Cdecl]<bool, bool, int> fn__endTextCommandThefeedPostTicker;
		private delegate* unmanaged[Cdecl]<bool, bool, int> fn__endTextCommandThefeedPostTickerForced;
		private delegate* unmanaged[Cdecl]<bool, bool, int> fn__endTextCommandThefeedPostTickerWithTokens;
		private delegate* unmanaged[Cdecl]<nint, nint, int, int, nint, int> fn__endTextCommandThefeedPostAward;
		private delegate* unmanaged[Cdecl]<bool, bool, int*, int, bool, bool, int, int, int, int, int> fn__endTextCommandThefeedPostCrewtag;
		private delegate* unmanaged[Cdecl]<bool, bool, int*, int, bool, bool, int, nint, int, int, int, int> fn__endTextCommandThefeedPostCrewtagWithGameName;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__endTextCommandThefeedPostUnlock;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__endTextCommandThefeedPostUnlockTu;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int> fn__endTextCommandThefeedPostUnlockTuWithColor;
		private delegate* unmanaged[Cdecl]<bool, bool, int> fn__endTextCommandThefeedPostMpticker;
		private delegate* unmanaged[Cdecl]<nint, nint, nint, bool, bool, int> fn__endTextCommandThefeedPostCrewRankup;
		private delegate* unmanaged[Cdecl]<int*, int*, int, int*, int*, int, int, int, int> fn__endTextCommandThefeedPostVersusTu;
		private delegate* unmanaged[Cdecl]<int, int, nint, int> fn__endTextCommandThefeedPostReplayIcon;
		private delegate* unmanaged[Cdecl]<int, nint, nint, int> fn__endTextCommandThefeedPostReplayInput;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandPrint;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__endTextCommandPrint;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandIsMessageDisplayed;
		private delegate* unmanaged[Cdecl]<bool> fn__endTextCommandIsMessageDisplayed;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandDisplayText;
		private delegate* unmanaged[Cdecl]<float, float, int, void> fn__endTextCommandDisplayText;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandGetWidth;
		private delegate* unmanaged[Cdecl]<bool, float> fn__endTextCommandGetWidth;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandLineCount;
		private delegate* unmanaged[Cdecl]<float, float, int> fn__endTextCommandLineCount;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandDisplayHelp;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, void> fn__endTextCommandDisplayHelp;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandIsThisHelpMessageBeingDisplayed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__endTextCommandIsThisHelpMessageBeingDisplayed;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandSetBlipName;
		private delegate* unmanaged[Cdecl]<int, void> fn__endTextCommandSetBlipName;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandObjective;
		private delegate* unmanaged[Cdecl]<bool, void> fn__endTextCommandObjective;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandClearPrint;
		private delegate* unmanaged[Cdecl]<void> fn__endTextCommandClearPrint;
		private delegate* unmanaged[Cdecl]<nint, void> fn__beginTextCommandOverrideButtonText;
		private delegate* unmanaged[Cdecl]<int, void> fn__endTextCommandOverrideButtonText;
		private delegate* unmanaged[Cdecl]<int, void> fn__addTextComponentInteger;
		private delegate* unmanaged[Cdecl]<float, int, void> fn__addTextComponentFloat;
		private delegate* unmanaged[Cdecl]<nint, void> fn__addTextComponentSubstringTextLabel;
		private delegate* unmanaged[Cdecl]<int, void> fn__addTextComponentSubstringTextLabelHashKey;
		private delegate* unmanaged[Cdecl]<int, void> fn__addTextComponentSubstringBlipName;
		private delegate* unmanaged[Cdecl]<nint, void> fn__addTextComponentSubstringPlayerName;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__addTextComponentSubstringTime;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__addTextComponentFormattedInteger;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__addTextComponentSubstringPhoneNumber;
		private delegate* unmanaged[Cdecl]<nint, void> fn__addTextComponentSubstringWebsite;
		private delegate* unmanaged[Cdecl]<nint, void> fn__addTextComponentSubstringKeyboardDisplay;
		private delegate* unmanaged[Cdecl]<int, void> fn__setColourOfNextTextComponent;
		private delegate* unmanaged[Cdecl]<nint, int, int, nint> fn__getTextSubstring;
		private delegate* unmanaged[Cdecl]<nint, int, int, int, nint> fn__getTextSubstringSafe;
		private delegate* unmanaged[Cdecl]<nint, int, int, nint> fn__getTextSubstringSlice;
		private delegate* unmanaged[Cdecl]<nint, nint> fn__getLabelText;
		private delegate* unmanaged[Cdecl]<void> fn__clearPrints;
		private delegate* unmanaged[Cdecl]<void> fn__clearBrief;
		private delegate* unmanaged[Cdecl]<void> fn__clearAllHelpMessages;
		private delegate* unmanaged[Cdecl]<nint, void> fn__clearThisPrint;
		private delegate* unmanaged[Cdecl]<void> fn__clearSmallPrints;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__doesTextBlockExist;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__requestAdditionalText;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__requestAdditionalTextForDlc;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasAdditionalTextLoaded;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__clearAdditionalText;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isStreamingAdditionalText;
		private delegate* unmanaged[Cdecl]<nint, int, bool> fn__hasThisAdditionalTextLoaded;
		private delegate* unmanaged[Cdecl]<bool> fn__isMessageBeingDisplayed;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__doesTextLabelExist;
		private delegate* unmanaged[Cdecl]<nint, int, nint> fn__0x98C3CF913D895111;
		private delegate* unmanaged[Cdecl]<nint, int> fn__getLengthOfStringWithThisTextLabel;
		private delegate* unmanaged[Cdecl]<nint, int> fn__getLengthOfLiteralString;
		private delegate* unmanaged[Cdecl]<nint, int> fn__getLengthOfLiteralStringInBytes;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getStreetNameFromHashKey;
		private delegate* unmanaged[Cdecl]<bool> fn__isHudPreferenceSwitchedOn;
		private delegate* unmanaged[Cdecl]<bool> fn__isRadarPreferenceSwitchedOn;
		private delegate* unmanaged[Cdecl]<bool> fn__isSubtitlePreferenceSwitchedOn;
		private delegate* unmanaged[Cdecl]<bool, void> fn__displayHud;
		private delegate* unmanaged[Cdecl]<void> fn__displayHudWhenDeadThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__displayHudWhenPausedThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__displayRadar;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xCD74233600C4EA6B;
		private delegate* unmanaged[Cdecl]<bool> fn__0xC2D2AD9EAAE265B8;
		private delegate* unmanaged[Cdecl]<bool> fn__isHudHidden;
		private delegate* unmanaged[Cdecl]<bool> fn__isRadarHidden;
		private delegate* unmanaged[Cdecl]<bool> fn__isMinimapRendering;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x0C698D8F099174C7;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xE4C3B169876D33D7;
		private delegate* unmanaged[Cdecl]<void> fn__0xEB81A3DADD503187;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipRoute;
		private delegate* unmanaged[Cdecl]<void> fn__clearAllBlipRoutes;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipRouteColour;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x2790F4B17D098E26;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x6CDD58146A436083;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xD1942374085C8469;
		private delegate* unmanaged[Cdecl]<bool, void> fn__addNextMessageToPreviousBriefs;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x57D760D55F54E071;
		private delegate* unmanaged[Cdecl]<float, void> fn__setRadarZoomPrecise;
		private delegate* unmanaged[Cdecl]<int, void> fn__setRadarZoom;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setRadarZoomToBlip;
		private delegate* unmanaged[Cdecl]<float, void> fn__setRadarZoomToDistance;
		private delegate* unmanaged[Cdecl]<void> fn__0xD2049635DEB9C375;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, int*, void> fn__getHudColour;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setScriptVariableHudColour;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setScriptVariable2HudColour;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__replaceHudColour;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__replaceHudColourWithRgba;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setAbilityBarVisibilityInMultiplayer;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setAllowAbilityBarInMultiplayer;
		private delegate* unmanaged[Cdecl]<int, void> fn__flashAbilityBar;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__setAbilityBarValue;
		private delegate* unmanaged[Cdecl]<bool, void> fn__flashWantedDisplay;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xBA8D65C1C65702E5;
		private delegate* unmanaged[Cdecl]<float, int, float> fn__getRenderedCharacterHeight;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__setTextScale;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setTextColour;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setTextCentre;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setTextRightJustify;
		private delegate* unmanaged[Cdecl]<int, void> fn__setTextJustification;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__setTextWrap;
		private delegate* unmanaged[Cdecl]<int, void> fn__setTextLeading;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setTextProportional;
		private delegate* unmanaged[Cdecl]<int, void> fn__setTextFont;
		private delegate* unmanaged[Cdecl]<void> fn__setTextDropShadow;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setTextDropshadow;
		private delegate* unmanaged[Cdecl]<void> fn__setTextOutline;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setTextEdge;
		private delegate* unmanaged[Cdecl]<int, void> fn__setTextRenderId;
		private delegate* unmanaged[Cdecl]<int> fn__getDefaultScriptRendertargetRenderId;
		private delegate* unmanaged[Cdecl]<nint, bool, bool> fn__registerNamedRendertarget;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isNamedRendertargetRegistered;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__releaseNamedRendertarget;
		private delegate* unmanaged[Cdecl]<int, void> fn__linkNamedRendertarget;
		private delegate* unmanaged[Cdecl]<nint, int> fn__getNamedRendertargetRenderId;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isNamedRendertargetLinked;
		private delegate* unmanaged[Cdecl]<bool, void> fn__clearHelp;
		private delegate* unmanaged[Cdecl]<bool> fn__isHelpMessageOnScreen;
		private delegate* unmanaged[Cdecl]<bool> fn__0x214CD562A939246A;
		private delegate* unmanaged[Cdecl]<bool> fn__isHelpMessageBeingDisplayed;
		private delegate* unmanaged[Cdecl]<bool> fn__isHelpMessageFadingOut;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setHelpMessageTextStyle;
		private delegate* unmanaged[Cdecl]<bool> fn__getStandardBlipEnumId;
		private delegate* unmanaged[Cdecl]<int> fn__getWaypointBlipEnumId;
		private delegate* unmanaged[Cdecl]<int> fn__getNumberOfActiveBlips;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNextBlipInfoId;
		private delegate* unmanaged[Cdecl]<int, int> fn__getFirstBlipInfoId;
		private delegate* unmanaged[Cdecl]<int, int> fn__getClosestBlipOfType;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getBlipInfoIdCoord;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipInfoIdDisplay;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipInfoIdType;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipInfoIdEntityIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipInfoIdPickupIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipFromEntity;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int> fn__addBlipForRadius;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, int> fn__addBlipForArea;
		private delegate* unmanaged[Cdecl]<int, int> fn__addBlipForEntity;
		private delegate* unmanaged[Cdecl]<int, int> fn__addBlipForPickup;
		private delegate* unmanaged[Cdecl]<float, float, float, int> fn__addBlipForCoord;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, void> fn__triggerSonarBlip;
		private delegate* unmanaged[Cdecl]<bool, void> fn__allowSonarBlips;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setBlipCoords;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getBlipCoords;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipSprite;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipSprite;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x9FCB3CBFB3EAD69A;
		private delegate* unmanaged[Cdecl]<void> fn__0xB7B873520C84C118;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setBlipNameFromTextFile;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipNameToPlayerName;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipAlpha;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipAlpha;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setBlipFade;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x2C173AE2BDB9385E;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipRotation;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setBlipSquaredRotation;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipRotation;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipFlashTimer;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipFlashInterval;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipColour;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setBlipSecondaryColour;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipColour;
		private delegate* unmanaged[Cdecl]<int, int> fn__getBlipHudColour;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isBlipShortRange;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isBlipOnMinimap;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesBlipHaveGpsRoute;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipHiddenOnLegend;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipHighDetail;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipAsMissionCreatorBlip;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMissionCreatorBlip;
		private delegate* unmanaged[Cdecl]<int> fn__getNewSelectedMissionCreatorBlip;
		private delegate* unmanaged[Cdecl]<bool> fn__isHoveringOverMissionCreatorBlip;
		private delegate* unmanaged[Cdecl]<bool, void> fn__showStartMissionInstructionalButton;
		private delegate* unmanaged[Cdecl]<void> fn__0x2916A928514C9827;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xB552929B85FC27EC;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipFlashes;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipFlashesAlternate;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isBlipFlashing;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipAsShortRange;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setBlipScale;
		private delegate* unmanaged[Cdecl]<int, float, float, void> fn__setBlipScaleTransformation;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipPriority;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipDisplay;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setBlipCategory;
		private delegate* unmanaged[Cdecl]<int*, void> fn__removeBlip;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipAsFriendly;
		private delegate* unmanaged[Cdecl]<int, void> fn__pulseBlip;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__showNumberOnBlip;
		private delegate* unmanaged[Cdecl]<int, void> fn__hideNumberOnBlip;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__showHeightOnBlip;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__showTickOnBlip;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__showHeadingIndicatorOnBlip;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__showOutlineIndicatorOnBlip;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__showFriendIndicatorOnBlip;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__showCrewIndicatorOnBlip;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipDisplayIndicatorOnBlip;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x4B5B620C9B59ED34;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x2C9F302398E13141;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipAsMinimalOnEdge;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setRadiusBlipEdge;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesBlipExist;
		private delegate* unmanaged[Cdecl]<void> fn__setWaypointOff;
		private delegate* unmanaged[Cdecl]<void> fn__deleteWaypoint;
		private delegate* unmanaged[Cdecl]<void> fn__refreshWaypoint;
		private delegate* unmanaged[Cdecl]<bool> fn__isWaypointActive;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__setNewWaypoint;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlipBright;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__setBlipShowCone;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC594B315EDF2D4AF;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, void> fn__0xF83D0FEBE75E62C9;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x35A3CD97B2C0A6D2;
		private delegate* unmanaged[Cdecl]<void> fn__0x8410C5E0CD847B9D;
		private delegate* unmanaged[Cdecl]<int, bool, int, int> fn__setMinimapComponent;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMinimapSonarEnabled;
		private delegate* unmanaged[Cdecl]<void> fn__showSigninUi;
		private delegate* unmanaged[Cdecl]<int> fn__getMainPlayerBlipId;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x41350B4FC28E3941;
		private delegate* unmanaged[Cdecl]<void> fn__hideLoadingOnFadeThisFrame;
		private delegate* unmanaged[Cdecl]<int, float, float, int, int, void> fn__setRadarAsInteriorThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setInteriorZoomLevelIncreased;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setInteriorZoomLevelDecreased;
		private delegate* unmanaged[Cdecl]<void> fn__setRadarAsExteriorThisFrame;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__setPlayerBlipPositionThisFrame;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0xA17784FCA9548D15;
		private delegate* unmanaged[Cdecl]<bool> fn__isMinimapInInterior;
		private delegate* unmanaged[Cdecl]<void> fn__hideMinimapExteriorMapThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__hideMinimapInteriorMapThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setToggleMinimapHeistIsland;
		private delegate* unmanaged[Cdecl]<void> fn__dontTiltMinimapThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__0x55F5A5F07134DE60;
		private delegate* unmanaged[Cdecl]<int, void> fn__setWidescreenFormat;
		private delegate* unmanaged[Cdecl]<bool, void> fn__displayAreaName;
		private delegate* unmanaged[Cdecl]<bool, void> fn__displayCash;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x170F541E1CADD1DE;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerCashChange;
		private delegate* unmanaged[Cdecl]<bool, void> fn__displayAmmoThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__displaySniperScopeThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__hideHudAndRadarThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xE67C6DFD386EA5E7;
		private delegate* unmanaged[Cdecl]<void> fn__setMultiplayerWalletCash;
		private delegate* unmanaged[Cdecl]<void> fn__removeMultiplayerWalletCash;
		private delegate* unmanaged[Cdecl]<void> fn__setMultiplayerBankCash;
		private delegate* unmanaged[Cdecl]<void> fn__removeMultiplayerBankCash;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setMultiplayerHudCash;
		private delegate* unmanaged[Cdecl]<void> fn__removeMultiplayerHudCash;
		private delegate* unmanaged[Cdecl]<void> fn__hideHelpTextThisFrame;
		private delegate* unmanaged[Cdecl]<bool> fn__0x801879A9B4F4B2FB;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__displayHelpTextThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__hudForceWeaponWheel;
		private delegate* unmanaged[Cdecl]<void> fn__hudDisplayLoadingScreenTips;
		private delegate* unmanaged[Cdecl]<void> fn__blockWeaponWheelThisFrame;
		private delegate* unmanaged[Cdecl]<int> fn__hudWeaponWheelGetSelectedHash;
		private delegate* unmanaged[Cdecl]<int, void> fn__hudSetWeaponWheelTopSlot;
		private delegate* unmanaged[Cdecl]<int, int> fn__hudWeaponWheelGetSlotHash;
		private delegate* unmanaged[Cdecl]<bool, void> fn__hudWeaponWheelIgnoreControlInput;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setGpsFlags;
		private delegate* unmanaged[Cdecl]<void> fn__clearGpsFlags;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setRaceTrackRender;
		private delegate* unmanaged[Cdecl]<void> fn__clearGpsRaceTrack;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__startGpsCustomRoute;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__addPointToGpsCustomRoute;
		private delegate* unmanaged[Cdecl]<bool, int, int, void> fn__setGpsCustomRouteRender;
		private delegate* unmanaged[Cdecl]<void> fn__clearGpsCustomRoute;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__startGpsMultiRoute;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__addPointToGpsMultiRoute;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setGpsMultiRouteRender;
		private delegate* unmanaged[Cdecl]<void> fn__clearGpsMultiRoute;
		private delegate* unmanaged[Cdecl]<void> fn__clearGpsPlayerWaypoint;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setGpsFlashes;
		private delegate* unmanaged[Cdecl]<int, void> fn__setMainPlayerBlipColour;
		private delegate* unmanaged[Cdecl]<void> fn__flashMinimapDisplay;
		private delegate* unmanaged[Cdecl]<int, void> fn__flashMinimapDisplayWithColor;
		private delegate* unmanaged[Cdecl]<bool, void> fn__toggleStealthRadar;
		private delegate* unmanaged[Cdecl]<bool, int, void> fn__setMinimapInSpectatorMode;
		private delegate* unmanaged[Cdecl]<bool, nint, void> fn__setMissionName;
		private delegate* unmanaged[Cdecl]<bool, nint, void> fn__setMissionName2;
		private delegate* unmanaged[Cdecl]<bool, int*, int*, int*, int*, int*, int*, int*, int*, void> fn__0x817B86108EB94E51;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMinimapBlockWaypoint;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMinimapInPrologue;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMinimapHideFow;
		private delegate* unmanaged[Cdecl]<float> fn__getMinimapFowDiscoveryRatio;
		private delegate* unmanaged[Cdecl]<float, float, float, bool> fn__getMinimapFowCoordinateIsRevealed;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x62E849B7EB28E770;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__setMinimapFowRevealCoordinate;
		private delegate* unmanaged[Cdecl]<int, void> fn__setMinimapGolfCourse;
		private delegate* unmanaged[Cdecl]<void> fn__setMinimapGolfCourseOff;
		private delegate* unmanaged[Cdecl]<int, void> fn__lockMinimapAngle;
		private delegate* unmanaged[Cdecl]<void> fn__unlockMinimapAngle;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__lockMinimapPosition;
		private delegate* unmanaged[Cdecl]<void> fn__unlockMinimapPosition;
		private delegate* unmanaged[Cdecl]<float, bool, int, void> fn__setMinimapAltitudeIndicatorLevel;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setHealthHudDisplayValues;
		private delegate* unmanaged[Cdecl]<int, void> fn__setMaxHealthHudDisplay;
		private delegate* unmanaged[Cdecl]<int, void> fn__setMaxArmourHudDisplay;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__setBigmapActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isHudComponentActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isScriptedHudComponentActive;
		private delegate* unmanaged[Cdecl]<int, void> fn__hideScriptedHudComponentThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__showScriptedHudComponentThisFrame;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isScriptedHudComponentHiddenThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__hideHudComponentThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__showHudComponentThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__hideAreaAndVehicleNameThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__resetReticuleValues;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetHudComponentValues;
		private delegate* unmanaged[Cdecl]<int, float, float, void> fn__setHudComponentPosition;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getHudComponentPosition;
		private delegate* unmanaged[Cdecl]<void> fn__clearReminderMessage;
		private delegate* unmanaged[Cdecl]<float, float, float, float*, float*, bool> fn__getScreenCoordFromWorldCoord2;
		private delegate* unmanaged[Cdecl]<void> fn__openReportugcMenu;
		private delegate* unmanaged[Cdecl]<void> fn__forceCloseReportugcMenu;
		private delegate* unmanaged[Cdecl]<bool> fn__isReportugcMenuOpen;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isFloatingHelpTextOnScreen;
		private delegate* unmanaged[Cdecl]<int, float, float, void> fn__setFloatingHelpTextScreenPosition;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setFloatingHelpTextWorldPosition;
		private delegate* unmanaged[Cdecl]<int, int, float, float, void> fn__setFloatingHelpTextToEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__setFloatingHelpTextStyle;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__clearFloatingHelp;
		private delegate* unmanaged[Cdecl]<int, nint, bool, bool, nint, int, int, int, int, void> fn__createMpGamerTagWithCrewColor;
		private delegate* unmanaged[Cdecl]<bool> fn__isMpGamerTagMovieActive;
		private delegate* unmanaged[Cdecl]<int, nint, bool, bool, nint, int, int> fn__createFakeMpGamerTag;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeMpGamerTag;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMpGamerTagActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMpGamerTagFree;
		private delegate* unmanaged[Cdecl]<int, int, bool, int, void> fn__setMpGamerTagVisibility;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setMpGamerTagEnabled;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setMpGamerTagIcons;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setMpGamerHealthBarDisplay;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setMpGamerHealthBarMax;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setMpGamerTagColour;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setMpGamerTagHealthBarColour;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setMpGamerTagAlpha;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setMpGamerTagWantedLevel;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setMpGamerTagUnk;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setMpGamerTagName;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isValidMpGamerTagMovie;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setMpGamerTagBigText;
		private delegate* unmanaged[Cdecl]<int> fn__getCurrentWebpageId;
		private delegate* unmanaged[Cdecl]<int> fn__getCurrentWebsiteId;
		private delegate* unmanaged[Cdecl]<int, int> fn__getGlobalActionscriptFlag;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetGlobalActionscriptFlag;
		private delegate* unmanaged[Cdecl]<bool> fn__isWarningMessageActive2;
		private delegate* unmanaged[Cdecl]<nint, int, nint, bool, int, nint, nint, bool, int, void> fn__setWarningMessage;
		private delegate* unmanaged[Cdecl]<nint, nint, int, nint, bool, int, int*, int*, bool, int, void> fn__setWarningMessageWithHeader;
		private delegate* unmanaged[Cdecl]<nint, nint, int, nint, bool, int, int, nint, nint, bool, int, void> fn__setWarningMessageWithHeaderAndSubstringFlags;
		private delegate* unmanaged[Cdecl]<nint, nint, int, nint, bool, int, int*, int*, bool, int, int, void> fn__setWarningMessageWithHeaderUnk;
		private delegate* unmanaged[Cdecl]<nint, nint, int, int, nint, bool, int, int, nint, nint, bool, int, void> fn__setWarningMessageWithAlert;
		private delegate* unmanaged[Cdecl]<int> fn__getWarningMessageTitleHash;
		private delegate* unmanaged[Cdecl]<int, nint, int, int, int, int, bool> fn__setWarningMessageListRow;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xDAF87174BE7454FF;
		private delegate* unmanaged[Cdecl]<void> fn__removeWarningMessageListItems;
		private delegate* unmanaged[Cdecl]<bool> fn__isWarningMessageActive;
		private delegate* unmanaged[Cdecl]<void> fn__clearDynamicPauseMenuErrorMessage;
		private delegate* unmanaged[Cdecl]<bool, void> fn__raceGalleryFullscreen;
		private delegate* unmanaged[Cdecl]<int, void> fn__raceGalleryNextBlipSprite;
		private delegate* unmanaged[Cdecl]<float, float, float, int> fn__raceGalleryAddBlip;
		private delegate* unmanaged[Cdecl]<void> fn__clearRaceGalleryBlips;
		private delegate* unmanaged[Cdecl]<int> fn__forceSonarBlipsThisFrame;
		private delegate* unmanaged[Cdecl]<int> fn__getNorthRadarBlip;
		private delegate* unmanaged[Cdecl]<bool, void> fn__displayPlayerNameTagsOnBlips;
		private delegate* unmanaged[Cdecl]<void> fn__0x211C4EF450086857;
		private delegate* unmanaged[Cdecl]<void> fn__0xBF4F34A85CA2970C;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__activateFrontendMenu;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__restartFrontendMenu;
		private delegate* unmanaged[Cdecl]<int> fn__getCurrentFrontendMenuVersion;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setPauseMenuActive;
		private delegate* unmanaged[Cdecl]<void> fn__disableFrontendThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__suppressFrontendRenderingThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__allowPauseMenuWhenDeadThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setFrontendActive;
		private delegate* unmanaged[Cdecl]<bool> fn__isPauseMenuActive;
		private delegate* unmanaged[Cdecl]<bool> fn__0x2F057596F2BD0061;
		private delegate* unmanaged[Cdecl]<int> fn__getPauseMenuState;
		private delegate* unmanaged[Cdecl]<Vector3> fn__0x5BFF36D6ED83E0AE;
		private delegate* unmanaged[Cdecl]<bool> fn__isPauseMenuRestarting;
		private delegate* unmanaged[Cdecl]<nint, void> fn__logDebugInfo;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x77F16B447824DA6C;
		private delegate* unmanaged[Cdecl]<void> fn__0xCDCA26E80FAECB8F;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x2DE6C5E2E996F178;
		private delegate* unmanaged[Cdecl]<int, void> fn__pauseMenuActivateContext;
		private delegate* unmanaged[Cdecl]<int, void> fn__pauseMenuDeactivateContext;
		private delegate* unmanaged[Cdecl]<int, bool> fn__pauseMenuIsContextActive;
		private delegate* unmanaged[Cdecl]<bool> fn__pauseMenuIsContextMenuActive;
		private delegate* unmanaged[Cdecl]<int> fn__0xDE03620F8703A9DF;
		private delegate* unmanaged[Cdecl]<int> fn__0x359AF31A4B52F5ED;
		private delegate* unmanaged[Cdecl]<int> fn__0x13C4B962653A5280;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, bool> fn__0xC8E1071177A23BE5;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x4895BDEA16E7C080;
		private delegate* unmanaged[Cdecl]<bool, int, int, void> fn__pauseMenuSetBusySpinner;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xF06EBB91A81E09E3;
		private delegate* unmanaged[Cdecl]<bool> fn__isFrontendReadyForControl;
		private delegate* unmanaged[Cdecl]<void> fn__takeControlOfFrontend;
		private delegate* unmanaged[Cdecl]<void> fn__releaseControlOfFrontend;
		private delegate* unmanaged[Cdecl]<bool> fn__0x66E7CB63C97B7D20;
		private delegate* unmanaged[Cdecl]<int> fn__0x593FEAE1F73392D4;
		private delegate* unmanaged[Cdecl]<bool> fn__isNavigatingMenuContent;
		private delegate* unmanaged[Cdecl]<bool> fn__0xF284AC67940C6812;
		private delegate* unmanaged[Cdecl]<bool> fn__0x2E22FEFA0100275E;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x0CF54F20DE43879C;
		private delegate* unmanaged[Cdecl]<int*, int*, void> fn__getPauseMenuSelection;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, void> fn__getPauseMenuSelectionData;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, bool> fn__0xA238192F33110615;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getMenuPedIntStat;
		private delegate* unmanaged[Cdecl]<int, int*, int, bool> fn__0xCA6B2F7CE32AB653;
		private delegate* unmanaged[Cdecl]<int, int*, int, int, bool> fn__getMenuPedMaskedIntStat;
		private delegate* unmanaged[Cdecl]<int, int*, int, int, int, bool> fn__0x24A49BEAF468DC90;
		private delegate* unmanaged[Cdecl]<int, float*, bool> fn__getMenuPedFloatStat;
		private delegate* unmanaged[Cdecl]<int, int*, int, bool> fn__0x8F08017F9D7C47BD;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getMenuPedBoolStat;
		private delegate* unmanaged[Cdecl]<void> fn__clearPedInPauseMenu;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__givePedToPauseMenu;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setPauseMenuPedLighting;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setPauseMenuPedSleepState;
		private delegate* unmanaged[Cdecl]<void> fn__openOnlinePoliciesMenu;
		private delegate* unmanaged[Cdecl]<bool> fn__0xF13FE2A80C05C561;
		private delegate* unmanaged[Cdecl]<bool> fn__isOnlinePoliciesMenuActive;
		private delegate* unmanaged[Cdecl]<void> fn__openSocialClubMenu;
		private delegate* unmanaged[Cdecl]<void> fn__closeSocialClubMenu;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setSocialClubTour;
		private delegate* unmanaged[Cdecl]<bool> fn__isSocialClubActive;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x1185A8087587322C;
		private delegate* unmanaged[Cdecl]<void> fn__forceCloseTextInputBox;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x577599CCED639CA2;
		private delegate* unmanaged[Cdecl]<int, void> fn__overrideMultiplayerChatPrefix;
		private delegate* unmanaged[Cdecl]<bool> fn__isMultiplayerChatActive;
		private delegate* unmanaged[Cdecl]<void> fn__closeMultiplayerChat;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x7C226D5346D4D10A;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__overrideMultiplayerChatColour;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setTextChatUnk;
		private delegate* unmanaged[Cdecl]<bool, void> fn__flagPlayerContextInTournament;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedHasAiBlip;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__setPedHasAiBlipWithColor;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesPedHaveAiBlip;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedAiBlipGangId;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAiBlipHasCone;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAiBlipForcedOn;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedAiBlipNoticeRange;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedAiBlipSprite;
		private delegate* unmanaged[Cdecl]<int, int> fn__getAiBlip2;
		private delegate* unmanaged[Cdecl]<int, int> fn__getAiBlip;
		private delegate* unmanaged[Cdecl]<bool> fn__hasDirectorModeBeenTriggered;
		private delegate* unmanaged[Cdecl]<void> fn__setDirectorModeClearTriggeredFlag;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setPlayerIsInDirectorMode;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x04655F9D075D0AE5;
		private delegate* unmanaged[Cdecl]<void> fn__0x243296A510B562B6;
		private delegate* unmanaged[Cdecl]<int, float> fn__getInteriorHeading;
		private delegate* unmanaged[Cdecl]<int, Vector3*, int*, void> fn__getInteriorInfo;
		private delegate* unmanaged[Cdecl]<int, int> fn__getInteriorGroupId;
		private delegate* unmanaged[Cdecl]<int, float, float, float, Vector3> fn__getOffsetFromInteriorInWorldCoords;
		private delegate* unmanaged[Cdecl]<bool> fn__isInteriorScene;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isValidInterior;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearRoomForEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__forceRoomForEntity;
		private delegate* unmanaged[Cdecl]<int, int> fn__getRoomKeyFromEntity;
		private delegate* unmanaged[Cdecl]<int, int> fn__getKeyForEntityInRoom;
		private delegate* unmanaged[Cdecl]<int, int> fn__getInteriorFromEntity;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x82EBB79E258FA2B7;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearInteriorForEntity;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x38C1CB1CB119A016;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__forceRoomForGameViewport;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0xAF348AFCB575A441;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x405DC2AEF6AF95B9;
		private delegate* unmanaged[Cdecl]<int> fn__getRoomKeyForGameViewport;
		private delegate* unmanaged[Cdecl]<void> fn__clearRoomForGameViewport;
		private delegate* unmanaged[Cdecl]<int> fn__getInteriorFromGameplayCam;
		private delegate* unmanaged[Cdecl]<float, float, float, int> fn__getInteriorAtCoords;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__addPickupToInteriorRoomByName;
		private delegate* unmanaged[Cdecl]<int, void> fn__pinInteriorInMemory;
		private delegate* unmanaged[Cdecl]<int, void> fn__unpinInterior;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isInteriorReady;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x4C2330E61D3DEB56;
		private delegate* unmanaged[Cdecl]<float, float, float, nint, int> fn__getInteriorAtCoordsWithType;
		private delegate* unmanaged[Cdecl]<float, float, float, int, int> fn__getInteriorAtCoordsWithTypehash;
		private delegate* unmanaged[Cdecl]<void> fn__0x483ACA1176CA93F1;
		private delegate* unmanaged[Cdecl]<float, float, float, bool> fn__isCollisionMarkedOutside;
		private delegate* unmanaged[Cdecl]<float, float, float, int> fn__getInteriorFromCollision;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x7ECDF98587E92DEC;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__activateInteriorEntitySet;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__deactivateInteriorEntitySet;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__isInteriorEntitySetActive;
		private delegate* unmanaged[Cdecl]<int, nint, int, void> fn__setInteriorEntitySetColor;
		private delegate* unmanaged[Cdecl]<int, void> fn__refreshInterior;
		private delegate* unmanaged[Cdecl]<int, void> fn__enableExteriorCullModelThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__enableScriptCullModelThisFrame;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__disableInterior;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isInteriorDisabled;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__capInterior;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isInteriorCapped;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x9E6542F0CE8E70A3;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x7241CCB7D020DB69;
		private delegate* unmanaged[Cdecl]<bool, int> fn__createItemset;
		private delegate* unmanaged[Cdecl]<int, void> fn__destroyItemset;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isItemsetValid;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__addToItemset;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__removeFromItemset;
		private delegate* unmanaged[Cdecl]<int, int> fn__getItemsetSize;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getIndexedItemInItemset;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isInItemset;
		private delegate* unmanaged[Cdecl]<int, void> fn__cleanItemset;
		private delegate* unmanaged[Cdecl]<int> fn__0xF2CA003F167E21D2;
		private delegate* unmanaged[Cdecl]<bool> fn__loadingscreenGetLoadFreemode;
		private delegate* unmanaged[Cdecl]<bool, void> fn__loadingscreenSetLoadFreemode;
		private delegate* unmanaged[Cdecl]<bool> fn__loadingscreenGetLoadFreemodeWithEventName;
		private delegate* unmanaged[Cdecl]<bool, void> fn__loadingscreenSetLoadFreemodeWithEventName;
		private delegate* unmanaged[Cdecl]<bool> fn__loadingscreenIsLoadingFreemode;
		private delegate* unmanaged[Cdecl]<bool, void> fn__loadingscreenSetIsLoadingFreemode;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xFA1E0E893D915215;
		private delegate* unmanaged[Cdecl]<int> fn__localizationGetSystemLanguage;
		private delegate* unmanaged[Cdecl]<int> fn__getCurrentLanguage;
		private delegate* unmanaged[Cdecl]<int> fn__localizationGetSystemDateFormat;
		private delegate* unmanaged[Cdecl]<int> fn__getAllocatedStackSize;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumberOfFreeStacksOfThisSize;
		private delegate* unmanaged[Cdecl]<int, void> fn__setRandomSeed;
		private delegate* unmanaged[Cdecl]<float, void> fn__setTimeScale;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMissionFlag;
		private delegate* unmanaged[Cdecl]<bool> fn__getMissionFlag;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setRandomEventFlag;
		private delegate* unmanaged[Cdecl]<bool> fn__getRandomEventFlag;
		private delegate* unmanaged[Cdecl]<nint> fn__getGlobalCharBuffer;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__0x4DCDF92BF64236CD;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0x31125FD509D9043F;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0xEBD3205A207939ED;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x97E7E2C04245115B;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0x916CA67D26FD1E37;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__0xEB078CA2B5E82ADD;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0x703CC7F60CBB2B57;
		private delegate* unmanaged[Cdecl]<void> fn__0x8951EB9C6906D3C8;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0xBA4B8D83BDC75551;
		private delegate* unmanaged[Cdecl]<bool> fn__hasResumedFromSuspend;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x65D2EBB47E1CEC21;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x6F2135B6129620C1;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0x8D74E26F54B4E5C3;
		private delegate* unmanaged[Cdecl]<int*, int*, int, bool, bool> fn__getBaseElementMetadata;
		private delegate* unmanaged[Cdecl]<int> fn__getPrevWeatherTypeHashName;
		private delegate* unmanaged[Cdecl]<int> fn__getNextWeatherTypeHashName;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isPrevWeatherType;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isNextWeatherType;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setWeatherTypePersist;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setWeatherTypeNowPersist;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setWeatherTypeNow;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__setWeatherTypeOvertimePersist;
		private delegate* unmanaged[Cdecl]<void> fn__setRandomWeatherType;
		private delegate* unmanaged[Cdecl]<void> fn__clearWeatherTypePersist;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x0CF97F497FE7D048;
		private delegate* unmanaged[Cdecl]<int*, int*, float*, void> fn__getWeatherTypeTransition;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__setWeatherTypeTransition;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setOverrideWeather;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x1178E104409FE58C;
		private delegate* unmanaged[Cdecl]<void> fn__clearOverrideWeather;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetShorewaveamplitude;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetShorewaveminamplitude;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetShorewavemaxamplitude;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetOceannoiseminamplitude;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetOceanwaveamplitude;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetOceanwaveminamplitude;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetOceanwavemaxamplitude;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetRipplebumpiness;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetRippleminbumpiness;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetRipplemaxbumpiness;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetRippledisturb;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideSetStrength;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideFadeIn;
		private delegate* unmanaged[Cdecl]<float, void> fn__waterOverrideFadeOut;
		private delegate* unmanaged[Cdecl]<float, void> fn__setWind;
		private delegate* unmanaged[Cdecl]<float, void> fn__setWindSpeed;
		private delegate* unmanaged[Cdecl]<float> fn__getWindSpeed;
		private delegate* unmanaged[Cdecl]<float, void> fn__setWindDirection;
		private delegate* unmanaged[Cdecl]<Vector3> fn__getWindDirection;
		private delegate* unmanaged[Cdecl]<float, void> fn__setRainLevel;
		private delegate* unmanaged[Cdecl]<float> fn__getRainLevel;
		private delegate* unmanaged[Cdecl]<float, void> fn__setSnowLevel;
		private delegate* unmanaged[Cdecl]<float> fn__getSnowLevel;
		private delegate* unmanaged[Cdecl]<void> fn__forceLightningFlash;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0x02DEAAC8F8EA7FE7;
		private delegate* unmanaged[Cdecl]<nint, void> fn__preloadCloudHat;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__loadCloudHat;
		private delegate* unmanaged[Cdecl]<nint, float, void> fn__unloadCloudHat;
		private delegate* unmanaged[Cdecl]<void> fn__clearCloudHat;
		private delegate* unmanaged[Cdecl]<float, void> fn__setCloudHatOpacity;
		private delegate* unmanaged[Cdecl]<float> fn__getCloudHatOpacity;
		private delegate* unmanaged[Cdecl]<int> fn__getGameTimer;
		private delegate* unmanaged[Cdecl]<float> fn__getFrameTime;
		private delegate* unmanaged[Cdecl]<float> fn__getBenchmarkTime;
		private delegate* unmanaged[Cdecl]<int> fn__getFrameCount;
		private delegate* unmanaged[Cdecl]<float, float, float> fn__getRandomFloatInRange;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getRandomIntInRange;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getRandomIntInRange2;
		private delegate* unmanaged[Cdecl]<float, float, float, float*, bool, bool, bool> fn__getGroundZFor3dCoord;
		private delegate* unmanaged[Cdecl]<float, float, float, float*, Vector3*, bool> fn__getGroundZAndNormalFor3dCoord;
		private delegate* unmanaged[Cdecl]<float, float, float, float*, bool, bool, bool> fn__getGroundZFor3dCoord2;
		private delegate* unmanaged[Cdecl]<float, float> fn__asin;
		private delegate* unmanaged[Cdecl]<float, float> fn__acos;
		private delegate* unmanaged[Cdecl]<float, float> fn__tan;
		private delegate* unmanaged[Cdecl]<float, float> fn__atan;
		private delegate* unmanaged[Cdecl]<float, float, float> fn__atan2;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, float> fn__getDistanceBetweenCoords;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float> fn__getAngleBetween2dVectors;
		private delegate* unmanaged[Cdecl]<float, float, float> fn__getHeadingFromVector2d;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, bool, float> fn__0x7F8F6405F4777AF6;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, bool, Vector3> fn__0x21C235BC64831E5A;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, float*, bool> fn__0xF56DFB7B61BE7276;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, int, int, int> fn__0xA0AD167E4B39D9A2;
		private delegate* unmanaged[Cdecl]<int*, int, void> fn__setBit;
		private delegate* unmanaged[Cdecl]<int*, int, void> fn__clearBit;
		private delegate* unmanaged[Cdecl]<nint, int> fn__getHashKey;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float*, float*, float*, float*, void> fn__slerpNearQuaternion;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool, bool, bool, int, bool, bool> fn__isAreaOccupied;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, int, int> fn__0x39455BF4F4F55186;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, bool, bool, int, bool, bool> fn__isPositionOccupied;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool> fn__isPointObscuredByAMissionEntity;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, bool, void> fn__clearArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, bool, void> fn__clearAreaLeaveVehicleHealth;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, bool, bool, bool, void> fn__clearAreaOfVehicles;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, bool, bool, bool, bool, bool, int, void> fn__clearAngledAreaOfVehicles;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, void> fn__clearAreaOfObjects;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, void> fn__clearAreaOfPeds;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, void> fn__clearAreaOfCops;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, void> fn__clearAreaOfProjectiles;
		private delegate* unmanaged[Cdecl]<void> fn__0x7EC6F9A478A6A512;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setSaveMenuActive;
		private delegate* unmanaged[Cdecl]<int> fn__0x397BAA01068BAA96;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setCreditsActive;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xB51B9AB9EF81868C;
		private delegate* unmanaged[Cdecl]<bool> fn__haveCreditsReachedEnd;
		private delegate* unmanaged[Cdecl]<nint, void> fn__terminateAllScriptsWithThisName;
		private delegate* unmanaged[Cdecl]<void> fn__networkSetScriptIsSafeForNetworkGame;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int> fn__addHospitalRestart;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__disableHospitalRestart;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int> fn__addPoliceRestart;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__disablePoliceRestart;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__setRestartCustomPosition;
		private delegate* unmanaged[Cdecl]<void> fn__clearRestartCustomPosition;
		private delegate* unmanaged[Cdecl]<bool, void> fn__pauseDeathArrestRestart;
		private delegate* unmanaged[Cdecl]<bool, void> fn__ignoreNextRestart;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setFadeOutAfterDeath;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setFadeOutAfterArrest;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setFadeInAfterDeathArrest;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setFadeInAfterLoad;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int*, int, int, int> fn__registerSaveHouse;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setSaveHouse;
		private delegate* unmanaged[Cdecl]<bool, float, float, float, float, bool, float, float, bool> fn__overrideSaveHouse;
		private delegate* unmanaged[Cdecl]<Vector3*, float*, bool*, bool*, bool> fn__0xA4A0065E39C9F25C;
		private delegate* unmanaged[Cdecl]<void> fn__doAutoSave;
		private delegate* unmanaged[Cdecl]<bool> fn__getIsAutoSaveOff;
		private delegate* unmanaged[Cdecl]<bool> fn__isAutoSaveInProgress;
		private delegate* unmanaged[Cdecl]<bool> fn__hasCodeRequestedAutosave;
		private delegate* unmanaged[Cdecl]<void> fn__clearCodeRequestedAutosave;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__beginReplayStats;
		private delegate* unmanaged[Cdecl]<int, void> fn__addReplayStatValue;
		private delegate* unmanaged[Cdecl]<void> fn__endReplayStats;
		private delegate* unmanaged[Cdecl]<int> fn__haveReplayStatsBeenStored;
		private delegate* unmanaged[Cdecl]<int> fn__getReplayStatMissionId;
		private delegate* unmanaged[Cdecl]<int> fn__getReplayStatMissionType;
		private delegate* unmanaged[Cdecl]<int> fn__getReplayStatCount;
		private delegate* unmanaged[Cdecl]<int, int> fn__getReplayStatAtIndex;
		private delegate* unmanaged[Cdecl]<void> fn__clearReplayStats;
		private delegate* unmanaged[Cdecl]<bool> fn__queueMissionRepeatLoad;
		private delegate* unmanaged[Cdecl]<bool> fn__queueMissionRepeatSave;
		private delegate* unmanaged[Cdecl]<int> fn__0xEB2104E905C6F2E9;
		private delegate* unmanaged[Cdecl]<int> fn__getStatusOfMissionRepeatSave;
		private delegate* unmanaged[Cdecl]<bool> fn__isMemoryCardInUse;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, int, int, bool, bool, float, void> fn__shootSingleBulletBetweenCoords;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, int, int, bool, bool, float, int, int, void> fn__shootSingleBulletBetweenCoordsIgnoreEntity;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, int, int, bool, bool, float, int, bool, bool, bool, bool, int, int, int, void> fn__shootSingleBulletBetweenCoordsIgnoreEntityNew;
		private delegate* unmanaged[Cdecl]<int, Vector3*, Vector3*, void> fn__getModelDimensions;
		private delegate* unmanaged[Cdecl]<int, void> fn__setFakeWantedLevel;
		private delegate* unmanaged[Cdecl]<int> fn__getFakeWantedLevel;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isBitSet;
		private delegate* unmanaged[Cdecl]<bool, void> fn__usingMissionCreator;
		private delegate* unmanaged[Cdecl]<bool, void> fn__allowMissionCreatorWarp;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMinigameInProgress;
		private delegate* unmanaged[Cdecl]<bool> fn__isMinigameInProgress;
		private delegate* unmanaged[Cdecl]<bool> fn__isThisAMinigameScript;
		private delegate* unmanaged[Cdecl]<bool> fn__isSniperInverted;
		private delegate* unmanaged[Cdecl]<bool> fn__shouldUseMetricMeasurements;
		private delegate* unmanaged[Cdecl]<int, int> fn__getProfileSetting;
		private delegate* unmanaged[Cdecl]<nint, nint, bool> fn__areStringsEqual;
		private delegate* unmanaged[Cdecl]<nint, nint, bool, int, int> fn__compareStrings;
		private delegate* unmanaged[Cdecl]<int, int> fn__absi;
		private delegate* unmanaged[Cdecl]<float, float> fn__absf;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool> fn__isSniperBulletInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool> fn__isProjectileInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, bool> fn__isProjectileTypeInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, bool, bool> fn__isProjectileTypeInAngledArea;
		private delegate* unmanaged[Cdecl]<float, float, float, int, float, bool, bool> fn__isProjectileTypeWithinDistance;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, Vector3*, bool, bool> fn__getCoordsOfProjectileTypeInArea;
		private delegate* unmanaged[Cdecl]<int, int, float, Vector3*, bool, bool> fn__getCoordsOfProjectileTypeWithinDistance;
		private delegate* unmanaged[Cdecl]<int, int, float, Vector3*, int*, bool, bool> fn__getProjectileNearPed;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, bool, bool> fn__isBulletInAngledArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool> fn__isBulletInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool> fn__isBulletInBox;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool> fn__hasBulletImpactedInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool> fn__hasBulletImpactedInBox;
		private delegate* unmanaged[Cdecl]<bool> fn__isOrbisVersion;
		private delegate* unmanaged[Cdecl]<bool> fn__isDurangoVersion;
		private delegate* unmanaged[Cdecl]<bool> fn__isXbox360Version;
		private delegate* unmanaged[Cdecl]<bool> fn__isPs3Version;
		private delegate* unmanaged[Cdecl]<bool> fn__isPcVersion;
		private delegate* unmanaged[Cdecl]<bool> fn__isAussieVersion;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isStringNull;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isStringNullOrEmpty;
		private delegate* unmanaged[Cdecl]<nint, int*, bool> fn__stringToInt;
		private delegate* unmanaged[Cdecl]<int*, int, int, int, void> fn__setBitsInRange;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__getBitsInRange;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, int, int, int> fn__addStuntJump;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, int, int, int> fn__addStuntJumpAngled;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xFB80AB299D2EE1BD;
		private delegate* unmanaged[Cdecl]<int, void> fn__deleteStuntJump;
		private delegate* unmanaged[Cdecl]<int, void> fn__enableStuntJumpSet;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableStuntJumpSet;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setStuntJumpsCanTrigger;
		private delegate* unmanaged[Cdecl]<bool> fn__isStuntJumpInProgress;
		private delegate* unmanaged[Cdecl]<bool> fn__isStuntJumpMessageShowing;
		private delegate* unmanaged[Cdecl]<int> fn__getNumSuccessfulStuntJumps;
		private delegate* unmanaged[Cdecl]<int> fn__getTotalSuccessfulStuntJumps;
		private delegate* unmanaged[Cdecl]<void> fn__cancelStuntJump;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setGamePaused;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setThisScriptCanBePaused;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setThisScriptCanRemoveBlipsCreatedByAnyScript;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__hasButtonCombinationJustBeenEntered;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasCheatStringJustBeenEntered;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xFA3FFB0EEBC288A3;
		private delegate* unmanaged[Cdecl]<int, void> fn__setInstancePriorityMode;
		private delegate* unmanaged[Cdecl]<int, void> fn__setInstancePriorityHint;
		private delegate* unmanaged[Cdecl]<bool> fn__isFrontendFading;
		private delegate* unmanaged[Cdecl]<void> fn__populateNow;
		private delegate* unmanaged[Cdecl]<int> fn__getIndexOfCurrentLevel;
		private delegate* unmanaged[Cdecl]<int, void> fn__setGravityLevel;
		private delegate* unmanaged[Cdecl]<int*, int, bool, void> fn__startSaveData;
		private delegate* unmanaged[Cdecl]<void> fn__stopSaveData;
		private delegate* unmanaged[Cdecl]<bool, int> fn__getSizeOfSaveData;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__registerIntToSave;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__registerInt64ToSave;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__registerEnumToSave;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__registerFloatToSave;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__registerBoolToSave;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__registerTextLabelToSave;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__registerTextLabelToSave2;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__0x48F069265A0E4BEC;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__0x8269816F6CFD40F8;
		private delegate* unmanaged[Cdecl]<int*, nint, void> fn__0xFAA457EF263E8763;
		private delegate* unmanaged[Cdecl]<int*, int, nint, void> fn__startSaveStructWithSize;
		private delegate* unmanaged[Cdecl]<void> fn__stopSaveStruct;
		private delegate* unmanaged[Cdecl]<int*, int, nint, void> fn__startSaveArrayWithSize;
		private delegate* unmanaged[Cdecl]<void> fn__stopSaveArray;
		private delegate* unmanaged[Cdecl]<int*, int*, int, void> fn__copyMemory;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__enableDispatchService;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__blockDispatchServiceResourceCreation;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumDispatchedUnitsForPlayer;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, float, int*, int, int, bool> fn__createIncident;
		private delegate* unmanaged[Cdecl]<int, int, int, float, int*, int, int, bool> fn__createIncidentWithEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__deleteIncident;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isIncidentValid;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setIncidentRequestedUnits;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setIncidentUnk;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, Vector3*, bool> fn__findSpawnPointInDirection;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, bool, bool, int> fn__addPopMultiplierArea;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesPopMultiplierAreaExist;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removePopMultiplierArea;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPopMultiplierAreaUnk;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, int> fn__addPopMultiplierSphere;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesPopMultiplierSphereExist;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removePopMultiplierSphere;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__enableTennisMode;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isTennisMode;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, float, bool, void> fn__playTennisSwingAnim;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getTennisSwingAnimComplete;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x19BFED045C647C49;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xE95B0C7D5BA3B96B;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void> fn__playTennisDiveAnim;
		private delegate* unmanaged[Cdecl]<int, nint, float, void> fn__0x54F157E0336A3822;
		private delegate* unmanaged[Cdecl]<void> fn__resetDispatchSpawnLocation;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__setDispatchSpawnLocation;
		private delegate* unmanaged[Cdecl]<void> fn__resetDispatchIdealSpawnDistance;
		private delegate* unmanaged[Cdecl]<float, void> fn__setDispatchIdealSpawnDistance;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetDispatchTimeBetweenSpawnAttempts;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setDispatchTimeBetweenSpawnAttempts;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setDispatchTimeBetweenSpawnAttemptsMultiplier;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int> fn__addDispatchSpawnBlockingAngledArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int> fn__addDispatchSpawnBlockingArea;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeDispatchSpawnBlockingArea;
		private delegate* unmanaged[Cdecl]<void> fn__resetDispatchSpawnBlockingAreas;
		private delegate* unmanaged[Cdecl]<void> fn__0xD9F692D349249528;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xE532EC1A63231B4F;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__addTacticalAnalysisPoint;
		private delegate* unmanaged[Cdecl]<void> fn__clearTacticalAnalysisPoints;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setRiotModeEnabled;
		private delegate* unmanaged[Cdecl]<int, nint, int*, nint, nint, nint, nint, nint, nint, nint, nint, int, void> fn__displayOnscreenKeyboardWithLongerInitialString;
		private delegate* unmanaged[Cdecl]<int, nint, nint, nint, nint, nint, nint, int, void> fn__displayOnscreenKeyboard;
		private delegate* unmanaged[Cdecl]<int> fn__updateOnscreenKeyboard;
		private delegate* unmanaged[Cdecl]<nint> fn__getOnscreenKeyboardResult;
		private delegate* unmanaged[Cdecl]<void> fn__cancelOnscreenKeyboard;
		private delegate* unmanaged[Cdecl]<int, void> fn__nextOnscreenKeyboardResultWillDisplayUsingTheseFonts;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removeStealthKill;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x1EAE0A6E978894A2;
		private delegate* unmanaged[Cdecl]<int, void> fn__setExplosiveAmmoThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__setFireAmmoThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__setExplosiveMeleeThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__setSuperJumpThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__setBeastModeActive;
		private delegate* unmanaged[Cdecl]<int, void> fn__setForcePlayerToJump;
		private delegate* unmanaged[Cdecl]<bool> fn__0x6FDDF453C0C756EC;
		private delegate* unmanaged[Cdecl]<void> fn__0xFB00CA71DA386228;
		private delegate* unmanaged[Cdecl]<bool> fn__areProfileSettingsValid;
		private delegate* unmanaged[Cdecl]<void> fn__0xE3D969D2785FFB5E;
		private delegate* unmanaged[Cdecl]<void> fn__forceGameStatePlaying;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__scriptRaceInit;
		private delegate* unmanaged[Cdecl]<void> fn__scriptRaceShutdown;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x1BB299305C3E8C13;
		private delegate* unmanaged[Cdecl]<int, int*, int*, bool> fn__scriptRaceGetPlayerSplitTime;
		private delegate* unmanaged[Cdecl]<void> fn__startBenchmarkRecording;
		private delegate* unmanaged[Cdecl]<void> fn__stopBenchmarkRecording;
		private delegate* unmanaged[Cdecl]<void> fn__resetBenchmarkRecording;
		private delegate* unmanaged[Cdecl]<void> fn__saveBenchmarkRecording;
		private delegate* unmanaged[Cdecl]<bool> fn__uiIsSingleplayerPauseMenuActive;
		private delegate* unmanaged[Cdecl]<bool> fn__landingMenuIsActive;
		private delegate* unmanaged[Cdecl]<bool> fn__isCommandLineBenchmarkValueSet;
		private delegate* unmanaged[Cdecl]<int> fn__getBenchmarkIterationsFromCommandLine;
		private delegate* unmanaged[Cdecl]<int> fn__getBenchmarkPassFromCommandLine;
		private delegate* unmanaged[Cdecl]<void> fn__restartGame;
		private delegate* unmanaged[Cdecl]<void> fn__forceSocialClubUpdate;
		private delegate* unmanaged[Cdecl]<bool> fn__hasAsyncInstallFinished;
		private delegate* unmanaged[Cdecl]<void> fn__cleanupAsyncInstall;
		private delegate* unmanaged[Cdecl]<bool> fn__isInPowerSavingMode;
		private delegate* unmanaged[Cdecl]<int> fn__getPowerSavingModeDuration;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setPlayerIsInAnimalForm;
		private delegate* unmanaged[Cdecl]<bool> fn__getIsPlayerInAnimalForm;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setPlayerRockstarEditorDisabled;
		private delegate* unmanaged[Cdecl]<void> fn__0x23227DF0B2115469;
		private delegate* unmanaged[Cdecl]<int> fn__0xD10282B6E3751BA0;
		private delegate* unmanaged[Cdecl]<void> fn__0x693478ACBD7F18E7;
		private delegate* unmanaged[Cdecl]<int, void> fn__createMobilePhone;
		private delegate* unmanaged[Cdecl]<void> fn__destroyMobilePhone;
		private delegate* unmanaged[Cdecl]<float, void> fn__setMobilePhoneScale;
		private delegate* unmanaged[Cdecl]<float, float, float, int, void> fn__setMobilePhoneRotation;
		private delegate* unmanaged[Cdecl]<Vector3*, int, void> fn__getMobilePhoneRotation;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__setMobilePhonePosition;
		private delegate* unmanaged[Cdecl]<Vector3*, void> fn__getMobilePhonePosition;
		private delegate* unmanaged[Cdecl]<bool, void> fn__scriptIsMovingMobilePhoneOffscreen;
		private delegate* unmanaged[Cdecl]<bool> fn__canPhoneBeSeenOnScreen;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setMobilePhoneUnk;
		private delegate* unmanaged[Cdecl]<int, void> fn__cellCamMoveFinger;
		private delegate* unmanaged[Cdecl]<bool, void> fn__cellCamSetLean;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__cellCamActivate;
		private delegate* unmanaged[Cdecl]<bool, void> fn__cellCamDisableThisFrame;
		private delegate* unmanaged[Cdecl]<int*, void> fn__0xA2CCBE62CD4C91A4;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x1B0B4AEED5B9B41C;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x53F4892D18EC90A4;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x3117D84EFA60F77B;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x15E69E2802C24B8D;
		private delegate* unmanaged[Cdecl]<float, void> fn__0xAC2890471901861C;
		private delegate* unmanaged[Cdecl]<float, void> fn__0xD6ADE981781FCA09;
		private delegate* unmanaged[Cdecl]<float, void> fn__0xF1E22DC13F5EEBAD;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x466DA42C89865553;
		private delegate* unmanaged[Cdecl]<int, bool> fn__cellCamIsCharVisibleNoFaceCheck;
		private delegate* unmanaged[Cdecl]<int*, void> fn__getMobilePhoneRenderId;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkInitializeCash;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkDeleteCharacter;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkManualDeleteCharacter;
		private delegate* unmanaged[Cdecl]<bool> fn__networkGetIsHighEarner;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkClearCharacterWallet;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__networkGivePlayerJobshareCash;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__networkReceivePlayerJobshareCash;
		private delegate* unmanaged[Cdecl]<bool> fn__networkCanShareJobCash;
		private delegate* unmanaged[Cdecl]<int, nint, nint, bool, void> fn__networkRefundCash;
		private delegate* unmanaged[Cdecl]<int, nint, nint, bool, bool, bool, void> fn__networkDeductCash;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool> fn__networkMoneyCanBet;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkCanBet;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkCasinoCanUseGamblingType;
		private delegate* unmanaged[Cdecl]<bool> fn__networkCasinoCanPurchaseChipsWithPvc;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkCasinoCanGamble;
		private delegate* unmanaged[Cdecl]<bool> fn__networkCasinoCanPurchaseChipsWithPvc2;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkCasinoPurchaseChips;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkCasinoSellChips;
		private delegate* unmanaged[Cdecl]<void> fn__0xCD0F5B5D932AE473;
		private delegate* unmanaged[Cdecl]<int, int, int, int*, bool> fn__canPayGoon;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromCashingOut;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromPickup;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromGangPickup;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromAssassinateTargetKilled;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromArmourTruck;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromCrateDrop;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__networkEarnFromBetting;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__networkEarnFromJob;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__networkEarnFromJobX2;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__networkEarnFromPremiumJob;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__networkEarnFromBendJob;
		private delegate* unmanaged[Cdecl]<int, int*, bool, void> fn__networkEarnFromChallengeWin;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int, void> fn__networkEarnFromBounty;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromImportExport;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromHoldups;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromProperty;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromAiTargetKill;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromNotBadsport;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromRockstar;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, void> fn__networkEarnFromVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, void> fn__networkEarnFromPersonalVehicle;
		private delegate* unmanaged[Cdecl]<int, nint, int, void> fn__networkEarnFromDailyObjectives;
		private delegate* unmanaged[Cdecl]<int, nint, int*, void> fn__networkEarnFromAmbientJob;
		private delegate* unmanaged[Cdecl]<int, int*, int*, void> fn__networkEarnFromJobBonus;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkEarnJobBonusHeistAward;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkEarnJobBonusFirstTimeBonus;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkEarnGoon;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkEarnBoss;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkEarnBossAgency;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromWarehouse;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromContraband;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromDestroyingContraband;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0x6B7E4FB50D5F3D65;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x31BA138F6304FB9F;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x55A1E095DB052FA5;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkEarnFromBusinessProduct;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkEarnFromVehicleExport;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkEarnFromSmuggling;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnBountyHunterReward;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromBusinessBattle;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromClubManagementParticipation;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromFmbbPhonecallMission;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkEarnFromBusinessHubSell;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromFmbbBossWork;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFmbbWageBonus;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, int, int, bool> fn__networkCanSpendMoney;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, int*, int, int, bool> fn__networkCanSpendMoney2;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, nint, int, int, int, bool, void> fn__networkBuyItem;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentTaxi;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkPayEmployeeWage;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkPayUtilityBill;
		private delegate* unmanaged[Cdecl]<int, nint, bool, bool, void> fn__networkPayMatchEntryFee;
		private delegate* unmanaged[Cdecl]<int, int, nint, bool, bool, void> fn__networkSpentBetting;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkSpentWager;
		private delegate* unmanaged[Cdecl]<int, bool, int, bool, void> fn__networkSpentInStripclub;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkBuyHealthcare;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkBuyAirstrike;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkBuyBackupGang;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkBuyHeliStrike;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentAmmoDrop;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkBuyBounty;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkBuyProperty;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkBuySmokes;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentHeliPickup;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentBoatPickup;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentBullShark;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentCashDrop;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentHireMugger;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentRobbedByMugger;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentHireMercenary;
		private delegate* unmanaged[Cdecl]<int, int*, bool, bool, void> fn__networkSpentBuyWantedlevel;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentBuyOfftheradar;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentBuyRevealPlayers;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, bool, void> fn__networkSpentCarwash;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkSpentCinema;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentTelescope;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentHoldups;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentBuyPassiveMode;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentBankInterest;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentProstitutes;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentArrestBail;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool, bool, void> fn__networkSpentPayVehicleInsurancePremium;
		private delegate* unmanaged[Cdecl]<int, int*, bool, bool, void> fn__networkSpentCallPlayer;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentBounty;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentFromRockstar;
		private delegate* unmanaged[Cdecl]<int> fn__0x9B5016A6433A68C5;
		private delegate* unmanaged[Cdecl]<int*, int*, nint, nint> fn__processCashGift;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkSpentPlayerHealthcare;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentNoCops;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentRequestJob;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentRequestHeist;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkBuyFairgroundRide;
		private delegate* unmanaged[Cdecl]<bool> fn__0x7C4FCCD2E4DEB394;
		private delegate* unmanaged[Cdecl]<int, nint, bool, bool, void> fn__networkSpentJobSkip;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool> fn__networkSpentBoss;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkSpentPayGoon;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkSpentPayBoss;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentMoveYacht;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkSpentRenameOrganization;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, bool, void> fn__networkBuyContraband;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkSpentVipUtilityCharges;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x112209CE0290C03A;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0xED5FD7AF10F5E262;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x0D30EB83668E63C5;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentPaServiceDancer;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0xE23ADC6FCB1F29AE;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentPaServiceHeliPickup;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x69EF772B192614C1;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x8E243837643D9583;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0xBD0EFB25CCA8F97A;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0xA95F667A755725DA;
		private delegate* unmanaged[Cdecl]<int, int*, bool, bool, void> fn__networkSpentPurchaseWarehouse;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x4128464231E3CA0B;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x2FAB6614CE22E196;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentOrderWarehouseVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentOrderBodyguardVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentJukebox;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x998E18CEB44487FC;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0xFA07759E6FDDD7CF;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x6FD97159FE3C971A;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x675D19C6067CAE08;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0xA51B086B0B2C0F7A;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__networkSpentBaService;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentBusiness;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x5F456788B05FAEAC;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void> fn__networkSpentVehicleExportMods;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0xB4C2EC463672474E;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x2AFC2D19B50797F2;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkSpentImportExportRepair;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentPurchaseHangar;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentUpgradeHangar;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentHangarUtilityCharges;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentHangarStaffCharges;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentBuyTruck;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentUpgradeTruck;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentBuyBunker;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentUpgradeBunker;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromSellBunker;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentBallisticEquipment;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromRdrBonus;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromWagePayment;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromWagePaymentBonus;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentBuyBase;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentUpgradeBase;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentBuyTiltrotor;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentUpgradeTiltrotor;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentEmployAssassins;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentGangopsCannon;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentGangopsStartMission;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentCasinoHeistSkipMission;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromSellBase;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromTargetRefund;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromGangopsWages;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromGangopsWagesBonus;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromDarChallenge;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromDoomsdayFinaleBonus;
		private delegate* unmanaged[Cdecl]<int, nint, int, void> fn__networkEarnFromGangopsAwards;
		private delegate* unmanaged[Cdecl]<int, nint, int, void> fn__networkEarnFromGangopsElite;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkRivalDeliveryCompleted;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkSpentGangopsStartStrand;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentGangopsTripSkip;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromGangopsJobsPrepParticipation;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__networkEarnFromGangopsJobsSetup;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__networkEarnFromGangopsJobsFinale;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x2A7CEC72C3443BCC;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xE0F82D68C7039158;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xB4DEAE67F35E2ACD;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromBbEventBonus;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x2A93C46AAB1EACC9;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x226C284C830D0CA8;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkEarnFromHackerTruckMission;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0xED76D195E6E3BF7F;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x1DC9B749E7AE282B;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__0xC6E74CF8C884C880;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__0x65482BFD0923C8A1;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentRdrhatchetBonus;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, bool, void> fn__networkSpentNightclubEntryFee;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkSpentNightclubBarDrink;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentBountyHunterMission;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkSpentRehireDj;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkSpentArenaJoinSpectator;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromArenaSkillLevelProgression;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromArenaCareerProgression;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentMakeItRain;
		private delegate* unmanaged[Cdecl]<int, bool, bool, nint, void> fn__networkSpentBuyArena;
		private delegate* unmanaged[Cdecl]<int, bool, bool, nint, void> fn__networkSpentUpgradeArena;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__networkSpentArenaSpectatorBox;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__networkSpentSpinTheWheelPayment;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromSpinTheWheelCash;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkSpentArenaPremium;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkEarnFromArenaWar;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromAssassinateTargetKilled2;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromBbEventCargo;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromRcTimeTrial;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromDailyObjectiveEvent;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, void> fn__networkSpentCasinoMembership;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int*, void> fn__networkSpentBuyCasino;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int*, void> fn__networkSpentUpgradeCasino;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__networkSpentCasinoGeneric;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromTimeTrialWin;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromCollectablesActionFigures;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromCompleteCollection;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkEarnFromSellingVehicle;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromCasinoMissionReward;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromCasinoStoryMissionReward;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromCasinoMissionParticipation;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromCasinoAward;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x870289A558348378;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x5574637681911FDA;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, void> fn__networkSpentCasinoHeist;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0xB5B58E24868CB09E;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__networkSpentArcadeGame;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__networkSpentArcadeGeneric;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__networkEarnCasinoHeist;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x4C3B75694F7E0D9C;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0xD29334ED1A256DBF;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0xA95CFB4E02390842;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x0DD362F14F18942A;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__networkEarnCasinoHeistBonus;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromCollectionItem;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnCollectableCompletedCollection;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xDE68E30D89F97132;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xE2E244AB823B4483;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSpentBeachPartyGeneric;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__networkSpentSubmarine;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, void> fn__networkSpentCasinoClubGeneric;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x90CD7C6871FBF1B4;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentUpgradeSub;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentIslandHeist;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__networkEarnIslandHeist;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0xA51338E0DCCD4065;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xE2BB399D90942091;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__networkSpentCarclubMembership;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, void> fn__networkSpentCarclub;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__networkSpentAutoshopModifications;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentCarclubTakeover;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentBuyAutoshop;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentUpgradeAutoshop;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromAutoshopBusiness;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromAutoshopIncome;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromCarclubMembership;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromVehicleAutoshop;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkEarnFromVehicleAutoshopBonus;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkEarnFromTunerAward;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__networkEarnFromTunerFinale;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkEarnFromUpgradeAutoshopLocation;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSpentImAbility;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, void> fn__networkSpentFromBank;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetVcBankBalance;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetVcWalletBalance;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetVcBalance;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetEvcBalance;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetPvcBalance;
		private delegate* unmanaged[Cdecl]<int, nint> fn__networkGetStringWalletBalance;
		private delegate* unmanaged[Cdecl]<nint> fn__networkGetStringBankBalance;
		private delegate* unmanaged[Cdecl]<nint> fn__networkGetStringBankWalletBalance;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkGetVcWalletBalanceIsNotLessThan;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkGetVcBankBalanceIsNotLessThan;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkGetVcBankWalletBalanceIsNotLessThan;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetPvcTransferBalance;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x08E8EEADFD0DC4A0;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool> fn__networkCanReceivePlayerCash;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetRemainingTransferBalance;
		private delegate* unmanaged[Cdecl]<int, int> fn__withdrawVc;
		private delegate* unmanaged[Cdecl]<int, bool> fn__depositVc;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xE154B48B68EF72BC;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x6FCF8DDEA146C45B;
		private delegate* unmanaged[Cdecl]<bool> fn__netGameserverUseServerTransactions;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__netGameserverCatalogItemExists;
		private delegate* unmanaged[Cdecl]<int, bool> fn__netGameserverCatalogItemExistsHash;
		private delegate* unmanaged[Cdecl]<int, int, bool, int> fn__netGameserverGetPrice;
		private delegate* unmanaged[Cdecl]<bool> fn__netGameserverCatalogIsReady;
		private delegate* unmanaged[Cdecl]<bool> fn__netGameserverIsCatalogValid;
		private delegate* unmanaged[Cdecl]<int> fn__0x85F6C9ABA1DE2BCF;
		private delegate* unmanaged[Cdecl]<int> fn__0x357B152EF96C30B6;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__netGameserverGetCatalogState;
		private delegate* unmanaged[Cdecl]<int> fn__0xE3E5A7C64CA2C6ED;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__0x0395CB47B022E62C;
		private delegate* unmanaged[Cdecl]<int, bool> fn__netGameserverStartSession;
		private delegate* unmanaged[Cdecl]<bool> fn__0x72EB7BA9B69BF6AB;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__0x170910093218C8B9;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__0xC13C38E47EA5DF31;
		private delegate* unmanaged[Cdecl]<int, bool> fn__netGameserverIsSessionValid;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x74A0FD0688F1EE45;
		private delegate* unmanaged[Cdecl]<int, bool> fn__netGameserverSessionApplyReceivedData;
		private delegate* unmanaged[Cdecl]<bool> fn__netGameserverIsSessionRefreshPending;
		private delegate* unmanaged[Cdecl]<bool, bool, bool> fn__netGameserverGetBalance;
		private delegate* unmanaged[Cdecl]<bool> fn__0x613F125BA3BD2EB9;
		private delegate* unmanaged[Cdecl]<int*, bool*, bool> fn__netGameserverGetTransactionManagerData;
		private delegate* unmanaged[Cdecl]<int*, int, int, int, bool> fn__netGameserverBasketStart;
		private delegate* unmanaged[Cdecl]<bool> fn__netGameserverBasketDelete;
		private delegate* unmanaged[Cdecl]<bool> fn__netGameserverBasketEnd;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__netGameserverBasketAddItem;
		private delegate* unmanaged[Cdecl]<bool> fn__netGameserverBasketIsFull;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__netGameserverBasketApplyServerData;
		private delegate* unmanaged[Cdecl]<int, bool> fn__netGameserverCheckoutStart;
		private delegate* unmanaged[Cdecl]<int*, int, int, int, int, int, bool> fn__netGameserverBeginService;
		private delegate* unmanaged[Cdecl]<int, bool> fn__netGameserverEndService;
		private delegate* unmanaged[Cdecl]<int, bool, int, bool> fn__netGameserverDeleteCharacterSlot;
		private delegate* unmanaged[Cdecl]<int> fn__netGameserverDeleteCharacterSlotGetStatus;
		private delegate* unmanaged[Cdecl]<bool> fn__netGameserverDeleteSetTelemetryNonceSeed;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__netGameserverTransferBankToWallet;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__netGameserverTransferWalletToBank;
		private delegate* unmanaged[Cdecl]<int> fn__netGameserverTransferCashGetStatus;
		private delegate* unmanaged[Cdecl]<int> fn__netGameserverTransferCashGetStatus2;
		private delegate* unmanaged[Cdecl]<bool> fn__netGameserverTransferCashSetTelemetryNonceSeed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__netGameserverSetTelemetryNonceSeed;
		private delegate* unmanaged[Cdecl]<nint> fn__getOnlineVersion;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsSignedIn;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsSignedOnline;
		private delegate* unmanaged[Cdecl]<bool> fn__0xBD545D44CCE70597;
		private delegate* unmanaged[Cdecl]<int> fn__0xEBCAB9E5048434F4;
		private delegate* unmanaged[Cdecl]<int> fn__0x74FB3E29E6D10FA9;
		private delegate* unmanaged[Cdecl]<int> fn__0x7808619F31FF22DB;
		private delegate* unmanaged[Cdecl]<int> fn__0xA0FA4EC6A05DA44E;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHasValidRosCredentials;
		private delegate* unmanaged[Cdecl]<bool> fn__0x8D11E61A4ABF49CC;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsCloudAvailable;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHasSocialClubAccount;
		private delegate* unmanaged[Cdecl]<bool> fn__networkAreSocialClubPoliciesCurrent;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsHost;
		private delegate* unmanaged[Cdecl]<bool> fn__0x4237E822315D8BA9;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHaveOnlinePrivileges;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHasAgeRestrictedProfile;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkHaveUserContentPrivileges;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkHaveCommunicationPrivileges;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__0x78321BEA235FD8CD;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__networkCheckUserContentPrivileges;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__networkCheckCommunicationPrivileges;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__0x07EAB372C8841D99;
		private delegate* unmanaged[Cdecl]<int> fn__0x906CA41A4B74ECA4;
		private delegate* unmanaged[Cdecl]<int> fn__0x023ACAB2DC9DC4A4;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHasSocialNetworkingSharingPriv;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetAgeGroup;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__0x0CF6CC51AA18F0F8;
		private delegate* unmanaged[Cdecl]<bool> fn__0x64E5C4CC82847B73;
		private delegate* unmanaged[Cdecl]<void> fn__0x1F7BC3539F9E0224;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHaveOnlinePrivilege2;
		private delegate* unmanaged[Cdecl]<int> fn__0xA8ACB6459542A8C8;
		private delegate* unmanaged[Cdecl]<void> fn__0x83FE8D7229593017;
		private delegate* unmanaged[Cdecl]<int> fn__0x53C10C8BD774F2C9;
		private delegate* unmanaged[Cdecl]<bool> fn__networkCanBail;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkBail;
		private delegate* unmanaged[Cdecl]<void> fn__0x283B6062A2C01E9B;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__0x8B4FFC790CA131EF;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__networkTransitionTrack;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__0x04918A41BC9B8157;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkCanAccessMultiplayer;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsMultiplayerDisabled;
		private delegate* unmanaged[Cdecl]<bool> fn__networkCanEnterMultiplayer;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int> fn__networkSessionEnter;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, bool> fn__networkSessionFriendMatchmaking;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool> fn__networkSessionCrewMatchmaking;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool> fn__networkSessionActivityQuickmatch;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__networkSessionHost;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkSessionHostClosed;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkSessionHostFriendsOnly;
		private delegate* unmanaged[Cdecl]<bool> fn__networkSessionIsClosedFriends;
		private delegate* unmanaged[Cdecl]<bool> fn__networkSessionIsClosedCrew;
		private delegate* unmanaged[Cdecl]<bool> fn__networkSessionIsSolo;
		private delegate* unmanaged[Cdecl]<bool> fn__networkSessionIsPrivate;
		private delegate* unmanaged[Cdecl]<bool, bool, bool> fn__networkSessionEnd;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xB9351A07A0D458B1;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSessionKickPlayer;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkSessionGetKickVote;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__0x041C7F2A6C9894E6;
		private delegate* unmanaged[Cdecl]<bool> fn__networkJoinPreviouslyFailedSession;
		private delegate* unmanaged[Cdecl]<bool> fn__networkJoinPreviouslyFailedTransition;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSessionSetMatchmakingGroup;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkSessionSetMatchmakingGroupMax;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkSessionGetMatchmakingGroupFree;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSessionAddActiveMatchmakingGroup;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xF49ABC20D8552257;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x4811BBAC21C5FCD5;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x5539C3EBF104A53A;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x702BC4D605522539;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSessionSetMatchmakingPropertyId;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSessionSetMatchmakingMentalState;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x5ECD378EE64450AB;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x59D421683D31835A;
		private delegate* unmanaged[Cdecl]<void> fn__0x1153FA02A659051C;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSessionValidateJoin;
		private delegate* unmanaged[Cdecl]<int*, int, void> fn__networkAddFollowers;
		private delegate* unmanaged[Cdecl]<void> fn__networkClearFollowers;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, void> fn__networkGetGlobalMultiplayerClock;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x600F8CB31C7AAB6E;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetTargetingMode;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkFindGamersInCrew;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool> fn__networkFindMatchedGamers;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsFindingGamers;
		private delegate* unmanaged[Cdecl]<bool> fn__networkDidFindGamersSucceed;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetNumFoundGamers;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__networkGetFoundGamer;
		private delegate* unmanaged[Cdecl]<void> fn__networkClearFoundGamers;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkQueueGamerForStatus;
		private delegate* unmanaged[Cdecl]<bool> fn__networkGetGamerStatusFromQueue;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsGettingGamerStatus;
		private delegate* unmanaged[Cdecl]<bool> fn__networkDidGetGamerStatusSucceed;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__networkGetGamerStatusResult;
		private delegate* unmanaged[Cdecl]<void> fn__networkClearGetGamerStatus;
		private delegate* unmanaged[Cdecl]<void> fn__networkSessionJoinInvite;
		private delegate* unmanaged[Cdecl]<void> fn__networkSessionCancelInvite;
		private delegate* unmanaged[Cdecl]<void> fn__networkSessionForceCancelInvite;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHasPendingInvite;
		private delegate* unmanaged[Cdecl]<bool> fn__0xC42DD763159F3461;
		private delegate* unmanaged[Cdecl]<bool> fn__networkAcceptInvite;
		private delegate* unmanaged[Cdecl]<bool> fn__networkSessionWasInvited;
		private delegate* unmanaged[Cdecl]<int*, void> fn__networkSessionGetInviter;
		private delegate* unmanaged[Cdecl]<bool> fn__0xD313DE83394AF134;
		private delegate* unmanaged[Cdecl]<bool> fn__0xBDB6F89C729CF388;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSuppressInvite;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkBlockInvites;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkBlockJoinQueueInvites;
		private delegate* unmanaged[Cdecl]<void> fn__0xF814FEC6A19FD6E0;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkBlockKickedPlayers;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetScriptReadyForEvents;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsOfflineInvitePending;
		private delegate* unmanaged[Cdecl]<void> fn__networkClearOfflineInvitePending;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSessionHostSinglePlayer;
		private delegate* unmanaged[Cdecl]<void> fn__networkSessionLeaveSinglePlayer;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsGameInProgress;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsSessionActive;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsInSession;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsSessionStarted;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsSessionBusy;
		private delegate* unmanaged[Cdecl]<bool> fn__networkCanSessionEnd;
		private delegate* unmanaged[Cdecl]<int> fn__0x4C9034162368E206;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSessionMarkVisible;
		private delegate* unmanaged[Cdecl]<bool> fn__networkSessionIsVisible;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSessionBlockJoinRequests;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkSessionChangeSlots;
		private delegate* unmanaged[Cdecl]<int> fn__networkSessionGetPrivateSlots;
		private delegate* unmanaged[Cdecl]<void> fn__networkSessionVoiceHost;
		private delegate* unmanaged[Cdecl]<void> fn__networkSessionVoiceLeave;
		private delegate* unmanaged[Cdecl]<int*, void> fn__networkSessionVoiceConnectToPlayer;
		private delegate* unmanaged[Cdecl]<bool, int, void> fn__networkSessionVoiceRespondToRequest;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSessionVoiceSetTimeout;
		private delegate* unmanaged[Cdecl]<bool> fn__networkSessionIsInVoiceSession;
		private delegate* unmanaged[Cdecl]<int> fn__0xB5D3453C98456528;
		private delegate* unmanaged[Cdecl]<bool> fn__networkSessionIsVoiceSessionBusy;
		private delegate* unmanaged[Cdecl]<nint, int*, bool> fn__networkSendTextMessage;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetActivitySpectator;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsActivitySpectator;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x0E4F77F7B9D74D84;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSetActivitySpectatorMax;
		private delegate* unmanaged[Cdecl]<bool, int> fn__networkGetActivityPlayerNum;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsActivitySpectatorFromHandle;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, bool, bool, int, int, int, bool> fn__networkHostTransition;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, bool> fn__networkDoTransitionQuickmatch;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, bool> fn__networkDoTransitionQuickmatchAsync;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int*, int, int, int, bool> fn__networkDoTransitionQuickmatchWithGroup;
		private delegate* unmanaged[Cdecl]<int> fn__networkJoinGroupActivity;
		private delegate* unmanaged[Cdecl]<void> fn__0x1888694923EF4591;
		private delegate* unmanaged[Cdecl]<void> fn__0xB13E88E655E5A3BC;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionClosedFriends;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionClosedCrew;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionSolo;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionPrivate;
		private delegate* unmanaged[Cdecl]<int> fn__0x617F49C2668E6155;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x261E97AD7BCF3D40;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x39917E1B4CB0F911;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x2CE9D95E4051AECD;
		private delegate* unmanaged[Cdecl]<int*, void> fn__networkSetTransitionCreatorHandle;
		private delegate* unmanaged[Cdecl]<void> fn__networkClearTransitionCreatorHandle;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__networkInviteGamersToTransition;
		private delegate* unmanaged[Cdecl]<int*, void> fn__networkSetGamerInvitedToTransition;
		private delegate* unmanaged[Cdecl]<bool> fn__networkLeaveTransition;
		private delegate* unmanaged[Cdecl]<bool> fn__networkLaunchTransition;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xA2E9C1AB8A92E8CD;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkBailTransition;
		private delegate* unmanaged[Cdecl]<bool, int, bool> fn__networkDoTransitionToGame;
		private delegate* unmanaged[Cdecl]<bool, int, bool, bool> fn__networkDoTransitionToNewGame;
		private delegate* unmanaged[Cdecl]<int*, int, bool, int, bool, bool> fn__networkDoTransitionToFreemode;
		private delegate* unmanaged[Cdecl]<int*, int*, int, bool, bool, bool, bool> fn__networkDoTransitionToNewFreemode;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionToGame;
		private delegate* unmanaged[Cdecl]<int*, int, int> fn__networkGetTransitionMembers;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkApplyTransitionParameter;
		private delegate* unmanaged[Cdecl]<int, nint, bool, void> fn__networkApplyTransitionParameterString;
		private delegate* unmanaged[Cdecl]<int*, nint, int, int, bool, bool> fn__networkSendTransitionGamerInstruction;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkMarkTransitionGamerAsFullyJoined;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionHost;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsTransitionHostFromHandle;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkGetTransitionHost;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsInTransition;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionStarted;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionBusy;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionMatchmaking;
		private delegate* unmanaged[Cdecl]<bool> fn__0xC571D0E77D8BBC29;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x1398582B7F72B3ED;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x1F8E00FB18239600;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xF6F4383B7C92F11A;
		private delegate* unmanaged[Cdecl]<void> fn__networkOpenTransitionMatchmaking;
		private delegate* unmanaged[Cdecl]<void> fn__networkCloseTransitionMatchmaking;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionOpenToMatchmaking;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__networkSetTransitionVisibilityLock;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTransitionVisibilityLocked;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSetTransitionActivityId;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkChangeTransitionSlots;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x973D76AA760A6CB6;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkHasPlayerStartedTransition;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkAreTransitionDetailsValid;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkJoinTransition;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkHasInvitedGamerToTransition;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__0x3F9990BF5F22759C;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsActivitySession;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x4A9FDE3A5A6D0437;
		private delegate* unmanaged[Cdecl]<int*, int*, int, int, bool> fn__networkSendInviteViaPresence;
		private delegate* unmanaged[Cdecl]<int*, int*, int, int, bool> fn__networkSendPresenceTransitionInvite;
		private delegate* unmanaged[Cdecl]<int*, int*, int, int, bool> fn__0x1171A97A3D3981B6;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x742B58F723233ED9;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetNumPresenceInvites;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkAcceptPresenceInvite;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkRemovePresenceInvite;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetPresenceInviteId;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetPresenceInviteInviter;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__networkGetPresenceInviteHandle;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetPresenceInviteSessionId;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetPresenceInviteContentId;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetPresenceInvitePlaylistLength;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetPresenceInvitePlaylistCurrent;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkGetPresenceInviteFromAdmin;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkGetPresenceInviteIsTournament;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHasFollowInvite;
		private delegate* unmanaged[Cdecl]<int> fn__networkActionFollowInvite;
		private delegate* unmanaged[Cdecl]<int> fn__networkClearFollowInvite;
		private delegate* unmanaged[Cdecl]<void> fn__0xEBF8284D8CADEB53;
		private delegate* unmanaged[Cdecl]<int*, void> fn__networkRemoveTransitionInvite;
		private delegate* unmanaged[Cdecl]<void> fn__networkRemoveAllTransitionInvite;
		private delegate* unmanaged[Cdecl]<void> fn__0xF083835B70BA9BFE;
		private delegate* unmanaged[Cdecl]<int*, int, int*, int*, bool> fn__networkInviteGamers;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkHasInvitedGamer;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__0x71DC455F5CD1C2B1;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x3855FB5EB2C5E8B2;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkGetCurrentlySelectedGamerHandleFromInviteMenu;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkSetCurrentlySelectedGamerHandleFromInviteMenu;
		private delegate* unmanaged[Cdecl]<int*, void> fn__networkSetInviteOnCallForInviteMenu;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__networkCheckDataManagerSucceededForHandle;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x4AD490AE1536933B;
		private delegate* unmanaged[Cdecl]<int*, int*, void> fn__0x0D77A82DC2D0DA59;
		private delegate* unmanaged[Cdecl]<int*, int, int, bool> fn__filloutPmPlayerList;
		private delegate* unmanaged[Cdecl]<int*, int*, int, int, bool> fn__filloutPmPlayerListWithNames;
		private delegate* unmanaged[Cdecl]<int, bool> fn__refreshPlayerListStats;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkSetCurrentDataManagerHandle;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsInPlatformParty;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetPlatformPartyUnk;
		private delegate* unmanaged[Cdecl]<int*, int, int> fn__networkGetPlatformPartyMembers;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsInPlatformPartyChat;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsChattingInPlatformParty;
		private delegate* unmanaged[Cdecl]<int> fn__0x2BF66D2E7414F686;
		private delegate* unmanaged[Cdecl]<bool> fn__0x14922ED3E38761F0;
		private delegate* unmanaged[Cdecl]<void> fn__0x6CE50E47F5543D0C;
		private delegate* unmanaged[Cdecl]<void> fn__0xFA2888E3833C8E96;
		private delegate* unmanaged[Cdecl]<void> fn__0x25D990F8E0E3F13C;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSeedRandomNumberGenerator;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetRandomInt;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__networkGetRandomIntRanged;
		private delegate* unmanaged[Cdecl]<bool> fn__networkPlayerIsCheater;
		private delegate* unmanaged[Cdecl]<int> fn__networkPlayerGetCheaterReason;
		private delegate* unmanaged[Cdecl]<bool> fn__networkPlayerIsBadsport;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__triggerScriptCrcCheckOnPlayer;
		private delegate* unmanaged[Cdecl]<int> fn__0xA12D3A5A3753CC23;
		private delegate* unmanaged[Cdecl]<int> fn__0xF287F506767CC8A9;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__remoteCheatDetected;
		private delegate* unmanaged[Cdecl]<int*, int, int, bool> fn__badSportPlayerLeftDetected;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkApplyPedScarData;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__networkSetThisScriptIsNetworkScript;
		private delegate* unmanaged[Cdecl]<int, bool, int, bool> fn__networkIsThisScriptMarked;
		private delegate* unmanaged[Cdecl]<bool> fn__networkGetThisScriptIsNetworkScript;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetMaxNumParticipants;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetNumParticipants;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetScriptStatus;
		private delegate* unmanaged[Cdecl]<int*, int, void> fn__networkRegisterHostBroadcastVariables;
		private delegate* unmanaged[Cdecl]<int*, int, void> fn__networkRegisterPlayerBroadcastVariables;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xEA8C0DDB10E2822A;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xD6D7478CA62B8D41;
		private delegate* unmanaged[Cdecl]<void> fn__networkFinishBroadcastingData;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHasReceivedHostBroadcastData;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetPlayerIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetParticipantIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetPlayerIndexFromPed;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetNumConnectedPlayers;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsPlayerConnected;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetTotalNumPlayers;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsParticipantActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsPlayerActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsPlayerAParticipant;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsHostOfThisScript;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetHostOfThisScript;
		private delegate* unmanaged[Cdecl]<nint, int, int, int> fn__networkGetHostOfScript;
		private delegate* unmanaged[Cdecl]<void> fn__networkSetMissionFinished;
		private delegate* unmanaged[Cdecl]<nint, int, bool, int, bool> fn__networkIsScriptActive;
		private delegate* unmanaged[Cdecl]<int, int, bool, int, bool> fn__networkIsScriptActiveByHash;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x560B423D73015E77;
		private delegate* unmanaged[Cdecl]<int*, int, int, int> fn__networkGetNumScriptParticipants;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetInstanceIdOfThisScript;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetPositionHashOfThisScript;
		private delegate* unmanaged[Cdecl]<int, nint, int, bool> fn__networkIsPlayerAParticipantOnScript;
		private delegate* unmanaged[Cdecl]<void> fn__0x2302C0264EA58D31;
		private delegate* unmanaged[Cdecl]<void> fn__0x741A3D8380319A81;
		private delegate* unmanaged[Cdecl]<int> fn__participantId;
		private delegate* unmanaged[Cdecl]<int> fn__participantIdToInt;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x2DA41ED6E1FCD7A5;
		private delegate* unmanaged[Cdecl]<int, int*, int> fn__networkGetDestroyerOfNetworkId;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0xC434133D9BA52777;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__0x83660B734994124D;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__networkGetDestroyerOfEntity;
		private delegate* unmanaged[Cdecl]<int, int*, int> fn__networkGetEntityKillerOfPlayer;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, int, void> fn__networkResurrectLocalPlayer;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSetLocalPlayerInvincibleTime;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsLocalPlayerInvincible;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkDisableInvincibleFlashing;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkPedForceGameStateUpdate;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetLocalPlayerSyncLookAt;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkHasEntityBeenRegisteredWithThisThread;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetNetworkIdFromEntity;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetEntityFromNetworkId;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkGetEntityIsNetworked;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkGetEntityIsLocal;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkRegisterEntityAsNetworked;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkUnregisterNetworkedEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkDoesNetworkIdExist;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkDoesEntityExistWithNetworkId;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkRequestControlOfNetworkId;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkHasControlOfNetworkId;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsNetworkIdAClone;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkRequestControlOfEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkRequestControlOfDoor;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkHasControlOfEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkHasControlOfPickup;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkHasControlOfDoor;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsDoorNetworked;
		private delegate* unmanaged[Cdecl]<int, int> fn__vehToNet;
		private delegate* unmanaged[Cdecl]<int, int> fn__pedToNet;
		private delegate* unmanaged[Cdecl]<int, int> fn__objToNet;
		private delegate* unmanaged[Cdecl]<int, int> fn__netToVeh;
		private delegate* unmanaged[Cdecl]<int, int> fn__netToPed;
		private delegate* unmanaged[Cdecl]<int, int> fn__netToObj;
		private delegate* unmanaged[Cdecl]<int, int> fn__netToEnt;
		private delegate* unmanaged[Cdecl]<int*, int, void> fn__networkGetLocalHandle;
		private delegate* unmanaged[Cdecl]<nint, int*, int, void> fn__networkHandleFromUserId;
		private delegate* unmanaged[Cdecl]<nint, int*, int, void> fn__networkHandleFromMemberId;
		private delegate* unmanaged[Cdecl]<int, int*, int, void> fn__networkHandleFromPlayer;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkHashFromPlayerHandle;
		private delegate* unmanaged[Cdecl]<int*, int> fn__networkHashFromGamerHandle;
		private delegate* unmanaged[Cdecl]<int, int*, int, void> fn__networkHandleFromFriend;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkGamertagFromHandleStart;
		private delegate* unmanaged[Cdecl]<bool> fn__networkGamertagFromHandlePending;
		private delegate* unmanaged[Cdecl]<bool> fn__networkGamertagFromHandleSucceeded;
		private delegate* unmanaged[Cdecl]<int*, nint> fn__networkGetGamertagFromHandle;
		private delegate* unmanaged[Cdecl]<int*, int, int> fn__networkDisplaynamesFromHandlesStart;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__networkGetDisplaynamesFromHandles;
		private delegate* unmanaged[Cdecl]<int*, int*, bool> fn__networkAreHandlesTheSame;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__networkIsHandleValid;
		private delegate* unmanaged[Cdecl]<int*, int> fn__networkGetPlayerFromGamerHandle;
		private delegate* unmanaged[Cdecl]<int*, nint> fn__networkMemberIdFromGamerHandle;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsGamerInMySession;
		private delegate* unmanaged[Cdecl]<int*, void> fn__networkShowProfileUi;
		private delegate* unmanaged[Cdecl]<int, nint> fn__networkPlayerGetName;
		private delegate* unmanaged[Cdecl]<int, int*, nint> fn__networkPlayerGetUserid;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkPlayerIsRockstarDev;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkPlayerIndexIsCheater;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetEntityNetScriptId;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x37D5F739FD494675;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsInactiveProfile;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetMaxFriends;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetFriendCount;
		private delegate* unmanaged[Cdecl]<int, nint> fn__networkGetFriendName;
		private delegate* unmanaged[Cdecl]<int, nint> fn__networkGetFriendNameFromIndex;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__networkIsFriendOnline;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsFriendHandleOnline;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__networkIsFriendInSameTitle;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__networkIsFriendInMultiplayer;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsFriend;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkIsPendingFriend;
		private delegate* unmanaged[Cdecl]<int> fn__networkIsAddingFriend;
		private delegate* unmanaged[Cdecl]<int*, nint, bool> fn__networkAddFriend;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsFriendIndexOnline;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetPlayerIsPassive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkGetPlayerOwnsWaypoint;
		private delegate* unmanaged[Cdecl]<bool> fn__networkCanSetWaypoint;
		private delegate* unmanaged[Cdecl]<void> fn__0x4C2A9FDC22377075;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xB309EBEA797E001F;
		private delegate* unmanaged[Cdecl]<int> fn__0x26F07DD83A5F7F98;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHasHeadset;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x7D395EA61622E116;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsLocalTalking;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkGamerHasHeadset;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsGamerTalking;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkCanCommunicateWithGamer2;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkCanCommunicateWithGamer;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsGamerMutedByMe;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkAmIMutedByGamer;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkIsGamerBlockedByMe;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkAmIBlockedByGamer;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkCanViewGamerUserContent;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkHasViewGamerUserContentResult;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkCanPlayMultiplayerWithGamer;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkCanGamerPlayMultiplayerWithMe;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsPlayerTalking;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkPlayerHasHeadset;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsPlayerMutedByMe;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkAmIMutedByPlayer;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsPlayerBlockedByMe;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkAmIBlockedByPlayer;
		private delegate* unmanaged[Cdecl]<int, float> fn__networkGetPlayerLoudness;
		private delegate* unmanaged[Cdecl]<float, void> fn__networkSetTalkerProximity;
		private delegate* unmanaged[Cdecl]<float> fn__networkGetTalkerProximity;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetVoiceActive;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xCFEB46DCD7D8D5EB;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkOverrideTransitionChat;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetTeamOnlyChat;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x265559DA40B3F327;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x4348BFDA56023A2F;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkOverrideTeamRestrictions;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetOverrideSpectatorMode;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x3C5C1E2C2FF814B1;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x9D7AFCBF21C51712;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetNoSpectatorChat;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x6A5D89D7769A40D8;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkOverrideChatRestrictions;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkOverrideSendRestrictions;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkOverrideSendRestrictionsAll;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkOverrideReceiveRestrictions;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkOverrideReceiveRestrictionsAll;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSetVoiceChannel;
		private delegate* unmanaged[Cdecl]<void> fn__networkClearVoiceChannel;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__networkApplyVoiceProximityOverride;
		private delegate* unmanaged[Cdecl]<void> fn__networkClearVoiceProximityOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x5E3AA4CA2B6FB0EE;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xCA575C391FEA25CC;
		private delegate* unmanaged[Cdecl]<int, float*, float*, void> fn__0xADB57E5B663CCA8B;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x8EF52ACAECC51D9C;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTextChatActive;
		private delegate* unmanaged[Cdecl]<void> fn__shutdownAndLaunchSinglePlayerGame;
		private delegate* unmanaged[Cdecl]<bool> fn__shutdownAndLoadMostRecentSave;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetFriendlyFireOption;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__networkSetRichPresence;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__networkSetRichPresenceString;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetTimeoutTime;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, void> fn__networkLeavePedBehindBeforeWarp;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkLeavePedBehindBeforeCutscene;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__removeAllStickyBombsFromEntity;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x17C9E241111A674D;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int> fn__0x2E4C123D1C8A710E;
		private delegate* unmanaged[Cdecl]<bool> fn__networkClanServiceIsValid;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkClanPlayerIsActive;
		private delegate* unmanaged[Cdecl]<int*, int, int*, bool> fn__networkClanPlayerGetDesc;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__networkClanIsRockstarClan;
		private delegate* unmanaged[Cdecl]<int*, int, nint*, void> fn__networkClanGetUiFormattedTag;
		private delegate* unmanaged[Cdecl]<int> fn__networkClanGetLocalMembershipsCount;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__networkClanGetMembershipDesc;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkClanDownloadMembership;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkClanDownloadMembershipPending;
		private delegate* unmanaged[Cdecl]<bool> fn__networkClanAnyDownloadMembershipPending;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__networkClanRemoteMembershipsAreInCache;
		private delegate* unmanaged[Cdecl]<int*, int> fn__networkClanGetMembershipCount;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__networkClanGetMembershipValid;
		private delegate* unmanaged[Cdecl]<int*, int*, int, bool> fn__networkClanGetMembership;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkClanJoin;
		private delegate* unmanaged[Cdecl]<nint, nint, bool> fn__networkClanAnimation;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__0x2B51EDBEFC301339;
		private delegate* unmanaged[Cdecl]<int> fn__0xC32EA7A2F6CA7557;
		private delegate* unmanaged[Cdecl]<int*, nint*, bool> fn__networkClanGetEmblemTxdName;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkClanRequestEmblem;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__networkClanIsEmblemReady;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkClanReleaseEmblem;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetPrimaryClanDataClear;
		private delegate* unmanaged[Cdecl]<void> fn__networkGetPrimaryClanDataCancel;
		private delegate* unmanaged[Cdecl]<int*, int, bool> fn__networkGetPrimaryClanDataStart;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetPrimaryClanDataPending;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetPrimaryClanDataSuccess;
		private delegate* unmanaged[Cdecl]<int*, int*, bool> fn__networkGetPrimaryClanDataNew;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setNetworkIdCanMigrate;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setNetworkIdExistsOnAllMachines;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setNetworkIdAlwaysExistsForPlayer;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x9D724B400A7E8FFC;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkSetEntityCanBlend;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x0379DAF89BA09AA5;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkSetEntityInvisibleToNetwork;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setNetworkIdVisibleInCutscene;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x32EBD154CB6B8B99;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x76B3F29D3F967692;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setNetworkCutsceneEntities;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x3FA36981311FA4FF;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isNetworkIdOwnedByParticipant;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__setLocalPlayerVisibleInCutscene;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setLocalPlayerInvisibleLocally;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setLocalPlayerVisibleLocally;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerInvisibleLocally;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerVisibleLocally;
		private delegate* unmanaged[Cdecl]<bool, void> fn__fadeOutLocalPlayer;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkFadeOutEntity;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__networkFadeInEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsPlayerFading;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsEntityFading;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerInCutscene;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setEntityVisibleInCutscene;
		private delegate* unmanaged[Cdecl]<int, void> fn__setEntityLocallyInvisible;
		private delegate* unmanaged[Cdecl]<int, void> fn__setEntityLocallyVisible;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isDamageTrackerActiveOnNetworkId;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__activateDamageTrackerOnNetworkId;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isDamageTrackerActiveOnPlayer;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__activateDamageTrackerOnPlayer;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool> fn__isSphereVisibleToAnotherMachine;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool> fn__isSphereVisibleToPlayer;
		private delegate* unmanaged[Cdecl]<int, void> fn__reserveNetworkMissionObjects;
		private delegate* unmanaged[Cdecl]<int, void> fn__reserveNetworkMissionPeds;
		private delegate* unmanaged[Cdecl]<int, void> fn__reserveNetworkMissionVehicles;
		private delegate* unmanaged[Cdecl]<int, void> fn__reserveNetworkLocalObjects;
		private delegate* unmanaged[Cdecl]<int, void> fn__reserveNetworkLocalPeds;
		private delegate* unmanaged[Cdecl]<int, void> fn__reserveNetworkLocalVehicles;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canRegisterMissionObjects;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canRegisterMissionPeds;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canRegisterMissionVehicles;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canRegisterMissionPickups;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xE16AA70CE9BEEDC3;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool> fn__canRegisterMissionEntities;
		private delegate* unmanaged[Cdecl]<bool, int, int> fn__getNumReservedMissionObjects;
		private delegate* unmanaged[Cdecl]<bool, int, int> fn__getNumReservedMissionPeds;
		private delegate* unmanaged[Cdecl]<bool, int, int> fn__getNumReservedMissionVehicles;
		private delegate* unmanaged[Cdecl]<bool, int> fn__getNumCreatedMissionObjects;
		private delegate* unmanaged[Cdecl]<bool, int> fn__getNumCreatedMissionPeds;
		private delegate* unmanaged[Cdecl]<bool, int> fn__getNumCreatedMissionVehicles;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__0xE42D626EEC94E5D9;
		private delegate* unmanaged[Cdecl]<int> fn__getMaxNumNetworkObjects;
		private delegate* unmanaged[Cdecl]<int> fn__getMaxNumNetworkPeds;
		private delegate* unmanaged[Cdecl]<int> fn__getMaxNumNetworkVehicles;
		private delegate* unmanaged[Cdecl]<int> fn__getMaxNumNetworkPickups;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xBA7F0B77D80A4EB7;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x0F1A4B45B7693B95;
		private delegate* unmanaged[Cdecl]<int> fn__getNetworkTime;
		private delegate* unmanaged[Cdecl]<int> fn__getNetworkTimeAccurate;
		private delegate* unmanaged[Cdecl]<bool> fn__hasNetworkTimeStarted;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getTimeOffset;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isTimeLessThan;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isTimeMoreThan;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isTimeEqualTo;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getTimeDifference;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getTimeAsString;
		private delegate* unmanaged[Cdecl]<nint> fn__getCloudTimeAsString;
		private delegate* unmanaged[Cdecl]<int> fn__getCloudTimeAsInt;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__convertPosixTime;
		private delegate* unmanaged[Cdecl]<bool, int, void> fn__networkSetInSpectatorMode;
		private delegate* unmanaged[Cdecl]<bool, int, bool, void> fn__networkSetInSpectatorModeExtended;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkSetInFreeCamMode;
		private delegate* unmanaged[Cdecl]<bool, int, void> fn__networkSetChoiceMigrateOptions;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsInSpectatorMode;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__networkSetInMpCutscene;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsInMpCutscene;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsPlayerInMpCutscene;
		private delegate* unmanaged[Cdecl]<void> fn__0xFAC18E7356BD3210;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setNetworkVehicleRespotTimer;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setNetworkVehicleAsGhost;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setNetworkVehiclePositionUpdateMultiplier;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setNetworkEnableVehiclePositionCorrection;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__setLocalPlayerAsGhost;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityGhostedToLocalPlayer;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x13F1FCB111B820B0;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setRelationshipToPlayer;
		private delegate* unmanaged[Cdecl]<int, void> fn__setGhostedEntityAlpha;
		private delegate* unmanaged[Cdecl]<void> fn__resetGhostedEntityAlpha;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkSetEntityGhostedWithOwner;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xD7B6C73CAD419BCF;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x7EF7649B64D7FF10;
		private delegate* unmanaged[Cdecl]<bool, void> fn__usePlayerColourInsteadOfTeamColour;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, bool, float, float, float, int> fn__networkCreateSynchronisedScene;
		private delegate* unmanaged[Cdecl]<int, int, nint, nint, float, float, int, int, float, int, void> fn__networkAddPedToSynchronisedScene;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void> fn__0xA5EAFE473E45C442;
		private delegate* unmanaged[Cdecl]<int, int, nint, nint, float, float, int, void> fn__networkAddEntityToSynchronisedScene;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, nint, float, float, int, void> fn__0x45F35C0EDC33B03B;
		private delegate* unmanaged[Cdecl]<int, nint, nint, void> fn__networkAddSynchronisedSceneCamera;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkAttachSynchronisedSceneToEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkStartSynchronisedScene;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkStopSynchronisedScene;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetLocalSceneFromNetworkId;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC9B43A33D09CADA7;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x144DA052257AE7D8;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0xFB1F9381E80FA13F;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int, bool> fn__networkStartRespawnSearchForPlayer;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, int, bool> fn__networkStartRespawnSearchInAngledAreaForPlayer;
		private delegate* unmanaged[Cdecl]<int*, int> fn__networkQueryRespawnResults;
		private delegate* unmanaged[Cdecl]<void> fn__networkCancelRespawnSearch;
		private delegate* unmanaged[Cdecl]<int, Vector3*, float*, void> fn__networkGetRespawnResult;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetRespawnResultFlags;
		private delegate* unmanaged[Cdecl]<void> fn__networkStartSoloTutorialSession;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xFB680D403909DC70;
		private delegate* unmanaged[Cdecl]<void> fn__networkEndTutorialSession;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsInTutorialSession;
		private delegate* unmanaged[Cdecl]<bool> fn__0xB37E4E6A2388CA7B;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTutorialSessionChangePending;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetPlayerTutorialSessionInstance;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkIsPlayerEqualToIndex;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__networkConcealPlayer;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsPlayerConcealed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkConcealEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsEntityConcealed;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__networkOverrideClockTime;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkOverrideClockMillisecondsPerGameMinute;
		private delegate* unmanaged[Cdecl]<void> fn__networkClearClockTimeOverride;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsClockTimeOverridden;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int> fn__networkAddEntityArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int> fn__networkAddEntityAngledArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int> fn__networkAddEntityDisplayedBoundaries;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int> fn__0x2B1C623823DB0D9D;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkRemoveEntityArea;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkEntityAreaDoesExist;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x4DF7CFFF471A7FB1;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkEntityAreaIsOccupied;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkUseHighPrecisionBlending;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xA6FCECCF4721D679;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x95BAF97C82464629;
		private delegate* unmanaged[Cdecl]<bool> fn__networkRequestCloudBackgroundScripts;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsCloudBackgroundScriptRequestPending;
		private delegate* unmanaged[Cdecl]<void> fn__networkRequestCloudTunables;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsTunableCloudRequestPending;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetTunableCloudCrc;
		private delegate* unmanaged[Cdecl]<nint, nint, bool> fn__networkDoesTunableExist;
		private delegate* unmanaged[Cdecl]<nint, nint, int*, bool> fn__networkAccessTunableInt;
		private delegate* unmanaged[Cdecl]<nint, nint, float*, bool> fn__networkAccessTunableFloat;
		private delegate* unmanaged[Cdecl]<nint, nint, bool> fn__networkAccessTunableBool;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkDoesTunableExistHash;
		private delegate* unmanaged[Cdecl]<bool> fn__networkAllocateTunablesRegistrationDataMap;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__networkAccessTunableIntHash;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__networkRegisterTunableIntHash;
		private delegate* unmanaged[Cdecl]<int, int, float*, bool> fn__networkAccessTunableFloatHash;
		private delegate* unmanaged[Cdecl]<int, int, float*, bool> fn__networkRegisterTunableFloatHash;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkAccessTunableBoolHash;
		private delegate* unmanaged[Cdecl]<int, int, bool*, bool> fn__networkRegisterTunableBoolHash;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__networkTryAccessTunableBoolHash;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetContentModifierListId;
		private delegate* unmanaged[Cdecl]<int> fn__0x7DB53B37A2F211A0;
		private delegate* unmanaged[Cdecl]<void> fn__networkResetBodyTracker;
		private delegate* unmanaged[Cdecl]<int> fn__networkGetNumBodyTrackers;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x2E0BF682CC778D49;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__0x0EDE326D47CD0F3E;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkSetVehicleWheelsDestructible;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x38B7C51AB1EDC7D8;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x3FC795691834481D;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, void> fn__networkExplodeVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x2A5E0621DD815A9A;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkUseLogarithmicBlendingThisFrame;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, void> fn__networkOverrideCoordsAndHeading;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xE6717E652B8C8D8A;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkDisableProximityMigration;
		private delegate* unmanaged[Cdecl]<int, void> fn__networkSetPropertyId;
		private delegate* unmanaged[Cdecl]<void> fn__networkClearPropertyId;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x367EF5E2F439B4C6;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x94538037EE44F5CF;
		private delegate* unmanaged[Cdecl]<void> fn__networkCacheLocalPlayerHeadBlendData;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkHasCachedPlayerHeadBlendData;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__networkApplyCachedPlayerHeadBlendData;
		private delegate* unmanaged[Cdecl]<int> fn__getNumCommerceItems;
		private delegate* unmanaged[Cdecl]<bool> fn__isCommerceDataValid;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xB606E6CC59664972;
		private delegate* unmanaged[Cdecl]<bool> fn__0x1D4DC17C38FEAFF0;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getCommerceItemId;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getCommerceItemName;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getCommerceProductPrice;
		private delegate* unmanaged[Cdecl]<int, int> fn__getCommerceItemNumCats;
		private delegate* unmanaged[Cdecl]<int, int, nint> fn__getCommerceItemCat;
		private delegate* unmanaged[Cdecl]<nint, nint, int, void> fn__openCommerceStore;
		private delegate* unmanaged[Cdecl]<bool> fn__isCommerceStoreOpen;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setStoreEnabled;
		private delegate* unmanaged[Cdecl]<int, bool> fn__requestCommerceItemImage;
		private delegate* unmanaged[Cdecl]<void> fn__releaseAllCommerceItemImages;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getCommerceItemTexturename;
		private delegate* unmanaged[Cdecl]<bool> fn__isStoreAvailableToUser;
		private delegate* unmanaged[Cdecl]<void> fn__0x265635150FB0D82E;
		private delegate* unmanaged[Cdecl]<void> fn__0x444C4525ECE0A4B9;
		private delegate* unmanaged[Cdecl]<bool> fn__0x59328EB08C5CEB2B;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0xFAE628F1E9ADB239;
		private delegate* unmanaged[Cdecl]<int> fn__0x754615490A029508;
		private delegate* unmanaged[Cdecl]<int> fn__0x155467ACA0F55705;
		private delegate* unmanaged[Cdecl]<nint, int> fn__cloudDeleteMemberFile;
		private delegate* unmanaged[Cdecl]<int, bool> fn__cloudHasRequestCompleted;
		private delegate* unmanaged[Cdecl]<int, bool> fn__cloudDidRequestSucceed;
		private delegate* unmanaged[Cdecl]<void> fn__cloudCheckAvailability;
		private delegate* unmanaged[Cdecl]<bool> fn__cloudIsCheckingAvailability;
		private delegate* unmanaged[Cdecl]<bool> fn__cloudGetAvailabilityCheckResult;
		private delegate* unmanaged[Cdecl]<int> fn__0x8B0C2964BA471961;
		private delegate* unmanaged[Cdecl]<int> fn__0x88B588B41FF7868E;
		private delegate* unmanaged[Cdecl]<int> fn__0x67FC09BC554A75E5;
		private delegate* unmanaged[Cdecl]<void> fn__clearLaunchParams;
		private delegate* unmanaged[Cdecl]<int*, int*, bool> fn__ugcCopyContent;
		private delegate* unmanaged[Cdecl]<int> fn__0x9FEDF86898F100E9;
		private delegate* unmanaged[Cdecl]<bool> fn__ugcHasCreateFinished;
		private delegate* unmanaged[Cdecl]<int> fn__ugcDidCreateSucceed;
		private delegate* unmanaged[Cdecl]<int> fn__ugcGetCreateResult;
		private delegate* unmanaged[Cdecl]<int> fn__ugcGetCreateContentId;
		private delegate* unmanaged[Cdecl]<void> fn__ugcClearCreateResult;
		private delegate* unmanaged[Cdecl]<int, int, int*, int, int, int, bool> fn__ugcQueryMyContent;
		private delegate* unmanaged[Cdecl]<int, int, int, nint, int, bool, bool> fn__0x692D58DF40657E8C;
		private delegate* unmanaged[Cdecl]<nint, bool, nint, bool> fn__ugcQueryByContentId;
		private delegate* unmanaged[Cdecl]<int*, int, bool, nint, bool> fn__ugcQueryByContentIds;
		private delegate* unmanaged[Cdecl]<int, int, nint, int, bool> fn__ugcQueryRecentlyCreatedContent;
		private delegate* unmanaged[Cdecl]<int, int, nint, int*, bool> fn__ugcGetBookmarkedContent;
		private delegate* unmanaged[Cdecl]<int, int, nint, int*, bool> fn__ugcGetMyContent;
		private delegate* unmanaged[Cdecl]<int, int, nint, int*, bool> fn__ugcGetFriendContent;
		private delegate* unmanaged[Cdecl]<int, int, int, nint, int*, bool> fn__ugcGetCrewContent;
		private delegate* unmanaged[Cdecl]<int, int, int, nint, int*, bool> fn__ugcGetGetByCategory;
		private delegate* unmanaged[Cdecl]<nint, nint, bool> fn__setBalanceAddMachine;
		private delegate* unmanaged[Cdecl]<int*, int, nint, bool> fn__setBalanceAddMachines;
		private delegate* unmanaged[Cdecl]<int, int, int*, int*, bool> fn__0xA7862BC5ED1DFD7E;
		private delegate* unmanaged[Cdecl]<int, int, int*, int*, bool> fn__0x97A770BEEF227E2B;
		private delegate* unmanaged[Cdecl]<int, int, int*, int*, bool> fn__0x5324A0E3E4CE3570;
		private delegate* unmanaged[Cdecl]<void> fn__ugcCancelQuery;
		private delegate* unmanaged[Cdecl]<bool> fn__ugcIsGetting;
		private delegate* unmanaged[Cdecl]<bool> fn__ugcHasGetFinished;
		private delegate* unmanaged[Cdecl]<int> fn__ugcDidGetSucceed;
		private delegate* unmanaged[Cdecl]<int> fn__0xC87E740D9F3872CC;
		private delegate* unmanaged[Cdecl]<int> fn__ugcGetQueryResult;
		private delegate* unmanaged[Cdecl]<int> fn__ugcGetContentNum;
		private delegate* unmanaged[Cdecl]<int> fn__ugcGetContentTotal;
		private delegate* unmanaged[Cdecl]<int> fn__ugcGetContentHash;
		private delegate* unmanaged[Cdecl]<void> fn__ugcClearQueryResults;
		private delegate* unmanaged[Cdecl]<int, nint> fn__ugcGetContentUserId;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__0x584770794D758C18;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x8C8D2739BA44AF0F;
		private delegate* unmanaged[Cdecl]<int, int> fn__ugcGetContentUserName;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xAEAB987727C5A8A4;
		private delegate* unmanaged[Cdecl]<int, int> fn__ugcGetContentCategory;
		private delegate* unmanaged[Cdecl]<int, nint> fn__ugcGetContentId;
		private delegate* unmanaged[Cdecl]<int, nint> fn__ugcGetRootContentId;
		private delegate* unmanaged[Cdecl]<int, int> fn__ugcGetContentName;
		private delegate* unmanaged[Cdecl]<int, int> fn__ugcGetContentDescriptionHash;
		private delegate* unmanaged[Cdecl]<int, int, nint> fn__ugcGetContentPath;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__ugcGetContentUpdatedDate;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__ugcGetContentFileVersion;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x1D610EB0FEA716D9;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x7FCC39C46C3C03BD;
		private delegate* unmanaged[Cdecl]<int, int> fn__ugcGetContentLanguage;
		private delegate* unmanaged[Cdecl]<int, bool> fn__ugcGetContentIsPublished;
		private delegate* unmanaged[Cdecl]<int, bool> fn__ugcGetContentIsVerified;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__ugcGetContentRating;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__ugcGetContentRatingCount;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__ugcGetContentRatingPositiveCount;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__ugcGetContentRatingNegativeCount;
		private delegate* unmanaged[Cdecl]<int, bool> fn__ugcGetContentHasPlayerRecord;
		private delegate* unmanaged[Cdecl]<int, bool> fn__ugcGetContentHasPlayerBookmarked;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__ugcRequestContentDataFromIndex;
		private delegate* unmanaged[Cdecl]<nint, nint, int, int, int, int> fn__ugcRequestContentDataFromParams;
		private delegate* unmanaged[Cdecl]<int, int> fn__ugcRequestCachedDescription;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x2D5DC831176D0114;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xEBFA8D50ADDC54C4;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x162C23CA83ED0A62;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__ugcGetCachedDescription;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x5A34CD9C3C5BEC44;
		private delegate* unmanaged[Cdecl]<void> fn__0x68103E2247887242;
		private delegate* unmanaged[Cdecl]<nint, nint, nint, bool> fn__ugcPublish;
		private delegate* unmanaged[Cdecl]<nint, bool, nint, bool> fn__ugcSetBookmarked;
		private delegate* unmanaged[Cdecl]<int*, bool, nint, bool> fn__ugcSetDeleted;
		private delegate* unmanaged[Cdecl]<int> fn__0x45E816772E93A9DB;
		private delegate* unmanaged[Cdecl]<bool> fn__ugcHasModifyFinished;
		private delegate* unmanaged[Cdecl]<int> fn__0x793FF272D5B365F4;
		private delegate* unmanaged[Cdecl]<int> fn__ugcGetModifyResult;
		private delegate* unmanaged[Cdecl]<void> fn__ugcClearModifyResult;
		private delegate* unmanaged[Cdecl]<int*, int*, bool> fn__0xB746D20B17F2A229;
		private delegate* unmanaged[Cdecl]<int> fn__0x63B406D7884BFA95;
		private delegate* unmanaged[Cdecl]<int> fn__0x4D02279C83BE69FE;
		private delegate* unmanaged[Cdecl]<int> fn__ugcGetCreatorNum;
		private delegate* unmanaged[Cdecl]<int, bool> fn__ugcPoliciesMakePrivate;
		private delegate* unmanaged[Cdecl]<void> fn__ugcClearOfflineQuery;
		private delegate* unmanaged[Cdecl]<bool, void> fn__ugcSetQueryDataFromOffline;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xFD75DABC0957BF33;
		private delegate* unmanaged[Cdecl]<int, bool> fn__ugcIsLanguageSupported;
		private delegate* unmanaged[Cdecl]<nint, int, int, bool> fn__facebookSetHeistComplete;
		private delegate* unmanaged[Cdecl]<bool> fn__facebookSetCreateCharacterComplete;
		private delegate* unmanaged[Cdecl]<int, bool> fn__facebookSetMilestoneComplete;
		private delegate* unmanaged[Cdecl]<bool> fn__facebookIsSendingData;
		private delegate* unmanaged[Cdecl]<bool> fn__facebookDoUnkCheck;
		private delegate* unmanaged[Cdecl]<bool> fn__facebookIsAvailable;
		private delegate* unmanaged[Cdecl]<int*, nint, nint, bool, int> fn__textureDownloadRequest;
		private delegate* unmanaged[Cdecl]<nint, nint, bool, int> fn__titleTextureDownloadRequest;
		private delegate* unmanaged[Cdecl]<nint, int, int, int, nint, bool, int> fn__ugcTextureDownloadRequest;
		private delegate* unmanaged[Cdecl]<int, void> fn__textureDownloadRelease;
		private delegate* unmanaged[Cdecl]<int, bool> fn__textureDownloadHasFailed;
		private delegate* unmanaged[Cdecl]<int, nint> fn__textureDownloadGetName;
		private delegate* unmanaged[Cdecl]<int, int> fn__getStatusOfTextureDownload;
		private delegate* unmanaged[Cdecl]<bool> fn__0x60EDD13EB3AC1FF3;
		private delegate* unmanaged[Cdecl]<bool> fn__networkShouldShowConnectivityTroubleshooting;
		private delegate* unmanaged[Cdecl]<bool> fn__networkIsCableConnected;
		private delegate* unmanaged[Cdecl]<bool> fn__networkGetRosPrivilege9;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHaveRosSocialClubPriv;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHaveRosBannedPriv;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHaveRosCreateTicketPriv;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHaveRosMultiplayerPriv;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHaveRosLeaderboardWritePriv;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkHasRosPrivilege;
		private delegate* unmanaged[Cdecl]<int, int*, int*, bool> fn__networkHasRosPrivilegeEndDate;
		private delegate* unmanaged[Cdecl]<bool> fn__networkGetRosPrivilege24;
		private delegate* unmanaged[Cdecl]<bool> fn__networkGetRosPrivilege25;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x36391F397731595D;
		private delegate* unmanaged[Cdecl]<int*, int> fn__networkStartUserContentPermissionsCheck;
		private delegate* unmanaged[Cdecl]<void> fn__0x9465E683B12D3F6B;
		private delegate* unmanaged[Cdecl]<void> fn__0xCA59CCAE5D01E4CE;
		private delegate* unmanaged[Cdecl]<bool> fn__networkHasGameBeenAltered;
		private delegate* unmanaged[Cdecl]<void> fn__networkUpdatePlayerScars;
		private delegate* unmanaged[Cdecl]<bool, void> fn__networkDisableLeaveRemotePedBehind;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkAllowLocalEntityAttachment;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x6BFF5F84102DF80A;
		private delegate* unmanaged[Cdecl]<void> fn__0x5C497525F803486B;
		private delegate* unmanaged[Cdecl]<int> fn__0x6FB7BB3607D27FA2;
		private delegate* unmanaged[Cdecl]<void> fn__0x45A83257ED02D9BC;
		private delegate* unmanaged[Cdecl]<int, bool> fn__networkIsConnectionEndpointRelayServer;
		private delegate* unmanaged[Cdecl]<int, float> fn__networkGetAverageLatencyForPlayer;
		private delegate* unmanaged[Cdecl]<int, float> fn__networkGetAverageLatencyForPlayer2;
		private delegate* unmanaged[Cdecl]<int, float> fn__networkGetAveragePacketLossForPlayer;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetNumUnackedForPlayer;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetUnreliableResendCountForPlayer;
		private delegate* unmanaged[Cdecl]<int, int> fn__networkGetOldestResendCountForPlayer;
		private delegate* unmanaged[Cdecl]<void> fn__networkReportMyself;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__0x64D779659BC37B19;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__networkGetPlayerCoords;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__networkGetLastVelocityReceived;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__0xAA5FAFCD2C5F5E47;
		private delegate* unmanaged[Cdecl]<int> fn__0xAEDF1BC1C133D6E3;
		private delegate* unmanaged[Cdecl]<int> fn__0x2555CF7DA5473794;
		private delegate* unmanaged[Cdecl]<int> fn__0x6FD992C4A1C1B986;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xDB663CC9FF3407A9;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__networkUgcNav;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, int> fn__createObject;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, int> fn__createObjectNoOffset;
		private delegate* unmanaged[Cdecl]<int*, void> fn__deleteObject;
		private delegate* unmanaged[Cdecl]<int, bool> fn__placeObjectOnGroundProperly;
		private delegate* unmanaged[Cdecl]<int, bool> fn__placeObjectOnGroundProperly2;
		private delegate* unmanaged[Cdecl]<int, float, float, bool, bool> fn__0xAFE24E4D29249E4A;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, bool> fn__slideObject;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setObjectTargettable;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setObjectForceVehiclesToAvoid;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, bool, bool, int> fn__getClosestObjectOfType;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__hasObjectBeenBroken;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, bool> fn__hasClosestObjectOfTypeBeenBroken;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, bool> fn__hasClosestObjectOfTypeBeenCompletelyDestroyed;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x2542269291C6AC84;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, Vector3> fn__getObjectOffsetFromCoords;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, Vector3*, Vector3*, int, int> fn__getCoordsAndRotationOfClosestObjectOfType;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, float, bool, void> fn__setStateOfClosestDoorOfType;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool*, float*, void> fn__getStateOfClosestDoorOfType;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, float, float, float, void> fn__doorControl;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x006E4B040ED37EC3;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, bool, bool, void> fn__addDoorToSystem;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeDoorFromSystem;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__doorSystemSetDoorState;
		private delegate* unmanaged[Cdecl]<int, int> fn__doorSystemGetDoorState;
		private delegate* unmanaged[Cdecl]<int, int> fn__doorSystemGetDoorPendingState;
		private delegate* unmanaged[Cdecl]<int, float, bool, bool, void> fn__doorSystemSetAutomaticRate;
		private delegate* unmanaged[Cdecl]<int, float, bool, bool, void> fn__doorSystemSetAutomaticDistance;
		private delegate* unmanaged[Cdecl]<int, float, bool, bool, void> fn__doorSystemSetOpenRatio;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xE851471AEFC3374F;
		private delegate* unmanaged[Cdecl]<int, float> fn__doorSystemGetOpenRatio;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, void> fn__doorSystemSetSpringRemoved;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__doorSystemSetHoldOpen;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xA85A21582451E951;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isDoorRegisteredWithSystem;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isDoorClosed;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xC7F29CA00F46350E;
		private delegate* unmanaged[Cdecl]<void> fn__0x701FDA1E82076BA4;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doorSystemGetIsPhysicsLoaded;
		private delegate* unmanaged[Cdecl]<float, float, float, int, int*, bool> fn__doorSystemFindExistingDoor;
		private delegate* unmanaged[Cdecl]<int, bool, int, bool> fn__isGarageEmpty;
		private delegate* unmanaged[Cdecl]<int, int, float, int, bool> fn__isPlayerEntirelyInsideGarage;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__isPlayerPartiallyInsideGarage;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, int, bool> fn__areEntitiesEntirelyInsideGarage;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, int, bool> fn__isAnyEntityEntirelyInsideGarage;
		private delegate* unmanaged[Cdecl]<int, int, float, int, bool> fn__isObjectEntirelyInsideGarage;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__isObjectPartiallyInsideGarage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__clearGarageArea;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, void> fn__clearObjectsInsideGarage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x659F9D71F52843F8;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__enableSavingInGarage;
		private delegate* unmanaged[Cdecl]<void> fn__0x66A49D021870FE88;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, bool> fn__doesObjectOfTypeExistAtCoords;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, bool, bool, bool> fn__isPointInAngledArea;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setObjectAllowLowLodBuoyancy;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, void> fn__setObjectPhysicsParams;
		private delegate* unmanaged[Cdecl]<int, bool, float> fn__getObjectFragmentDamageHealth;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setActivateObjectPhysicsAsSoonAsItIsUnfrozen;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool> fn__isAnyObjectNearPoint;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool> fn__isObjectNearPoint;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeObjectHighDetailModel;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__breakObjectFragmentChild;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0xE05F6AEEFEB0BB02;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xF9C1681347C8BD15;
		private delegate* unmanaged[Cdecl]<int, void> fn__trackObjectVisibility;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isObjectVisible;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xC6033D32241F6FB5;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xEB6F1A9B5510A5D2;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setUnkGlobalBoolRelatedToDamage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCreateWeaponObjectLightSource;
		private delegate* unmanaged[Cdecl]<float, float, float, float, nint, int> fn__getRayfireMapObject;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setStateOfRayfireMapObject;
		private delegate* unmanaged[Cdecl]<int, int> fn__getStateOfRayfireMapObject;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesRayfireMapObjectExist;
		private delegate* unmanaged[Cdecl]<int, float> fn__getRayfireMapObjectAnimPhase;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, int, bool, int, int> fn__createPickup;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, int, int, int, bool, int, int> fn__createPickupRotate;
		private delegate* unmanaged[Cdecl]<void> fn__0x394CD08E31313C28;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x826D1EE4D1CAFC78;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, int, int, bool, bool, int> fn__createAmbientPickup;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, int, int, bool, bool, int> fn__createNonNetworkedAmbientPickup;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x1E3F1B1B891A2AAA;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int> fn__createPortablePickup;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int> fn__createNonNetworkedPortablePickup;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__attachPortablePickupToPed;
		private delegate* unmanaged[Cdecl]<int, void> fn__detachPortablePickupFromPed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__hidePickup;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setMaxNumPortablePickupsCarriedByPlayer;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setLocalPlayerCanCollectPortablePickups;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, Vector3> fn__getSafePickupCoords;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__0xD4A7A435B3710D05;
		private delegate* unmanaged[Cdecl]<void> fn__0xB7C6D80FB371659A;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getPickupCoords;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x8DCA505A5C196F05;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeAllPickupsOfType;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasPickupBeenCollected;
		private delegate* unmanaged[Cdecl]<int, void> fn__removePickup;
		private delegate* unmanaged[Cdecl]<float, float, float, int, int, int, void> fn__createMoneyPickups;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesPickupExist;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesPickupObjectExist;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPickupObject;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isObjectAPortablePickup;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isObjectAPickup;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool> fn__doesPickupOfTypeExistInArea;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPickupRegenerationTime;
		private delegate* unmanaged[Cdecl]<int, void> fn__forcePickupRegenerate;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__toggleUsePickupsForPlayer;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setLocalPlayerCanUsePickupsWithThisModel;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xFDC07C58E8AAB715;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setTeamPickupObject;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__preventCollectionOfPortablePickup;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x27F248C3FEBFAAD3;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x0596843B34B95CE5;
		private delegate* unmanaged[Cdecl]<int, float, bool, void> fn__0xA08FE5E49BDC39DD;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x62454A641B41F3C5;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x39A5FB7EAF150840;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x834344A414C7C85D;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xDB41D07A45A6D4B7;
		private delegate* unmanaged[Cdecl]<float, void> fn__setPickupGenerationRangeMultiplier;
		private delegate* unmanaged[Cdecl]<float> fn__getPickupGenerationRangeMultiplier;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x31F924B53EADDF65;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPickupUncollectable;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x858EC9FD25DE04AA;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPickupHiddenWhenUncollectable;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x8881C98A31117998;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x8CFF648FBD7330F1;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x46F3ADD1E2D5BAF2;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x641F272B52E2F0F8;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x4C134B4DF76025D0;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xAA059C615DE9DD03;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xF92099527DB8E2A7;
		private delegate* unmanaged[Cdecl]<void> fn__0xA2C1F5E92AFE49ED;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x762DB2D380B48D04;
		private delegate* unmanaged[Cdecl]<float, float, float, int, void> fn__renderFakePickupGlow;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x7813E8B8C4AE4799;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xBFFE53AE7E67FCDC;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xD05A3241B9A86F19;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xB2D0BDE54F0E8E5A;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeaponTypeFromPickupType;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPickupHashFromWeapon;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPickupWeaponObjectValid;
		private delegate* unmanaged[Cdecl]<int, int> fn__getObjectTextureVariation;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setObjectTextureVariation;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, bool> fn__setTextureVariationOfClosestObjectOfType;
		private delegate* unmanaged[Cdecl]<int, bool, int, int, int, int> fn__setObjectLightColor;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xADF084FB8F075D06;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x3B2FD68DB5F8331C;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setObjectStuntPropSpeedup;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setObjectStuntPropDuration;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPickupHash;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__setForceObjectThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__markObjectForDeletion;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x8CAAB2BD3EA58BD4;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x63ECF581BC70E363;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__setEnableArenaPropPhysics;
		private delegate* unmanaged[Cdecl]<int, bool, int, int, void> fn__setEnableArenaPropPhysicsOnPed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x734E1714D077DA9A;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x1A6CBB06E2D0D79D;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__getIsArenaPropPhysicsDisabled;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x3BD770D281982DB5;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x1C57C94A6446492A;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xB5B7742424BD4445;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isControlEnabled;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isControlPressed;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isControlReleased;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isControlJustPressed;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isControlJustReleased;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getControlValue;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getControlNormal;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x5B73C77D9EB66E24;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getControlUnboundNormal;
		private delegate* unmanaged[Cdecl]<int, int, float, bool> fn__setControlNormal;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isDisabledControlPressed;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isDisabledControlReleased;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isDisabledControlJustPressed;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isDisabledControlJustReleased;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getDisabledControlNormal;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getDisabledControlUnboundNormal;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xD7D22F5592AED8BA;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isUsingKeyboard;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isUsingKeyboard2;
		private delegate* unmanaged[Cdecl]<float, float, bool> fn__setCursorLocation;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x23F09EADC01449D6;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x6CD79468A1E595C6;
		private delegate* unmanaged[Cdecl]<int, int, bool, nint> fn__getControlInstructionalButton;
		private delegate* unmanaged[Cdecl]<int, int, bool, nint> fn__getControlGroupInstructionalButton;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setControlLightEffectColor;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xCB0360EFEFB2580D;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setPadShake;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0x14D29BB12D47F68C;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopPadShake;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPadShakeSuppressedId;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xA0CEFCEA390AAB9B;
		private delegate* unmanaged[Cdecl]<bool> fn__isLookInverted;
		private delegate* unmanaged[Cdecl]<bool> fn__0xE1615EC03B3BB4FD;
		private delegate* unmanaged[Cdecl]<int> fn__getLocalPlayerAimState;
		private delegate* unmanaged[Cdecl]<int> fn__getLocalPlayerAimState2;
		private delegate* unmanaged[Cdecl]<int> fn__0x25AAA32BDC98F2A3;
		private delegate* unmanaged[Cdecl]<bool> fn__getIsUsingAlternateDriveby;
		private delegate* unmanaged[Cdecl]<bool> fn__getAllowMovementWhileZoomed;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setPlayerpadShakesWhenControllerDisabled;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setInputExclusive;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__disableControlAction;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__enableControlAction;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableAllControlActions;
		private delegate* unmanaged[Cdecl]<int, void> fn__enableAllControlActions;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__switchToInputMappingScheme;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__switchToInputMappingScheme2;
		private delegate* unmanaged[Cdecl]<void> fn__resetInputMappingScheme;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableInputGroup;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, void> fn__setRoadsInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, bool, bool, bool, void> fn__setRoadsInAngledArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, int, void> fn__setPedPathsInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, bool, Vector3*, int, bool> fn__getSafeCoordForPed;
		private delegate* unmanaged[Cdecl]<float, float, float, Vector3*, int, float, float, bool> fn__getClosestVehicleNode;
		private delegate* unmanaged[Cdecl]<float, float, float, Vector3*, float, int, bool> fn__getClosestMajorVehicleNode;
		private delegate* unmanaged[Cdecl]<float, float, float, Vector3*, float*, int, float, int, bool> fn__getClosestVehicleNodeWithHeading;
		private delegate* unmanaged[Cdecl]<float, float, float, int, Vector3*, int, int, int, bool> fn__getNthClosestVehicleNode;
		private delegate* unmanaged[Cdecl]<float, float, float, int, int, float, float, int> fn__getNthClosestVehicleNodeId;
		private delegate* unmanaged[Cdecl]<float, float, float, int, Vector3*, float*, int*, int, float, float, bool> fn__getNthClosestVehicleNodeWithHeading;
		private delegate* unmanaged[Cdecl]<float, float, float, int, Vector3*, float*, int, float, float, int> fn__getNthClosestVehicleNodeIdWithHeading;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, Vector3*, float*, int, float, int, bool> fn__getNthClosestVehicleNodeFavourDirection;
		private delegate* unmanaged[Cdecl]<float, float, float, int*, int*, bool> fn__getVehicleNodeProperties;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleNodeIdValid;
		private delegate* unmanaged[Cdecl]<int, Vector3*, void> fn__getVehicleNodePosition;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getVehicleNodeIsGpsAllowed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getVehicleNodeIsSwitchedOff;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, Vector3*, Vector3*, int*, int*, float*, bool, int> fn__getClosestRoad;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setAllPathsCacheBoundingstruct;
		private delegate* unmanaged[Cdecl]<int, void> fn__setAiGlobalPathNodesType;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool> fn__areNodesLoadedForArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool> fn__requestPathsPreferAccurateBoundingstruct;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, void> fn__setRoadsBackToOriginal;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, void> fn__setRoadsBackToOriginalInAngledArea;
		private delegate* unmanaged[Cdecl]<float, void> fn__setAmbientPedRangeMultiplierThisFrame;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__0xAA76052DDA9BFC3E;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__setPedPathsBackToOriginal;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, Vector3*, int*, bool> fn__getRandomVehicleNode;
		private delegate* unmanaged[Cdecl]<float, float, float, int*, int*, void> fn__getStreetNameAtCoord;
		private delegate* unmanaged[Cdecl]<float, float, float, bool, int*, float*, float*, int> fn__generateDirectionsToCoord;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setIgnoreNoGpsFlag;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setIgnoreSecondaryRouteNodes;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void> fn__setGpsDisabledZone;
		private delegate* unmanaged[Cdecl]<int> fn__getGpsBlipRouteLength;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__0xF3162836C28F9DA5;
		private delegate* unmanaged[Cdecl]<bool> fn__getGpsBlipRouteFound;
		private delegate* unmanaged[Cdecl]<float, float, float, float, Vector3*, bool> fn__getRoadSidePointWithHeading;
		private delegate* unmanaged[Cdecl]<float, float, float, int, Vector3*, bool> fn__getPointOnRoadSide;
		private delegate* unmanaged[Cdecl]<float, float, float, int, bool> fn__isPointOnRoad;
		private delegate* unmanaged[Cdecl]<int> fn__getNextGpsDisabledZoneIndex;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, void> fn__setGpsDisabledZoneAtIndex;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearGpsDisabledZoneAtIndex;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__addNavmeshRequiredRegion;
		private delegate* unmanaged[Cdecl]<void> fn__removeNavmeshRequiredRegions;
		private delegate* unmanaged[Cdecl]<bool> fn__isNavmeshRequiredRegionOwnedByAnyThread;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__disableNavmeshInArea;
		private delegate* unmanaged[Cdecl]<bool> fn__areAllNavmeshRegionsLoaded;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool> fn__isNavmeshLoadedInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int> fn__0x01708E8DD3FF8C65;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, bool, int, int> fn__addNavmeshBlockingObject;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int, void> fn__updateNavmeshBlockingObject;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeNavmeshBlockingObject;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesNavmeshBlockingObjectExist;
		private delegate* unmanaged[Cdecl]<float, float, float> fn__getHeightmapTopZForPosition;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float> fn__getHeightmapTopZForArea;
		private delegate* unmanaged[Cdecl]<float, float, float> fn__getHeightmapBottomZForPosition;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float> fn__getHeightmapBottomZForArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float> fn__calculateTravelDistanceBetweenPoints;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool, bool, int> fn__createPed;
		private delegate* unmanaged[Cdecl]<int*, void> fn__deletePed;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, int> fn__clonePed;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, int> fn__clonePedEx;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__clonePedToTarget;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__clonePedToTargetEx;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__isPedInVehicle;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedInModel;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isPedInAnyVehicle;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool> fn__isCopPedInArea3d;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInjured;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedHurt;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedFatallyInjured;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isPedDeadOrDying;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isConversationPedDead;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedAimingFromCover;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedReloading;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedAPlayer;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool, int> fn__createPedInsideVehicle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedDesiredHeading;
		private delegate* unmanaged[Cdecl]<int, void> fn__freezePedCameraRotation;
		private delegate* unmanaged[Cdecl]<int, int, float, bool> fn__isPedFacingPed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInMeleeCombat;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedStopped;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, bool, bool> fn__isPedShootingInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool> fn__isAnyPedShootingInArea;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedShooting;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedAccuracy;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedAccuracy;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x87DDEB611B329A9C;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedModel;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__explodePedHead;
		private delegate* unmanaged[Cdecl]<int*, void> fn__removePedElegantly;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__addArmourToPed;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedArmour;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setPedIntoVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAllowVehiclesOverride;
		private delegate* unmanaged[Cdecl]<bool, bool> fn__canCreateRandomPed;
		private delegate* unmanaged[Cdecl]<float, float, float, int> fn__createRandomPed;
		private delegate* unmanaged[Cdecl]<int, bool, int> fn__createRandomPedAsDriver;
		private delegate* unmanaged[Cdecl]<bool> fn__canCreateRandomDriver;
		private delegate* unmanaged[Cdecl]<bool> fn__canCreateRandomBikeRider;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedMoveAnimsBlendOut;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanBeDraggedOut;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xF2BEBCDFAFDAA19E;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedMale;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedHuman;
		private delegate* unmanaged[Cdecl]<int, bool, int> fn__getVehiclePedIsIn;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPedLastVehicle;
		private delegate* unmanaged[Cdecl]<float, void> fn__setPedDensityMultiplierThisFrame;
		private delegate* unmanaged[Cdecl]<float, float, void> fn__setScenarioPedDensityMultiplierThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__0x5A7F62FDA59759BD;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__setScriptedConversionCoordThisFrame;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void> fn__setPedNonCreationArea;
		private delegate* unmanaged[Cdecl]<void> fn__clearPedNonCreationArea;
		private delegate* unmanaged[Cdecl]<void> fn__instantlyFillPedPopulation;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedOnMount;
		private delegate* unmanaged[Cdecl]<int, int> fn__getMount;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedOnVehicle;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedOnSpecificVehicle;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedMoney;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedMoney;
		private delegate* unmanaged[Cdecl]<float, int, void> fn__0xFF4803BC019852D9;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setAmbientPedsDropMoney;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x9911F4A24485F653;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedSuffersCriticalHits;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xAFC976FD0580C7B3;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedSittingInVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedSittingInAnyVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedOnFoot;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedOnAnyBike;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedPlantingBomb;
		private delegate* unmanaged[Cdecl]<int, float, float, Vector3> fn__getDeadPedPickupCoords;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInAnyBoat;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInAnySub;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInAnyHeli;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInAnyPlane;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInFlyingVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedDiesInWater;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedDiesInSinkingVehicle;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedArmour;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedStayInVehicleWhenJacked;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanBeShotInVehicle;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getPedLastDamageBone;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedLastDamageBone;
		private delegate* unmanaged[Cdecl]<float, void> fn__setAiWeaponDamageModifier;
		private delegate* unmanaged[Cdecl]<void> fn__resetAiWeaponDamageModifier;
		private delegate* unmanaged[Cdecl]<float, void> fn__setAiMeleeWeaponDamageModifier;
		private delegate* unmanaged[Cdecl]<void> fn__resetAiMeleeWeaponDamageModifier;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x2F3C3D9F50681DE4;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanBeTargetted;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPedCanBeTargettedByTeam;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPedCanBeTargettedByPlayer;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x061CB768363D6424;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xFD325494792302D7;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInAnyPoliceVehicle;
		private delegate* unmanaged[Cdecl]<int, void> fn__forcePedToOpenParachute;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInParachuteFreeFall;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedFalling;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedJumping;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x412F1364FA066CFB;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x451D05012CCEC234;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedClimbing;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedVaulting;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedDiving;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedJumpingOutOfVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedOpeningADoor;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedParachuteState;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedParachuteLandingType;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedParachuteTintIndex;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getPedParachuteTintIndex;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedReserveParachuteTintIndex;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int> fn__createParachuteBagObject;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedDucking;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedDucking;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInAnyTaxi;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedIdRange;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedHighlyPerceptive;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__0x2F074C904D85129E;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0xEC4B4B3B9908052A;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x733C87D4CE22BEA2;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedSeeingRange;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedHearingRange;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedVisualFieldMinAngle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedVisualFieldMaxAngle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedVisualFieldMinElevationAngle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedVisualFieldMaxElevationAngle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedVisualFieldPeripheralRange;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedVisualFieldCenterAngle;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPedVisualFieldCenterAngle;
		private delegate* unmanaged[Cdecl]<int, bool, nint, void> fn__setPedStealthMovement;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getPedStealthMovement;
		private delegate* unmanaged[Cdecl]<int, int> fn__createGroup;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedAsGroupLeader;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedAsGroupMember;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPedCanTeleportToGroupLeader;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeGroup;
		private delegate* unmanaged[Cdecl]<int, void> fn__removePedFromGroup;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedGroupMember;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedHangingOnToVehicle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setGroupSeparationRange;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedMinGroundTimeForStungun;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedProne;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedInCombat;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedTaskCombatTarget;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__canPedInCombatSeeTarget;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedDoingDriveby;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedJacking;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedBeingJacked;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedBeingStunned;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedsJacker;
		private delegate* unmanaged[Cdecl]<int, int> fn__getJackTarget;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedFleeing;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isPedInCover;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInCoverFacingLeft;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInHighCover;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedGoingIntoCover;
		private delegate* unmanaged[Cdecl]<int, bool, int, int> fn__setPedPinnedDown;
		private delegate* unmanaged[Cdecl]<int, int> fn__getSeatPedIsTryingToEnter;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehiclePedIsTryingToEnter;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedSourceOfDeath;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedCauseOfDeath;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedTimeOfDeath;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x5407B7288D0478B7;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int> fn__0x336B3D200AB007CB;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedRelationshipGroupDefaultHash;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedRelationshipGroupHash;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setRelationshipBetweenGroups;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__clearRelationshipBetweenGroups;
		private delegate* unmanaged[Cdecl]<nint, int*, int> fn__addRelationshipGroup;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeRelationshipGroup;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesRelationshipGroupExist;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getRelationshipBetweenPeds;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedRelationshipGroupDefaultHash;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedRelationshipGroupHash;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getRelationshipBetweenGroups;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setRelationshipGroupDontAffectWantedLevel;
		private delegate* unmanaged[Cdecl]<int, int, float, int, int, int, void> fn__0xAD27D957598E49E9;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanBeTargetedWithoutLos;
		private delegate* unmanaged[Cdecl]<int, float, int, void> fn__setPedToInformRespectedFriends;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedRespondingToEvent;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__getPedEventData;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedFiringPattern;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedShootRate;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__setCombatFloat;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getCombatFloat;
		private delegate* unmanaged[Cdecl]<int, int*, int*, void> fn__getGroupSize;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesGroupExist;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedGroupIndex;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInGroup;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerPedIsFollowing;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setGroupFormation;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setGroupFormationSpacing;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetGroupFormationDefaultSpacing;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehiclePedIsUsing;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehiclePedIsEntering;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedGravity;
		private delegate* unmanaged[Cdecl]<int, int, bool, int, void> fn__applyDamageToPed;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getTimeOfLastPedWeaponDamage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAllowedToDuck;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedNeverLeavesGroup;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedType;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAsCop;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedMaxHealth;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedMaxHealth;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedMaxTimeInWater;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedMaxTimeUnderwater;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x2735233A786B1BEF;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setPedVehicleForcedSeatUsage;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearAllPedVehicleForcedSeatUsage;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xB282749D5E028163;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedCanBeKnockedOffVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canKnockPedOffVehicle;
		private delegate* unmanaged[Cdecl]<int, void> fn__knockPedOffVehicle;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setPedCoordsNoGang;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedAsGroupMember;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedAsGroupLeader;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedKeepTask;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x49E50BDB8BA4DAB2;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedSwimming;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedSwimmingUnderWater;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setPedCoordsKeepVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedDiesInVehicle;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setCreateRandomCops;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setCreateRandomCopsNotOnScenarios;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setCreateRandomCopsOnScenarios;
		private delegate* unmanaged[Cdecl]<bool> fn__canCreateRandomCops;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAsEnemy;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setPedCanSmashGlass;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInAnyTrain;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedGettingIntoAVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedTryingToEnterALockedVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEnableHandcuffs;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEnableBoundAnkles;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEnableScuba;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setCanAttackFriendly;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedAlertness;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedAlertness;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedGetOutUpsideDownVehicle;
		private delegate* unmanaged[Cdecl]<int, nint, float, void> fn__setPedMovementClipset;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__resetPedMovementClipset;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setPedStrafeClipset;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPedStrafeClipset;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setPedWeaponMovementClipset;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPedWeaponMovementClipset;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setPedDriveByClipsetOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedDriveByClipsetOverride;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setPedCoverClipsetOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedCoverClipsetOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x80054D7FCC70EEC6;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedInVehicleContext;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPedInVehicleContext;
		private delegate* unmanaged[Cdecl]<int, nint, nint, bool> fn__isScriptedScenarioPedUsingConditionalAnim;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, bool, void> fn__setPedAlternateWalkAnim;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__clearPedAlternateWalkAnim;
		private delegate* unmanaged[Cdecl]<int, int, nint, nint, float, bool, void> fn__setPedAlternateMovementAnim;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__clearPedAlternateMovementAnim;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setPedGestureGroup;
		private delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, float, float, int, Vector3> fn__getAnimInitialOffsetPosition;
		private delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, float, float, int, Vector3> fn__getAnimInitialOffsetRotation;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedDrawableVariation;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getNumberOfPedDrawableVariations;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedTextureVariation;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__getNumberOfPedTextureVariations;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getNumberOfPedPropDrawableVariations;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__getNumberOfPedPropTextureVariations;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedPaletteVariation;
		private delegate* unmanaged[Cdecl]<int*, int*, bool> fn__0x9E30E91FB03A2CAF;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x1E77FA7A62EE6C4C;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xF033419D1B81FAE8;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool> fn__isPedComponentVariationValid;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setPedComponentVariation;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedRandomComponentVariation;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedRandomProps;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedDefaultComponentVariation;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, void> fn__setPedBlendFromParents;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, float, float, float, bool, void> fn__setPedHeadBlendData;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getPedHeadBlendData;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__updatePedHeadBlendData;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedEyeColor;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedEyeColor;
		private delegate* unmanaged[Cdecl]<int, int, int, float, void> fn__setPedHeadOverlay;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedHeadOverlayValue;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedHeadOverlayNum;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setPedHeadOverlayColor;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setPedHairColor;
		private delegate* unmanaged[Cdecl]<int> fn__getNumHairColors;
		private delegate* unmanaged[Cdecl]<int> fn__getNumMakeupColors;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getPedHairRgbColor;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getPedMakeupRgbColor;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedHairColorValid2;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xEA9960D07DADCF10;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedLipstickColorValid2;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedBlushColorValid2;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedHairColorValid;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xAAA6A3698A69E048;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedLipstickColorValid;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedBlushColorValid;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedBodyBlemishValid;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__0xC56FBF2F228E1DAC;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__setPedFaceFeature;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasPedHeadBlendFinished;
		private delegate* unmanaged[Cdecl]<int, void> fn__finalizeHeadBlend;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__setHeadBlendPaletteColor;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableHeadBlendPaletteColor;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedHeadBlendFirstIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedHeadBlendNumHeads;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__setPedPreloadVariationData;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasPedPreloadVariationDataFinished;
		private delegate* unmanaged[Cdecl]<int, void> fn__releasePedPreloadVariationData;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool> fn__setPedPreloadPropData;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasPedPreloadPropDataFinished;
		private delegate* unmanaged[Cdecl]<int, void> fn__releasePedPreloadPropData;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedPropIndex;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, void> fn__setPedPropIndex;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, void> fn__knockOffPedProp;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__clearPedProp;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearAllPedProps;
		private delegate* unmanaged[Cdecl]<int, void> fn__dropAmbientProp;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedPropTextureIndex;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedParachutePackVariation;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedScubaGearVariation;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedScubaGearVariation;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xFEC9A3B1820F3331;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBlockingOfNonTemporaryEvents;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, void> fn__setPedBoundsOrientation;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__registerTarget;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__registerHatedTargetsAroundPed;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int> fn__getRandomPedAtCoord;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, int*, bool, bool, int, bool> fn__getClosestPed;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setScenarioPedsToBeReturnedByNextCommand;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, bool, bool, bool, int, bool> fn__0x03EA03AF85A85CB7;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setDriverRacingModifier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setDriverAbility;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setDriverAggressiveness;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canPedRagdoll;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool, bool, bool> fn__setPedToRagdoll;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, float, float, float, float, float, float, float, bool> fn__setPedToRagdollWithFall;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedRagdollOnCollision;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedRagdoll;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedRunningRagdollTask;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedRagdollForceFall;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPedRagdollTimer;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanRagdoll;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedRunningMeleeTask;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedRunningMobilePhoneTask;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMobilePhoneToPedEar;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setRagdollBlockingFlags;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__clearRagdollBlockingFlags;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, bool, void> fn__setPedAngledDefensiveArea;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool, bool, void> fn__setPedSphereDefensiveArea;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool, void> fn__setPedDefensiveSphereAttachedToPed;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool, void> fn__setPedDefensiveSphereAttachedToVehicle;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, float, bool, bool, void> fn__setPedDefensiveAreaAttachedToPed;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, void> fn__setPedDefensiveAreaDirection;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removePedDefensiveArea;
		private delegate* unmanaged[Cdecl]<int, bool, Vector3> fn__getPedDefensiveAreaPosition;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isPedDefensiveAreaActive;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedPreferredCoverSet;
		private delegate* unmanaged[Cdecl]<int, void> fn__removePedPreferredCoverSet;
		private delegate* unmanaged[Cdecl]<int, void> fn__reviveInjuredPed;
		private delegate* unmanaged[Cdecl]<int, void> fn__resurrectPed;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setPedNameDebug;
		private delegate* unmanaged[Cdecl]<int, bool, Vector3> fn__getPedExtractedDisplacement;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedDiesWhenInjured;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedEnableWeaponBlocking;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xF9ACF4A08098EA25;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPedVisibleDamage;
		private delegate* unmanaged[Cdecl]<int, int, float, float, int, void> fn__applyPedBloodDamageByZone;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, nint, void> fn__applyPedBlood;
		private delegate* unmanaged[Cdecl]<int, int, float, float, nint, void> fn__applyPedBloodByZone;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, nint, void> fn__applyPedBloodSpecific;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, int, bool, nint, void> fn__applyPedDamageDecal;
		private delegate* unmanaged[Cdecl]<int, nint, float, float, void> fn__applyPedDamagePack;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedBloodDamage;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__clearPedBloodDamageByZone;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__hidePedBloodDamageByZone;
		private delegate* unmanaged[Cdecl]<int, int, nint, void> fn__clearPedDamageDecalByZone;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedDecorationsState;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x2B694AFCF64E6994;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedWetness;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedWetnessHeight;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedWetnessEnabledThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedEnvDirt;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedSweat;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__addPedDecorationFromHashes;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__addPedDecorationFromHashesInCorona;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedDecorationZoneFromHashes;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedDecorations;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedDecorationsLeaveScars;
		private delegate* unmanaged[Cdecl]<int, bool> fn__wasPedSkeletonUpdated;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, Vector3> fn__getPedBoneCoords;
		private delegate* unmanaged[Cdecl]<bool, int, void> fn__createNmMessage;
		private delegate* unmanaged[Cdecl]<int, void> fn__givePedNmMessage;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool, bool, int> fn__addScenarioBlockingArea;
		private delegate* unmanaged[Cdecl]<void> fn__removeScenarioBlockingAreas;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removeScenarioBlockingArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, void> fn__setScenarioPedsSpawnInSphereArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool> fn__doesScenarioBlockingAreaExist;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__isPedUsingScenario;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedUsingAnyScenario;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__setPedPanicExitScenario;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x9A77DFD295E29B09;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__0x25361A96E0F7E419;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__setPedShouldPlayDirectedScenarioExit;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedShouldPlayNormalScenarioExit;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedShouldPlayImmediateScenarioExit;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__setPedShouldPlayFleeScenarioExit;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x425AECF167663F48;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x5B6010B3CBC29095;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xCEDA60A74219D064;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xC30BDAEE47256C13;
		private delegate* unmanaged[Cdecl]<int, nint, nint, void> fn__playFacialAnim;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setFacialClipsetOverride;
		private delegate* unmanaged[Cdecl]<int, nint, nint, void> fn__setFacialIdleAnimOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearFacialIdleAnimOverride;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanPlayGestureAnims;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setPedCanPlayVisemeAnims;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanPlayInjuredAnims;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanPlayAmbientAnims;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanPlayAmbientBaseAnims;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC2EE020F5FB4DB53;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanArmIk;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanHeadIk;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanLegIk;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanTorsoIk;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanTorsoReactIk;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x6647C5F6F5792496;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanUseAutoConversationLookat;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedHeadtrackingPed;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedHeadtrackingEntity;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedPrimaryLookat;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedClothPackageIndex;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedClothProne;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xA660FAF550EB37E5;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPedConfigFlag;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPedResetFlag;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__getPedConfigFlag;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__getPedResetFlag;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedGroupMemberPassengerIndex;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanEvasiveDive;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__isPedEvasiveDiving;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, void> fn__setPedShootsAtCoord;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedModelIsSuppressed;
		private delegate* unmanaged[Cdecl]<void> fn__stopAnyPedModelBeingSuppressed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanBeTargetedWhenInjured;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedGeneratesDeadBodyEvents;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__blockPedDeadBodyShockingEvents;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x3E9679C1DFCF422C;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanRagdollFromPlayerImpact;
		private delegate* unmanaged[Cdecl]<int, bool, int, int, void> fn__givePedHelmet;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removePedHelmet;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedTakingOffHelmet;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedHelmet;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedHelmetFlag;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPedHelmetPropIndex;
		private delegate* unmanaged[Cdecl]<int, bool, int, int, void> fn__setPedHelmetUnk;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedHelmetUnk;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedHelmetTextureIndex;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedWearingHelmet;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedStoredHatProp;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedHelmetStoredHatPropIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedHelmetStoredHatTexIndex;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xF2385935BFFD4D92;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedToLoadCover;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanCowerInCover;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanPeekInCover;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedPlaysHeadOnHornAnimWhenDiesInVehicle;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedLegIkMode;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedMotionBlur;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanSwitchWeapon;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedDiesInstantlyInWater;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x1A330D297AAC6BC1;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopPedWeaponFiringWhenDropped;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setScriptedAnimSeatOffset;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedCombatMovement;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedCombatMovement;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedCombatAbility;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedCombatRange;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedCombatRange;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPedCombatAttributes;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedTargetLossResponse;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedPerformingMeleeAction;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedPerformingStealthKill;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedPerformingDependentComboLimit;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedBeingStealthKilled;
		private delegate* unmanaged[Cdecl]<int, int> fn__getMeleeTargetForPed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__wasPedKilledByStealth;
		private delegate* unmanaged[Cdecl]<int, bool> fn__wasPedKilledByTakedown;
		private delegate* unmanaged[Cdecl]<int, bool> fn__wasPedKnockedOut;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPedFleeAttributes;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setPedCowerHash;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x2016C603D6B8987C;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedSteersAroundPeds;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedSteersAroundObjects;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedSteersAroundVehicles;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xA9B61A329BFDCBEA;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedIncreasedAvoidanceRadius;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedBlocksPathingWhenDead;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xA52D5247A4227E14;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool> fn__isAnyPedNearPoint;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__forcePedAiAndAnimationUpdate;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool> fn__isPedHeadingTowardsPosition;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestPedVisibilityTracking;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__requestPedVehicleVisibilityTracking;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xCD018C591F94CB43;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x75BA1CB3B7D40CAF;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isTrackedPedVisible;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x511F1A683387C7E2;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedTracked;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__hasPedReceivedEvent;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__canPedSeeHatedPed;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__0x9C6A6C19B6C0C496;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__0x2DFC81C9B9608549;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedBoneIndex;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedRagdollBoneIndex;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedEnveffScale;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPedEnveffScale;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEnablePedEnveffScale;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x110F526AB784111F;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setPedEnveffColorModulator;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedEmissiveIntensity;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPedEmissiveIntensity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedShaderEffectValid;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xE906EC930F5FE7C8;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x1216E0BFA72CC703;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedAoBlobRendering;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xB8B52E498014F5B0;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int> fn__createSynchronizedScene;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int> fn__createSynchronizedScene2;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isSynchronizedSceneRunning;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, void> fn__setSynchronizedSceneOrigin;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setSynchronizedScenePhase;
		private delegate* unmanaged[Cdecl]<int, float> fn__getSynchronizedScenePhase;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setSynchronizedSceneRate;
		private delegate* unmanaged[Cdecl]<int, float> fn__getSynchronizedSceneRate;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setSynchronizedSceneLooped;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isSynchronizedSceneLooped;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setSynchronizedSceneHoldLastFrame;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isSynchronizedSceneHoldLastFrame;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__attachSynchronizedSceneToEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__detachSynchronizedScene;
		private delegate* unmanaged[Cdecl]<int, void> fn__disposeSynchronizedScene;
		private delegate* unmanaged[Cdecl]<int, int, bool, int, bool, bool> fn__forcePedMotionState;
		private delegate* unmanaged[Cdecl]<int, float*, float*, bool> fn__getPedCurrentMovementSpeed;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedMaxMoveBlendRatio;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedMinMoveBlendRatio;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedMoveRateOverride;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x0B3E35AC043707D9;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__0x46B05BCAE43856B0;
		private delegate* unmanaged[Cdecl]<int, int*, int> fn__getPedNearbyVehicles;
		private delegate* unmanaged[Cdecl]<int, int*, int, int> fn__getPedNearbyPeds;
		private delegate* unmanaged[Cdecl]<int, bool> fn__haveAllStreamingRequestsCompleted;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedUsingActionMode;
		private delegate* unmanaged[Cdecl]<int, bool, int, nint, void> fn__setPedUsingActionMode;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setMovementModeOverride;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedCapsule;
		private delegate* unmanaged[Cdecl]<int, int> fn__registerPedheadshot;
		private delegate* unmanaged[Cdecl]<int, int> fn__registerPedheadshot3;
		private delegate* unmanaged[Cdecl]<int, int> fn__registerPedheadshotTransparent;
		private delegate* unmanaged[Cdecl]<int, void> fn__unregisterPedheadshot;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedheadshotValid;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedheadshotReady;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getPedheadshotTxdString;
		private delegate* unmanaged[Cdecl]<int, bool> fn__requestPedheadshotImgUpload;
		private delegate* unmanaged[Cdecl]<int, void> fn__releasePedheadshotImgUpload;
		private delegate* unmanaged[Cdecl]<bool> fn__isPedheadshotImgUploadAvailable;
		private delegate* unmanaged[Cdecl]<bool> fn__hasPedheadshotImgUploadFailed;
		private delegate* unmanaged[Cdecl]<bool> fn__hasPedheadshotImgUploadSucceeded;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedHeatscaleOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__disablePedHeatscaleOverride;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, int, float, int, void> fn__spawnpointsStartSearch;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, float, int, void> fn__spawnpointsStartSearchInAngledArea;
		private delegate* unmanaged[Cdecl]<void> fn__spawnpointsCancelSearch;
		private delegate* unmanaged[Cdecl]<bool> fn__spawnpointsIsSearchActive;
		private delegate* unmanaged[Cdecl]<bool> fn__spawnpointsIsSearchComplete;
		private delegate* unmanaged[Cdecl]<bool> fn__spawnpointsIsSearchFailed;
		private delegate* unmanaged[Cdecl]<int> fn__spawnpointsGetNumSearchResults;
		private delegate* unmanaged[Cdecl]<int, float*, float*, float*, void> fn__spawnpointsGetSearchResult;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__spawnpointsGetSearchResultFlags;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, int, int, int, void> fn__setIkTarget;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xED3C76ADFA6D07C4;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestActionModeAsset;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasActionModeAssetLoaded;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeActionModeAsset;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestStealthModeAsset;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasStealthModeAssetLoaded;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeStealthModeAsset;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedLodMultiplier;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__setPedCanLosePropsOnDamage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setForceFootstepUpdate;
		private delegate* unmanaged[Cdecl]<int, bool, int, int, void> fn__setForceStepType;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool> fn__isAnyHostilePedNearPoint;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedCanPlayInCarIdles;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool> fn__isTargetPedInPerceptionArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, void> fn__setPopControlSphereThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xD33DAA36272177C4;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x711794453CFD692B;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x83A169EABCDB10A2;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x288DF530C92DAD6F;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedSwappingWeapon;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x0F62619393661D6E;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xDFE68C4B787E1BFB;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEnableScubaGearLight;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isScubaGearLightEnabled;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearFacialClipsetOverride;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xFAB944D4D481ACCB;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, float, float, float, bool, bool, bool, float, bool, int*, int> fn__addRope;
		private delegate* unmanaged[Cdecl]<int*, void> fn__deleteRope;
		private delegate* unmanaged[Cdecl]<int, void> fn__deleteChildRope;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__doesRopeExist;
		private delegate* unmanaged[Cdecl]<int*, bool, void> fn__0xA1AE736541B0FCA3;
		private delegate* unmanaged[Cdecl]<int*, bool, void> fn__ropeDrawShadowEnabled;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__loadRopeData;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, void> fn__pinRopeVertex;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__unpinRopeVertex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getRopeVertexCount;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, float, float, bool, bool, int*, int*, void> fn__attachEntitiesToRope;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void> fn__attachRopeToEntity;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__detachRopeFromEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__ropeSetUpdatePinverts;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__ropeSetUpdateOrder;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x36CCB9BE67B970FD;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__0x84DE3B5FB3E666F0;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getRopeLastVertexCoord;
		private delegate* unmanaged[Cdecl]<int, int, Vector3> fn__getRopeVertexCoord;
		private delegate* unmanaged[Cdecl]<int, void> fn__startRopeWinding;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopRopeWinding;
		private delegate* unmanaged[Cdecl]<int, void> fn__startRopeUnwindingFront;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopRopeUnwindingFront;
		private delegate* unmanaged[Cdecl]<int, void> fn__ropeConvertToSimple;
		private delegate* unmanaged[Cdecl]<void> fn__ropeLoadTextures;
		private delegate* unmanaged[Cdecl]<bool> fn__ropeAreTexturesLoaded;
		private delegate* unmanaged[Cdecl]<void> fn__ropeUnloadTextures;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesRopeBelongToThisScript;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, float, float, float, float, float, float, void> fn__0xBC0CE682D4D05650;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__0xB1B6216CA2E7B55E;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xB743F735C03D7810;
		private delegate* unmanaged[Cdecl]<int, float> fn__ropeGetDistanceBetweenEnds;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__ropeForceLength;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__ropeResetLength;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, void> fn__applyImpulseToCloth;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__setDamping;
		private delegate* unmanaged[Cdecl]<int, void> fn__activatePhysics;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setCgoffset;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getCgoffset;
		private delegate* unmanaged[Cdecl]<int, void> fn__setCgAtBoundcenter;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, int, bool, void> fn__breakEntityGlass;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getHasObjectFragInst;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisableBreaking;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xCC6E963682533882;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisableFragDamage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEntityProofUnk;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x9EBD751E5787BAF2;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setLaunchControlEnabled;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerPed;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerPedScriptIndex;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerModel;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__changePlayerPed;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getPlayerRgbColour;
		private delegate* unmanaged[Cdecl]<int> fn__getNumberOfPlayers;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerTeam;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerTeam;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumberOfPlayersInTeam;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getPlayerName;
		private delegate* unmanaged[Cdecl]<int, float> fn__getWantedLevelRadius;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getPlayerWantedCentrePosition;
		private delegate* unmanaged[Cdecl]<int, Vector3*, bool, bool, void> fn__setPlayerWantedCentrePosition;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWantedLevelThreshold;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPlayerWantedLevel;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPlayerWantedLevelNoDrop;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerWantedLevelNow;
		private delegate* unmanaged[Cdecl]<int, bool> fn__arePlayerFlashingStarsAboutToDrop;
		private delegate* unmanaged[Cdecl]<int, bool> fn__arePlayerStarsGreyedOut;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x7E07C78925D5FD96;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDispatchCopsForPlayer;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPlayerWantedLevelGreater;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPlayerWantedLevel;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerDead;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerPressingHorn;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__setPlayerControl;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerWantedLevel;
		private delegate* unmanaged[Cdecl]<int, void> fn__setMaxWantedLevel;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setPoliceRadarBlips;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPoliceIgnorePlayer;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerPlaying;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setEveryoneIgnorePlayer;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setAllRandomPedsFlee;
		private delegate* unmanaged[Cdecl]<int, void> fn__setAllRandomPedsFleeThisFrame;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xDE45D1A1EF45EE61;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC3376F42B1FACCC6;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xFAC75988A7D078D3;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setIgnoreLowPriorityShockingEvents;
		private delegate* unmanaged[Cdecl]<float, void> fn__setWantedLevelMultiplier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setWantedLevelDifficulty;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetWantedLevelDifficulty;
		private delegate* unmanaged[Cdecl]<int> fn__getWantedLevelParoleDuration;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setWantedLevelHiddenEvasionTime;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x823EC8E82BA45986;
		private delegate* unmanaged[Cdecl]<int, void> fn__startFiringAmnesty;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__reportCrime;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__switchCrimeType;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xBC9490CA15AEA8FB;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x4669B3ED80F24B4E;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x2F41A3BAE005E5FA;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xAD73CE5A09E42D12;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x36F1B38855F2A8DF;
		private delegate* unmanaged[Cdecl]<int, void> fn__reportPoliceSpottedPlayer;
		private delegate* unmanaged[Cdecl]<float, void> fn__0xB45EFF719D8427A6;
		private delegate* unmanaged[Cdecl]<void> fn__0x0032A6DBA562C518;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canPlayerStartMission;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerReadyForCutscene;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPlayerTargettingEntity;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getPlayerTargetEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerFreeAiming;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPlayerFreeAimingAtEntity;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getEntityPlayerIsFreeAimingAt;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerLockonRangeOverride;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerCanDoDriveBy;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerCanBeHassledByGangs;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerCanUseCover;
		private delegate* unmanaged[Cdecl]<int> fn__getMaxWantedLevel;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerTargettingAnything;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerSprint;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPlayerStamina;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__restorePlayerStamina;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPlayerSprintStaminaRemaining;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPlayerSprintTimeRemaining;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPlayerUnderwaterTimeRemaining;
		private delegate* unmanaged[Cdecl]<int, float, int> fn__setPlayerUnderwaterTimeRemaining;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerGroup;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerMaxArmour;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerControlOn;
		private delegate* unmanaged[Cdecl]<bool> fn__isPlayerCamControlDisabled;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerScriptControlOn;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerClimbing;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isPlayerBeingArrested;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPlayerArrestState;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayersLastVehicle;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayerIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__intToPlayerindex;
		private delegate* unmanaged[Cdecl]<int, int> fn__intToParticipantindex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getTimeSincePlayerHitVehicle;
		private delegate* unmanaged[Cdecl]<int, int> fn__getTimeSincePlayerHitPed;
		private delegate* unmanaged[Cdecl]<int, int> fn__getTimeSincePlayerDroveOnPavement;
		private delegate* unmanaged[Cdecl]<int, int> fn__getTimeSincePlayerDroveAgainstTraffic;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerFreeForAmbientTask;
		private delegate* unmanaged[Cdecl]<int> fn__playerId;
		private delegate* unmanaged[Cdecl]<int> fn__playerPedId;
		private delegate* unmanaged[Cdecl]<int> fn__networkPlayerIdToInt;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasForceCleanupOccurred;
		private delegate* unmanaged[Cdecl]<int, void> fn__forceCleanup;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__forceCleanupForAllThreadsWithThisName;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__forceCleanupForThreadWithThisId;
		private delegate* unmanaged[Cdecl]<int> fn__getCauseOfMostRecentForceCleanup;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerMayOnlyEnterThisVehicle;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPlayerMayNotEnterAnyVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__giveAchievementToPlayer;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__setAchievementProgress;
		private delegate* unmanaged[Cdecl]<int, int> fn__getAchievementProgress;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasAchievementBeenPassed;
		private delegate* unmanaged[Cdecl]<bool> fn__isPlayerOnline;
		private delegate* unmanaged[Cdecl]<bool> fn__isPlayerLoggingInNp;
		private delegate* unmanaged[Cdecl]<bool, void> fn__displaySystemSigninUi;
		private delegate* unmanaged[Cdecl]<bool> fn__isSystemUiBeingDisplayed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerInvincible;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getPlayerInvincible;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xDCC07526B8EC45AF;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerInvincibleKeepRagdollEnabled;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xCAC57395B151135F;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removePlayerHelmet;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__givePlayerRagdollControl;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerLockon;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPlayerTargetingMode;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPlayerTargetLevel;
		private delegate* unmanaged[Cdecl]<bool> fn__0xB9CF1F793A9F1BF1;
		private delegate* unmanaged[Cdecl]<bool> fn__0xCB645E85E97EA48B;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPlayerHasDamagedAtLeastOnePed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasPlayerDamagedAtLeastOnePed;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPlayerHasDamagedAtLeastOneNonAnimalPed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasPlayerDamagedAtLeastOneNonAnimalPed;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setAirDragMultiplierForPlayersVehicle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setSwimMultiplierForPlayer;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setRunSprintMultiplierForPlayer;
		private delegate* unmanaged[Cdecl]<int> fn__getTimeSinceLastArrest;
		private delegate* unmanaged[Cdecl]<int> fn__getTimeSinceLastDeath;
		private delegate* unmanaged[Cdecl]<void> fn__assistedMovementCloseRoute;
		private delegate* unmanaged[Cdecl]<void> fn__assistedMovementFlushRoute;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerForcedAim;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerForcedZoom;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerForceSkipAimIntro;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__disablePlayerFiring;
		private delegate* unmanaged[Cdecl]<void> fn__0xB885852C39CC265D;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisableAmbientMeleeMove;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerMaxArmour;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__specialAbilityActivate;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setSpecialAbility;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__specialAbilityDeplete;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__specialAbilityDeactivate;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__specialAbilityDeactivateFast;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__specialAbilityReset;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__specialAbilityChargeOnMissionFailed;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, void> fn__specialAbilityChargeSmall;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, void> fn__specialAbilityChargeMedium;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, void> fn__specialAbilityChargeLarge;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__specialAbilityChargeContinuous;
		private delegate* unmanaged[Cdecl]<int, int, bool, int, void> fn__specialAbilityChargeAbsolute;
		private delegate* unmanaged[Cdecl]<int, float, bool, int, void> fn__specialAbilityChargeNormalized;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__specialAbilityFillMeter;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__specialAbilityDepleteMeter;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__specialAbilityLock;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__specialAbilityUnlock;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isSpecialAbilityUnlocked;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isSpecialAbilityActive;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isSpecialAbilityMeterFull;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__enableSpecialAbility;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isSpecialAbilityEnabled;
		private delegate* unmanaged[Cdecl]<float, void> fn__setSpecialAbilityMultiplier;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xFFEE8FA29AB9A18E;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x5FC472C501CCADB3;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__0xF10B44FD479D69F3;
		private delegate* unmanaged[Cdecl]<int, float, bool> fn__0xDD2620B7B9D16FF1;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool, bool, bool, void> fn__startPlayerTeleport;
		private delegate* unmanaged[Cdecl]<int, bool> fn__updatePlayerTeleport;
		private delegate* unmanaged[Cdecl]<void> fn__stopPlayerTeleport;
		private delegate* unmanaged[Cdecl]<bool> fn__isPlayerTeleportActive;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPlayerCurrentStealthNoise;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerHealthRechargeMultiplier;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPlayerHealthRechargeLimit;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerHealthRechargeLimit;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerFallDistance;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerWeaponDamageModifier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerWeaponDefenseModifier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerWeaponDefenseModifier2;
		private delegate* unmanaged[Cdecl]<int, float, bool, void> fn__setPlayerMeleeWeaponDamageModifier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerMeleeWeaponDefenseModifier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerVehicleDamageModifier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerVehicleDefenseModifier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x8D768602ADEF2245;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xD821056B9ACF8052;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x31E90B8873A4CD3B;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerParachuteTintIndex;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getPlayerParachuteTintIndex;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerReserveParachuteTintIndex;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getPlayerReserveParachuteTintIndex;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerParachutePackTintIndex;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getPlayerParachutePackTintIndex;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPlayerHasReserveParachute;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getPlayerHasReserveParachute;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerCanLeaveParachuteSmokeTrail;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setPlayerParachuteSmokeTrailColor;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getPlayerParachuteSmokeTrailColor;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerResetFlagPreferRearSeats;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerNoiseMultiplier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerSneakingNoiseMultiplier;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__canPedHearPlayer;
		private delegate* unmanaged[Cdecl]<int, float, int, float, bool, bool, void> fn__simulatePlayerInputGait;
		private delegate* unmanaged[Cdecl]<int, void> fn__resetPlayerInputGait;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setAutoGiveParachuteWhenEnterPlane;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setAutoGiveScubaGearWhenExitVehicle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlayerStealthPerceptionModifier;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x690A61A6D13583F6;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x9EDD76E87D5D51BA;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerSimulateAiming;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerClothPinFrames;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPlayerClothPackageIndex;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPlayerClothLockCounter;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, void> fn__playerAttachVirtualBound;
		private delegate* unmanaged[Cdecl]<void> fn__playerDetachVirtualBound;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasPlayerBeenSpottedInStolenVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerBattleAware;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__0xBC0753C9CA14B506;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__extendWorldBoundaryForPlayer;
		private delegate* unmanaged[Cdecl]<void> fn__resetWorldBoundaryForPlayer;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerRidingTrain;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasPlayerLeftTheWorld;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerLeavePedBehind;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, void> fn__setPlayerParachuteVariationOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPlayerParachuteVariationOverride;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerParachuteModelOverride;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerReserveParachuteModelOverride;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerParachuteModelOverride;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerReserveParachuteModelOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPlayerParachuteModelOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPlayerReserveParachuteModelOverride;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerParachutePackModelOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPlayerParachutePackModelOverride;
		private delegate* unmanaged[Cdecl]<int, void> fn__disablePlayerVehicleRewards;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x2F7CEB6520288061;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPlayerBluetoothState;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayerBluetoothEnable;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x5501B7A5CDB79D37;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPlayerFakeWantedLevel;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x55FCC0C390620314;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x2382AB11450AE7BA;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x6E4361FF3E8CD7CA;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x237440E46D918649;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlayerHomingRocketDisabled;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x9097EB6D4BB9A12A;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x9F260BFB59ADBCA3;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__0x7BAE68775557AE0B;
		private delegate* unmanaged[Cdecl]<void> fn__0x7148E0F43D11F0D9;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__0x70A382ADEC069DD3;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x48621C9FCA3EBD28;
		private delegate* unmanaged[Cdecl]<void> fn__0x81CBAE94390F9F89;
		private delegate* unmanaged[Cdecl]<void> fn__0x13B350B8AD0EEE10;
		private delegate* unmanaged[Cdecl]<float, float, int, void> fn__0x293220DA1B46CEBC;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__0x208784099002BC30;
		private delegate* unmanaged[Cdecl]<void> fn__stopRecordingThisFrame;
		private delegate* unmanaged[Cdecl]<void> fn__0xF854439EFBB3B583;
		private delegate* unmanaged[Cdecl]<void> fn__disableRockstarEditorCameraChanges;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x66972397E0757E7A;
		private delegate* unmanaged[Cdecl]<int, void> fn__startRecording;
		private delegate* unmanaged[Cdecl]<void> fn__stopRecordingAndSaveClip;
		private delegate* unmanaged[Cdecl]<void> fn__stopRecordingAndDiscardClip;
		private delegate* unmanaged[Cdecl]<bool> fn__saveRecordingClip;
		private delegate* unmanaged[Cdecl]<bool> fn__isRecording;
		private delegate* unmanaged[Cdecl]<int> fn__0xDF4B952F7D381B95;
		private delegate* unmanaged[Cdecl]<int> fn__0x4282E08174868BE3;
		private delegate* unmanaged[Cdecl]<bool, bool> fn__0x33D47E85B476ABCD;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__0x7E2BD3EF6C205F09;
		private delegate* unmanaged[Cdecl]<bool> fn__isInteriorRenderingDisabled;
		private delegate* unmanaged[Cdecl]<void> fn__0x5AD3932DAEB1E5D3;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0xE058175F8EAFE79A;
		private delegate* unmanaged[Cdecl]<void> fn__resetEditorValues;
		private delegate* unmanaged[Cdecl]<int, void> fn__activateRockstarEditor;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestScript;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setScriptAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasScriptLoaded;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__doesScriptExist;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestScriptWithNameHash;
		private delegate* unmanaged[Cdecl]<int, void> fn__setScriptWithNameHashAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasScriptWithNameHashLoaded;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesScriptWithNameHashExist;
		private delegate* unmanaged[Cdecl]<int, void> fn__terminateThread;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThreadActive;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getNameOfThread;
		private delegate* unmanaged[Cdecl]<void> fn__scriptThreadIteratorReset;
		private delegate* unmanaged[Cdecl]<int> fn__scriptThreadIteratorGetNextThreadId;
		private delegate* unmanaged[Cdecl]<int> fn__getIdOfThisThread;
		private delegate* unmanaged[Cdecl]<void> fn__terminateThisThread;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumberOfReferencesOfScriptWithNameHash;
		private delegate* unmanaged[Cdecl]<nint> fn__getThisScriptName;
		private delegate* unmanaged[Cdecl]<int> fn__getHashOfThisScriptName;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumberOfEvents;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__getEventExists;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getEventAtIndex;
		private delegate* unmanaged[Cdecl]<int, int, int*, int, bool> fn__getEventData;
		private delegate* unmanaged[Cdecl]<int, int*, int, int, void> fn__triggerScriptEvent;
		private delegate* unmanaged[Cdecl]<void> fn__shutdownLoadingScreen;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setNoLoadingScreen;
		private delegate* unmanaged[Cdecl]<bool> fn__getNoLoadingScreen;
		private delegate* unmanaged[Cdecl]<void> fn__0xB1577667C3708F9B;
		private delegate* unmanaged[Cdecl]<bool> fn__0x836B62713E0534CA;
		private delegate* unmanaged[Cdecl]<void> fn__0x760910B49D2B98EA;
		private delegate* unmanaged[Cdecl]<int, void> fn__bgStartContextHash;
		private delegate* unmanaged[Cdecl]<int, void> fn__bgEndContextHash;
		private delegate* unmanaged[Cdecl]<nint, void> fn__bgStartContext;
		private delegate* unmanaged[Cdecl]<nint, void> fn__bgEndContext;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__0x0F6F1EBBC4E1D5E6;
		private delegate* unmanaged[Cdecl]<int, nint, int> fn__0x22E21FBCFC88C149;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x829CD22E043A2577;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int> fn__startShapeTestLosProbe;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int> fn__startExpensiveSynchronousShapeTestLosProbe;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__startShapeTestBoundingBox;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, int, int, int, int, int> fn__startShapeTestBox;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__startShapeTestBound;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, int, int, int> fn__startShapeTestCapsule;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, int, int, int> fn__startShapeTestSweptSphere;
		private delegate* unmanaged[Cdecl]<Vector3*, Vector3*, int, int, int, int> fn__startShapeTestSurroundingCoords;
		private delegate* unmanaged[Cdecl]<int, bool*, Vector3*, Vector3*, int*, int> fn__getShapeTestResult;
		private delegate* unmanaged[Cdecl]<int, bool*, Vector3*, Vector3*, int*, int*, int> fn__getShapeTestResultIncludingMaterial;
		private delegate* unmanaged[Cdecl]<int, void> fn__releaseScriptGuidFromEntity;
		private delegate* unmanaged[Cdecl]<int> fn__scInboxGetTotalNumMessages;
		private delegate* unmanaged[Cdecl]<int, int> fn__scInboxGetMessageTypeAtIndex;
		private delegate* unmanaged[Cdecl]<int, bool> fn__scInboxGetMessageIsReadAtIndex;
		private delegate* unmanaged[Cdecl]<int, bool> fn__scInboxMessagePop;
		private delegate* unmanaged[Cdecl]<int, nint, int*, bool> fn__scInboxMessageGetDataInt;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__scInboxMessageGetDataBool;
		private delegate* unmanaged[Cdecl]<int, nint, nint*, bool> fn__scInboxMessageGetDataString;
		private delegate* unmanaged[Cdecl]<int, bool> fn__scInboxMessageDoApply;
		private delegate* unmanaged[Cdecl]<int, nint> fn__scInboxMessageGetString;
		private delegate* unmanaged[Cdecl]<int*, void> fn__scInboxMessagePushGamerToEventRecipList;
		private delegate* unmanaged[Cdecl]<int*, void> fn__scInboxMessageSendUgcStatUpdateEvent;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__scInboxMessageGetUgcdata;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__scInboxMessageSendBountyPresenceEvent;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__scInboxMessageGetBountyData;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__scInboxGetEmails;
		private delegate* unmanaged[Cdecl]<int> fn__0x16DA8172459434AA;
		private delegate* unmanaged[Cdecl]<int> fn__0x7DB18CA8CAD5B098;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__0x4737980E8A283806;
		private delegate* unmanaged[Cdecl]<int*, int, void> fn__0x44ACA259D67651DB;
		private delegate* unmanaged[Cdecl]<int*, void> fn__scEmailMessagePushGamerToRecipList;
		private delegate* unmanaged[Cdecl]<void> fn__scEmailMessageClearRecipList;
		private delegate* unmanaged[Cdecl]<nint, void> fn__0x116FB94DC4B79F17;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x07DBD622D9533857;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setHandleRockstarMessageViaScript;
		private delegate* unmanaged[Cdecl]<bool> fn__isRockstarMessageReadyForScript;
		private delegate* unmanaged[Cdecl]<nint> fn__rockstarMessageGetString;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__scPresenceAttrSetInt;
		private delegate* unmanaged[Cdecl]<int, float, bool> fn__scPresenceAttrSetFloat;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__scPresenceAttrSetString;
		private delegate* unmanaged[Cdecl]<int, float, bool> fn__0x487912FD248EFDDF;
		private delegate* unmanaged[Cdecl]<int> fn__0xC85A7127E7AD02AA;
		private delegate* unmanaged[Cdecl]<int> fn__0xA770C8EEC6FB2AC5;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__scGetIsProfileAttributeSet;
		private delegate* unmanaged[Cdecl]<int> fn__0x7FFCBFEE44ECFABF;
		private delegate* unmanaged[Cdecl]<int> fn__0x2D874D4AE612A65F;
		private delegate* unmanaged[Cdecl]<nint, int*, bool> fn__scProfanityCheckString;
		private delegate* unmanaged[Cdecl]<nint, int*, bool> fn__scProfanityCheckUgcString;
		private delegate* unmanaged[Cdecl]<int, bool> fn__scProfanityGetCheckIsValid;
		private delegate* unmanaged[Cdecl]<int, bool> fn__scProfanityGetCheckIsPending;
		private delegate* unmanaged[Cdecl]<int, bool> fn__scProfanityGetStringPassed;
		private delegate* unmanaged[Cdecl]<int, int> fn__scProfanityGetStringStatus;
		private delegate* unmanaged[Cdecl]<nint, int*, bool> fn__0xF6BAAAF762E1BF40;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xF22CA0FD74B80E7A;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x9237E334F6E43156;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x700569DBA175A77C;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x1D4446A62D35B0D0;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x2E89990DDFF670C3;
		private delegate* unmanaged[Cdecl]<nint, nint, int*, bool> fn__0xD0EE05FE193646EA;
		private delegate* unmanaged[Cdecl]<nint, int*, int*, bool> fn__0x1989C6E6F67E76A8;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x07C61676E5BB52CD;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x8147FFF6A718E1AD;
		private delegate* unmanaged[Cdecl]<nint, int*, bool> fn__0x0F73393BAC7E6730;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xD302E99EDF0449CF;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x5C4EBFFA98BDB41C;
		private delegate* unmanaged[Cdecl]<bool> fn__0xFF8F3A92B75ED67A;
		private delegate* unmanaged[Cdecl]<int> fn__0x4ED9C8D6DA297639;
		private delegate* unmanaged[Cdecl]<nint, int*, bool> fn__0x710BCDA8071EDED1;
		private delegate* unmanaged[Cdecl]<nint, float*, bool> fn__0x50A8A36201DBF83E;
		private delegate* unmanaged[Cdecl]<nint, nint*, bool> fn__0x9DE5D2F723575ED0;
		private delegate* unmanaged[Cdecl]<nint*, bool> fn__0xC2C97EA97711D1AE;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__0x450819D8CF90C416;
		private delegate* unmanaged[Cdecl]<nint, int> fn__0x4A7D6E727F941747;
		private delegate* unmanaged[Cdecl]<nint, int*, nint, bool> fn__0xE75A4A2E5E316D86;
		private delegate* unmanaged[Cdecl]<nint, float*, nint, bool> fn__0x2570E26BE63964E3;
		private delegate* unmanaged[Cdecl]<nint, nint*, nint, bool> fn__0x1D12A56FC95BE92E;
		private delegate* unmanaged[Cdecl]<nint*, nint, bool> fn__0x33DF47CC0642061B;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xA468E0BE12B12C70;
		private delegate* unmanaged[Cdecl]<int, nint, int*, bool> fn__0x8CC469AB4D349B7C;
		private delegate* unmanaged[Cdecl]<int, nint, float*, bool> fn__0xC5A35C73B68F3C49;
		private delegate* unmanaged[Cdecl]<int, nint, nint*, bool> fn__0x699E4A5C8C893A18;
		private delegate* unmanaged[Cdecl]<int, nint*, bool> fn__0x19853B5B17D77BCA;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x6BFB12CE158E3DD4;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__0xFE4C1D0D3B9CC17E;
		private delegate* unmanaged[Cdecl]<int> fn__0xD8122C407663B995;
		private delegate* unmanaged[Cdecl]<bool> fn__0x3001BEF2FECA3680;
		private delegate* unmanaged[Cdecl]<nint, int*, bool> fn__0x92DA6E70EF249BD1;
		private delegate* unmanaged[Cdecl]<void> fn__0x675721C9F644D161;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xE4F6E8D07A2F0F51;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x8A4416C0DB05FA66;
		private delegate* unmanaged[Cdecl]<void> fn__0xEA95C0853A27888E;
		private delegate* unmanaged[Cdecl]<nint> fn__scGetNickname;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__0x225798743970412B;
		private delegate* unmanaged[Cdecl]<int, bool> fn__scGetHasAchievementBeenPassed;
		private delegate* unmanaged[Cdecl]<int, int> fn__statClearSlotForReload;
		private delegate* unmanaged[Cdecl]<int, bool> fn__statLoad;
		private delegate* unmanaged[Cdecl]<int, bool, int, int, bool> fn__statSave;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x5688585E6D563CD8;
		private delegate* unmanaged[Cdecl]<int, bool> fn__statLoadPending;
		private delegate* unmanaged[Cdecl]<bool> fn__statSavePending;
		private delegate* unmanaged[Cdecl]<bool> fn__statSavePendingOrRequested;
		private delegate* unmanaged[Cdecl]<int, int> fn__statDeleteSlot;
		private delegate* unmanaged[Cdecl]<int, bool> fn__statSlotIsLoaded;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x7F2C4CDF2E82DF4C;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xE496A53BA5F50A56;
		private delegate* unmanaged[Cdecl]<bool, void> fn__statSetBlockSaves;
		private delegate* unmanaged[Cdecl]<bool> fn__0x6A7F19756F1A9016;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x7E6946F68A38B74F;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xA8733668D1047B51;
		private delegate* unmanaged[Cdecl]<bool> fn__0xECB41AC6AB754401;
		private delegate* unmanaged[Cdecl]<void> fn__0x9B4BD21D69B1E609;
		private delegate* unmanaged[Cdecl]<int> fn__0xC0E0D686DDFC6EAE;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__statSetInt;
		private delegate* unmanaged[Cdecl]<int, float, bool, bool> fn__statSetFloat;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool> fn__statSetBool;
		private delegate* unmanaged[Cdecl]<int, nint, bool, bool> fn__statSetGxtLabel;
		private delegate* unmanaged[Cdecl]<int, int*, int, bool, bool> fn__statSetDate;
		private delegate* unmanaged[Cdecl]<int, nint, bool, bool> fn__statSetString;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool> fn__statSetPos;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool> fn__statSetMaskedInt;
		private delegate* unmanaged[Cdecl]<int, nint, bool, bool> fn__statSetUserId;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__statSetCurrentPosixTime;
		private delegate* unmanaged[Cdecl]<int, int*, int, bool> fn__statGetInt;
		private delegate* unmanaged[Cdecl]<int, float*, int, bool> fn__statGetFloat;
		private delegate* unmanaged[Cdecl]<int, bool*, int, bool> fn__statGetBool;
		private delegate* unmanaged[Cdecl]<int, int*, int, int, bool> fn__statGetDate;
		private delegate* unmanaged[Cdecl]<int, int, nint> fn__statGetString;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, int, bool> fn__statGetPos;
		private delegate* unmanaged[Cdecl]<int, int*, int, int, int, bool> fn__statGetMaskedInt;
		private delegate* unmanaged[Cdecl]<int, nint> fn__statGetUserId;
		private delegate* unmanaged[Cdecl]<int, nint> fn__statGetLicensePlate;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__statSetLicensePlate;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__statIncrement;
		private delegate* unmanaged[Cdecl]<bool> fn__0x5A556B229A169402;
		private delegate* unmanaged[Cdecl]<bool> fn__0xB1D2BB1E1631F5B1;
		private delegate* unmanaged[Cdecl]<int, int, float*, bool> fn__0xBED9F5693F34ED17;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x26D7399B9587FE89;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xA78B8FA58200DA56;
		private delegate* unmanaged[Cdecl]<int, int> fn__statGetNumberOfDays;
		private delegate* unmanaged[Cdecl]<int, int> fn__statGetNumberOfHours;
		private delegate* unmanaged[Cdecl]<int, int> fn__statGetNumberOfMinutes;
		private delegate* unmanaged[Cdecl]<int, int> fn__statGetNumberOfSeconds;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__statSetProfileSettingValue;
		private delegate* unmanaged[Cdecl]<void> fn__0xC01D2470F22CDE5A;
		private delegate* unmanaged[Cdecl]<int, int> fn__statGetPackedBoolMask;
		private delegate* unmanaged[Cdecl]<int, int> fn__statGetPackedIntMask;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, int> fn__getPackedBoolStatKey;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, int> fn__getPackedIntStatKey;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, int> fn__getPackedTuBoolStatKey;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, int> fn__getPackedTuIntStatKey;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, nint, int> fn__getNgstatBoolHash;
		private delegate* unmanaged[Cdecl]<int, bool, bool, int, nint, int> fn__getNgstatIntHash;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__statGetBoolMasked;
		private delegate* unmanaged[Cdecl]<int, bool, int, bool, bool> fn__statSetBoolMasked;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__playstatsBackgroundScriptAction;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsNpcInvite;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__playstatsAwardXp;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsRankUp;
		private delegate* unmanaged[Cdecl]<void> fn__playstatsStartOfflineMode;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__playstatsActivityDone;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__playstatsLeaveJobChain;
		private delegate* unmanaged[Cdecl]<int*, int, int, bool, void> fn__playstatsMissionStarted;
		private delegate* unmanaged[Cdecl]<int*, int, int, bool, bool, bool, void> fn__playstatsMissionOver;
		private delegate* unmanaged[Cdecl]<int*, int, int, int, void> fn__playstatsMissionCheckpoint;
		private delegate* unmanaged[Cdecl]<nint, int, int, int, void> fn__playstatsRandomMissionDone;
		private delegate* unmanaged[Cdecl]<int, int, int, float, void> fn__playstatsRosBet;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__playstatsRaceCheckpoint;
		private delegate* unmanaged[Cdecl]<int*, int*, bool> fn__0x6DEE77AFF8C21BD1;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__playstatsMatchStarted;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__playstatsShopItem;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, void> fn__playstatsCrateDropMissionDone;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__playstatsCrateCreatedMissionDone;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__playstatsHoldUpMissionDone;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__playstatsImportExportMissionDone;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__playstatsRaceToPointMissionDone;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsAcquiredHiddenPackage;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__playstatsWebsiteVisited;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__playstatsFriendActivity;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__playstatsOddjobDone;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__playstatsPropChange;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__playstatsClothChange;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__playstatsWeaponModeChange;
		private delegate* unmanaged[Cdecl]<nint, void> fn__playstatsCheatApplied;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void> fn__0xF8C54A461C3E11DC;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void> fn__0xF5BB8DAC426A52C0;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void> fn__0xA736CF7FB7C5BFF4;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void> fn__0x14E0B2D1AD1044E0;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__playstatsQuickfixTool;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsIdleKick;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xD1032E482629049E;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__playstatsHeistSaveCheat;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsDirectorMode;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsAwardBadsport;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsPegasaircraft;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x6A60E43998228229;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xBFAFDB5FAAA5C5AB;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x8C9D11605E59D955;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x3DE3AA516FB126A4;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xBAA2F0490E146BE8;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x1A7CE7CD3E653485;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x419615486BBF1956;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x84DFC579C2FC214C;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x0A9C7F36E5D7B683;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x164C5FF663790845;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xEDBF6C9B0D2C65C8;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x6551B1F7F6CD46EA;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x2CD90358F67D0AA8;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsPiMenuHideSettings;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__leaderboardsGetNumberOfColumns;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__leaderboardsGetColumnId;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__leaderboardsGetColumnType;
		private delegate* unmanaged[Cdecl]<int> fn__leaderboardsReadClearAll;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__leaderboardsReadClear;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__leaderboardsReadPending;
		private delegate* unmanaged[Cdecl]<bool> fn__leaderboardsReadAnyPending;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__leaderboardsReadSuccessful;
		private delegate* unmanaged[Cdecl]<int*, int*, int, bool, int, int, bool> fn__leaderboards2ReadFriendsByRow;
		private delegate* unmanaged[Cdecl]<int*, int*, bool> fn__leaderboards2ReadByHandle;
		private delegate* unmanaged[Cdecl]<int*, int*, int, int*, int, int*, int, bool> fn__leaderboards2ReadByRow;
		private delegate* unmanaged[Cdecl]<int*, int, int, bool> fn__leaderboards2ReadByRank;
		private delegate* unmanaged[Cdecl]<int*, int, int*, bool> fn__leaderboards2ReadByRadius;
		private delegate* unmanaged[Cdecl]<int*, int, int, bool> fn__leaderboards2ReadByScoreInt;
		private delegate* unmanaged[Cdecl]<int*, float, int, bool> fn__leaderboards2ReadByScoreFloat;
		private delegate* unmanaged[Cdecl]<int*, int*, int*, bool> fn__leaderboards2ReadRankPrediction;
		private delegate* unmanaged[Cdecl]<int*, nint, nint, bool> fn__leaderboards2ReadByPlatform;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__0xA0F93D5465B3094D;
		private delegate* unmanaged[Cdecl]<void> fn__0x71B008056E5692D6;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__0x34770B9CE0E03B91;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x88578F6EC36B4A3A;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__0x38491439B6BA7F7D;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__leaderboards2WriteData;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__leaderboardsWriteAddColumn;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__leaderboardsWriteAddColumnLong;
		private delegate* unmanaged[Cdecl]<int*, bool> fn__leaderboardsCacheDataRow;
		private delegate* unmanaged[Cdecl]<void> fn__leaderboardsClearCacheData;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x8EC74CEB042E7CFF;
		private delegate* unmanaged[Cdecl]<int, bool> fn__leaderboardsGetCacheExists;
		private delegate* unmanaged[Cdecl]<int, int> fn__leaderboardsGetCacheTime;
		private delegate* unmanaged[Cdecl]<int, int> fn__leaderboardsGetCacheNumberOfRows;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__leaderboardsGetCacheDataRow;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__updateStatInt;
		private delegate* unmanaged[Cdecl]<int, float, int, void> fn__updateStatFloat;
		private delegate* unmanaged[Cdecl]<int, int, int, int*, void> fn__0x6483C25849031C4F;
		private delegate* unmanaged[Cdecl]<bool> fn__0x5EAD2BF6484852E4;
		private delegate* unmanaged[Cdecl]<void> fn__0xC141B8917E0017EC;
		private delegate* unmanaged[Cdecl]<void> fn__setProfileSettingPrologueComplete;
		private delegate* unmanaged[Cdecl]<void> fn__0xC67E2DA1CBE759E2;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xF1A1803D3476F215;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x38BAAA5DD4C9D19F;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x55384438FC55AD8E;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x723C1CE13FBFDB67;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x0D01D20616FC73FB;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x428EAF89E24F6C36;
		private delegate* unmanaged[Cdecl]<void> fn__statSetCheatIsActive;
		private delegate* unmanaged[Cdecl]<int*, int*, bool> fn__leaderboards2WriteDataForEventType;
		private delegate* unmanaged[Cdecl]<void> fn__0x6F361B8889A792A3;
		private delegate* unmanaged[Cdecl]<void> fn__0xC847B43F369AC0B5;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__statMigrateSave;
		private delegate* unmanaged[Cdecl]<int> fn__0x9A62EC95AE10E011;
		private delegate* unmanaged[Cdecl]<int> fn__0x4C89FE2BDEB3F169;
		private delegate* unmanaged[Cdecl]<int> fn__0xC6E0E2616A7576BB;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x5BD5F255321C4AAF;
		private delegate* unmanaged[Cdecl]<int, int*, int> fn__0xDEAAF77EB3687E97;
		private delegate* unmanaged[Cdecl]<int*, int> fn__statGetSaveMigrationStatus;
		private delegate* unmanaged[Cdecl]<bool> fn__statSaveMigrationCancel;
		private delegate* unmanaged[Cdecl]<int> fn__statGetCancelSaveMigrationStatus;
		private delegate* unmanaged[Cdecl]<int, nint, nint, bool> fn__statSaveMigrationConsumeContentUnlock;
		private delegate* unmanaged[Cdecl]<int*, int> fn__statGetSaveMigrationConsumeContentUnlockStatus;
		private delegate* unmanaged[Cdecl]<void> fn__0x98E2BC1CA26287C3;
		private delegate* unmanaged[Cdecl]<void> fn__0x629526ABA383BCAA;
		private delegate* unmanaged[Cdecl]<int> fn__0xBE3DB208333D9844;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x33D72899E24C3365;
		private delegate* unmanaged[Cdecl]<int> fn__0xA761D4AC6115623D;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xF11F01D98113536A;
		private delegate* unmanaged[Cdecl]<int> fn__0x8B9CDBD6C566C38C;
		private delegate* unmanaged[Cdecl]<int> fn__0xE8853FBCE7D8D0D6;
		private delegate* unmanaged[Cdecl]<int> fn__0xA943FD1722E11EFD;
		private delegate* unmanaged[Cdecl]<int> fn__0x84A810B375E69C0E;
		private delegate* unmanaged[Cdecl]<int> fn__0x9EC8858184CD253A;
		private delegate* unmanaged[Cdecl]<int> fn__0xBA9749CC94C1FD85;
		private delegate* unmanaged[Cdecl]<int> fn__0x55A8BECAF28A4EB7;
		private delegate* unmanaged[Cdecl]<int> fn__0x32CAC93C9DE73D32;
		private delegate* unmanaged[Cdecl]<int> fn__0xAFF47709F1D5DCCE;
		private delegate* unmanaged[Cdecl]<int> fn__0x6E0A5253375C4584;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x1A8EA222F9C67DBB;
		private delegate* unmanaged[Cdecl]<int> fn__0xF9F2922717B819EC;
		private delegate* unmanaged[Cdecl]<int> fn__0x0B8B7F74BF061C6D;
		private delegate* unmanaged[Cdecl]<bool> fn__0xB3DA2606774A8E2D;
		private delegate* unmanaged[Cdecl]<int, void> fn__setHasContentUnlocksFlags;
		private delegate* unmanaged[Cdecl]<int, void> fn__setSaveMigrationTransactionId;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x6BC0ACD0673ACEBE;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x8D8ADB562F09A245;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xD1A1EE3B4FA8E760;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x88087EE1F28024AE;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xFCC228E07217FCAC;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x678F86D8FC040BDB;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xA6F54BB2FFCA35EA;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x5FF2C33B13A02A11;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x282B6739644F4347;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xF06A6F41CB445443;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x7B18DA61F6BAE9D5;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x06EAF70AE066441E;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x14EDA9EE27BD1626;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x930F504203F561C9;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xE3261D791EB44ACB;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x73001E34F85137F8;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x53CAE13E9B426993;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x7D36291161859389;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsSpentPiCustomLoadout;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsBuyContraband;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsSellContraband;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsDefendContraband;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsRecoverContraband;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x60EEDC12AF66E846;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x3EBEAC6C3F81F6BD;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x96E6D5150DBF1C09;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xA3C53804BDB68ED2;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0x6BCCF9948492FD85;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__hiredLimo;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__orderedBossVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0xD1C9B92BDD3F151D;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x44919CC079BB60BF;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x7033EEFD9B28088E;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0xAA525DFF66BB82F5;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x015B03EE1C43E6EC;
		private delegate* unmanaged[Cdecl]<void> fn__playstatsStuntPerformedEventAllowTrigger;
		private delegate* unmanaged[Cdecl]<void> fn__playstatsStuntPerformedEventDisallowTrigger;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xBF371CD2B64212FD;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x7D8BA05688AD64C7;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__0x0B565B0AAE56A0E8;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0x28ECB8AC2F607DB2;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__playstatsChangeMcEmblem;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0xCC25A4553DFBF9EA;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0xF534D94DFA2EAD26;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0xD558BEC0BBA7E8D2;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__playstatsEarnedMcPoints;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__0x03C2EEBB04B3FB72;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__0x8989CBD7B4E82534;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void> fn__0x27AA1C973CACFE63;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__playstatsCopyRankIntoNewSlot;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsDupeDetection;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsBanAlert;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsGunrunMissionEnded;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xDAF80797FC534BEC;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x316DB59CD14C1774;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x2D7A9B577E72385E;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x830C3A44EB3F2CF9;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xB26F670685631727;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xC14BD9F5337219B2;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsStoneHatchetEnd;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsSmugMissionEnded;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsH2FmprepEnd;
		private delegate* unmanaged[Cdecl]<int*, int, int, int, void> fn__playstatsH2InstanceEnd;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsDarMissionEnd;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsEnterSessionPack;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__playstatsDroneUsage;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__playstatsSpectatorWheelSpin;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__playstatsArenaWarSpectator;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsArenaWarsEnded;
		private delegate* unmanaged[Cdecl]<bool, int, int, int, void> fn__playstatsPassiveMode;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void> fn__playstatsCollectible;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__playstatsCasinoStoryMissionEnded;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoChip;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoRoulette;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoBlackjack;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoThreecardpoker;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoSlotmachine;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoInsidetrack;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoLuckyseven;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoRouletteLight;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoBlackjackLight;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoThreecardpokerLight;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoSlotmachineLight;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCasinoInsidetrackLight;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__playstatsArcadegame;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x4FCDBD3F0A813C25;
		private delegate* unmanaged[Cdecl]<int*, void> fn__playstatsCasinoMissionEnded;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xDFBD93BF2943E29B;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__0x92FC0EEDFAC04A14;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x0077F15613D36993;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xF9096193DF1F99D4;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x2E0259BABC27A327;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x53C31853EC9531FF;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0x810B5FCC52EC7FF0;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0x5BF29846C6527C54;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC03FAB2C2F92289B;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x5CDAED54B34B0ED0;
		private delegate* unmanaged[Cdecl]<void> fn__0x4AFF7E02E485E92B;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xDFCDB14317A9B361;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC1E963C58664B556;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0x2FA3173480008493;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0xD4367D310F079DB0;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0x4DC416F246A41FC8;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x2818FF6638CB09DE;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xD6CA58B3B53A0F22;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsRobberyPrep;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsRobberyFinale;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsExtraEvent;
		private delegate* unmanaged[Cdecl]<int, void> fn__playstatsCarclubPoints;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__playstatsCarclubChallenge;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__playstatsCarclubPrize;
		private delegate* unmanaged[Cdecl]<void> fn__loadAllObjectsNow;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__loadScene;
		private delegate* unmanaged[Cdecl]<bool> fn__networkUpdateLoadScene;
		private delegate* unmanaged[Cdecl]<bool> fn__isNetworkLoadingScene;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setInteriorActive;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestModel;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestMenuPedModel;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasModelLoaded;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__requestModelsInRoom;
		private delegate* unmanaged[Cdecl]<int, void> fn__setModelAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isModelInCdimage;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isModelValid;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isModelAPed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isModelAVehicle;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__requestCollisionAtCoord;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestCollisionForModel;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasCollisionForModelLoaded;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__requestAdditionalCollisionAtCoord;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__doesAnimDictExist;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestAnimDict;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasAnimDictLoaded;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeAnimDict;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestAnimSet;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasAnimSetLoaded;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeAnimSet;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestClipSet;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasClipSetLoaded;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeClipSet;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestIpl;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeIpl;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isIplActive;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setStreaming;
		private delegate* unmanaged[Cdecl]<int, void> fn__loadGlobalWaterType;
		private delegate* unmanaged[Cdecl]<int> fn__getGlobalWaterType;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setGamePausesForStreaming;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setReducePedModelBudget;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setReduceVehicleModelBudget;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setDitchPoliceModels;
		private delegate* unmanaged[Cdecl]<int> fn__getNumberOfStreamingRequests;
		private delegate* unmanaged[Cdecl]<void> fn__requestPtfxAsset;
		private delegate* unmanaged[Cdecl]<bool> fn__hasPtfxAssetLoaded;
		private delegate* unmanaged[Cdecl]<void> fn__removePtfxAsset;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestNamedPtfxAsset;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__hasNamedPtfxAssetLoaded;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeNamedPtfxAsset;
		private delegate* unmanaged[Cdecl]<int, void> fn__setVehiclePopulationBudget;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedPopulationBudget;
		private delegate* unmanaged[Cdecl]<void> fn__clearFocus;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void> fn__setFocusPosAndVel;
		private delegate* unmanaged[Cdecl]<int, void> fn__setFocusEntity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isEntityFocus;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x0811381EF5062FEC;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__setMapdatacullboxEnabled;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x4E52E752C76E7E7A;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int> fn__streamvolCreateSphere;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, int, int> fn__streamvolCreateFrustum;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int> fn__streamvolCreateLine;
		private delegate* unmanaged[Cdecl]<int, void> fn__streamvolDelete;
		private delegate* unmanaged[Cdecl]<int, bool> fn__streamvolHasLoaded;
		private delegate* unmanaged[Cdecl]<int, bool> fn__streamvolIsValid;
		private delegate* unmanaged[Cdecl]<bool> fn__isStreamvolActive;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, bool> fn__newLoadSceneStart;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, bool> fn__newLoadSceneStartSphere;
		private delegate* unmanaged[Cdecl]<void> fn__newLoadSceneStop;
		private delegate* unmanaged[Cdecl]<bool> fn__isNewLoadSceneActive;
		private delegate* unmanaged[Cdecl]<bool> fn__isNewLoadSceneLoaded;
		private delegate* unmanaged[Cdecl]<int> fn__0x71E7B2E657449AAD;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__startPlayerSwitch;
		private delegate* unmanaged[Cdecl]<void> fn__stopPlayerSwitch;
		private delegate* unmanaged[Cdecl]<bool> fn__isPlayerSwitchInProgress;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayerSwitchType;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int> fn__getIdealPlayerSwitchType;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayerSwitchState;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayerShortSwitchState;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x5F2013F8BC24EE69;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayerSwitchJumpCutIndex;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, int, void> fn__setPlayerSwitchOutro;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setPlayerSwitchEstablishingShot;
		private delegate* unmanaged[Cdecl]<void> fn__allowPlayerSwitchPan;
		private delegate* unmanaged[Cdecl]<void> fn__allowPlayerSwitchOutro;
		private delegate* unmanaged[Cdecl]<void> fn__allowPlayerSwitchAscent;
		private delegate* unmanaged[Cdecl]<void> fn__allowPlayerSwitchDescent;
		private delegate* unmanaged[Cdecl]<bool> fn__isSwitchReadyForDescent;
		private delegate* unmanaged[Cdecl]<void> fn__enableSwitchPauseBeforeDescent;
		private delegate* unmanaged[Cdecl]<void> fn__disableSwitchOutroFx;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__switchOutPlayer;
		private delegate* unmanaged[Cdecl]<int, void> fn__switchInPlayer;
		private delegate* unmanaged[Cdecl]<bool> fn__0x933BBEEB8C61B5F4;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayerSwitchInterpOutDuration;
		private delegate* unmanaged[Cdecl]<int> fn__getPlayerSwitchInterpOutCurrentTime;
		private delegate* unmanaged[Cdecl]<bool> fn__isSwitchSkippingDescent;
		private delegate* unmanaged[Cdecl]<void> fn__0x1E9057A74FD73E23;
		private delegate* unmanaged[Cdecl]<float> fn__getLodscale;
		private delegate* unmanaged[Cdecl]<float, void> fn__overrideLodscaleThisFrame;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__0xBED8CA5FF5E04113;
		private delegate* unmanaged[Cdecl]<void> fn__0x472397322E92A856;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setRenderHdOnly;
		private delegate* unmanaged[Cdecl]<void> fn__0x03F1A106BDA7DD3E;
		private delegate* unmanaged[Cdecl]<nint, nint, void> fn__0x95A7DABDDBB78AE7;
		private delegate* unmanaged[Cdecl]<void> fn__0x63EB2B972A218CAC;
		private delegate* unmanaged[Cdecl]<bool> fn__0xFB199266061F820A;
		private delegate* unmanaged[Cdecl]<void> fn__0xF4A0DADB70F57FA6;
		private delegate* unmanaged[Cdecl]<int> fn__0x5068F488DDB54DD8;
		private delegate* unmanaged[Cdecl]<nint, void> fn__prefetchSrl;
		private delegate* unmanaged[Cdecl]<bool> fn__isSrlLoaded;
		private delegate* unmanaged[Cdecl]<void> fn__beginSrl;
		private delegate* unmanaged[Cdecl]<void> fn__endSrl;
		private delegate* unmanaged[Cdecl]<float, void> fn__setSrlTime;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__0xEF39EE20C537E98C;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__0xBEB2D9A1D9A8F55A;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x20C6C7E4EB082A7F;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xF8155A7F03DDFC8E;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__setHdArea;
		private delegate* unmanaged[Cdecl]<void> fn__clearHdArea;
		private delegate* unmanaged[Cdecl]<void> fn__initCreatorBudget;
		private delegate* unmanaged[Cdecl]<void> fn__shutdownCreatorBudget;
		private delegate* unmanaged[Cdecl]<int, bool> fn__addModelToCreatorBudget;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeModelFromCreatorBudget;
		private delegate* unmanaged[Cdecl]<float> fn__getUsedCreatorModelMemoryPercentage;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__setIslandHopperEnabled;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskPause;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskStandStill;
		private delegate* unmanaged[Cdecl]<int, bool, int, int, void> fn__taskJump;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskCower;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool, void> fn__taskHandsUp;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__updateTaskHandsUpDuration;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, void> fn__taskOpenVehicleDoor;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, int, int, void> fn__taskEnterVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__taskLeaveVehicle;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskGetOffBoat;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__taskSkyDive;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__taskParachute;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__taskParachuteToTarget;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setParachuteTaskTarget;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setParachuteTaskThrust;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__taskRappelFromHeli;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, int, int, float, float, void> fn__taskVehicleDriveToCoord;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, void> fn__taskVehicleDriveToCoordLongrange;
		private delegate* unmanaged[Cdecl]<int, int, float, int, void> fn__taskVehicleDriveWander;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, bool, void> fn__taskFollowToOffsetOfEntity;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, float, float, void> fn__taskGoStraightToCoord;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, void> fn__taskGoStraightToCoordRelativeToEntity;
		private delegate* unmanaged[Cdecl]<int, float, int, void> fn__taskAchieveHeading;
		private delegate* unmanaged[Cdecl]<void> fn__taskFlushRoute;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__taskExtendRoute;
		private delegate* unmanaged[Cdecl]<int, float, int, void> fn__taskFollowPointRoute;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, int, void> fn__taskGoToEntity;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, bool, bool, void> fn__taskSmartFleeCoord;
		private delegate* unmanaged[Cdecl]<int, int, float, int, bool, bool, void> fn__taskSmartFleePed;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskReactAndFleePed;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskShockingEventReact;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, void> fn__taskWanderInArea;
		private delegate* unmanaged[Cdecl]<int, float, int, void> fn__taskWanderStandard;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__taskWanderSpecific;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, bool, void> fn__taskVehiclePark;
		private delegate* unmanaged[Cdecl]<int, int, int, float, int, void> fn__taskStealthKill;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, void> fn__taskPlantBomb;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, float, bool, float, void> fn__taskFollowNavMeshToCoord;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, float, int, float, float, float, float, void> fn__taskFollowNavMeshToCoordAdvanced;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedPathCanUseClimbovers;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedPathCanUseLadders;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedPathCanDropFromHeight;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedPathClimbCostModifier;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedPathMayEnterWater;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedPathPreferToAvoidWater;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedPathAvoidFire;
		private delegate* unmanaged[Cdecl]<float, void> fn__setGlobalMinBirdFlightHeight;
		private delegate* unmanaged[Cdecl]<int, float*, bool*, int> fn__getNavmeshRouteDistanceRemaining;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNavmeshRouteResult;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0x3E38E28A1D80DDF6;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, bool, int, float, void> fn__taskGoToCoordAnyMeans;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, bool, int, float, int, int, int, int, void> fn__taskGoToCoordAnyMeansExtraParams;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, bool, int, float, int, int, int, int, int, void> fn__taskGoToCoordAnyMeansExtraParamsWithCruiseSpeed;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, float, int, int, float, bool, bool, bool, void> fn__taskPlayAnim;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, float, float, float, float, float, float, float, int, int, float, int, int, void> fn__taskPlayAnimAdvanced;
		private delegate* unmanaged[Cdecl]<int, nint, nint, float, void> fn__stopAnimTask;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, float, float, void> fn__taskScriptedAnimation;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, float, float, void> fn__playEntityScriptedAnim;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__stopAnimPlayback;
		private delegate* unmanaged[Cdecl]<int, float, int, int, bool, void> fn__setAnimWeight;
		private delegate* unmanaged[Cdecl]<int, float, int, bool, void> fn__setAnimPlaybackTime;
		private delegate* unmanaged[Cdecl]<int, float, int, bool, void> fn__setAnimRate;
		private delegate* unmanaged[Cdecl]<int, bool, int, bool, void> fn__setAnimLooped;
		private delegate* unmanaged[Cdecl]<int, nint, nint, nint, float, float, bool, bool, void> fn__taskPlayPhoneGestureAnimation;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskStopPhoneGestureAnimation;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlayingPhoneGestureAnim;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPhoneGestureAnimCurrentTime;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPhoneGestureAnimTotalTime;
		private delegate* unmanaged[Cdecl]<int, nint, nint, void> fn__taskVehiclePlayAnim;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, int, int, void> fn__taskLookAtCoord;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__taskLookAtEntity;
		private delegate* unmanaged[Cdecl]<int, void> fn__taskClearLookAt;
		private delegate* unmanaged[Cdecl]<int*, void> fn__openSequenceTask;
		private delegate* unmanaged[Cdecl]<int, void> fn__closeSequenceTask;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskPerformSequence;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskPerformSequenceLocally;
		private delegate* unmanaged[Cdecl]<int*, void> fn__clearSequenceTask;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setSequenceToRepeat;
		private delegate* unmanaged[Cdecl]<int, int> fn__getSequenceProgress;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__getIsTaskActive;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getScriptTaskStatus;
		private delegate* unmanaged[Cdecl]<int, int> fn__getActiveVehicleMissionType;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__taskLeaveAnyVehicle;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__taskAimGunScripted;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, int, bool, bool, void> fn__taskAimGunScriptedWithTarget;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void> fn__updateTaskAimGunScriptedTarget;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getClipSetForScriptedGunTask;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, void> fn__taskAimGunAtEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__taskTurnPedToFaceEntity;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, bool, bool, void> fn__taskAimGunAtCoord;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, int, void> fn__taskShootAtCoord;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__taskShuffleToNextVehicleSeat;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedTasks;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedSecondaryTask;
		private delegate* unmanaged[Cdecl]<int, void> fn__taskEveryoneLeaveVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, int, void> fn__taskGotoEntityOffset;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, bool, void> fn__taskGotoEntityOffsetXy;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, void> fn__taskTurnPedToFaceCoord;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__taskVehicleTempAction;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, int, float, float, bool, void> fn__taskVehicleMission;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, int, float, float, bool, void> fn__taskVehicleMissionPedTarget;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, int, int, int, float, float, bool, void> fn__taskVehicleMissionCoorsTarget;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, int, float, int, float, void> fn__taskVehicleEscort;
		private delegate* unmanaged[Cdecl]<int, int, int, float, int, int, void> fn__taskVehicleFollow;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskVehicleChase;
		private delegate* unmanaged[Cdecl]<int, int, int, float, int, float, int, int, void> fn__taskVehicleHeliProtect;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setTaskVehicleChaseBehaviorFlag;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setTaskVehicleChaseIdealPursuitDistance;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, void> fn__taskHeliChase;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, void> fn__taskPlaneChase;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, void> fn__taskPlaneLand;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x6100B3CEFD43452E;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearVehicleTasks;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x53DDC75BC3AC0A90;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void> fn__taskPlaneGotoPreciseVtol;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, int, void> fn__taskSubmarineGotoAndStop;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, int, float, float, float, int, int, float, int, void> fn__taskHeliMission;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, void> fn__taskHeliEscortHeli;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, int, float, float, float, float, float, int, void> fn__taskPlaneMission;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void> fn__taskPlaneTaxi;
		private delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, int, float, int, float, int, void> fn__taskBoatMission;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, int, bool, int, void> fn__taskDriveBy;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, void> fn__setDrivebyTaskTarget;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearDrivebyTaskUnderneathDrivingTask;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isDrivebyTaskUnderneathDrivingTask;
		private delegate* unmanaged[Cdecl]<int, bool> fn__controlMountedWeapon;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, int, int, void> fn__setMountedWeaponTarget;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMountedWeaponTaskUnderneathDrivingTask;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__taskUseMobilePhone;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskUseMobilePhoneTimed;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, void> fn__taskChatToPed;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__taskWarpPedIntoVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__taskShootAtEntity;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__taskClimb;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskClimbLadder;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, void> fn__taskRappelDownWall;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x9D252648778160DF;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedTasksImmediately;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__taskPerformSequenceFromProgress;
		private delegate* unmanaged[Cdecl]<float, void> fn__setNextDesiredMoveState;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPedDesiredMoveBlendRatio;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPedDesiredMoveBlendRatio;
		private delegate* unmanaged[Cdecl]<int, int, float, float, void> fn__taskGotoEntityAiming;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskSetDecisionMaker;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, void> fn__taskSetSphereDefensiveArea;
		private delegate* unmanaged[Cdecl]<int, void> fn__taskClearDefensiveArea;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, void> fn__taskPedSlideToCoord;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, void> fn__taskPedSlideToCoordHdgRate;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, bool, int> fn__addCoverPoint;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeCoverPoint;
		private delegate* unmanaged[Cdecl]<float, float, float, bool> fn__doesScriptedCoverPointExistAtCoords;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getScriptedCoverPointCoords;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__taskCombatPed;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__taskCombatPedTimed;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, bool, void> fn__taskSeekCoverFromPos;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, void> fn__taskSeekCoverFromPed;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, int, bool, void> fn__taskSeekCoverToCoverPoint;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, int, bool, void> fn__taskSeekCoverToCoords;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, bool, float, bool, bool, int, bool, void> fn__taskPutPedDirectlyIntoCover;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, void> fn__taskExitCover;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void> fn__taskPutPedDirectlyIntoMelee;
		private delegate* unmanaged[Cdecl]<bool, bool, void> fn__taskToggleDuck;
		private delegate* unmanaged[Cdecl]<int, float, float, bool, void> fn__taskGuardCurrentPosition;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, int, void> fn__taskGuardAssignedDefensiveArea;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, int, float, float, float, float, void> fn__taskGuardSphereDefensiveArea;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, nint, void> fn__taskStandGuard;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setDriveTaskCruiseSpeed;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setDriveTaskMaxCruiseSpeed;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setDriveTaskDrivingStyle;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool, bool, void> fn__addCoverBlockingArea;
		private delegate* unmanaged[Cdecl]<void> fn__removeAllCoverBlockingAreas;
		private delegate* unmanaged[Cdecl]<float, float, float, void> fn__0xFA83CA6776038F64;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void> fn__0x1F351CF1C6475734;
		private delegate* unmanaged[Cdecl]<int, nint, int, bool, void> fn__taskStartScenarioInPlace;
		private delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, int, bool, bool, void> fn__taskStartScenarioAtPosition;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void> fn__taskUseNearestScenarioToCoord;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void> fn__taskUseNearestScenarioToCoordWarp;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void> fn__taskUseNearestScenarioChainToCoord;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void> fn__taskUseNearestScenarioChainToCoordWarp;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool> fn__doesScenarioExistInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, int*, float, bool, bool> fn__doesScenarioOfTypeExistInArea;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool> fn__isScenarioOccupied;
		private delegate* unmanaged[Cdecl]<int, bool> fn__pedHasUseScenarioTask;
		private delegate* unmanaged[Cdecl]<int, nint, nint, void> fn__playAnimOnRunningScenario;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__doesScenarioGroupExist;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isScenarioGroupEnabled;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__setScenarioGroupEnabled;
		private delegate* unmanaged[Cdecl]<void> fn__resetScenarioGroupsEnabled;
		private delegate* unmanaged[Cdecl]<nint, void> fn__setExclusiveScenarioGroup;
		private delegate* unmanaged[Cdecl]<void> fn__resetExclusiveScenarioGroup;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__isScenarioTypeEnabled;
		private delegate* unmanaged[Cdecl]<nint, bool, void> fn__setScenarioTypeEnabled;
		private delegate* unmanaged[Cdecl]<void> fn__resetScenarioTypesEnabled;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedActiveInScenario;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedPlayingBaseClipInScenario;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setPedCanPlayAmbientIdles;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void> fn__taskCombatHatedTargetsInArea;
		private delegate* unmanaged[Cdecl]<int, float, int, void> fn__taskCombatHatedTargetsAroundPed;
		private delegate* unmanaged[Cdecl]<int, float, int, int, void> fn__taskCombatHatedTargetsAroundPedTimed;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, int, void> fn__taskThrowProjectile;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__taskSwapWeapon;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__taskReloadWeapon;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedGettingUp;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__taskWrithe;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedInWrithe;
		private delegate* unmanaged[Cdecl]<nint, void> fn__openPatrolRoute;
		private delegate* unmanaged[Cdecl]<void> fn__closePatrolRoute;
		private delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, float, float, int, void> fn__addPatrolRouteNode;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__addPatrolRouteLink;
		private delegate* unmanaged[Cdecl]<void> fn__createPatrolRoute;
		private delegate* unmanaged[Cdecl]<nint, void> fn__deletePatrolRoute;
		private delegate* unmanaged[Cdecl]<int, nint, int, bool, bool, void> fn__taskPatrol;
		private delegate* unmanaged[Cdecl]<int, void> fn__taskStayInCover;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__addVehicleSubtaskAttackCoord;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__addVehicleSubtaskAttackPed;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__taskVehicleShootAtPed;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskVehicleAimAtPed;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, void> fn__taskVehicleShootAtCoord;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__taskVehicleAimAtCoord;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, void> fn__taskVehicleGotoNavmesh;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, float, float, bool, int, bool, int, void> fn__taskGoToCoordWhileAimingAtCoord;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, float, bool, float, float, bool, int, bool, int, int, void> fn__taskGoToCoordWhileAimingAtEntity;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, float, float, bool, int, int, int, void> fn__taskGoToCoordAndAimAtHatedEntitiesNearCoord;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool, float, float, bool, bool, int, void> fn__taskGoToEntityWhileAimingAtCoord;
		private delegate* unmanaged[Cdecl]<int, int, int, float, bool, float, float, bool, bool, int, void> fn__taskGoToEntityWhileAimingAtEntity;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setHighFallTask;
		private delegate* unmanaged[Cdecl]<nint, void> fn__requestWaypointRecording;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__getIsWaypointRecordingLoaded;
		private delegate* unmanaged[Cdecl]<nint, void> fn__removeWaypointRecording;
		private delegate* unmanaged[Cdecl]<nint, int*, bool> fn__waypointRecordingGetNumPoints;
		private delegate* unmanaged[Cdecl]<nint, int, Vector3*, bool> fn__waypointRecordingGetCoord;
		private delegate* unmanaged[Cdecl]<nint, int, float> fn__waypointRecordingGetSpeedAtPoint;
		private delegate* unmanaged[Cdecl]<nint, float, float, float, int*, bool> fn__waypointRecordingGetClosestWaypoint;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__taskFollowWaypointRecording;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isWaypointPlaybackGoingOnForPed;
		private delegate* unmanaged[Cdecl]<int, int> fn__getPedWaypointProgress;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPedWaypointDistance;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int> fn__setPedWaypointRouteOffset;
		private delegate* unmanaged[Cdecl]<nint, int, float> fn__getWaypointDistanceAlongRoute;
		private delegate* unmanaged[Cdecl]<int, bool> fn__waypointPlaybackGetIsPaused;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__waypointPlaybackPause;
		private delegate* unmanaged[Cdecl]<int, bool, int, int, void> fn__waypointPlaybackResume;
		private delegate* unmanaged[Cdecl]<int, float, bool, void> fn__waypointPlaybackOverrideSpeed;
		private delegate* unmanaged[Cdecl]<int, void> fn__waypointPlaybackUseDefaultSpeed;
		private delegate* unmanaged[Cdecl]<nint, bool, float, float, void> fn__useWaypointRecordingAsAssistedMovementRoute;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__waypointPlaybackStartAimingAtPed;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, void> fn__waypointPlaybackStartAimingAtCoord;
		private delegate* unmanaged[Cdecl]<int, int, bool, int, void> fn__waypointPlaybackStartShootingAtPed;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, void> fn__waypointPlaybackStartShootingAtCoord;
		private delegate* unmanaged[Cdecl]<int, void> fn__waypointPlaybackStopAimingOrShooting;
		private delegate* unmanaged[Cdecl]<nint, void> fn__assistedMovementRequestRoute;
		private delegate* unmanaged[Cdecl]<nint, void> fn__assistedMovementRemoveRoute;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__assistedMovementIsRouteLoaded;
		private delegate* unmanaged[Cdecl]<nint, int, void> fn__assistedMovementSetRouteProperties;
		private delegate* unmanaged[Cdecl]<float, void> fn__assistedMovementOverrideLoadDistanceThisFrame;
		private delegate* unmanaged[Cdecl]<int, int, nint, int, int, int, int, float, bool, float, void> fn__taskVehicleFollowWaypointRecording;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isWaypointPlaybackGoingOnForVehicle;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleWaypointProgress;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleWaypointTargetPoint;
		private delegate* unmanaged[Cdecl]<int, void> fn__vehicleWaypointPlaybackPause;
		private delegate* unmanaged[Cdecl]<int, void> fn__vehicleWaypointPlaybackResume;
		private delegate* unmanaged[Cdecl]<int, void> fn__vehicleWaypointPlaybackUseDefaultSpeed;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__vehicleWaypointPlaybackOverrideSpeed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__taskSetBlockingOfNonTemporaryEvents;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__taskForceMotionState;
		private delegate* unmanaged[Cdecl]<int, nint, float, bool, nint, int, void> fn__taskMoveNetworkByName;
		private delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, float, float, int, float, bool, nint, int, void> fn__taskMoveNetworkAdvancedByName;
		private delegate* unmanaged[Cdecl]<int, nint, int*, float, bool, nint, int, void> fn__taskMoveNetworkByNameWithInitParams;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, int, int, void> fn__0x29682E2CCF21E9B5;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isTaskMoveNetworkActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isTaskMoveNetworkReadyForTransition;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__requestTaskMoveNetworkStateTransition;
		private delegate* unmanaged[Cdecl]<int, nint, int> fn__0xAB13A5565480B6D9;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getTaskMoveNetworkState;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x8423541E8B3A1589;
		private delegate* unmanaged[Cdecl]<int, nint, float, void> fn__setTaskMoveNetworkSignalFloat;
		private delegate* unmanaged[Cdecl]<int, nint, float, void> fn__setTaskMoveNetworkSignalFloat2;
		private delegate* unmanaged[Cdecl]<int, nint, float, void> fn__0x8634CEF2522D987B;
		private delegate* unmanaged[Cdecl]<int, nint, bool, void> fn__setTaskMoveNetworkSignalBool;
		private delegate* unmanaged[Cdecl]<int, nint, float> fn__getTaskMoveNetworkSignalFloat;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__getTaskMoveNetworkSignalBool;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__getTaskMoveNetworkEvent;
		private delegate* unmanaged[Cdecl]<int, bool, int> fn__0x0FFB3C758E8C07B9;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMoveBlendRatioStill;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMoveBlendRatioWalking;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMoveBlendRatioRunning;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMoveBlendRatioSprinting;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedStill;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedWalking;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedRunning;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedSprinting;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedStrafing;
		private delegate* unmanaged[Cdecl]<int, int, nint, nint, float, float, int, int, float, int, void> fn__taskSynchronizedScene;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskAgitatedAction;
		private delegate* unmanaged[Cdecl]<int, nint, nint, nint, nint, int, int, float, float, void> fn__taskSweepAimEntity;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__updateTaskSweepAimEntity;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, int*, int, float, float, float, float, float, void> fn__taskSweepAimPosition;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__updateTaskSweepAimPosition;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__taskArrestPed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedRunningArrestTask;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedBeingArrested;
		private delegate* unmanaged[Cdecl]<int, void> fn__uncuffPed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedCuffed;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, bool, bool, bool, int> fn__createVehicle;
		private delegate* unmanaged[Cdecl]<int*, void> fn__deleteVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__0x7D6F9A3EF26136A0;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setVehicleCanBeLockedOn;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleAllowNoPassengersLockon;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleHomingLockonState;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x6EAAEFC76ACC311F;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x407DC5E97DB1A4D3;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isVehicleModel;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesScriptVehicleGeneratorExist;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int, int, bool, bool, bool, bool, bool, int, int> fn__createScriptVehicleGenerator;
		private delegate* unmanaged[Cdecl]<int, void> fn__deleteScriptVehicleGenerator;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setScriptVehicleGenerator;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, void> fn__setAllVehicleGeneratorsActiveInArea;
		private delegate* unmanaged[Cdecl]<void> fn__setAllVehicleGeneratorsActive;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setAllLowPriorityVehicleGeneratorsActive;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__0x9A75585FB2E54FAD;
		private delegate* unmanaged[Cdecl]<void> fn__0x0A436B8643716D14;
		private delegate* unmanaged[Cdecl]<int, float, bool> fn__setVehicleOnGroundProperly;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, int> fn__setVehicleUseCutsceneWheelCompression;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleStuckOnRoof;
		private delegate* unmanaged[Cdecl]<int, void> fn__addVehicleUpsidedownCheck;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeVehicleUpsidedownCheck;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleStopped;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleNumberOfPassengers;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleMaxNumberOfPassengers;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleModelNumberOfSeats;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isSeatWarpOnly;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isTurretSeat;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesVehicleAllowRappel;
		private delegate* unmanaged[Cdecl]<float, void> fn__setVehicleDensityMultiplierThisFrame;
		private delegate* unmanaged[Cdecl]<float, void> fn__setRandomVehicleDensityMultiplierThisFrame;
		private delegate* unmanaged[Cdecl]<float, void> fn__setParkedVehicleDensityMultiplierThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setDisableRandomTrainsThisFrame;
		private delegate* unmanaged[Cdecl]<float, void> fn__setAmbientVehicleRangeMultiplierThisFrame;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setFarDrawVehicles;
		private delegate* unmanaged[Cdecl]<int, void> fn__setNumberOfParkedVehicles;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleDoorsLocked;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setVehicleIndividualDoorsLocked;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleHasMutedSirens;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleDoorsLockedForPlayer;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__getVehicleDoorsLockedForPlayer;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleDoorsLockedForAllPlayers;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleDoorsLockedForNonScriptPlayers;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleDoorsLockedForTeam;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleDoorsLockedForUnk;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x76D26A22750E849E;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__explodeVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setVehicleOutOfControl;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleTimedExplosion;
		private delegate* unmanaged[Cdecl]<int, void> fn__addVehiclePhoneExplosiveDevice;
		private delegate* unmanaged[Cdecl]<void> fn__clearVehiclePhoneExplosiveDevice;
		private delegate* unmanaged[Cdecl]<bool> fn__hasVehiclePhoneExplosiveDevice;
		private delegate* unmanaged[Cdecl]<void> fn__detonateVehiclePhoneExplosiveDevice;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setTaxiLights;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isTaxiLightOn;
		private delegate* unmanaged[Cdecl]<nint, int, bool> fn__isVehicleInGarageArea;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setVehicleColours;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleFullbeam;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleIsRacing;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setVehicleCustomPrimaryColour;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getVehicleCustomPrimaryColour;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearVehicleCustomPrimaryColour;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getIsVehiclePrimaryColourCustom;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setVehicleCustomSecondaryColour;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getVehicleCustomSecondaryColour;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearVehicleCustomSecondaryColour;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getIsVehicleSecondaryColourCustom;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleEnveffScale;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleEnveffScale;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCanResprayVehicle;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xAB31EF4DE6800CE9;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x1B212B26DD3C04DF;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__forceSubmarineSurfaceMode;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xC67DB108A9ADE3BE;
		private delegate* unmanaged[Cdecl]<int, bool, float, float, float, void> fn__setSubmarineCrushDepths;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getSubmarineIsBelowFirstCrushDepth;
		private delegate* unmanaged[Cdecl]<int, int> fn__getSubmarineCrushDepthWarningState;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xED5EDE9E676643C9;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBoatAnchor;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canAnchorBoatHere;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canAnchorBoatHere2;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBoatFrozenWhenAnchored;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xB28B1FE5BFADD7F5;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setBoatMovementResistance;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isBoatAnchoredAndFrozen;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBoatSinksWhenWrecked;
		private delegate* unmanaged[Cdecl]<int, void> fn__setBoatIsSinking;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleSiren;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleSirenOn;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleSirenAudioOn;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleStrong;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeVehicleStuckCheck;
		private delegate* unmanaged[Cdecl]<int, int*, int*, void> fn__getVehicleColours;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__isVehicleSeatFree;
		private delegate* unmanaged[Cdecl]<int, int, bool, int> fn__getPedInVehicleSeat;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getLastPedInVehicleSeat;
		private delegate* unmanaged[Cdecl]<int, bool*, bool*, bool> fn__getVehicleLightsState;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__isVehicleTyreBurst;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleForwardSpeed;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x6501129C9E0FFA05;
		private delegate* unmanaged[Cdecl]<int, float, int, bool, void> fn__bringVehicleToHalt;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xDCE97BDF8A0EABC8;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x9849DE24FCF23CCC;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x8664170EF165C4A6;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopBringVehicleToHalt;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleBeingHalted;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setForkliftForkHeight;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isEntityAttachedToHandlerFrame;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isAnyEntityAttachedToHandlerFrame;
		private delegate* unmanaged[Cdecl]<int, int> fn__findVehicleCarryingThisEntity;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isHandlerFrameAboveContainer;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x6A98C2ECF57FA5D4;
		private delegate* unmanaged[Cdecl]<int, void> fn__detachContainerFromHandlerFrame;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x8AA9180DE2FEDD45;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setBoatDisableAvoidance;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isHeliLandingAreaBlocked;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x107A473D7A6647A9;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setHeliTurbulenceScalar;
		private delegate* unmanaged[Cdecl]<int, void> fn__setCarBootOpen;
		private delegate* unmanaged[Cdecl]<int, int, bool, float, void> fn__setVehicleTyreBurst;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleDoorsShut;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleTyresCanBurst;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getVehicleTyresCanBurst;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleWheelsCanBreak;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, void> fn__setVehicleDoorOpen;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__0x3B458DDB57038F08;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xA247F9EF01D8082E;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__removeVehicleWindow;
		private delegate* unmanaged[Cdecl]<int, void> fn__rollDownWindows;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__rollDownWindow;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__rollUpWindow;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__smashVehicleWindow;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__fixVehicleWindow;
		private delegate* unmanaged[Cdecl]<int, void> fn__popOutVehicleWindscreen;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__ejectJb700Roof;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleLights;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleUsePlayerLightSettings;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleLightsMode;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleAlarm;
		private delegate* unmanaged[Cdecl]<int, void> fn__startVehicleAlarm;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleAlarmActivated;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleInteriorlight;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x8821196D91FA2DE5;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleLightMultiplier;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__attachVehicleToTrailer;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, float, float, float, float, void> fn__attachVehicleOnToTrailer;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__stabiliseEntityAttachedToHeli;
		private delegate* unmanaged[Cdecl]<int, void> fn__detachVehicleFromTrailer;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleAttachedToTrailer;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setTrailerInverseMassScale;
		private delegate* unmanaged[Cdecl]<int, void> fn__setTrailerLegsRaised;
		private delegate* unmanaged[Cdecl]<int, void> fn__setTrailerLegsLowered;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleTyreFixed;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setVehicleNumberPlateText;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getVehicleNumberPlateText;
		private delegate* unmanaged[Cdecl]<int> fn__getNumberOfVehicleNumberPlates;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleNumberPlateTextIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleNumberPlateTextIndex;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setRandomTrains;
		private delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int> fn__createMissionTrain;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__switchTrainTrack;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setTrainTrackSpawnFrequency;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x2310A8F9421EBF43;
		private delegate* unmanaged[Cdecl]<void> fn__deleteAllTrains;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setTrainSpeed;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setTrainCruiseSpeed;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setRandomBoats;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setRandomBoatsInMp;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setGarbageTrucks;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesVehicleHaveStuckVehicleCheck;
		private delegate* unmanaged[Cdecl]<int, nint, int> fn__getVehicleRecordingId;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__requestVehicleRecording;
		private delegate* unmanaged[Cdecl]<int, nint, bool> fn__hasVehicleRecordingBeenLoaded;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__removeVehicleRecording;
		private delegate* unmanaged[Cdecl]<int, float, Vector3> fn__getPositionOfVehicleRecordingIdAtTime;
		private delegate* unmanaged[Cdecl]<int, float, nint, Vector3> fn__getPositionOfVehicleRecordingAtTime;
		private delegate* unmanaged[Cdecl]<int, float, Vector3> fn__getRotationOfVehicleRecordingIdAtTime;
		private delegate* unmanaged[Cdecl]<int, float, nint, Vector3> fn__getRotationOfVehicleRecordingAtTime;
		private delegate* unmanaged[Cdecl]<int, float> fn__getTotalDurationOfVehicleRecordingId;
		private delegate* unmanaged[Cdecl]<int, nint, float> fn__getTotalDurationOfVehicleRecording;
		private delegate* unmanaged[Cdecl]<int, float> fn__getPositionInRecording;
		private delegate* unmanaged[Cdecl]<int, float> fn__getTimePositionInRecording;
		private delegate* unmanaged[Cdecl]<int, int, nint, bool, void> fn__startPlaybackRecordedVehicle;
		private delegate* unmanaged[Cdecl]<int, int, nint, int, int, int, void> fn__startPlaybackRecordedVehicleWithFlags;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__forcePlaybackRecordedVehicleUpdate;
		private delegate* unmanaged[Cdecl]<int, void> fn__stopPlaybackRecordedVehicle;
		private delegate* unmanaged[Cdecl]<int, void> fn__pausePlaybackRecordedVehicle;
		private delegate* unmanaged[Cdecl]<int, void> fn__unpausePlaybackRecordedVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlaybackGoingOnForVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlaybackUsingAiGoingOnForVehicle;
		private delegate* unmanaged[Cdecl]<int, int> fn__getCurrentPlaybackForVehicle;
		private delegate* unmanaged[Cdecl]<int, void> fn__skipToEndAndStopPlaybackRecordedVehicle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlaybackSpeed;
		private delegate* unmanaged[Cdecl]<int, int, nint, float, int, void> fn__startPlaybackRecordedVehicleUsingAi;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__skipTimeInPlaybackRecordedVehicle;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPlaybackToUseAi;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, void> fn__setPlaybackToUseAiTryToRevertBackLater;
		private delegate* unmanaged[Cdecl]<int, float, float, float, int, void> fn__0x5845066D8A1EA7F7;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__0x796A877E459B99EA;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__0xFAF2A78061FD9EF4;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x063AE2B2CC273588;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__explodeVehicleInCutscene;
		private delegate* unmanaged[Cdecl]<int, float, int, bool, bool, bool, int, void> fn__addVehicleStuckCheckWithWarp;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleModelIsSuppressed;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int> fn__getRandomVehicleInSphere;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int> fn__getRandomVehicleFrontBumperInSphere;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int> fn__getRandomVehicleBackBumperInSphere;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int> fn__getClosestVehicle;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getTrainCarriage;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isMissionTrain;
		private delegate* unmanaged[Cdecl]<int*, void> fn__deleteMissionTrain;
		private delegate* unmanaged[Cdecl]<int*, bool, void> fn__setMissionTrainAsNoLongerNeeded;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__setMissionTrainCoords;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelABoat;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelAJetski;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelAPlane;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelAHeli;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelACar;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelATrain;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelABike;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelABicycle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelAQuadbike;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelAnAmphibiousCar;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isThisModelAnAmphibiousQuadbike;
		private delegate* unmanaged[Cdecl]<int, void> fn__setHeliBladesFullSpeed;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setHeliBladesSpeed;
		private delegate* unmanaged[Cdecl]<int, float, float, void> fn__0x99CAD8E7AFDB60FA;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleCanBeTargetted;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xDBC631F109350B8C;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleCanBeVisiblyDamaged;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleHasUnbreakableLights;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x2311DD7159F00582;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x065D03A9D6B2C6B5;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleDirtLevel;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleDirtLevel;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleDamaged;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isVehicleDoorFullyOpen;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, void> fn__setVehicleEngineOn;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleUndriveable;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleProvidesCover;
		private delegate* unmanaged[Cdecl]<int, int, int, float, void> fn__setVehicleDoorControl;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool, bool, void> fn__setVehicleDoorLatched;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getVehicleDoorAngleRatio;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedUsingVehicleDoor;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleDoorShut;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleDoorBroken;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleCanBreak;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesVehicleHaveRoof;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xC4B3347BD68BD609;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xD3301660A57C9272;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xB9562064627FF9DB;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isBigVehicle;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumberOfVehicleColours;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleColourCombination;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleColourCombination;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleXenonLightsColor;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleXenonLightsColor;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleIsConsideredByPlayer;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xBE5C1255A1830FF5;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x9BECD4B9FEF3F8A6;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x88BC673CA9E0AE99;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xE851E480B814D4BA;
		private delegate* unmanaged[Cdecl]<bool, int*, int*, void> fn__getRandomVehicleModelInMemory;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleDoorLockStatus;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getVehicleDoorDestroyType;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isVehicleDoorDamaged;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleDoorCanBreak;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isVehicleBumperBouncing;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isVehicleBumperBrokenOff;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool> fn__isCopVehicleInArea3d;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleOnAllWheels;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleModelMonetaryValue;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleLayoutHash;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0xA01BC64DD4BFBBAC;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setRenderTrainAsDerailed;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setVehicleExtraColours;
		private delegate* unmanaged[Cdecl]<int, int*, int*, void> fn__getVehicleExtraColours;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleInteriorColor;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getVehicleInteriorColor;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleDashboardColor;
		private delegate* unmanaged[Cdecl]<int, int*, void> fn__getVehicleDashboardColor;
		private delegate* unmanaged[Cdecl]<void> fn__stopAllGarageActivity;
		private delegate* unmanaged[Cdecl]<int, void> fn__setVehicleFixed;
		private delegate* unmanaged[Cdecl]<int, void> fn__setVehicleDeformationFixed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleCanEngineOperateOnFire;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleCanLeakOil;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleCanLeakPetrol;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisableVehiclePetrolTankFires;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisableVehiclePetrolTankDamage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisableVehicleEngineFires;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xC50CE861B55EAB8B;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x6EBFB22D646FFC18;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisablePretendOccupants;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, void> fn__removeVehiclesFromGeneratorsInArea;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleSteerBias;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isVehicleExtraTurnedOn;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleExtra;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__doesExtraExist;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__doesVehicleTyreExist;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setConvertibleRoof;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__lowerConvertibleRoof;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__raiseConvertibleRoof;
		private delegate* unmanaged[Cdecl]<int, int> fn__getConvertibleRoofState;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isVehicleAConvertible;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__transformVehicleToSubmarine;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__transformSubmarineToVehicle;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getIsSubmarineVehicleTransformed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleStoppedAtTrafficLights;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, bool, void> fn__setVehicleDamage;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x35BB21DE06784373;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleEngineHealth;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleEngineHealth;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlaneEngineHealth;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehiclePetrolTankHealth;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehiclePetrolTankHealth;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__isVehicleStuckTimerUp;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__resetVehicleStuckTimer;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__isVehicleDriveable;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleHasBeenOwnedByPlayer;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleNeedsToBeHotwired;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x9F3F689B814F2599;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x4E74E62E0A97E901;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, void> fn__startVehicleHorn;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleSilent;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleHasStrongAxles;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getDisplayNameFromVehicleModel;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getMakeNameFromVehicleModel;
		private delegate* unmanaged[Cdecl]<int, float, float, float, Vector3> fn__getVehicleDeformationAtPos;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleLivery;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleLivery;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleLiveryCount;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleRoofLivery;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleRoofLivery;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleRoofLiveryCount;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isVehicleWindowIntact;
		private delegate* unmanaged[Cdecl]<int, bool> fn__areAllVehicleWindowsIntact;
		private delegate* unmanaged[Cdecl]<int, bool> fn__areAnyVehicleSeatsFree;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__resetVehicleWheels;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool> fn__isHeliPartBroken;
		private delegate* unmanaged[Cdecl]<int, float> fn__getHeliMainRotorHealth;
		private delegate* unmanaged[Cdecl]<int, float> fn__getHeliTailRotorHealth;
		private delegate* unmanaged[Cdecl]<int, float> fn__getHeliTailBoomHealth;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setHeliMainRotorHealth;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setHeliTailRotorHealth;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setHeliTailExplodeThrowDashboard;
		private delegate* unmanaged[Cdecl]<int, nint, void> fn__setVehicleNameDebug;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleExplodesOnHighExplosionDamage;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xD565F438137F0E10;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x3441CAD2F2231923;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleDisableTowing;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesVehicleHaveLandingGear;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__controlLandingGear;
		private delegate* unmanaged[Cdecl]<int, int> fn__getLandingGearState;
		private delegate* unmanaged[Cdecl]<float, float, float, float, bool> fn__isAnyVehicleNearPoint;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestVehicleHighDetailModel;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeVehicleHighDetailModel;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleHighDetail;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__requestVehicleAsset;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasVehicleAssetLoaded;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeVehicleAsset;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleTowTruckArmPosition;
		private delegate* unmanaged[Cdecl]<int, int, bool, float, float, float, void> fn__attachVehicleToTowTruck;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__detachVehicleFromTowTruck;
		private delegate* unmanaged[Cdecl]<int, bool> fn__detachVehicleFromAnyTowTruck;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isVehicleAttachedToTowTruck;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityAttachedToTowTruck;
		private delegate* unmanaged[Cdecl]<int, bool, int, int> fn__setVehicleAutomaticallyAttaches;
		private delegate* unmanaged[Cdecl]<int, float, bool, void> fn__setVehicleBulldozerArmPosition;
		private delegate* unmanaged[Cdecl]<int, float, bool, void> fn__setVehicleTankTurretPosition;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__0x0581730AB9380412;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x737E398138550FFF;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleTurretSpeedThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableVehicleTurretMovementThisFrame;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleFlightNozzlePosition;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleFlightNozzlePositionImmediate;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleFlightNozzlePosition;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisableVehicleFlightNozzlePosition;
		private delegate* unmanaged[Cdecl]<Vector3*, int, Vector3*, int, int, int, int, int, int, bool> fn__0xA4822F1CF23F4810;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleBurnout;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleInBurnout;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleReduceGrip;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleReduceTraction;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleIndicatorLights;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleBrakeLights;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleHandbrake;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleBrake;
		private delegate* unmanaged[Cdecl]<void> fn__instantlyFillVehiclePopulation;
		private delegate* unmanaged[Cdecl]<bool> fn__hasFilledVehiclePopulation;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x51DB102F4A3BA5E0;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xA4A9A4C40E615885;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getVehicleTrailerVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleUsesLargeRearRamp;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleRudderBroken;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setConvertibleRoofLatchState;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleEstimatedMaxSpeed;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleMaxBraking;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleMaxTraction;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleAcceleration;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleModelEstimatedMaxSpeed;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleModelMaxBraking;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleModelMaxBrakingMaxMods;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleModelMaxTraction;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleModelAcceleration;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleModelEstimatedAgility;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleModelMaxKnots;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleModelMoveResistance;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleClassEstimatedMaxSpeed;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleClassMaxTraction;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleClassMaxAgility;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleClassMaxAcceleration;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleClassMaxBraking;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, bool, int> fn__addRoadNodeSpeedZone;
		private delegate* unmanaged[Cdecl]<int, bool> fn__removeRoadNodeSpeedZone;
		private delegate* unmanaged[Cdecl]<int, void> fn__openBombBayDoors;
		private delegate* unmanaged[Cdecl]<int, void> fn__closeBombBayDoors;
		private delegate* unmanaged[Cdecl]<int, bool> fn__areBombBayDoorsOpen;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleSearchlightOn;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setVehicleSearchlight;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesVehicleHaveSearchlight;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, bool, bool> fn__isVehicleSeatAccessible;
		private delegate* unmanaged[Cdecl]<int, int, Vector3> fn__getEntryPositionOfDoor;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__canShuffleSeat;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumModKits;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleModKit;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleModKit;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleModKitType;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleWheelType;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleWheelType;
		private delegate* unmanaged[Cdecl]<int, bool, int> fn__getNumModColors;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setVehicleModColor1;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setVehicleModColor2;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getVehicleModColor1;
		private delegate* unmanaged[Cdecl]<int, int*, int*, void> fn__getVehicleModColor2;
		private delegate* unmanaged[Cdecl]<int, bool, nint> fn__getVehicleModColor1Name;
		private delegate* unmanaged[Cdecl]<int, nint> fn__getVehicleModColor2Name;
		private delegate* unmanaged[Cdecl]<int, bool> fn__haveVehicleModsStreamedIn;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, void> fn__setVehicleMod;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getVehicleMod;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__getVehicleModVariation;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getNumVehicleMods;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__removeVehicleMod;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__toggleVehicleMod;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isToggleModOn;
		private delegate* unmanaged[Cdecl]<int, int, int, nint> fn__getModTextLabel;
		private delegate* unmanaged[Cdecl]<int, int, nint> fn__getModSlotName;
		private delegate* unmanaged[Cdecl]<int, int, nint> fn__getLiveryName;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__getVehicleModModifierValue;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__getVehicleModIdentifierHash;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__preloadVehicleMod;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasPreloadModsFinished;
		private delegate* unmanaged[Cdecl]<int, void> fn__releasePreloadMods;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setVehicleTyreSmokeColor;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getVehicleTyreSmokeColor;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleWindowTint;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleWindowTint;
		private delegate* unmanaged[Cdecl]<int> fn__getNumVehicleWindowTints;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getVehicleColor;
		private delegate* unmanaged[Cdecl]<int, int> fn__0xEEBFC7A7EFDC35B4;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleCauseOfDestruction;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x5EE5632F47AE9695;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getIsLeftVehicleHeadlightDamaged;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getIsRightVehicleHeadlightDamaged;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleEngineOnFire;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__modifyVehicleTopSpeed;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleMaxSpeed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x1CF38D529D7441D9;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x1F9FB66F3A3842D2;
		private delegate* unmanaged[Cdecl]<int, bool, float, void> fn__0x59C3757B3B7408E8;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int> fn__addVehicleCombatAngledAvoidanceArea;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeVehicleCombatAvoidanceArea;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isAnyPedRappellingFromHeli;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleCheatPowerIncrease;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x0AD9E8F87FF7C16F;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleIsWanted;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setBoatBoomPositionRatio;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__getBoatBoomPositionRatio2;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__getBoatBoomPositionRatio3;
		private delegate* unmanaged[Cdecl]<int, float> fn__getBoatBoomPositionRatio;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__disablePlaneAileron;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getIsVehicleEngineRunning;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleUseAlternateHandling;
		private delegate* unmanaged[Cdecl]<int, float, float, void> fn__setBikeOnStand;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xAB04325045427AAE;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xCFD778E7904C255E;
		private delegate* unmanaged[Cdecl]<int, void> fn__setLastDrivenVehicle;
		private delegate* unmanaged[Cdecl]<int> fn__getLastDrivenVehicle;
		private delegate* unmanaged[Cdecl]<void> fn__clearLastDrivenVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleHasBeenDrivenFlag;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setTaskVehicleGotoPlaneMinHeightAboveTerrain;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleLodMultiplier;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleCanSaveInGarage;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleNumberOfBrokenOffBones;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleNumberOfBrokenBones;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x4D9D109F63FEE1D4;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleGeneratesEngineShockingEvents;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__copyVehicleDamages;
		private delegate* unmanaged[Cdecl]<void> fn__0xF25E02CB9C5818F8;
		private delegate* unmanaged[Cdecl]<float, void> fn__setLightsCutoffDistanceTweak;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, void> fn__setVehicleShootAtTarget;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getVehicleLockOnTarget;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setForceHdVehicle;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x182F266C2D9E2BEB;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehiclePlateType;
		private delegate* unmanaged[Cdecl]<int, void> fn__trackVehicleVisibility;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleVisible;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleGravity;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setEnableVehicleSlipstreaming;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xF051D9BFB6BA39C0;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleCurrentSlipstreamDraft;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleSlipstreamLeader;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleInactiveDuringPlayback;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleActiveDuringPlayback;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleSprayable;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleEngineCanDegrade;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setVehicleShadowEffect;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeVehicleShadowEffect;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPlaneLandingGearIntact;
		private delegate* unmanaged[Cdecl]<int, bool> fn__arePlanePropellersIntact;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlanePropellersHealth;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleCanDeformWheels;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleStolen;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleIsStolen;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setPlaneTurbulenceMultiplier;
		private delegate* unmanaged[Cdecl]<int, bool> fn__arePlaneWingsIntact;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xB264C4D2F2B0A78B;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__detachVehicleFromCargobob;
		private delegate* unmanaged[Cdecl]<int, bool> fn__detachVehicleFromAnyCargobob;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__detachEntityFromCargobob;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isVehicleAttachedToCargobob;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleAttachedToCargobob;
		private delegate* unmanaged[Cdecl]<int, int> fn__getEntityAttachedToCargobob;
		private delegate* unmanaged[Cdecl]<int, int, int, float, float, float, void> fn__attachVehicleToCargobob;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void> fn__attachEntityToCargobob;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCargobobHookCanDetach;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x1F34B0626C594380;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x2C1D8B3B19E517CC;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__getCargobobHookPosition;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesCargobobHavePickUpRope;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__createPickUpRopeForCargobob;
		private delegate* unmanaged[Cdecl]<int, void> fn__removePickUpRopeForCargobob;
		private delegate* unmanaged[Cdecl]<int, float, float, bool, void> fn__setPickupRopeLengthForCargobob;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0xC0ED6438E6D39BA8;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setCargobobPickupRopeDampingMultiplier;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setCargobobPickupRopeType;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesCargobobHavePickupMagnet;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCargobobPickupMagnetActive;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCargobobPickupMagnetStrength;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCargobobPickupMagnetEffectRadius;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCargobobPickupMagnetReducedFalloff;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCargobobPickupMagnetPullRopeLength;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCargobobPickupMagnetPullStrength;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setCargobobPickupMagnetFalloff;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setCargobobPickupMagnetReducedStrength;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__0x9BDDC73CC6A115D4;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x56EB5E94318D3FB6;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesVehicleHaveWeapons;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x2C4A1590ABF43E8B;
		private delegate* unmanaged[Cdecl]<bool, int, int, int, void> fn__disableVehicleWeapon;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__isVehicleWeaponDisabled;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xE05DD0E9707003A3;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleActiveForPedNavigation;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleClass;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleClassFromName;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPlayersLastVehicle;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleCanBeUsedByFleeingPeds;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0xE5810AC70602F2F5;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleDropsMoneyWhenBlownUp;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleJetEngineOn;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x6A973569BA094650;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleHandlingHashForAi;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleExtendedRemovalRange;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleSteeringBiasScalar;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setHelicopterRollPitchYawMult;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleFrictionOverride;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleWheelsCanBreakOffWhenBlowUp;
		private delegate* unmanaged[Cdecl]<int, bool, bool> fn__0xF78F94D60248C737;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleCeilingHeight;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x5E569EC46EC21CAE;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearVehicleRouteHistory;
		private delegate* unmanaged[Cdecl]<nint, bool> fn__doesVehicleExistWithDecorator;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x41062318F23ED854;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setVehicleExclusiveDriver;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__isPedExclusiveDriverOfVehicle;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__disableIndividualPlanePropeller;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleForceAfterburner;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisableVehicleWindowCollisions;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x4AD280EB48B2D8E6;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xB68CFAF83A02768D;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x0205F5365292D2EB;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xCF9159024555488C;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setDistantCarsEnabled;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setVehicleNeonLightsColour;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xB93B2867F7B479D1;
		private delegate* unmanaged[Cdecl]<int, int*, int*, int*, void> fn__getVehicleNeonLightsColour;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleNeonLightEnabled;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isVehicleNeonLightEnabled;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x35E0654F4BAD7971;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__disableVehicleNeonLights;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDisableSuperdummyMode;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestVehicleDashboardScaleformMovie;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleBodyHealth;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleBodyHealth;
		private delegate* unmanaged[Cdecl]<int, Vector3*, Vector3*, void> fn__getVehicleSuspensionBounds;
		private delegate* unmanaged[Cdecl]<int, float> fn__getVehicleSuspensionHeight;
		private delegate* unmanaged[Cdecl]<float, void> fn__setCarHighSpeedBumpSeverityMultiplier;
		private delegate* unmanaged[Cdecl]<int, int> fn__getNumberOfVehicleDoors;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setHydraulicRaised;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xA7DCDF4DED40A8F4;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float> fn__getVehicleBodyHealth2;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xD4C4642CB7F50B5D;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xC361AA040D6637A8;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleKersAllowed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getVehicleHasKers;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xE16142B94664DEFD;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x26D99D5A82FD18E8;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__setHydraulicWheelValue;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getHydraulicWheelValue;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setCamberedWheelsDisabled;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setHydraulicWheelState;
		private delegate* unmanaged[Cdecl]<int, int, int, float, int, void> fn__setHydraulicWheelStateTransition;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x5BA68A0840D546AC;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x4419966C9936071A;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x870B8B7A766615C8;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x8533CAFDE1F0F336;
		private delegate* unmanaged[Cdecl]<int, float, int> fn__setVehicleDamageModifier;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleUnkDamageMultiplier;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0xD4196117AF7BB974;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xBB2333BB87DDD87F;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x73561D4425A021A2;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleControlsInverted;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x7BBE7FF626A591FE;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x65B080555EA48149;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, void> fn__0x428AD3E26C8D9EB0;
		private delegate* unmanaged[Cdecl]<void> fn__0xE2F53F172B45EDE1;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xBA91D045575699AD;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x80E3357FDEF45C21;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleRampLaunchModifier;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__getIsDoorValid;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleRocketBoostRefillTime;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getHasRocketBoost;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isVehicleRocketBoostActive;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleRocketBoostActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getHasRetractableWheels;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getIsWheelsLoweredStateActive;
		private delegate* unmanaged[Cdecl]<int, void> fn__raiseRetractableWheels;
		private delegate* unmanaged[Cdecl]<int, void> fn__lowerRetractableWheels;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getCanVehicleJump;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setUseHigherVehicleJumpForce;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xB2E0C0D6922D31F2;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setVehicleWeaponCapacity;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getVehicleWeaponCapacity;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getVehicleHasParachute;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getVehicleCanActivateParachute;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleParachuteActive;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x3DE51E9C80B116CF;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleReceivesRampDamage;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleRampSidewaysLaunchMotion;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleRampUpwardsLaunchMotion;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x9D30687C57BAA0BB;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleWeaponsDisabled;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x41290B40FA63E6DA;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleParachuteModel;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleParachuteTextureVariation;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0x0419B167EE128F33;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0xF3B0E0AED097A3F5;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0xD3E51C0AB8C26EEE;
		private delegate* unmanaged[Cdecl]<int*, int> fn__getAllVehicles;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x72BECCF4B829522E;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x66E3AAFACE2D1EB8;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x1312DDD8385AEE4E;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xEDBC8405B3895CC9;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__0x26E13D440E7F6064;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x2FA2494B47FDD009;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleRocketBoostPercentage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setOppressorTransformState;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x78CEEE41F49F421F;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xAF60E6A2936F982A;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x430A7631A84C9BE7;
		private delegate* unmanaged[Cdecl]<int, void> fn__disableVehicleWorldCollision;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x8235F1BEAD557629;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, void> fn__0x9640E30A7F395E4B;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__0x0BBB9A7A8FFE931B;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCargobobHookCanAttach;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleBombCount;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleBombCount;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setVehicleCountermeasureCount;
		private delegate* unmanaged[Cdecl]<int, int> fn__getVehicleCountermeasureCount;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__0x0A3F820A9A9A9AC5;
		private delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, int, int, bool> fn__0x51F30DB60626A20E;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0x97841634EF7DF1D6;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleHoverTransformRatio;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setVehicleHoverTransformPercentage;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleHoverTransformEnabled;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleHoverTransformActive;
		private delegate* unmanaged[Cdecl]<int, int> fn__0x3A9128352EAC9E85;
		private delegate* unmanaged[Cdecl]<int, Vector3> fn__findRandomPointInSpace;
		private delegate* unmanaged[Cdecl]<int, bool, bool, void> fn__setDeployHeliStubWings;
		private delegate* unmanaged[Cdecl]<int, bool> fn__areHeliStubWingsDeployed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__0xAA653AE61924B0A0;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setVehicleTurretUnk;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setSpecialflightWingRatio;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setDisableTurretMovementThisFrame;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x887FA38787DE8C72;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setUnkFloat0x104ForSubmarineVehicleTask;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setUnkBool0x102ForSubmarineVehicleTask;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x36DE109527A2C0C4;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x82E0AC411E41A5B4;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x99A05839C46CE316;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getIsVehicleShuntBoostActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__0xE8718FAF591FD224;
		private delegate* unmanaged[Cdecl]<int, int> fn__getLastRammedVehicle;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setDisableVehicleUnk;
		private delegate* unmanaged[Cdecl]<int, bool, float, float, float, bool, void> fn__setVehicleNitroEnabled;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setVehicleWheelsDealDamage;
		private delegate* unmanaged[Cdecl]<bool, void> fn__setDisableVehicleUnk2;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x5BBCF35BF6E456F7;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getDoesVehicleHaveTombstone;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__hideVehicleTombstone;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getIsVehicleEmpDisabled;
		private delegate* unmanaged[Cdecl]<bool, void> fn__0x8F0D5BA1C2CC91D7;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getTyreHealth;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__setTyreHealth;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getTyreWearMultiplier;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__setTyreWearMultiplier;
		private delegate* unmanaged[Cdecl]<int, int, float, void> fn__setTyreTractionLossMultiplier;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xF8B49F5BA7F850E7;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setReduceDriftVehicleSuspension;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setDriftTyresEnabled;
		private delegate* unmanaged[Cdecl]<int, bool> fn__getDriftTyresEnabled;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__networkUseHighPrecisionVehicleBlending;
		private delegate* unmanaged[Cdecl]<float, float, float, float*, bool> fn__getWaterHeight;
		private delegate* unmanaged[Cdecl]<float, float, float, float*, bool> fn__getWaterHeightNoWaves;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, Vector3*, bool> fn__testProbeAgainstWater;
		private delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, bool> fn__testProbeAgainstAllWater;
		private delegate* unmanaged[Cdecl]<float, float, float, int, float*, bool> fn__testVerticalProbeAgainstAllWater;
		private delegate* unmanaged[Cdecl]<float, float, float, float, void> fn__modifyWater;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, int> fn__addCurrentRise;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeCurrentRise;
		private delegate* unmanaged[Cdecl]<float, void> fn__setDeepOceanScaler;
		private delegate* unmanaged[Cdecl]<float> fn__getDeepOceanScaler;
		private delegate* unmanaged[Cdecl]<float, void> fn__0x547237AA71AB44DE;
		private delegate* unmanaged[Cdecl]<void> fn__resetDeepOceanScaler;
		private delegate* unmanaged[Cdecl]<bool, void> fn__enableLaserSightRendering;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeaponComponentTypeModel;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeapontypeModel;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeapontypeSlot;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeapontypeGroup;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeaponComponentVariantExtraComponentCount;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getWeaponComponentVariantExtraComponentModel;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setCurrentPedWeapon;
		private delegate* unmanaged[Cdecl]<int, int*, bool, bool> fn__getCurrentPedWeapon;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getCurrentPedWeaponEntityIndex;
		private delegate* unmanaged[Cdecl]<int, bool, int> fn__getBestPedWeapon;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__setCurrentPedVehicleWeapon;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getCurrentPedVehicleWeapon;
		private delegate* unmanaged[Cdecl]<int, void> fn__0x50276EF8172F5F12;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__isPedArmed;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isWeaponValid;
		private delegate* unmanaged[Cdecl]<int, int, bool, bool> fn__hasPedGotWeapon;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedWeaponReadyToShoot;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedWeapontypeInSlot;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getAmmoInPedWeapon;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__addAmmoToPed;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, void> fn__setPedAmmo;
		private delegate* unmanaged[Cdecl]<int, bool, int, void> fn__setPedInfiniteAmmo;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedInfiniteAmmoClip;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x24C024BA8379A70A;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, bool, void> fn__giveWeaponToPed;
		private delegate* unmanaged[Cdecl]<int, int, int, bool, void> fn__giveDelayedWeaponToPed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removeAllPedWeapons;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__removeWeaponFromPed;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__hidePedWeaponForScriptedCutscene;
		private delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, void> fn__setPedCurrentWeaponVisible;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setPedDropsWeaponsWhenDead;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__hasPedBeenDamagedByWeapon;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPedLastWeaponDamage;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__hasEntityBeenDamagedByWeapon;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearEntityLastWeaponDamage;
		private delegate* unmanaged[Cdecl]<int, void> fn__setPedDropsWeapon;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, int, void> fn__setPedDropsInventoryWeapon;
		private delegate* unmanaged[Cdecl]<int, int, bool, int> fn__getMaxAmmoInClip;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__getAmmoInClip;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__setAmmoInClip;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__getMaxAmmo;
		private delegate* unmanaged[Cdecl]<int, int, int*, bool> fn__getMaxAmmoByType;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__addAmmoToPedByType;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setPedAmmoByType;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedAmmoByType;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setPedAmmoToDrop;
		private delegate* unmanaged[Cdecl]<float, void> fn__setPickupAmmoAmountScaler;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedAmmoTypeFromWeapon;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedAmmoTypeFromWeapon2;
		private delegate* unmanaged[Cdecl]<int, Vector3*, bool> fn__getPedLastWeaponImpactCoord;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPedGadget;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__getIsPedGadgetEquipped;
		private delegate* unmanaged[Cdecl]<int, int> fn__getSelectedPedWeapon;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__explodeProjectiles;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__removeAllProjectilesOfType;
		private delegate* unmanaged[Cdecl]<int, float> fn__getLockonDistanceOfCurrentPedWeapon;
		private delegate* unmanaged[Cdecl]<int, float> fn__getMaxRangeOfCurrentPedWeapon;
		private delegate* unmanaged[Cdecl]<int, int, int, int, bool> fn__hasVehicleGotProjectileAttached;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__giveWeaponComponentToPed;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__removeWeaponComponentFromPed;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__hasPedGotWeaponComponent;
		private delegate* unmanaged[Cdecl]<int, int, int, bool> fn__isPedWeaponComponentActive;
		private delegate* unmanaged[Cdecl]<int, bool> fn__refillAmmoInstantly;
		private delegate* unmanaged[Cdecl]<int, bool> fn__makePedReload;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__requestWeaponAsset;
		private delegate* unmanaged[Cdecl]<int, bool> fn__hasWeaponAssetLoaded;
		private delegate* unmanaged[Cdecl]<int, void> fn__removeWeaponAsset;
		private delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, float, int, int, int, int> fn__createWeaponObject;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__giveWeaponComponentToWeaponObject;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__removeWeaponComponentFromWeaponObject;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__hasWeaponGotWeaponComponent;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__giveWeaponObjectToPed;
		private delegate* unmanaged[Cdecl]<int, int, bool> fn__doesWeaponTakeWeaponComponent;
		private delegate* unmanaged[Cdecl]<int, bool, int> fn__getWeaponObjectFromPed;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__giveLoadoutToPed;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setPedWeaponTintIndex;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getPedWeaponTintIndex;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setWeaponObjectTintIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeaponObjectTintIndex;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeaponTintCount;
		private delegate* unmanaged[Cdecl]<int, int, int, int, void> fn__setPedWeaponLiveryColor;
		private delegate* unmanaged[Cdecl]<int, int, int, int> fn__getPedWeaponLiveryColor;
		private delegate* unmanaged[Cdecl]<int, int, int, void> fn__setWeaponObjectLiveryColor;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__getWeaponObjectLiveryColor;
		private delegate* unmanaged[Cdecl]<int, int, int> fn__0xA2C9AC24B4061285;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0x977CA98939E82E4B;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getWeaponHudStats;
		private delegate* unmanaged[Cdecl]<int, int*, bool> fn__getWeaponComponentHudStats;
		private delegate* unmanaged[Cdecl]<int, int, float> fn__getWeaponDamage;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeaponClipSize;
		private delegate* unmanaged[Cdecl]<int, float> fn__getWeaponTimeBetweenShots;
		private delegate* unmanaged[Cdecl]<int, float, float, void> fn__setPedChanceOfFiringBlanks;
		private delegate* unmanaged[Cdecl]<int, float, int> fn__setPedShootOrdnanceWeapon;
		private delegate* unmanaged[Cdecl]<int, void> fn__requestWeaponHighDetailModel;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setWeaponDamageModifierThisFrame;
		private delegate* unmanaged[Cdecl]<int, float, void> fn__setWeaponExplosionRadiusMultiplier;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__0xE6D2CEDD370FF98E;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isPedCurrentWeaponSilenced;
		private delegate* unmanaged[Cdecl]<int, bool> fn__isFlashLightOn;
		private delegate* unmanaged[Cdecl]<float, int> fn__setFlashLightFadeDistance;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setFlashLightEnabled;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__setWeaponAnimationOverride;
		private delegate* unmanaged[Cdecl]<int, int> fn__getWeaponDamageType;
		private delegate* unmanaged[Cdecl]<int, void> fn__0xE4DCEC7FD5B739A5;
		private delegate* unmanaged[Cdecl]<int, bool> fn__canUseWeaponOnParachute;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, int> fn__createAirDefenseSphere;
		private delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, int, int> fn__createAirDefenseArea;
		private delegate* unmanaged[Cdecl]<int, bool> fn__removeAirDefenseZone;
		private delegate* unmanaged[Cdecl]<void> fn__removeAllAirDefenseZones;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setPlayerAirDefenseZoneFlag;
		private delegate* unmanaged[Cdecl]<float, float, float, float, int*, bool> fn__isAnyAirDefenseZoneInsideSphere;
		private delegate* unmanaged[Cdecl]<int, float, float, float, void> fn__fireAirDefenseWeapon;
		private delegate* unmanaged[Cdecl]<int, bool> fn__doesAirDefenseZoneExist;
		private delegate* unmanaged[Cdecl]<int, int, bool, void> fn__setCanPedEquipWeapon;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setCanPedEquipAllWeapons;
		private delegate* unmanaged[Cdecl]<float, float, float, int> fn__getZoneAtCoords;
		private delegate* unmanaged[Cdecl]<nint, int> fn__getZoneFromNameId;
		private delegate* unmanaged[Cdecl]<int, int> fn__getZonePopschedule;
		private delegate* unmanaged[Cdecl]<float, float, float, nint> fn__getNameOfZone;
		private delegate* unmanaged[Cdecl]<int, bool, void> fn__setZoneEnabled;
		private delegate* unmanaged[Cdecl]<int, int> fn__getZoneScumminess;
		private delegate* unmanaged[Cdecl]<int, int, void> fn__overridePopscheduleVehicleModel;
		private delegate* unmanaged[Cdecl]<int, void> fn__clearPopscheduleOverrideVehicleModel;
		private delegate* unmanaged[Cdecl]<float, float, float, int> fn__getHashOfMapAreaAtCoords;

		public Natives(string dllName)
		{
			const DllImportSearchPath dllImportSearchPath = DllImportSearchPath.LegacyBehavior | DllImportSearchPath.AssemblyDirectory | DllImportSearchPath.SafeDirectories | DllImportSearchPath.System32 | DllImportSearchPath.UserDirectories | DllImportSearchPath.ApplicationDirectory | DllImportSearchPath.UseDllDirectoryForDependencies;
			handle = NativeLibrary.Load(dllName, Assembly.GetExecutingAssembly(), dllImportSearchPath);
			freeString = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "FreeString");
		}

		public void Wait(int _ms)
		{
			unsafe {
				if (fn__wait == null) fn__wait = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_wait");
				fn__wait(_ms);
			}
		}

		public int StartNewScript(string _scriptName, int _stackSize)
		{
			unsafe {
				if (fn__startNewScript == null) fn__startNewScript = (delegate* unmanaged[Cdecl]<nint, int, int>) NativeLibrary.GetExport(handle, "Native_startNewScript");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				var result = fn__startNewScript(ptr_scriptName, _stackSize);
				Marshal.FreeHGlobal(ptr_scriptName);
				return result;
			}
		}

		public int StartNewScriptWithArgs(string _scriptName, ref int _args, int _argCount, int _stackSize)
		{
			unsafe {
				if (fn__startNewScriptWithArgs == null) fn__startNewScriptWithArgs = (delegate* unmanaged[Cdecl]<nint, int*, int, int, int>) NativeLibrary.GetExport(handle, "Native_startNewScriptWithArgs");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				var ref_args = _args;
				var result = fn__startNewScriptWithArgs(ptr_scriptName, &ref_args, _argCount, _stackSize);
				Marshal.FreeHGlobal(ptr_scriptName);
				_args = ref_args;
				return result;
			}
		}

		public int StartNewScriptWithNameHash(int _scriptHash, int _stackSize)
		{
			unsafe {
				if (fn__startNewScriptWithNameHash == null) fn__startNewScriptWithNameHash = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_startNewScriptWithNameHash");
				var result = fn__startNewScriptWithNameHash(_scriptHash, _stackSize);
				return result;
			}
		}

		public int StartNewScriptWithNameHashAndArgs(int _scriptHash, ref int _args, int _argCount, int _stackSize)
		{
			unsafe {
				if (fn__startNewScriptWithNameHashAndArgs == null) fn__startNewScriptWithNameHashAndArgs = (delegate* unmanaged[Cdecl]<int, int*, int, int, int>) NativeLibrary.GetExport(handle, "Native_startNewScriptWithNameHashAndArgs");
				var ref_args = _args;
				var result = fn__startNewScriptWithNameHashAndArgs(_scriptHash, &ref_args, _argCount, _stackSize);
				_args = ref_args;
				return result;
			}
		}

		public int Timera()
		{
			unsafe {
				if (fn__timera == null) fn__timera = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_timera");
				var result = fn__timera();
				return result;
			}
		}

		public int Timerb()
		{
			unsafe {
				if (fn__timerb == null) fn__timerb = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_timerb");
				var result = fn__timerb();
				return result;
			}
		}

		public void Settimera(int _value)
		{
			unsafe {
				if (fn__settimera == null) fn__settimera = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_settimera");
				fn__settimera(_value);
			}
		}

		public void Settimerb(int _value)
		{
			unsafe {
				if (fn__settimerb == null) fn__settimerb = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_settimerb");
				fn__settimerb(_value);
			}
		}

		public float Timestep()
		{
			unsafe {
				if (fn__timestep == null) fn__timestep = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_timestep");
				var result = fn__timestep();
				return result;
			}
		}

		public float Sin(float _value)
		{
			unsafe {
				if (fn__sin == null) fn__sin = (delegate* unmanaged[Cdecl]<float, float>) NativeLibrary.GetExport(handle, "Native_sin");
				var result = fn__sin(_value);
				return result;
			}
		}

		public float Cos(float _value)
		{
			unsafe {
				if (fn__cos == null) fn__cos = (delegate* unmanaged[Cdecl]<float, float>) NativeLibrary.GetExport(handle, "Native_cos");
				var result = fn__cos(_value);
				return result;
			}
		}

		public float Sqrt(float _value)
		{
			unsafe {
				if (fn__sqrt == null) fn__sqrt = (delegate* unmanaged[Cdecl]<float, float>) NativeLibrary.GetExport(handle, "Native_sqrt");
				var result = fn__sqrt(_value);
				return result;
			}
		}

		public float Pow(float _base, float _exponent)
		{
			unsafe {
				if (fn__pow == null) fn__pow = (delegate* unmanaged[Cdecl]<float, float, float>) NativeLibrary.GetExport(handle, "Native_pow");
				var result = fn__pow(_base, _exponent);
				return result;
			}
		}

		public float Log10(float _value)
		{
			unsafe {
				if (fn__log10 == null) fn__log10 = (delegate* unmanaged[Cdecl]<float, float>) NativeLibrary.GetExport(handle, "Native_log10");
				var result = fn__log10(_value);
				return result;
			}
		}

		public float Vmag(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__vmag == null) fn__vmag = (delegate* unmanaged[Cdecl]<float, float, float, float>) NativeLibrary.GetExport(handle, "Native_vmag");
				var result = fn__vmag(_x, _y, _z);
				return result;
			}
		}

		public float Vmag2(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__vmag2 == null) fn__vmag2 = (delegate* unmanaged[Cdecl]<float, float, float, float>) NativeLibrary.GetExport(handle, "Native_vmag2");
				var result = fn__vmag2(_x, _y, _z);
				return result;
			}
		}

		public float Vdist(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__vdist == null) fn__vdist = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float>) NativeLibrary.GetExport(handle, "Native_vdist");
				var result = fn__vdist(_x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public float Vdist2(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__vdist2 == null) fn__vdist2 = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float>) NativeLibrary.GetExport(handle, "Native_vdist2");
				var result = fn__vdist2(_x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public int ShiftLeft(int _value, int _bitShift)
		{
			unsafe {
				if (fn__shiftLeft == null) fn__shiftLeft = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_shiftLeft");
				var result = fn__shiftLeft(_value, _bitShift);
				return result;
			}
		}

		public int ShiftRight(int _value, int _bitShift)
		{
			unsafe {
				if (fn__shiftRight == null) fn__shiftRight = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_shiftRight");
				var result = fn__shiftRight(_value, _bitShift);
				return result;
			}
		}

		public int Floor(float _value)
		{
			unsafe {
				if (fn__floor == null) fn__floor = (delegate* unmanaged[Cdecl]<float, int>) NativeLibrary.GetExport(handle, "Native_floor");
				var result = fn__floor(_value);
				return result;
			}
		}

		public int Ceil(float _value)
		{
			unsafe {
				if (fn__ceil == null) fn__ceil = (delegate* unmanaged[Cdecl]<float, int>) NativeLibrary.GetExport(handle, "Native_ceil");
				var result = fn__ceil(_value);
				return result;
			}
		}

		public int Round(float _value)
		{
			unsafe {
				if (fn__round == null) fn__round = (delegate* unmanaged[Cdecl]<float, int>) NativeLibrary.GetExport(handle, "Native_round");
				var result = fn__round(_value);
				return result;
			}
		}

		public float ToFloat(int _value)
		{
			unsafe {
				if (fn__toFloat == null) fn__toFloat = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_toFloat");
				var result = fn__toFloat(_value);
				return result;
			}
		}

		public void SetThreadPriority(int _priority)
		{
			unsafe {
				if (fn__setThreadPriority == null) fn__setThreadPriority = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setThreadPriority");
				fn__setThreadPriority(_priority);
			}
		}

		public bool AppDataValid()
		{
			unsafe {
				if (fn__appDataValid == null) fn__appDataValid = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_appDataValid");
				var result = fn__appDataValid();
				return result;
			}
		}

		public int AppGetInt(string _property)
		{
			unsafe {
				if (fn__appGetInt == null) fn__appGetInt = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_appGetInt");
				var ptr_property = MemoryUtils.StringToHGlobalUtf8(_property);
				var result = fn__appGetInt(ptr_property);
				Marshal.FreeHGlobal(ptr_property);
				return result;
			}
		}

		public float AppGetFloat(string _property)
		{
			unsafe {
				if (fn__appGetFloat == null) fn__appGetFloat = (delegate* unmanaged[Cdecl]<nint, float>) NativeLibrary.GetExport(handle, "Native_appGetFloat");
				var ptr_property = MemoryUtils.StringToHGlobalUtf8(_property);
				var result = fn__appGetFloat(ptr_property);
				Marshal.FreeHGlobal(ptr_property);
				return result;
			}
		}

		public string AppGetString(string _property)
		{
			unsafe {
				if (fn__appGetString == null) fn__appGetString = (delegate* unmanaged[Cdecl]<nint, nint>) NativeLibrary.GetExport(handle, "Native_appGetString");
				var ptr_property = MemoryUtils.StringToHGlobalUtf8(_property);
				var result = fn__appGetString(ptr_property);
				Marshal.FreeHGlobal(ptr_property);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void AppSetInt(string _property, int _value)
		{
			unsafe {
				if (fn__appSetInt == null) fn__appSetInt = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_appSetInt");
				var ptr_property = MemoryUtils.StringToHGlobalUtf8(_property);
				fn__appSetInt(ptr_property, _value);
				Marshal.FreeHGlobal(ptr_property);
			}
		}

		public void AppSetFloat(string _property, float _value)
		{
			unsafe {
				if (fn__appSetFloat == null) fn__appSetFloat = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_appSetFloat");
				var ptr_property = MemoryUtils.StringToHGlobalUtf8(_property);
				fn__appSetFloat(ptr_property, _value);
				Marshal.FreeHGlobal(ptr_property);
			}
		}

		public void AppSetString(string _property, string _value)
		{
			unsafe {
				if (fn__appSetString == null) fn__appSetString = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native_appSetString");
				var ptr_property = MemoryUtils.StringToHGlobalUtf8(_property);
				var ptr_value = MemoryUtils.StringToHGlobalUtf8(_value);
				fn__appSetString(ptr_property, ptr_value);
				Marshal.FreeHGlobal(ptr_property);
				Marshal.FreeHGlobal(ptr_value);
			}
		}

		public void AppSetApp(string _appName)
		{
			unsafe {
				if (fn__appSetApp == null) fn__appSetApp = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_appSetApp");
				var ptr_appName = MemoryUtils.StringToHGlobalUtf8(_appName);
				fn__appSetApp(ptr_appName);
				Marshal.FreeHGlobal(ptr_appName);
			}
		}

		public void AppSetBlock(string _blockName)
		{
			unsafe {
				if (fn__appSetBlock == null) fn__appSetBlock = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_appSetBlock");
				var ptr_blockName = MemoryUtils.StringToHGlobalUtf8(_blockName);
				fn__appSetBlock(ptr_blockName);
				Marshal.FreeHGlobal(ptr_blockName);
			}
		}

		public void AppClearBlock()
		{
			unsafe {
				if (fn__appClearBlock == null) fn__appClearBlock = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_appClearBlock");
				fn__appClearBlock();
			}
		}

		public void AppCloseApp()
		{
			unsafe {
				if (fn__appCloseApp == null) fn__appCloseApp = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_appCloseApp");
				fn__appCloseApp();
			}
		}

		public void AppCloseBlock()
		{
			unsafe {
				if (fn__appCloseBlock == null) fn__appCloseBlock = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_appCloseBlock");
				fn__appCloseBlock();
			}
		}

		public bool AppHasLinkedSocialClubAccount()
		{
			unsafe {
				if (fn__appHasLinkedSocialClubAccount == null) fn__appHasLinkedSocialClubAccount = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_appHasLinkedSocialClubAccount");
				var result = fn__appHasLinkedSocialClubAccount();
				return result;
			}
		}

		public bool AppHasSyncedData(string _appName)
		{
			unsafe {
				if (fn__appHasSyncedData == null) fn__appHasSyncedData = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_appHasSyncedData");
				var ptr_appName = MemoryUtils.StringToHGlobalUtf8(_appName);
				var result = fn__appHasSyncedData(ptr_appName);
				Marshal.FreeHGlobal(ptr_appName);
				return result;
			}
		}

		public void AppSaveData()
		{
			unsafe {
				if (fn__appSaveData == null) fn__appSaveData = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_appSaveData");
				fn__appSaveData();
			}
		}

		public int AppGetDeletedFileStatus()
		{
			unsafe {
				if (fn__appGetDeletedFileStatus == null) fn__appGetDeletedFileStatus = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_appGetDeletedFileStatus");
				var result = fn__appGetDeletedFileStatus();
				return result;
			}
		}

		public bool AppDeleteAppData(string _appName)
		{
			unsafe {
				if (fn__appDeleteAppData == null) fn__appDeleteAppData = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_appDeleteAppData");
				var ptr_appName = MemoryUtils.StringToHGlobalUtf8(_appName);
				var result = fn__appDeleteAppData(ptr_appName);
				Marshal.FreeHGlobal(ptr_appName);
				return result;
			}
		}

		public void SetDebugLinesAndSpheresDrawingActive(bool _enabled)
		{
			unsafe {
				if (fn__setDebugLinesAndSpheresDrawingActive == null) fn__setDebugLinesAndSpheresDrawingActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setDebugLinesAndSpheresDrawingActive");
				fn__setDebugLinesAndSpheresDrawingActive(_enabled);
			}
		}

		public void DrawDebugLine(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__drawDebugLine == null) fn__drawDebugLine = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawDebugLine");
				fn__drawDebugLine(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void DrawDebugLineWithTwoColours(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _r1, int _g1, int _b1, int _r2, int _g2, int _b2, int _alpha1, int _alpha2)
		{
			unsafe {
				if (fn__drawDebugLineWithTwoColours == null) fn__drawDebugLineWithTwoColours = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawDebugLineWithTwoColours");
				fn__drawDebugLineWithTwoColours(_x1, _y1, _z1, _x2, _y2, _z2, _r1, _g1, _b1, _r2, _g2, _b2, _alpha1, _alpha2);
			}
		}

		public void DrawDebugSphere(float _x, float _y, float _z, float _radius, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawDebugSphere == null) fn__drawDebugSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawDebugSphere");
				fn__drawDebugSphere(_x, _y, _z, _radius, _red, _green, _blue, _alpha);
			}
		}

		public void DrawDebugBox(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__drawDebugBox == null) fn__drawDebugBox = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawDebugBox");
				fn__drawDebugBox(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void DrawDebugCross(float _x, float _y, float _z, float _size, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawDebugCross == null) fn__drawDebugCross = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawDebugCross");
				fn__drawDebugCross(_x, _y, _z, _size, _red, _green, _blue, _alpha);
			}
		}

		public void DrawDebugText(string _text, float _x, float _y, float _z, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawDebugText == null) fn__drawDebugText = (delegate* unmanaged[Cdecl]<nint, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawDebugText");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				fn__drawDebugText(ptr_text, _x, _y, _z, _red, _green, _blue, _alpha);
				Marshal.FreeHGlobal(ptr_text);
			}
		}

		public void DrawDebugText2d(string _text, float _x, float _y, float _z, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawDebugText2d == null) fn__drawDebugText2d = (delegate* unmanaged[Cdecl]<nint, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawDebugText2d");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				fn__drawDebugText2d(ptr_text, _x, _y, _z, _red, _green, _blue, _alpha);
				Marshal.FreeHGlobal(ptr_text);
			}
		}

		public void DrawLine(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawLine == null) fn__drawLine = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawLine");
				fn__drawLine(_x1, _y1, _z1, _x2, _y2, _z2, _red, _green, _blue, _alpha);
			}
		}

		public void DrawPoly(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _x3, float _y3, float _z3, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawPoly == null) fn__drawPoly = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawPoly");
				fn__drawPoly(_x1, _y1, _z1, _x2, _y2, _z2, _x3, _y3, _z3, _red, _green, _blue, _alpha);
			}
		}

		public void DrawSpritePoly(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _x3, float _y3, float _z3, int _red, int _green, int _blue, int _alpha, string _textureDict, string _textureName, float _u1, float _v1, float _w1, float _u2, float _v2, float _w2, float _u3, float _v3, float _w3)
		{
			unsafe {
				if (fn__drawSpritePoly == null) fn__drawSpritePoly = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, int, int, int, int, nint, nint, float, float, float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_drawSpritePoly");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				fn__drawSpritePoly(_x1, _y1, _z1, _x2, _y2, _z2, _x3, _y3, _z3, _red, _green, _blue, _alpha, ptr_textureDict, ptr_textureName, _u1, _v1, _w1, _u2, _v2, _w2, _u3, _v3, _w3);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
			}
		}

		public void DrawSpritePoly2(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _x3, float _y3, float _z3, float _red1, float _green1, float _blue1, int _alpha1, float _red2, float _green2, float _blue2, int _alpha2, float _red3, float _green3, float _blue3, int _alpha3, string _textureDict, string _textureName, float _u1, float _v1, float _w1, float _u2, float _v2, float _w2, float _u3, float _v3, float _w3)
		{
			unsafe {
				if (fn__drawSpritePoly2 == null) fn__drawSpritePoly2 = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, int, float, float, float, int, float, float, float, int, nint, nint, float, float, float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_drawSpritePoly2");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				fn__drawSpritePoly2(_x1, _y1, _z1, _x2, _y2, _z2, _x3, _y3, _z3, _red1, _green1, _blue1, _alpha1, _red2, _green2, _blue2, _alpha2, _red3, _green3, _blue3, _alpha3, ptr_textureDict, ptr_textureName, _u1, _v1, _w1, _u2, _v2, _w2, _u3, _v3, _w3);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
			}
		}

		public void DrawBox(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawBox == null) fn__drawBox = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawBox");
				fn__drawBox(_x1, _y1, _z1, _x2, _y2, _z2, _red, _green, _blue, _alpha);
			}
		}

		public void SetBackfaceculling(bool _toggle)
		{
			unsafe {
				if (fn__setBackfaceculling == null) fn__setBackfaceculling = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setBackfaceculling");
				fn__setBackfaceculling(_toggle);
			}
		}

		public void _0xC5C8F970D4EDFF71(int _p0)
		{
			unsafe {
				if (fn__0xC5C8F970D4EDFF71 == null) fn__0xC5C8F970D4EDFF71 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC5C8F970D4EDFF71");
				fn__0xC5C8F970D4EDFF71(_p0);
			}
		}

		public int BeginTakeMissionCreatorPhoto()
		{
			unsafe {
				if (fn__beginTakeMissionCreatorPhoto == null) fn__beginTakeMissionCreatorPhoto = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_beginTakeMissionCreatorPhoto");
				var result = fn__beginTakeMissionCreatorPhoto();
				return result;
			}
		}

		public int GetStatusOfTakeMissionCreatorPhoto()
		{
			unsafe {
				if (fn__getStatusOfTakeMissionCreatorPhoto == null) fn__getStatusOfTakeMissionCreatorPhoto = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getStatusOfTakeMissionCreatorPhoto");
				var result = fn__getStatusOfTakeMissionCreatorPhoto();
				return result;
			}
		}

		public void FreeMemoryForMissionCreatorPhoto()
		{
			unsafe {
				if (fn__freeMemoryForMissionCreatorPhoto == null) fn__freeMemoryForMissionCreatorPhoto = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_freeMemoryForMissionCreatorPhoto");
				fn__freeMemoryForMissionCreatorPhoto();
			}
		}

		public bool LoadMissionCreatorPhoto(ref int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__loadMissionCreatorPhoto == null) fn__loadMissionCreatorPhoto = (delegate* unmanaged[Cdecl]<int*, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_loadMissionCreatorPhoto");
				var ref_p0 = _p0;
				var result = fn__loadMissionCreatorPhoto(&ref_p0, _p1, _p2, _p3);
				_p0 = ref_p0;
				return result;
			}
		}

		public int GetStatusOfLoadMissionCreatorPhoto(ref int _p0)
		{
			unsafe {
				if (fn__getStatusOfLoadMissionCreatorPhoto == null) fn__getStatusOfLoadMissionCreatorPhoto = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_getStatusOfLoadMissionCreatorPhoto");
				var ref_p0 = _p0;
				var result = fn__getStatusOfLoadMissionCreatorPhoto(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public int _0x7FA5D82B8F58EC06()
		{
			unsafe {
				if (fn__0x7FA5D82B8F58EC06 == null) fn__0x7FA5D82B8F58EC06 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x7FA5D82B8F58EC06");
				var result = fn__0x7FA5D82B8F58EC06();
				return result;
			}
		}

		public int _0x5B0316762AFD4A64()
		{
			unsafe {
				if (fn__0x5B0316762AFD4A64 == null) fn__0x5B0316762AFD4A64 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x5B0316762AFD4A64");
				var result = fn__0x5B0316762AFD4A64();
				return result;
			}
		}

		public void _0x346EF3ECAAAB149E()
		{
			unsafe {
				if (fn__0x346EF3ECAAAB149E == null) fn__0x346EF3ECAAAB149E = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x346EF3ECAAAB149E");
				fn__0x346EF3ECAAAB149E();
			}
		}

		public bool BeginTakeHighQualityPhoto()
		{
			unsafe {
				if (fn__beginTakeHighQualityPhoto == null) fn__beginTakeHighQualityPhoto = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_beginTakeHighQualityPhoto");
				var result = fn__beginTakeHighQualityPhoto();
				return result;
			}
		}

		public int GetStatusOfTakeHighQualityPhoto()
		{
			unsafe {
				if (fn__getStatusOfTakeHighQualityPhoto == null) fn__getStatusOfTakeHighQualityPhoto = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getStatusOfTakeHighQualityPhoto");
				var result = fn__getStatusOfTakeHighQualityPhoto();
				return result;
			}
		}

		public void FreeMemoryForHighQualityPhoto()
		{
			unsafe {
				if (fn__freeMemoryForHighQualityPhoto == null) fn__freeMemoryForHighQualityPhoto = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_freeMemoryForHighQualityPhoto");
				fn__freeMemoryForHighQualityPhoto();
			}
		}

		public void _0x1BBC135A4D25EDDE(bool _p0)
		{
			unsafe {
				if (fn__0x1BBC135A4D25EDDE == null) fn__0x1BBC135A4D25EDDE = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x1BBC135A4D25EDDE");
				fn__0x1BBC135A4D25EDDE(_p0);
			}
		}

		public void _0xF3F776ADA161E47D(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xF3F776ADA161E47D == null) fn__0xF3F776ADA161E47D = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xF3F776ADA161E47D");
				fn__0xF3F776ADA161E47D(_p0, _p1);
			}
		}

		public bool SaveHighQualityPhoto(int _unused)
		{
			unsafe {
				if (fn__saveHighQualityPhoto == null) fn__saveHighQualityPhoto = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_saveHighQualityPhoto");
				var result = fn__saveHighQualityPhoto(_unused);
				return result;
			}
		}

		public int GetStatusOfSaveHighQualityPhoto()
		{
			unsafe {
				if (fn__getStatusOfSaveHighQualityPhoto == null) fn__getStatusOfSaveHighQualityPhoto = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getStatusOfSaveHighQualityPhoto");
				var result = fn__getStatusOfSaveHighQualityPhoto();
				return result;
			}
		}

		public bool _0x759650634F07B6B4(int _p0)
		{
			unsafe {
				if (fn__0x759650634F07B6B4 == null) fn__0x759650634F07B6B4 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x759650634F07B6B4");
				var result = fn__0x759650634F07B6B4(_p0);
				return result;
			}
		}

		public int _0xCB82A0BF0E3E3265(int _p0)
		{
			unsafe {
				if (fn__0xCB82A0BF0E3E3265 == null) fn__0xCB82A0BF0E3E3265 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xCB82A0BF0E3E3265");
				var result = fn__0xCB82A0BF0E3E3265(_p0);
				return result;
			}
		}

		public void FreeMemoryForLowQualityPhoto()
		{
			unsafe {
				if (fn__freeMemoryForLowQualityPhoto == null) fn__freeMemoryForLowQualityPhoto = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_freeMemoryForLowQualityPhoto");
				fn__freeMemoryForLowQualityPhoto();
			}
		}

		public void DrawLowQualityPhotoToPhone(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__drawLowQualityPhotoToPhone == null) fn__drawLowQualityPhotoToPhone = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_drawLowQualityPhotoToPhone");
				fn__drawLowQualityPhotoToPhone(_p0, _p1);
			}
		}

		public int GetMaximumNumberOfPhotos()
		{
			unsafe {
				if (fn__getMaximumNumberOfPhotos == null) fn__getMaximumNumberOfPhotos = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMaximumNumberOfPhotos");
				var result = fn__getMaximumNumberOfPhotos();
				return result;
			}
		}

		public int GetMaximumNumberOfCloudPhotos()
		{
			unsafe {
				if (fn__getMaximumNumberOfCloudPhotos == null) fn__getMaximumNumberOfCloudPhotos = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMaximumNumberOfCloudPhotos");
				var result = fn__getMaximumNumberOfCloudPhotos();
				return result;
			}
		}

		public int GetCurrentNumberOfCloudPhotos()
		{
			unsafe {
				if (fn__getCurrentNumberOfCloudPhotos == null) fn__getCurrentNumberOfCloudPhotos = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCurrentNumberOfCloudPhotos");
				var result = fn__getCurrentNumberOfCloudPhotos();
				return result;
			}
		}

		public int _0x2A893980E96B659A(int _p0)
		{
			unsafe {
				if (fn__0x2A893980E96B659A == null) fn__0x2A893980E96B659A = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x2A893980E96B659A");
				var result = fn__0x2A893980E96B659A(_p0);
				return result;
			}
		}

		public int GetStatusOfSortedListOperation(int _p0)
		{
			unsafe {
				if (fn__getStatusOfSortedListOperation == null) fn__getStatusOfSortedListOperation = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getStatusOfSortedListOperation");
				var result = fn__getStatusOfSortedListOperation(_p0);
				return result;
			}
		}

		public void _0x4AF92ACD3141D96C()
		{
			unsafe {
				if (fn__0x4AF92ACD3141D96C == null) fn__0x4AF92ACD3141D96C = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x4AF92ACD3141D96C");
				fn__0x4AF92ACD3141D96C();
			}
		}

		public int _0xE791DF1F73ED2C8B(int _p0)
		{
			unsafe {
				if (fn__0xE791DF1F73ED2C8B == null) fn__0xE791DF1F73ED2C8B = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xE791DF1F73ED2C8B");
				var result = fn__0xE791DF1F73ED2C8B(_p0);
				return result;
			}
		}

		public int _0xEC72C258667BE5EA(int _p0)
		{
			unsafe {
				if (fn__0xEC72C258667BE5EA == null) fn__0xEC72C258667BE5EA = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xEC72C258667BE5EA");
				var result = fn__0xEC72C258667BE5EA(_p0);
				return result;
			}
		}

		public int ReturnTwo(int _p0)
		{
			unsafe {
				if (fn__returnTwo == null) fn__returnTwo = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_returnTwo");
				var result = fn__returnTwo(_p0);
				return result;
			}
		}

		public void DrawLightWithRangeAndShadow(float _x, float _y, float _z, int _r, int _g, int _b, float _range, float _intensity, float _shadow)
		{
			unsafe {
				if (fn__drawLightWithRangeAndShadow == null) fn__drawLightWithRangeAndShadow = (delegate* unmanaged[Cdecl]<float, float, float, int, int, int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_drawLightWithRangeAndShadow");
				fn__drawLightWithRangeAndShadow(_x, _y, _z, _r, _g, _b, _range, _intensity, _shadow);
			}
		}

		public void DrawLightWithRange(float _posX, float _posY, float _posZ, int _colorR, int _colorG, int _colorB, float _range, float _intensity)
		{
			unsafe {
				if (fn__drawLightWithRange == null) fn__drawLightWithRange = (delegate* unmanaged[Cdecl]<float, float, float, int, int, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_drawLightWithRange");
				fn__drawLightWithRange(_posX, _posY, _posZ, _colorR, _colorG, _colorB, _range, _intensity);
			}
		}

		public void DrawSpotLight(float _posX, float _posY, float _posZ, float _dirX, float _dirY, float _dirZ, int _colorR, int _colorG, int _colorB, float _distance, float _brightness, float _hardness, float _radius, float _falloff)
		{
			unsafe {
				if (fn__drawSpotLight == null) fn__drawSpotLight = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_drawSpotLight");
				fn__drawSpotLight(_posX, _posY, _posZ, _dirX, _dirY, _dirZ, _colorR, _colorG, _colorB, _distance, _brightness, _hardness, _radius, _falloff);
			}
		}

		public void DrawSpotLightWithShadow(float _posX, float _posY, float _posZ, float _dirX, float _dirY, float _dirZ, int _colorR, int _colorG, int _colorB, float _distance, float _brightness, float _roundness, float _radius, float _falloff, int _shadowId)
		{
			unsafe {
				if (fn__drawSpotLightWithShadow == null) fn__drawSpotLightWithShadow = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_drawSpotLightWithShadow");
				fn__drawSpotLightWithShadow(_posX, _posY, _posZ, _dirX, _dirY, _dirZ, _colorR, _colorG, _colorB, _distance, _brightness, _roundness, _radius, _falloff, _shadowId);
			}
		}

		public void FadeUpPedLight(float _p0)
		{
			unsafe {
				if (fn__fadeUpPedLight == null) fn__fadeUpPedLight = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_fadeUpPedLight");
				fn__fadeUpPedLight(_p0);
			}
		}

		public void UpdateLightsOnEntity(int _entity)
		{
			unsafe {
				if (fn__updateLightsOnEntity == null) fn__updateLightsOnEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_updateLightsOnEntity");
				fn__updateLightsOnEntity(_entity);
			}
		}

		public void _0x9641588DAB93B4B5(int _p0)
		{
			unsafe {
				if (fn__0x9641588DAB93B4B5 == null) fn__0x9641588DAB93B4B5 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x9641588DAB93B4B5");
				fn__0x9641588DAB93B4B5(_p0);
			}
		}

		public int _0x393BD2275CEB7793()
		{
			unsafe {
				if (fn__0x393BD2275CEB7793 == null) fn__0x393BD2275CEB7793 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x393BD2275CEB7793");
				var result = fn__0x393BD2275CEB7793();
				return result;
			}
		}

		public void DrawMarker(int _type, float _posX, float _posY, float _posZ, float _dirX, float _dirY, float _dirZ, float _rotX, float _rotY, float _rotZ, float _scaleX, float _scaleY, float _scaleZ, int _red, int _green, int _blue, int _alpha, bool _bobUpAndDown, bool _faceCamera, int _p19, bool _rotate, string _textureDict, string _textureName, bool _drawOnEnts)
		{
			unsafe {
				if (fn__drawMarker == null) fn__drawMarker = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, int, int, int, int, bool, bool, int, bool, nint, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_drawMarker");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				fn__drawMarker(_type, _posX, _posY, _posZ, _dirX, _dirY, _dirZ, _rotX, _rotY, _rotZ, _scaleX, _scaleY, _scaleZ, _red, _green, _blue, _alpha, _bobUpAndDown, _faceCamera, _p19, _rotate, ptr_textureDict, ptr_textureName, _drawOnEnts);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
			}
		}

		public void DrawMarker2(int _type, float _posX, float _posY, float _posZ, float _dirX, float _dirY, float _dirZ, float _rotX, float _rotY, float _rotZ, float _scaleX, float _scaleY, float _scaleZ, int _red, int _green, int _blue, int _alpha, bool _bobUpAndDown, bool _faceCamera, int _p19, bool _rotate, string _textureDict, string _textureName, bool _drawOnEnts, bool _p24, bool _p25)
		{
			unsafe {
				if (fn__drawMarker2 == null) fn__drawMarker2 = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, int, int, int, int, bool, bool, int, bool, nint, nint, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_drawMarker2");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				fn__drawMarker2(_type, _posX, _posY, _posZ, _dirX, _dirY, _dirZ, _rotX, _rotY, _rotZ, _scaleX, _scaleY, _scaleZ, _red, _green, _blue, _alpha, _bobUpAndDown, _faceCamera, _p19, _rotate, ptr_textureDict, ptr_textureName, _drawOnEnts, _p24, _p25);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
			}
		}

		public void DrawSphere(float _x, float _y, float _z, float _radius, int _red, int _green, int _blue, float _alpha)
		{
			unsafe {
				if (fn__drawSphere == null) fn__drawSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, float, void>) NativeLibrary.GetExport(handle, "Native_drawSphere");
				fn__drawSphere(_x, _y, _z, _radius, _red, _green, _blue, _alpha);
			}
		}

		public int CreateCheckpoint(int _type, float _posX1, float _posY1, float _posZ1, float _posX2, float _posY2, float _posZ2, float _diameter, int _red, int _green, int _blue, int _alpha, int _reserved)
		{
			unsafe {
				if (fn__createCheckpoint == null) fn__createCheckpoint = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_createCheckpoint");
				var result = fn__createCheckpoint(_type, _posX1, _posY1, _posZ1, _posX2, _posY2, _posZ2, _diameter, _red, _green, _blue, _alpha, _reserved);
				return result;
			}
		}

		public void SetCheckpointScale(int _checkpoint, float _p0)
		{
			unsafe {
				if (fn__setCheckpointScale == null) fn__setCheckpointScale = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCheckpointScale");
				fn__setCheckpointScale(_checkpoint, _p0);
			}
		}

		public void SetCheckpointIconScale(int _checkpoint, float _scale)
		{
			unsafe {
				if (fn__setCheckpointIconScale == null) fn__setCheckpointIconScale = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCheckpointIconScale");
				fn__setCheckpointIconScale(_checkpoint, _scale);
			}
		}

		public void SetCheckpointCylinderHeight(int _checkpoint, float _nearHeight, float _farHeight, float _radius)
		{
			unsafe {
				if (fn__setCheckpointCylinderHeight == null) fn__setCheckpointCylinderHeight = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setCheckpointCylinderHeight");
				fn__setCheckpointCylinderHeight(_checkpoint, _nearHeight, _farHeight, _radius);
			}
		}

		public void SetCheckpointRgba(int _checkpoint, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__setCheckpointRgba == null) fn__setCheckpointRgba = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setCheckpointRgba");
				fn__setCheckpointRgba(_checkpoint, _red, _green, _blue, _alpha);
			}
		}

		public void SetCheckpointRgba2(int _checkpoint, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__setCheckpointRgba2 == null) fn__setCheckpointRgba2 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setCheckpointRgba2");
				fn__setCheckpointRgba2(_checkpoint, _red, _green, _blue, _alpha);
			}
		}

		public void _0xF51D36185993515D(int _checkpoint, float _posX, float _posY, float _posZ, float _unkX, float _unkY, float _unkZ)
		{
			unsafe {
				if (fn__0xF51D36185993515D == null) fn__0xF51D36185993515D = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0xF51D36185993515D");
				fn__0xF51D36185993515D(_checkpoint, _posX, _posY, _posZ, _unkX, _unkY, _unkZ);
			}
		}

		public void _0xFCF6788FC4860CD4(int _checkpoint)
		{
			unsafe {
				if (fn__0xFCF6788FC4860CD4 == null) fn__0xFCF6788FC4860CD4 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xFCF6788FC4860CD4");
				fn__0xFCF6788FC4860CD4(_checkpoint);
			}
		}

		public void _0x615D3925E87A3B26(int _checkpoint)
		{
			unsafe {
				if (fn__0x615D3925E87A3B26 == null) fn__0x615D3925E87A3B26 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x615D3925E87A3B26");
				fn__0x615D3925E87A3B26(_checkpoint);
			}
		}

		public void _0xDB1EA9411C8911EC(int _p0)
		{
			unsafe {
				if (fn__0xDB1EA9411C8911EC == null) fn__0xDB1EA9411C8911EC = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xDB1EA9411C8911EC");
				fn__0xDB1EA9411C8911EC(_p0);
			}
		}

		public void _0x3C788E7F6438754D(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x3C788E7F6438754D == null) fn__0x3C788E7F6438754D = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x3C788E7F6438754D");
				fn__0x3C788E7F6438754D(_p0, _p1, _p2, _p3);
			}
		}

		public void DeleteCheckpoint(int _checkpoint)
		{
			unsafe {
				if (fn__deleteCheckpoint == null) fn__deleteCheckpoint = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_deleteCheckpoint");
				fn__deleteCheckpoint(_checkpoint);
			}
		}

		public void DontRenderInGameUi(bool _p0)
		{
			unsafe {
				if (fn__dontRenderInGameUi == null) fn__dontRenderInGameUi = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_dontRenderInGameUi");
				fn__dontRenderInGameUi(_p0);
			}
		}

		public void ForceRenderInGameUi(bool _toggle)
		{
			unsafe {
				if (fn__forceRenderInGameUi == null) fn__forceRenderInGameUi = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_forceRenderInGameUi");
				fn__forceRenderInGameUi(_toggle);
			}
		}

		public void RequestStreamedTextureDict(string _textureDict, bool _p1)
		{
			unsafe {
				if (fn__requestStreamedTextureDict == null) fn__requestStreamedTextureDict = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_requestStreamedTextureDict");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				fn__requestStreamedTextureDict(ptr_textureDict, _p1);
				Marshal.FreeHGlobal(ptr_textureDict);
			}
		}

		public bool HasStreamedTextureDictLoaded(string _textureDict)
		{
			unsafe {
				if (fn__hasStreamedTextureDictLoaded == null) fn__hasStreamedTextureDictLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasStreamedTextureDictLoaded");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var result = fn__hasStreamedTextureDictLoaded(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureDict);
				return result;
			}
		}

		public void SetStreamedTextureDictAsNoLongerNeeded(string _textureDict)
		{
			unsafe {
				if (fn__setStreamedTextureDictAsNoLongerNeeded == null) fn__setStreamedTextureDictAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setStreamedTextureDictAsNoLongerNeeded");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				fn__setStreamedTextureDictAsNoLongerNeeded(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureDict);
			}
		}

		public void DrawRect(float _x, float _y, float _width, float _height, int _r, int _g, int _b, int _a, bool _p8)
		{
			unsafe {
				if (fn__drawRect == null) fn__drawRect = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_drawRect");
				fn__drawRect(_x, _y, _width, _height, _r, _g, _b, _a, _p8);
			}
		}

		public void SetScriptGfxDrawBehindPausemenu(bool _toggle)
		{
			unsafe {
				if (fn__setScriptGfxDrawBehindPausemenu == null) fn__setScriptGfxDrawBehindPausemenu = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setScriptGfxDrawBehindPausemenu");
				fn__setScriptGfxDrawBehindPausemenu(_toggle);
			}
		}

		public void SetScriptGfxDrawOrder(int _drawOrder)
		{
			unsafe {
				if (fn__setScriptGfxDrawOrder == null) fn__setScriptGfxDrawOrder = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setScriptGfxDrawOrder");
				fn__setScriptGfxDrawOrder(_drawOrder);
			}
		}

		public void SetScriptGfxAlign(int _horizontalAlign, int _verticalAlign)
		{
			unsafe {
				if (fn__setScriptGfxAlign == null) fn__setScriptGfxAlign = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setScriptGfxAlign");
				fn__setScriptGfxAlign(_horizontalAlign, _verticalAlign);
			}
		}

		public void ResetScriptGfxAlign()
		{
			unsafe {
				if (fn__resetScriptGfxAlign == null) fn__resetScriptGfxAlign = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetScriptGfxAlign");
				fn__resetScriptGfxAlign();
			}
		}

		public void SetScriptGfxAlignParams(float _x, float _y, float _w, float _h)
		{
			unsafe {
				if (fn__setScriptGfxAlignParams == null) fn__setScriptGfxAlignParams = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setScriptGfxAlignParams");
				fn__setScriptGfxAlignParams(_x, _y, _w, _h);
			}
		}

		public void GetScriptGfxPosition(float _x, float _y, ref float _calculatedX, ref float _calculatedY)
		{
			unsafe {
				if (fn__getScriptGfxPosition == null) fn__getScriptGfxPosition = (delegate* unmanaged[Cdecl]<float, float, float*, float*, void>) NativeLibrary.GetExport(handle, "Native_getScriptGfxPosition");
				var ref_calculatedX = _calculatedX;
				var ref_calculatedY = _calculatedY;
				fn__getScriptGfxPosition(_x, _y, &ref_calculatedX, &ref_calculatedY);
				_calculatedX = ref_calculatedX;
				_calculatedY = ref_calculatedY;
			}
		}

		public float GetSafeZoneSize()
		{
			unsafe {
				if (fn__getSafeZoneSize == null) fn__getSafeZoneSize = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getSafeZoneSize");
				var result = fn__getSafeZoneSize();
				return result;
			}
		}

		public void DrawSprite(string _textureDict, string _textureName, float _screenX, float _screenY, float _width, float _height, float _heading, int _red, int _green, int _blue, int _alpha, bool _p11)
		{
			unsafe {
				if (fn__drawSprite == null) fn__drawSprite = (delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, int, int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_drawSprite");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				fn__drawSprite(ptr_textureDict, ptr_textureName, _screenX, _screenY, _width, _height, _heading, _red, _green, _blue, _alpha, _p11);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
			}
		}

		public void _0x2D3B147AFAD49DE0(string _textureDict, string _textureName, float _x, float _y, float _width, float _height, float _p6, int _red, int _green, int _blue, int _alpha, int _p11)
		{
			unsafe {
				if (fn__0x2D3B147AFAD49DE0 == null) fn__0x2D3B147AFAD49DE0 = (delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2D3B147AFAD49DE0");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				fn__0x2D3B147AFAD49DE0(ptr_textureDict, ptr_textureName, _x, _y, _width, _height, _p6, _red, _green, _blue, _alpha, _p11);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
			}
		}

		public void DrawInteractiveSprite(string _textureDict, string _textureName, float _screenX, float _screenY, float _width, float _height, float _heading, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawInteractiveSprite == null) fn__drawInteractiveSprite = (delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawInteractiveSprite");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				fn__drawInteractiveSprite(ptr_textureDict, ptr_textureName, _screenX, _screenY, _width, _height, _heading, _red, _green, _blue, _alpha);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
			}
		}

		public void DrawSpriteUv(string _textureDict, string _textureName, float _x, float _y, float _width, float _height, float _u1, float _v1, float _u2, float _v2, float _heading, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawSpriteUv == null) fn__drawSpriteUv = (delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawSpriteUv");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				fn__drawSpriteUv(ptr_textureDict, ptr_textureName, _x, _y, _width, _height, _u1, _v1, _u2, _v2, _heading, _red, _green, _blue, _alpha);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
			}
		}

		public int AddEntityIcon(int _entity, string _icon)
		{
			unsafe {
				if (fn__addEntityIcon == null) fn__addEntityIcon = (delegate* unmanaged[Cdecl]<int, nint, int>) NativeLibrary.GetExport(handle, "Native_addEntityIcon");
				var ptr_icon = MemoryUtils.StringToHGlobalUtf8(_icon);
				var result = fn__addEntityIcon(_entity, ptr_icon);
				Marshal.FreeHGlobal(ptr_icon);
				return result;
			}
		}

		public void SetEntityIconVisibility(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityIconVisibility == null) fn__setEntityIconVisibility = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityIconVisibility");
				fn__setEntityIconVisibility(_entity, _toggle);
			}
		}

		public void SetEntityIconColor(int _entity, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__setEntityIconColor == null) fn__setEntityIconColor = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setEntityIconColor");
				fn__setEntityIconColor(_entity, _red, _green, _blue, _alpha);
			}
		}

		public void SetDrawOrigin(float _x, float _y, float _z, int _p3)
		{
			unsafe {
				if (fn__setDrawOrigin == null) fn__setDrawOrigin = (delegate* unmanaged[Cdecl]<float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setDrawOrigin");
				fn__setDrawOrigin(_x, _y, _z, _p3);
			}
		}

		public void ClearDrawOrigin()
		{
			unsafe {
				if (fn__clearDrawOrigin == null) fn__clearDrawOrigin = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearDrawOrigin");
				fn__clearDrawOrigin();
			}
		}

		public int SetBinkMovie(string _name)
		{
			unsafe {
				if (fn__setBinkMovie == null) fn__setBinkMovie = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_setBinkMovie");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__setBinkMovie(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public void PlayBinkMovie(int _binkMovie)
		{
			unsafe {
				if (fn__playBinkMovie == null) fn__playBinkMovie = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playBinkMovie");
				fn__playBinkMovie(_binkMovie);
			}
		}

		public void StopBinkMovie(int _binkMovie)
		{
			unsafe {
				if (fn__stopBinkMovie == null) fn__stopBinkMovie = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopBinkMovie");
				fn__stopBinkMovie(_binkMovie);
			}
		}

		public void ReleaseBinkMovie(int _binkMovie)
		{
			unsafe {
				if (fn__releaseBinkMovie == null) fn__releaseBinkMovie = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_releaseBinkMovie");
				fn__releaseBinkMovie(_binkMovie);
			}
		}

		public void DrawBinkMovie(int _binkMovie, float _p1, float _p2, float _p3, float _p4, float _p5, int _r, int _g, int _b, int _a)
		{
			unsafe {
				if (fn__drawBinkMovie == null) fn__drawBinkMovie = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawBinkMovie");
				fn__drawBinkMovie(_binkMovie, _p1, _p2, _p3, _p4, _p5, _r, _g, _b, _a);
			}
		}

		public void SetBinkMovieTime(int _binkMovie, float _progress)
		{
			unsafe {
				if (fn__setBinkMovieTime == null) fn__setBinkMovieTime = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setBinkMovieTime");
				fn__setBinkMovieTime(_binkMovie, _progress);
			}
		}

		public float GetBinkMovieTime(int _binkMovie)
		{
			unsafe {
				if (fn__getBinkMovieTime == null) fn__getBinkMovieTime = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getBinkMovieTime");
				var result = fn__getBinkMovieTime(_binkMovie);
				return result;
			}
		}

		public void SetBinkMovieVolume(int _binkMovie, float _value)
		{
			unsafe {
				if (fn__setBinkMovieVolume == null) fn__setBinkMovieVolume = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setBinkMovieVolume");
				fn__setBinkMovieVolume(_binkMovie, _value);
			}
		}

		public void AttachTvAudioToEntity(int _entity)
		{
			unsafe {
				if (fn__attachTvAudioToEntity == null) fn__attachTvAudioToEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_attachTvAudioToEntity");
				fn__attachTvAudioToEntity(_entity);
			}
		}

		public void SetBinkMovieUnk2(int _binkMovie, bool _p1)
		{
			unsafe {
				if (fn__setBinkMovieUnk2 == null) fn__setBinkMovieUnk2 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBinkMovieUnk2");
				fn__setBinkMovieUnk2(_binkMovie, _p1);
			}
		}

		public void SetTvAudioFrontend(bool _toggle)
		{
			unsafe {
				if (fn__setTvAudioFrontend == null) fn__setTvAudioFrontend = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setTvAudioFrontend");
				fn__setTvAudioFrontend(_toggle);
			}
		}

		public void SetBinkShouldSkip(int _binkMovie, bool _bShouldSkip)
		{
			unsafe {
				if (fn__setBinkShouldSkip == null) fn__setBinkShouldSkip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBinkShouldSkip");
				fn__setBinkShouldSkip(_binkMovie, _bShouldSkip);
			}
		}

		public int LoadMovieMeshSet(string _movieMeshSetName)
		{
			unsafe {
				if (fn__loadMovieMeshSet == null) fn__loadMovieMeshSet = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_loadMovieMeshSet");
				var ptr_movieMeshSetName = MemoryUtils.StringToHGlobalUtf8(_movieMeshSetName);
				var result = fn__loadMovieMeshSet(ptr_movieMeshSetName);
				Marshal.FreeHGlobal(ptr_movieMeshSetName);
				return result;
			}
		}

		public void ReleaseMovieMeshSet(int _movieMeshSet)
		{
			unsafe {
				if (fn__releaseMovieMeshSet == null) fn__releaseMovieMeshSet = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_releaseMovieMeshSet");
				fn__releaseMovieMeshSet(_movieMeshSet);
			}
		}

		public int QueryMovieMeshSetState(int _p0)
		{
			unsafe {
				if (fn__queryMovieMeshSetState == null) fn__queryMovieMeshSetState = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_queryMovieMeshSetState");
				var result = fn__queryMovieMeshSetState(_p0);
				return result;
			}
		}

		public void GetScreenResolution(ref int _x, ref int _y)
		{
			unsafe {
				if (fn__getScreenResolution == null) fn__getScreenResolution = (delegate* unmanaged[Cdecl]<int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getScreenResolution");
				var ref_x = _x;
				var ref_y = _y;
				fn__getScreenResolution(&ref_x, &ref_y);
				_x = ref_x;
				_y = ref_y;
			}
		}

		public void GetActiveScreenResolution(ref int _x, ref int _y)
		{
			unsafe {
				if (fn__getActiveScreenResolution == null) fn__getActiveScreenResolution = (delegate* unmanaged[Cdecl]<int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getActiveScreenResolution");
				var ref_x = _x;
				var ref_y = _y;
				fn__getActiveScreenResolution(&ref_x, &ref_y);
				_x = ref_x;
				_y = ref_y;
			}
		}

		public float GetAspectRatio(bool _b)
		{
			unsafe {
				if (fn__getAspectRatio == null) fn__getAspectRatio = (delegate* unmanaged[Cdecl]<bool, float>) NativeLibrary.GetExport(handle, "Native_getAspectRatio");
				var result = fn__getAspectRatio(_b);
				return result;
			}
		}

		public int _0xB2EBE8CBC58B90E9()
		{
			unsafe {
				if (fn__0xB2EBE8CBC58B90E9 == null) fn__0xB2EBE8CBC58B90E9 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xB2EBE8CBC58B90E9");
				var result = fn__0xB2EBE8CBC58B90E9();
				return result;
			}
		}

		public bool GetIsWidescreen()
		{
			unsafe {
				if (fn__getIsWidescreen == null) fn__getIsWidescreen = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getIsWidescreen");
				var result = fn__getIsWidescreen();
				return result;
			}
		}

		public bool GetIsHidef()
		{
			unsafe {
				if (fn__getIsHidef == null) fn__getIsHidef = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getIsHidef");
				var result = fn__getIsHidef();
				return result;
			}
		}

		public void _0xEFABC7722293DA7C()
		{
			unsafe {
				if (fn__0xEFABC7722293DA7C == null) fn__0xEFABC7722293DA7C = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xEFABC7722293DA7C");
				fn__0xEFABC7722293DA7C();
			}
		}

		public void SetNightvision(bool _toggle)
		{
			unsafe {
				if (fn__setNightvision == null) fn__setNightvision = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setNightvision");
				fn__setNightvision(_toggle);
			}
		}

		public bool GetRequestingnightvision()
		{
			unsafe {
				if (fn__getRequestingnightvision == null) fn__getRequestingnightvision = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getRequestingnightvision");
				var result = fn__getRequestingnightvision();
				return result;
			}
		}

		public bool GetUsingnightvision()
		{
			unsafe {
				if (fn__getUsingnightvision == null) fn__getUsingnightvision = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getUsingnightvision");
				var result = fn__getUsingnightvision();
				return result;
			}
		}

		public void _0xEF398BEEE4EF45F9(bool _p0)
		{
			unsafe {
				if (fn__0xEF398BEEE4EF45F9 == null) fn__0xEF398BEEE4EF45F9 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xEF398BEEE4EF45F9");
				fn__0xEF398BEEE4EF45F9(_p0);
			}
		}

		public void _0x814AF7DCAACC597B(int _p0)
		{
			unsafe {
				if (fn__0x814AF7DCAACC597B == null) fn__0x814AF7DCAACC597B = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x814AF7DCAACC597B");
				fn__0x814AF7DCAACC597B(_p0);
			}
		}

		public void _0x43FA7CBE20DAB219(int _p0)
		{
			unsafe {
				if (fn__0x43FA7CBE20DAB219 == null) fn__0x43FA7CBE20DAB219 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x43FA7CBE20DAB219");
				fn__0x43FA7CBE20DAB219(_p0);
			}
		}

		public void SetNoiseoveride(bool _toggle)
		{
			unsafe {
				if (fn__setNoiseoveride == null) fn__setNoiseoveride = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setNoiseoveride");
				fn__setNoiseoveride(_toggle);
			}
		}

		public void SetNoisinessoveride(float _value)
		{
			unsafe {
				if (fn__setNoisinessoveride == null) fn__setNoisinessoveride = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setNoisinessoveride");
				fn__setNoisinessoveride(_value);
			}
		}

		public bool GetScreenCoordFromWorldCoord(float _worldX, float _worldY, float _worldZ, ref float _screenX, ref float _screenY)
		{
			unsafe {
				if (fn__getScreenCoordFromWorldCoord == null) fn__getScreenCoordFromWorldCoord = (delegate* unmanaged[Cdecl]<float, float, float, float*, float*, bool>) NativeLibrary.GetExport(handle, "Native_getScreenCoordFromWorldCoord");
				var ref_screenX = _screenX;
				var ref_screenY = _screenY;
				var result = fn__getScreenCoordFromWorldCoord(_worldX, _worldY, _worldZ, &ref_screenX, &ref_screenY);
				_screenX = ref_screenX;
				_screenY = ref_screenY;
				return result;
			}
		}

		public Vector3 GetTextureResolution(string _textureDict, string _textureName)
		{
			unsafe {
				if (fn__getTextureResolution == null) fn__getTextureResolution = (delegate* unmanaged[Cdecl]<nint, nint, Vector3>) NativeLibrary.GetExport(handle, "Native_getTextureResolution");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				var result = fn__getTextureResolution(ptr_textureDict, ptr_textureName);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
				return result;
			}
		}

		public bool OverridePedBadgeTexture(int _ped, string _txd, string _txn)
		{
			unsafe {
				if (fn__overridePedBadgeTexture == null) fn__overridePedBadgeTexture = (delegate* unmanaged[Cdecl]<int, nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_overridePedBadgeTexture");
				var ptr_txd = MemoryUtils.StringToHGlobalUtf8(_txd);
				var ptr_txn = MemoryUtils.StringToHGlobalUtf8(_txn);
				var result = fn__overridePedBadgeTexture(_ped, ptr_txd, ptr_txn);
				Marshal.FreeHGlobal(ptr_txd);
				Marshal.FreeHGlobal(ptr_txn);
				return result;
			}
		}

		public void _0xE2892E7E55D7073A(float _p0)
		{
			unsafe {
				if (fn__0xE2892E7E55D7073A == null) fn__0xE2892E7E55D7073A = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0xE2892E7E55D7073A");
				fn__0xE2892E7E55D7073A(_p0);
			}
		}

		public void SetFlash(float _p0, float _p1, float _fadeIn, float _duration, float _fadeOut)
		{
			unsafe {
				if (fn__setFlash == null) fn__setFlash = (delegate* unmanaged[Cdecl]<float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setFlash");
				fn__setFlash(_p0, _p1, _fadeIn, _duration, _fadeOut);
			}
		}

		public void DisableOcclusionThisFrame()
		{
			unsafe {
				if (fn__disableOcclusionThisFrame == null) fn__disableOcclusionThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_disableOcclusionThisFrame");
				fn__disableOcclusionThisFrame();
			}
		}

		public void SetArtificialLightsState(bool _state)
		{
			unsafe {
				if (fn__setArtificialLightsState == null) fn__setArtificialLightsState = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setArtificialLightsState");
				fn__setArtificialLightsState(_state);
			}
		}

		public void SetArtificialLightsStateAffectsVehicles(bool _toggle)
		{
			unsafe {
				if (fn__setArtificialLightsStateAffectsVehicles == null) fn__setArtificialLightsStateAffectsVehicles = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setArtificialLightsStateAffectsVehicles");
				fn__setArtificialLightsStateAffectsVehicles(_toggle);
			}
		}

		public void _0xC35A6D07C93802B2()
		{
			unsafe {
				if (fn__0xC35A6D07C93802B2 == null) fn__0xC35A6D07C93802B2 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xC35A6D07C93802B2");
				fn__0xC35A6D07C93802B2();
			}
		}

		public int CreateTrackedPoint()
		{
			unsafe {
				if (fn__createTrackedPoint == null) fn__createTrackedPoint = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_createTrackedPoint");
				var result = fn__createTrackedPoint();
				return result;
			}
		}

		public void SetTrackedPointInfo(int _point, float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__setTrackedPointInfo == null) fn__setTrackedPointInfo = (delegate* unmanaged[Cdecl]<int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setTrackedPointInfo");
				fn__setTrackedPointInfo(_point, _x, _y, _z, _radius);
			}
		}

		public bool IsTrackedPointVisible(int _point)
		{
			unsafe {
				if (fn__isTrackedPointVisible == null) fn__isTrackedPointVisible = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isTrackedPointVisible");
				var result = fn__isTrackedPointVisible(_point);
				return result;
			}
		}

		public void DestroyTrackedPoint(int _point)
		{
			unsafe {
				if (fn__destroyTrackedPoint == null) fn__destroyTrackedPoint = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_destroyTrackedPoint");
				fn__destroyTrackedPoint(_point);
			}
		}

		public int _0xBE197EAA669238F4(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xBE197EAA669238F4 == null) fn__0xBE197EAA669238F4 = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0xBE197EAA669238F4");
				var result = fn__0xBE197EAA669238F4(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public void _0x61F95E5BB3E0A8C6(int _p0)
		{
			unsafe {
				if (fn__0x61F95E5BB3E0A8C6 == null) fn__0x61F95E5BB3E0A8C6 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x61F95E5BB3E0A8C6");
				fn__0x61F95E5BB3E0A8C6(_p0);
			}
		}

		public void _0xAE51BC858F32BA66(int _p0, float _p1, float _p2, float _p3, float _p4)
		{
			unsafe {
				if (fn__0xAE51BC858F32BA66 == null) fn__0xAE51BC858F32BA66 = (delegate* unmanaged[Cdecl]<int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0xAE51BC858F32BA66");
				fn__0xAE51BC858F32BA66(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void _0x649C97D52332341A(int _p0)
		{
			unsafe {
				if (fn__0x649C97D52332341A == null) fn__0x649C97D52332341A = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x649C97D52332341A");
				fn__0x649C97D52332341A(_p0);
			}
		}

		public int _0x2C42340F916C5930(int _p0)
		{
			unsafe {
				if (fn__0x2C42340F916C5930 == null) fn__0x2C42340F916C5930 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x2C42340F916C5930");
				var result = fn__0x2C42340F916C5930(_p0);
				return result;
			}
		}

		public void _0x14FC5833464340A8()
		{
			unsafe {
				if (fn__0x14FC5833464340A8 == null) fn__0x14FC5833464340A8 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x14FC5833464340A8");
				fn__0x14FC5833464340A8();
			}
		}

		public void _0x0218BA067D249DEA()
		{
			unsafe {
				if (fn__0x0218BA067D249DEA == null) fn__0x0218BA067D249DEA = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x0218BA067D249DEA");
				fn__0x0218BA067D249DEA();
			}
		}

		public void _0x1612C45F9E3E0D44()
		{
			unsafe {
				if (fn__0x1612C45F9E3E0D44 == null) fn__0x1612C45F9E3E0D44 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x1612C45F9E3E0D44");
				fn__0x1612C45F9E3E0D44();
			}
		}

		public void _0x5DEBD9C4DC995692()
		{
			unsafe {
				if (fn__0x5DEBD9C4DC995692 == null) fn__0x5DEBD9C4DC995692 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x5DEBD9C4DC995692");
				fn__0x5DEBD9C4DC995692();
			}
		}

		public void _0xAAE9BE70EC7C69AB(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7)
		{
			unsafe {
				if (fn__0xAAE9BE70EC7C69AB == null) fn__0xAAE9BE70EC7C69AB = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xAAE9BE70EC7C69AB");
				fn__0xAAE9BE70EC7C69AB(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
			}
		}

		public void GrassLodShrinkScriptAreas(float _x, float _y, float _z, float _radius, float _p4, float _p5, float _p6)
		{
			unsafe {
				if (fn__grassLodShrinkScriptAreas == null) fn__grassLodShrinkScriptAreas = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_grassLodShrinkScriptAreas");
				fn__grassLodShrinkScriptAreas(_x, _y, _z, _radius, _p4, _p5, _p6);
			}
		}

		public void GrassLodResetScriptAreas()
		{
			unsafe {
				if (fn__grassLodResetScriptAreas == null) fn__grassLodResetScriptAreas = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_grassLodResetScriptAreas");
				fn__grassLodResetScriptAreas();
			}
		}

		public void CascadeShadowsInitSession()
		{
			unsafe {
				if (fn__cascadeShadowsInitSession == null) fn__cascadeShadowsInitSession = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsInitSession");
				fn__cascadeShadowsInitSession();
			}
		}

		public void CascadeShadowsSetCascadeBounds(int _p0, bool _p1, float _p2, float _p3, float _p4, float _p5, bool _p6, float _p7)
		{
			unsafe {
				if (fn__cascadeShadowsSetCascadeBounds == null) fn__cascadeShadowsSetCascadeBounds = (delegate* unmanaged[Cdecl]<int, bool, float, float, float, float, bool, float, void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsSetCascadeBounds");
				fn__cascadeShadowsSetCascadeBounds(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
			}
		}

		public void CascadeShadowsSetCascadeBoundsScale(float _p0)
		{
			unsafe {
				if (fn__cascadeShadowsSetCascadeBoundsScale == null) fn__cascadeShadowsSetCascadeBoundsScale = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsSetCascadeBoundsScale");
				fn__cascadeShadowsSetCascadeBoundsScale(_p0);
			}
		}

		public void CascadeShadowsSetEntityTrackerScale(float _p0)
		{
			unsafe {
				if (fn__cascadeShadowsSetEntityTrackerScale == null) fn__cascadeShadowsSetEntityTrackerScale = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsSetEntityTrackerScale");
				fn__cascadeShadowsSetEntityTrackerScale(_p0);
			}
		}

		public void _0x36F6626459D91457(float _p0)
		{
			unsafe {
				if (fn__0x36F6626459D91457 == null) fn__0x36F6626459D91457 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x36F6626459D91457");
				fn__0x36F6626459D91457(_p0);
			}
		}

		public void _0x259BA6D4E6F808F1(int _p0)
		{
			unsafe {
				if (fn__0x259BA6D4E6F808F1 == null) fn__0x259BA6D4E6F808F1 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x259BA6D4E6F808F1");
				fn__0x259BA6D4E6F808F1(_p0);
			}
		}

		public void CascadeShadowsEnableEntityTracker(bool _toggle)
		{
			unsafe {
				if (fn__cascadeShadowsEnableEntityTracker == null) fn__cascadeShadowsEnableEntityTracker = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsEnableEntityTracker");
				fn__cascadeShadowsEnableEntityTracker(_toggle);
			}
		}

		public void _0x25FC3E33A31AD0C9(bool _p0)
		{
			unsafe {
				if (fn__0x25FC3E33A31AD0C9 == null) fn__0x25FC3E33A31AD0C9 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x25FC3E33A31AD0C9");
				fn__0x25FC3E33A31AD0C9(_p0);
			}
		}

		public void CascadeShadowsSetShadowSampleType(string _type)
		{
			unsafe {
				if (fn__cascadeShadowsSetShadowSampleType == null) fn__cascadeShadowsSetShadowSampleType = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsSetShadowSampleType");
				var ptr_type = MemoryUtils.StringToHGlobalUtf8(_type);
				fn__cascadeShadowsSetShadowSampleType(ptr_type);
				Marshal.FreeHGlobal(ptr_type);
			}
		}

		public void CascadeShadowsClearShadowSampleType()
		{
			unsafe {
				if (fn__cascadeShadowsClearShadowSampleType == null) fn__cascadeShadowsClearShadowSampleType = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsClearShadowSampleType");
				fn__cascadeShadowsClearShadowSampleType();
			}
		}

		public void CascadeShadowsSetAircraftMode(bool _p0)
		{
			unsafe {
				if (fn__cascadeShadowsSetAircraftMode == null) fn__cascadeShadowsSetAircraftMode = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsSetAircraftMode");
				fn__cascadeShadowsSetAircraftMode(_p0);
			}
		}

		public void CascadeShadowsSetDynamicDepthMode(bool _p0)
		{
			unsafe {
				if (fn__cascadeShadowsSetDynamicDepthMode == null) fn__cascadeShadowsSetDynamicDepthMode = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsSetDynamicDepthMode");
				fn__cascadeShadowsSetDynamicDepthMode(_p0);
			}
		}

		public void CascadeShadowsSetDynamicDepthValue(float _p0)
		{
			unsafe {
				if (fn__cascadeShadowsSetDynamicDepthValue == null) fn__cascadeShadowsSetDynamicDepthValue = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_cascadeShadowsSetDynamicDepthValue");
				fn__cascadeShadowsSetDynamicDepthValue(_p0);
			}
		}

		public void _0x0AE73D8DF3A762B2(bool _p0)
		{
			unsafe {
				if (fn__0x0AE73D8DF3A762B2 == null) fn__0x0AE73D8DF3A762B2 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x0AE73D8DF3A762B2");
				fn__0x0AE73D8DF3A762B2(_p0);
			}
		}

		public void _0xCA465D9CC0D231BA(int _p0)
		{
			unsafe {
				if (fn__0xCA465D9CC0D231BA == null) fn__0xCA465D9CC0D231BA = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xCA465D9CC0D231BA");
				fn__0xCA465D9CC0D231BA(_p0);
			}
		}

		public void GolfTrailSetEnabled(bool _toggle)
		{
			unsafe {
				if (fn__golfTrailSetEnabled == null) fn__golfTrailSetEnabled = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_golfTrailSetEnabled");
				fn__golfTrailSetEnabled(_toggle);
			}
		}

		public void GolfTrailSetPath(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, bool _p8)
		{
			unsafe {
				if (fn__golfTrailSetPath == null) fn__golfTrailSetPath = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_golfTrailSetPath");
				fn__golfTrailSetPath(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
			}
		}

		public void GolfTrailSetRadius(float _p0, float _p1, float _p2)
		{
			unsafe {
				if (fn__golfTrailSetRadius == null) fn__golfTrailSetRadius = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_golfTrailSetRadius");
				fn__golfTrailSetRadius(_p0, _p1, _p2);
			}
		}

		public void GolfTrailSetColour(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9, int _p10, int _p11)
		{
			unsafe {
				if (fn__golfTrailSetColour == null) fn__golfTrailSetColour = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_golfTrailSetColour");
				fn__golfTrailSetColour(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11);
			}
		}

		public void GolfTrailSetTessellation(int _p0, int _p1)
		{
			unsafe {
				if (fn__golfTrailSetTessellation == null) fn__golfTrailSetTessellation = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_golfTrailSetTessellation");
				fn__golfTrailSetTessellation(_p0, _p1);
			}
		}

		public void _0xC0416B061F2B7E5E(bool _p0)
		{
			unsafe {
				if (fn__0xC0416B061F2B7E5E == null) fn__0xC0416B061F2B7E5E = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xC0416B061F2B7E5E");
				fn__0xC0416B061F2B7E5E(_p0);
			}
		}

		public void GolfTrailSetFixedControlPoint(int _type, float _xPos, float _yPos, float _zPos, float _p4, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__golfTrailSetFixedControlPoint == null) fn__golfTrailSetFixedControlPoint = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_golfTrailSetFixedControlPoint");
				fn__golfTrailSetFixedControlPoint(_type, _xPos, _yPos, _zPos, _p4, _red, _green, _blue, _alpha);
			}
		}

		public void GolfTrailSetShaderParams(float _p0, float _p1, float _p2, float _p3, float _p4)
		{
			unsafe {
				if (fn__golfTrailSetShaderParams == null) fn__golfTrailSetShaderParams = (delegate* unmanaged[Cdecl]<float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_golfTrailSetShaderParams");
				fn__golfTrailSetShaderParams(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void GolfTrailSetFacing(bool _p0)
		{
			unsafe {
				if (fn__golfTrailSetFacing == null) fn__golfTrailSetFacing = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_golfTrailSetFacing");
				fn__golfTrailSetFacing(_p0);
			}
		}

		public float GolfTrailGetMaxHeight()
		{
			unsafe {
				if (fn__golfTrailGetMaxHeight == null) fn__golfTrailGetMaxHeight = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_golfTrailGetMaxHeight");
				var result = fn__golfTrailGetMaxHeight();
				return result;
			}
		}

		public Vector3 GolfTrailGetVisualControlPoint(int _p0)
		{
			unsafe {
				if (fn__golfTrailGetVisualControlPoint == null) fn__golfTrailGetVisualControlPoint = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_golfTrailGetVisualControlPoint");
				var result = fn__golfTrailGetVisualControlPoint(_p0);
				return result;
			}
		}

		public void SetSeethrough(bool _toggle)
		{
			unsafe {
				if (fn__setSeethrough == null) fn__setSeethrough = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setSeethrough");
				fn__setSeethrough(_toggle);
			}
		}

		public bool GetUsingseethrough()
		{
			unsafe {
				if (fn__getUsingseethrough == null) fn__getUsingseethrough = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getUsingseethrough");
				var result = fn__getUsingseethrough();
				return result;
			}
		}

		public void SeethroughReset()
		{
			unsafe {
				if (fn__seethroughReset == null) fn__seethroughReset = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_seethroughReset");
				fn__seethroughReset();
			}
		}

		public void SeethroughSetFadeStartDistance(float _distance)
		{
			unsafe {
				if (fn__seethroughSetFadeStartDistance == null) fn__seethroughSetFadeStartDistance = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_seethroughSetFadeStartDistance");
				fn__seethroughSetFadeStartDistance(_distance);
			}
		}

		public void SeethroughSetFadeEndDistance(float _distance)
		{
			unsafe {
				if (fn__seethroughSetFadeEndDistance == null) fn__seethroughSetFadeEndDistance = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_seethroughSetFadeEndDistance");
				fn__seethroughSetFadeEndDistance(_distance);
			}
		}

		public float SeethroughGetMaxThickness()
		{
			unsafe {
				if (fn__seethroughGetMaxThickness == null) fn__seethroughGetMaxThickness = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_seethroughGetMaxThickness");
				var result = fn__seethroughGetMaxThickness();
				return result;
			}
		}

		public void SeethroughSetMaxThickness(float _thickness)
		{
			unsafe {
				if (fn__seethroughSetMaxThickness == null) fn__seethroughSetMaxThickness = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_seethroughSetMaxThickness");
				fn__seethroughSetMaxThickness(_thickness);
			}
		}

		public void SeethroughSetNoiseAmountMin(float _amount)
		{
			unsafe {
				if (fn__seethroughSetNoiseAmountMin == null) fn__seethroughSetNoiseAmountMin = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_seethroughSetNoiseAmountMin");
				fn__seethroughSetNoiseAmountMin(_amount);
			}
		}

		public void SeethroughSetNoiseAmountMax(float _amount)
		{
			unsafe {
				if (fn__seethroughSetNoiseAmountMax == null) fn__seethroughSetNoiseAmountMax = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_seethroughSetNoiseAmountMax");
				fn__seethroughSetNoiseAmountMax(_amount);
			}
		}

		public void SeethroughSetHiLightIntensity(float _intensity)
		{
			unsafe {
				if (fn__seethroughSetHiLightIntensity == null) fn__seethroughSetHiLightIntensity = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_seethroughSetHiLightIntensity");
				fn__seethroughSetHiLightIntensity(_intensity);
			}
		}

		public void SeethroughSetHiLightNoise(float _noise)
		{
			unsafe {
				if (fn__seethroughSetHiLightNoise == null) fn__seethroughSetHiLightNoise = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_seethroughSetHiLightNoise");
				fn__seethroughSetHiLightNoise(_noise);
			}
		}

		public void SeethroughSetHeatscale(int _index, float _heatScale)
		{
			unsafe {
				if (fn__seethroughSetHeatscale == null) fn__seethroughSetHeatscale = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_seethroughSetHeatscale");
				fn__seethroughSetHeatscale(_index, _heatScale);
			}
		}

		public void SeethroughSetColorNear(int _red, int _green, int _blue)
		{
			unsafe {
				if (fn__seethroughSetColorNear == null) fn__seethroughSetColorNear = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_seethroughSetColorNear");
				fn__seethroughSetColorNear(_red, _green, _blue);
			}
		}

		public void _0xB3C641F3630BF6DA(float _p0)
		{
			unsafe {
				if (fn__0xB3C641F3630BF6DA == null) fn__0xB3C641F3630BF6DA = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0xB3C641F3630BF6DA");
				fn__0xB3C641F3630BF6DA(_p0);
			}
		}

		public float _0xE59343E9E96529E7()
		{
			unsafe {
				if (fn__0xE59343E9E96529E7 == null) fn__0xE59343E9E96529E7 = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native__0xE59343E9E96529E7");
				var result = fn__0xE59343E9E96529E7();
				return result;
			}
		}

		public void _0x6A51F78772175A51(bool _toggle)
		{
			unsafe {
				if (fn__0x6A51F78772175A51 == null) fn__0x6A51F78772175A51 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x6A51F78772175A51");
				fn__0x6A51F78772175A51(_toggle);
			}
		}

		public void TogglePlayerDamageOverlay(bool _toggle)
		{
			unsafe {
				if (fn__togglePlayerDamageOverlay == null) fn__togglePlayerDamageOverlay = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_togglePlayerDamageOverlay");
				fn__togglePlayerDamageOverlay(_toggle);
			}
		}

		public void _0xE3E2C1B4C59DBC77(int _unk)
		{
			unsafe {
				if (fn__0xE3E2C1B4C59DBC77 == null) fn__0xE3E2C1B4C59DBC77 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xE3E2C1B4C59DBC77");
				fn__0xE3E2C1B4C59DBC77(_unk);
			}
		}

		public bool TriggerScreenblurFadeIn(float _transitionTime)
		{
			unsafe {
				if (fn__triggerScreenblurFadeIn == null) fn__triggerScreenblurFadeIn = (delegate* unmanaged[Cdecl]<float, bool>) NativeLibrary.GetExport(handle, "Native_triggerScreenblurFadeIn");
				var result = fn__triggerScreenblurFadeIn(_transitionTime);
				return result;
			}
		}

		public bool TriggerScreenblurFadeOut(float _transitionTime)
		{
			unsafe {
				if (fn__triggerScreenblurFadeOut == null) fn__triggerScreenblurFadeOut = (delegate* unmanaged[Cdecl]<float, bool>) NativeLibrary.GetExport(handle, "Native_triggerScreenblurFadeOut");
				var result = fn__triggerScreenblurFadeOut(_transitionTime);
				return result;
			}
		}

		public void DisableScreenblurFade()
		{
			unsafe {
				if (fn__disableScreenblurFade == null) fn__disableScreenblurFade = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_disableScreenblurFade");
				fn__disableScreenblurFade();
			}
		}

		public float GetScreenblurFadeCurrentTime()
		{
			unsafe {
				if (fn__getScreenblurFadeCurrentTime == null) fn__getScreenblurFadeCurrentTime = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getScreenblurFadeCurrentTime");
				var result = fn__getScreenblurFadeCurrentTime();
				return result;
			}
		}

		public bool IsScreenblurFadeRunning()
		{
			unsafe {
				if (fn__isScreenblurFadeRunning == null) fn__isScreenblurFadeRunning = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isScreenblurFadeRunning");
				var result = fn__isScreenblurFadeRunning();
				return result;
			}
		}

		public void TogglePausedRenderphases(bool _toggle)
		{
			unsafe {
				if (fn__togglePausedRenderphases == null) fn__togglePausedRenderphases = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_togglePausedRenderphases");
				fn__togglePausedRenderphases(_toggle);
			}
		}

		public bool GetTogglePausedRenderphasesStatus()
		{
			unsafe {
				if (fn__getTogglePausedRenderphasesStatus == null) fn__getTogglePausedRenderphasesStatus = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getTogglePausedRenderphasesStatus");
				var result = fn__getTogglePausedRenderphasesStatus();
				return result;
			}
		}

		public void ResetPausedRenderphases()
		{
			unsafe {
				if (fn__resetPausedRenderphases == null) fn__resetPausedRenderphases = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetPausedRenderphases");
				fn__resetPausedRenderphases();
			}
		}

		public void _0x851CD923176EBA7C()
		{
			unsafe {
				if (fn__0x851CD923176EBA7C == null) fn__0x851CD923176EBA7C = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x851CD923176EBA7C");
				fn__0x851CD923176EBA7C();
			}
		}

		public void SetHidofEnvBlurParams(bool _p0, bool _p1, float _nearplaneOut, float _nearplaneIn, float _farplaneOut, float _farplaneIn)
		{
			unsafe {
				if (fn__setHidofEnvBlurParams == null) fn__setHidofEnvBlurParams = (delegate* unmanaged[Cdecl]<bool, bool, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setHidofEnvBlurParams");
				fn__setHidofEnvBlurParams(_p0, _p1, _nearplaneOut, _nearplaneIn, _farplaneOut, _farplaneIn);
			}
		}

		public void _0xB569F41F3E7E83A4(int _p0)
		{
			unsafe {
				if (fn__0xB569F41F3E7E83A4 == null) fn__0xB569F41F3E7E83A4 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xB569F41F3E7E83A4");
				fn__0xB569F41F3E7E83A4(_p0);
			}
		}

		public bool _0x7AC24EAB6D74118D(bool _p0)
		{
			unsafe {
				if (fn__0x7AC24EAB6D74118D == null) fn__0x7AC24EAB6D74118D = (delegate* unmanaged[Cdecl]<bool, bool>) NativeLibrary.GetExport(handle, "Native__0x7AC24EAB6D74118D");
				var result = fn__0x7AC24EAB6D74118D(_p0);
				return result;
			}
		}

		public int _0xBCEDB009461DA156()
		{
			unsafe {
				if (fn__0xBCEDB009461DA156 == null) fn__0xBCEDB009461DA156 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xBCEDB009461DA156");
				var result = fn__0xBCEDB009461DA156();
				return result;
			}
		}

		public bool _0x27FEB5254759CDE3(string _textureDict, bool _p1)
		{
			unsafe {
				if (fn__0x27FEB5254759CDE3 == null) fn__0x27FEB5254759CDE3 = (delegate* unmanaged[Cdecl]<nint, bool, bool>) NativeLibrary.GetExport(handle, "Native__0x27FEB5254759CDE3");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var result = fn__0x27FEB5254759CDE3(ptr_textureDict, _p1);
				Marshal.FreeHGlobal(ptr_textureDict);
				return result;
			}
		}

		public int StartParticleFxNonLoopedAtCoord(string _effectName, float _xPos, float _yPos, float _zPos, float _xRot, float _yRot, float _zRot, float _scale, bool _xAxis, bool _yAxis, bool _zAxis)
		{
			unsafe {
				if (fn__startParticleFxNonLoopedAtCoord == null) fn__startParticleFxNonLoopedAtCoord = (delegate* unmanaged[Cdecl]<nint, float, float, float, float, float, float, float, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_startParticleFxNonLoopedAtCoord");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startParticleFxNonLoopedAtCoord(ptr_effectName, _xPos, _yPos, _zPos, _xRot, _yRot, _zRot, _scale, _xAxis, _yAxis, _zAxis);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public bool StartNetworkedParticleFxNonLoopedAtCoord(string _effectName, float _xPos, float _yPos, float _zPos, float _xRot, float _yRot, float _zRot, float _scale, bool _xAxis, bool _yAxis, bool _zAxis, bool _p11)
		{
			unsafe {
				if (fn__startNetworkedParticleFxNonLoopedAtCoord == null) fn__startNetworkedParticleFxNonLoopedAtCoord = (delegate* unmanaged[Cdecl]<nint, float, float, float, float, float, float, float, bool, bool, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_startNetworkedParticleFxNonLoopedAtCoord");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startNetworkedParticleFxNonLoopedAtCoord(ptr_effectName, _xPos, _yPos, _zPos, _xRot, _yRot, _zRot, _scale, _xAxis, _yAxis, _zAxis, _p11);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public bool StartParticleFxNonLoopedOnPedBone(string _effectName, int _ped, float _offsetX, float _offsetY, float _offsetZ, float _rotX, float _rotY, float _rotZ, int _boneIndex, float _scale, bool _axisX, bool _axisY, bool _axisZ)
		{
			unsafe {
				if (fn__startParticleFxNonLoopedOnPedBone == null) fn__startParticleFxNonLoopedOnPedBone = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_startParticleFxNonLoopedOnPedBone");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startParticleFxNonLoopedOnPedBone(ptr_effectName, _ped, _offsetX, _offsetY, _offsetZ, _rotX, _rotY, _rotZ, _boneIndex, _scale, _axisX, _axisY, _axisZ);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public bool StartNetworkedParticleFxNonLoopedOnPedBone(string _effectName, int _ped, float _offsetX, float _offsetY, float _offsetZ, float _rotX, float _rotY, float _rotZ, int _boneIndex, float _scale, bool _axisX, bool _axisY, bool _axisZ)
		{
			unsafe {
				if (fn__startNetworkedParticleFxNonLoopedOnPedBone == null) fn__startNetworkedParticleFxNonLoopedOnPedBone = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_startNetworkedParticleFxNonLoopedOnPedBone");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startNetworkedParticleFxNonLoopedOnPedBone(ptr_effectName, _ped, _offsetX, _offsetY, _offsetZ, _rotX, _rotY, _rotZ, _boneIndex, _scale, _axisX, _axisY, _axisZ);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public bool StartParticleFxNonLoopedOnEntity(string _effectName, int _entity, float _offsetX, float _offsetY, float _offsetZ, float _rotX, float _rotY, float _rotZ, float _scale, bool _axisX, bool _axisY, bool _axisZ)
		{
			unsafe {
				if (fn__startParticleFxNonLoopedOnEntity == null) fn__startParticleFxNonLoopedOnEntity = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, float, bool, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_startParticleFxNonLoopedOnEntity");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startParticleFxNonLoopedOnEntity(ptr_effectName, _entity, _offsetX, _offsetY, _offsetZ, _rotX, _rotY, _rotZ, _scale, _axisX, _axisY, _axisZ);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public bool StartNetworkedParticleFxNonLoopedOnEntity(string _effectName, int _entity, float _offsetX, float _offsetY, float _offsetZ, float _rotX, float _rotY, float _rotZ, float _scale, bool _axisX, bool _axisY, bool _axisZ)
		{
			unsafe {
				if (fn__startNetworkedParticleFxNonLoopedOnEntity == null) fn__startNetworkedParticleFxNonLoopedOnEntity = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, float, bool, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_startNetworkedParticleFxNonLoopedOnEntity");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startNetworkedParticleFxNonLoopedOnEntity(ptr_effectName, _entity, _offsetX, _offsetY, _offsetZ, _rotX, _rotY, _rotZ, _scale, _axisX, _axisY, _axisZ);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public bool StartNetworkedParticleFxNonLoopedOnEntityBone(string _effectName, int _entity, float _offsetX, float _offsetY, float _offsetZ, float _rotX, float _rotY, float _rotZ, int _boneIndex, float _scale, bool _axisX, bool _axisY, bool _axisZ)
		{
			unsafe {
				if (fn__startNetworkedParticleFxNonLoopedOnEntityBone == null) fn__startNetworkedParticleFxNonLoopedOnEntityBone = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_startNetworkedParticleFxNonLoopedOnEntityBone");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startNetworkedParticleFxNonLoopedOnEntityBone(ptr_effectName, _entity, _offsetX, _offsetY, _offsetZ, _rotX, _rotY, _rotZ, _boneIndex, _scale, _axisX, _axisY, _axisZ);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public void SetParticleFxNonLoopedColour(float _r, float _g, float _b)
		{
			unsafe {
				if (fn__setParticleFxNonLoopedColour == null) fn__setParticleFxNonLoopedColour = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxNonLoopedColour");
				fn__setParticleFxNonLoopedColour(_r, _g, _b);
			}
		}

		public void SetParticleFxNonLoopedAlpha(float _alpha)
		{
			unsafe {
				if (fn__setParticleFxNonLoopedAlpha == null) fn__setParticleFxNonLoopedAlpha = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxNonLoopedAlpha");
				fn__setParticleFxNonLoopedAlpha(_alpha);
			}
		}

		public void _0x8CDE909A0370BB3A(bool _toggle)
		{
			unsafe {
				if (fn__0x8CDE909A0370BB3A == null) fn__0x8CDE909A0370BB3A = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x8CDE909A0370BB3A");
				fn__0x8CDE909A0370BB3A(_toggle);
			}
		}

		public int StartParticleFxLoopedAtCoord(string _effectName, float _x, float _y, float _z, float _xRot, float _yRot, float _zRot, float _scale, bool _xAxis, bool _yAxis, bool _zAxis, bool _p11)
		{
			unsafe {
				if (fn__startParticleFxLoopedAtCoord == null) fn__startParticleFxLoopedAtCoord = (delegate* unmanaged[Cdecl]<nint, float, float, float, float, float, float, float, bool, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_startParticleFxLoopedAtCoord");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startParticleFxLoopedAtCoord(ptr_effectName, _x, _y, _z, _xRot, _yRot, _zRot, _scale, _xAxis, _yAxis, _zAxis, _p11);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public int StartParticleFxLoopedOnPedBone(string _effectName, int _ped, float _xOffset, float _yOffset, float _zOffset, float _xRot, float _yRot, float _zRot, int _boneIndex, float _scale, bool _xAxis, bool _yAxis, bool _zAxis)
		{
			unsafe {
				if (fn__startParticleFxLoopedOnPedBone == null) fn__startParticleFxLoopedOnPedBone = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_startParticleFxLoopedOnPedBone");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startParticleFxLoopedOnPedBone(ptr_effectName, _ped, _xOffset, _yOffset, _zOffset, _xRot, _yRot, _zRot, _boneIndex, _scale, _xAxis, _yAxis, _zAxis);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public int StartParticleFxLoopedOnEntity(string _effectName, int _entity, float _xOffset, float _yOffset, float _zOffset, float _xRot, float _yRot, float _zRot, float _scale, bool _xAxis, bool _yAxis, bool _zAxis)
		{
			unsafe {
				if (fn__startParticleFxLoopedOnEntity == null) fn__startParticleFxLoopedOnEntity = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, float, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_startParticleFxLoopedOnEntity");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startParticleFxLoopedOnEntity(ptr_effectName, _entity, _xOffset, _yOffset, _zOffset, _xRot, _yRot, _zRot, _scale, _xAxis, _yAxis, _zAxis);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public int StartParticleFxLoopedOnEntityBone(string _effectName, int _entity, float _xOffset, float _yOffset, float _zOffset, float _xRot, float _yRot, float _zRot, int _boneIndex, float _scale, bool _xAxis, bool _yAxis, bool _zAxis)
		{
			unsafe {
				if (fn__startParticleFxLoopedOnEntityBone == null) fn__startParticleFxLoopedOnEntityBone = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_startParticleFxLoopedOnEntityBone");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startParticleFxLoopedOnEntityBone(ptr_effectName, _entity, _xOffset, _yOffset, _zOffset, _xRot, _yRot, _zRot, _boneIndex, _scale, _xAxis, _yAxis, _zAxis);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public int StartNetworkedParticleFxLoopedOnEntity(string _effectName, int _entity, float _xOffset, float _yOffset, float _zOffset, float _xRot, float _yRot, float _zRot, float _scale, bool _xAxis, bool _yAxis, bool _zAxis, int _p12, int _p13, int _p14, int _p15)
		{
			unsafe {
				if (fn__startNetworkedParticleFxLoopedOnEntity == null) fn__startNetworkedParticleFxLoopedOnEntity = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, float, bool, bool, bool, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startNetworkedParticleFxLoopedOnEntity");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startNetworkedParticleFxLoopedOnEntity(ptr_effectName, _entity, _xOffset, _yOffset, _zOffset, _xRot, _yRot, _zRot, _scale, _xAxis, _yAxis, _zAxis, _p12, _p13, _p14, _p15);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public int StartNetworkedParticleFxLoopedOnEntityBone(string _effectName, int _entity, float _xOffset, float _yOffset, float _zOffset, float _xRot, float _yRot, float _zRot, int _boneIndex, float _scale, bool _xAxis, bool _yAxis, bool _zAxis, int _p13, int _p14, int _p15, int _p16)
		{
			unsafe {
				if (fn__startNetworkedParticleFxLoopedOnEntityBone == null) fn__startNetworkedParticleFxLoopedOnEntityBone = (delegate* unmanaged[Cdecl]<nint, int, float, float, float, float, float, float, int, float, bool, bool, bool, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startNetworkedParticleFxLoopedOnEntityBone");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__startNetworkedParticleFxLoopedOnEntityBone(ptr_effectName, _entity, _xOffset, _yOffset, _zOffset, _xRot, _yRot, _zRot, _boneIndex, _scale, _xAxis, _yAxis, _zAxis, _p13, _p14, _p15, _p16);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public void StopParticleFxLooped(int _ptfxHandle, bool _p1)
		{
			unsafe {
				if (fn__stopParticleFxLooped == null) fn__stopParticleFxLooped = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_stopParticleFxLooped");
				fn__stopParticleFxLooped(_ptfxHandle, _p1);
			}
		}

		public void RemoveParticleFx(int _ptfxHandle, bool _p1)
		{
			unsafe {
				if (fn__removeParticleFx == null) fn__removeParticleFx = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removeParticleFx");
				fn__removeParticleFx(_ptfxHandle, _p1);
			}
		}

		public void RemoveParticleFxFromEntity(int _entity)
		{
			unsafe {
				if (fn__removeParticleFxFromEntity == null) fn__removeParticleFxFromEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeParticleFxFromEntity");
				fn__removeParticleFxFromEntity(_entity);
			}
		}

		public void RemoveParticleFxInRange(float _X, float _Y, float _Z, float _radius)
		{
			unsafe {
				if (fn__removeParticleFxInRange == null) fn__removeParticleFxInRange = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_removeParticleFxInRange");
				fn__removeParticleFxInRange(_X, _Y, _Z, _radius);
			}
		}

		public void _0xBA0127DA25FD54C9(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xBA0127DA25FD54C9 == null) fn__0xBA0127DA25FD54C9 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xBA0127DA25FD54C9");
				fn__0xBA0127DA25FD54C9(_p0, _p1);
			}
		}

		public bool DoesParticleFxLoopedExist(int _ptfxHandle)
		{
			unsafe {
				if (fn__doesParticleFxLoopedExist == null) fn__doesParticleFxLoopedExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesParticleFxLoopedExist");
				var result = fn__doesParticleFxLoopedExist(_ptfxHandle);
				return result;
			}
		}

		public void SetParticleFxLoopedOffsets(int _ptfxHandle, float _x, float _y, float _z, float _rotX, float _rotY, float _rotZ)
		{
			unsafe {
				if (fn__setParticleFxLoopedOffsets == null) fn__setParticleFxLoopedOffsets = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxLoopedOffsets");
				fn__setParticleFxLoopedOffsets(_ptfxHandle, _x, _y, _z, _rotX, _rotY, _rotZ);
			}
		}

		public void SetParticleFxLoopedEvolution(int _ptfxHandle, string _propertyName, float _amount, bool _noNetwork)
		{
			unsafe {
				if (fn__setParticleFxLoopedEvolution == null) fn__setParticleFxLoopedEvolution = (delegate* unmanaged[Cdecl]<int, nint, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxLoopedEvolution");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				fn__setParticleFxLoopedEvolution(_ptfxHandle, ptr_propertyName, _amount, _noNetwork);
				Marshal.FreeHGlobal(ptr_propertyName);
			}
		}

		public void SetParticleFxLoopedColour(int _ptfxHandle, float _r, float _g, float _b, bool _p4)
		{
			unsafe {
				if (fn__setParticleFxLoopedColour == null) fn__setParticleFxLoopedColour = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxLoopedColour");
				fn__setParticleFxLoopedColour(_ptfxHandle, _r, _g, _b, _p4);
			}
		}

		public void SetParticleFxLoopedAlpha(int _ptfxHandle, float _alpha)
		{
			unsafe {
				if (fn__setParticleFxLoopedAlpha == null) fn__setParticleFxLoopedAlpha = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxLoopedAlpha");
				fn__setParticleFxLoopedAlpha(_ptfxHandle, _alpha);
			}
		}

		public void SetParticleFxLoopedScale(int _ptfxHandle, float _scale)
		{
			unsafe {
				if (fn__setParticleFxLoopedScale == null) fn__setParticleFxLoopedScale = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxLoopedScale");
				fn__setParticleFxLoopedScale(_ptfxHandle, _scale);
			}
		}

		public void SetParticleFxLoopedFarClipDist(int _ptfxHandle, float _range)
		{
			unsafe {
				if (fn__setParticleFxLoopedFarClipDist == null) fn__setParticleFxLoopedFarClipDist = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxLoopedFarClipDist");
				fn__setParticleFxLoopedFarClipDist(_ptfxHandle, _range);
			}
		}

		public void SetParticleFxCamInsideVehicle(bool _p0)
		{
			unsafe {
				if (fn__setParticleFxCamInsideVehicle == null) fn__setParticleFxCamInsideVehicle = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxCamInsideVehicle");
				fn__setParticleFxCamInsideVehicle(_p0);
			}
		}

		public void SetParticleFxCamInsideNonplayerVehicle(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__setParticleFxCamInsideNonplayerVehicle == null) fn__setParticleFxCamInsideNonplayerVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxCamInsideNonplayerVehicle");
				fn__setParticleFxCamInsideNonplayerVehicle(_vehicle, _p1);
			}
		}

		public void SetParticleFxShootoutBoat(int _p0)
		{
			unsafe {
				if (fn__setParticleFxShootoutBoat == null) fn__setParticleFxShootoutBoat = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxShootoutBoat");
				fn__setParticleFxShootoutBoat(_p0);
			}
		}

		public void _0x2A251AA48B2B46DB()
		{
			unsafe {
				if (fn__0x2A251AA48B2B46DB == null) fn__0x2A251AA48B2B46DB = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x2A251AA48B2B46DB");
				fn__0x2A251AA48B2B46DB();
			}
		}

		public void _0x908311265D42A820(int _p0)
		{
			unsafe {
				if (fn__0x908311265D42A820 == null) fn__0x908311265D42A820 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x908311265D42A820");
				fn__0x908311265D42A820(_p0);
			}
		}

		public void _0xCFD16F0DB5A3535C(bool _toggle)
		{
			unsafe {
				if (fn__0xCFD16F0DB5A3535C == null) fn__0xCFD16F0DB5A3535C = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xCFD16F0DB5A3535C");
				fn__0xCFD16F0DB5A3535C(_toggle);
			}
		}

		public void _0x5F6DF3D92271E8A1(bool _toggle)
		{
			unsafe {
				if (fn__0x5F6DF3D92271E8A1 == null) fn__0x5F6DF3D92271E8A1 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x5F6DF3D92271E8A1");
				fn__0x5F6DF3D92271E8A1(_toggle);
			}
		}

		public void _0x2B40A97646381508(int _p0)
		{
			unsafe {
				if (fn__0x2B40A97646381508 == null) fn__0x2B40A97646381508 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x2B40A97646381508");
				fn__0x2B40A97646381508(_p0);
			}
		}

		public void EnableClownBloodVfx(bool _toggle)
		{
			unsafe {
				if (fn__enableClownBloodVfx == null) fn__enableClownBloodVfx = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_enableClownBloodVfx");
				fn__enableClownBloodVfx(_toggle);
			}
		}

		public void EnableAlienBloodVfx(bool _toggle)
		{
			unsafe {
				if (fn__enableAlienBloodVfx == null) fn__enableAlienBloodVfx = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_enableAlienBloodVfx");
				fn__enableAlienBloodVfx(_toggle);
			}
		}

		public void SetParticleFxBulletImpactScale(float _scale)
		{
			unsafe {
				if (fn__setParticleFxBulletImpactScale == null) fn__setParticleFxBulletImpactScale = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxBulletImpactScale");
				fn__setParticleFxBulletImpactScale(_scale);
			}
		}

		public void _0xBB90E12CAC1DAB25(float _p0)
		{
			unsafe {
				if (fn__0xBB90E12CAC1DAB25 == null) fn__0xBB90E12CAC1DAB25 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0xBB90E12CAC1DAB25");
				fn__0xBB90E12CAC1DAB25(_p0);
			}
		}

		public void _0xCA4AE345A153D573(bool _p0)
		{
			unsafe {
				if (fn__0xCA4AE345A153D573 == null) fn__0xCA4AE345A153D573 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xCA4AE345A153D573");
				fn__0xCA4AE345A153D573(_p0);
			}
		}

		public void _0x54E22EA2C1956A8D(float _p0)
		{
			unsafe {
				if (fn__0x54E22EA2C1956A8D == null) fn__0x54E22EA2C1956A8D = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x54E22EA2C1956A8D");
				fn__0x54E22EA2C1956A8D(_p0);
			}
		}

		public void _0x949F397A288B28B3(float _p0)
		{
			unsafe {
				if (fn__0x949F397A288B28B3 == null) fn__0x949F397A288B28B3 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x949F397A288B28B3");
				fn__0x949F397A288B28B3(_p0);
			}
		}

		public void _0xBA3D194057C79A7B(string _p0)
		{
			unsafe {
				if (fn__0xBA3D194057C79A7B == null) fn__0xBA3D194057C79A7B = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0xBA3D194057C79A7B");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0xBA3D194057C79A7B(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void _0x5DBF05DB5926D089(int _p0)
		{
			unsafe {
				if (fn__0x5DBF05DB5926D089 == null) fn__0x5DBF05DB5926D089 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x5DBF05DB5926D089");
				fn__0x5DBF05DB5926D089(_p0);
			}
		}

		public void _0x9B079E5221D984D3(bool _p0)
		{
			unsafe {
				if (fn__0x9B079E5221D984D3 == null) fn__0x9B079E5221D984D3 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x9B079E5221D984D3");
				fn__0x9B079E5221D984D3(_p0);
			}
		}

		public void UseParticleFxAsset(string _name)
		{
			unsafe {
				if (fn__useParticleFxAsset == null) fn__useParticleFxAsset = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_useParticleFxAsset");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__useParticleFxAsset(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void SetParticleFxOverride(string _oldAsset, string _newAsset)
		{
			unsafe {
				if (fn__setParticleFxOverride == null) fn__setParticleFxOverride = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native_setParticleFxOverride");
				var ptr_oldAsset = MemoryUtils.StringToHGlobalUtf8(_oldAsset);
				var ptr_newAsset = MemoryUtils.StringToHGlobalUtf8(_newAsset);
				fn__setParticleFxOverride(ptr_oldAsset, ptr_newAsset);
				Marshal.FreeHGlobal(ptr_oldAsset);
				Marshal.FreeHGlobal(ptr_newAsset);
			}
		}

		public void ResetParticleFxOverride(string _name)
		{
			unsafe {
				if (fn__resetParticleFxOverride == null) fn__resetParticleFxOverride = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_resetParticleFxOverride");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__resetParticleFxOverride(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void _0xA46B73FAA3460AE1(bool _p0)
		{
			unsafe {
				if (fn__0xA46B73FAA3460AE1 == null) fn__0xA46B73FAA3460AE1 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xA46B73FAA3460AE1");
				fn__0xA46B73FAA3460AE1(_p0);
			}
		}

		public void _0xF78B803082D4386F(float _p0)
		{
			unsafe {
				if (fn__0xF78B803082D4386F == null) fn__0xF78B803082D4386F = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0xF78B803082D4386F");
				fn__0xF78B803082D4386F(_p0);
			}
		}

		public void WashDecalsInRange(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__washDecalsInRange == null) fn__washDecalsInRange = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_washDecalsInRange");
				fn__washDecalsInRange(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void WashDecalsFromVehicle(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__washDecalsFromVehicle == null) fn__washDecalsFromVehicle = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_washDecalsFromVehicle");
				fn__washDecalsFromVehicle(_vehicle, _p1);
			}
		}

		public void FadeDecalsInRange(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__fadeDecalsInRange == null) fn__fadeDecalsInRange = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_fadeDecalsInRange");
				fn__fadeDecalsInRange(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void RemoveDecalsInRange(float _x, float _y, float _z, float _range)
		{
			unsafe {
				if (fn__removeDecalsInRange == null) fn__removeDecalsInRange = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_removeDecalsInRange");
				fn__removeDecalsInRange(_x, _y, _z, _range);
			}
		}

		public void RemoveDecalsFromObject(int _obj)
		{
			unsafe {
				if (fn__removeDecalsFromObject == null) fn__removeDecalsFromObject = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeDecalsFromObject");
				fn__removeDecalsFromObject(_obj);
			}
		}

		public void RemoveDecalsFromObjectFacing(int _obj, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__removeDecalsFromObjectFacing == null) fn__removeDecalsFromObjectFacing = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_removeDecalsFromObjectFacing");
				fn__removeDecalsFromObjectFacing(_obj, _x, _y, _z);
			}
		}

		public void RemoveDecalsFromVehicle(int _vehicle)
		{
			unsafe {
				if (fn__removeDecalsFromVehicle == null) fn__removeDecalsFromVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeDecalsFromVehicle");
				fn__removeDecalsFromVehicle(_vehicle);
			}
		}

		public int AddDecal(int _decalType, float _posX, float _posY, float _posZ, float _p4, float _p5, float _p6, float _p7, float _p8, float _p9, float _width, float _height, float _rCoef, float _gCoef, float _bCoef, float _opacity, float _timeout, bool _p17, bool _p18, bool _p19)
		{
			unsafe {
				if (fn__addDecal == null) fn__addDecal = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_addDecal");
				var result = fn__addDecal(_decalType, _posX, _posY, _posZ, _p4, _p5, _p6, _p7, _p8, _p9, _width, _height, _rCoef, _gCoef, _bCoef, _opacity, _timeout, _p17, _p18, _p19);
				return result;
			}
		}

		public int AddPetrolDecal(float _x, float _y, float _z, float _groundLvl, float _width, float _transparency)
		{
			unsafe {
				if (fn__addPetrolDecal == null) fn__addPetrolDecal = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_addPetrolDecal");
				var result = fn__addPetrolDecal(_x, _y, _z, _groundLvl, _width, _transparency);
				return result;
			}
		}

		public void StartPetrolTrailDecals(float _p0)
		{
			unsafe {
				if (fn__startPetrolTrailDecals == null) fn__startPetrolTrailDecals = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_startPetrolTrailDecals");
				fn__startPetrolTrailDecals(_p0);
			}
		}

		public void AddPetrolTrailDecalInfo(float _x, float _y, float _z, float _p3)
		{
			unsafe {
				if (fn__addPetrolTrailDecalInfo == null) fn__addPetrolTrailDecalInfo = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_addPetrolTrailDecalInfo");
				fn__addPetrolTrailDecalInfo(_x, _y, _z, _p3);
			}
		}

		public void EndPetrolTrailDecals()
		{
			unsafe {
				if (fn__endPetrolTrailDecals == null) fn__endPetrolTrailDecals = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_endPetrolTrailDecals");
				fn__endPetrolTrailDecals();
			}
		}

		public void RemoveDecal(int _decal)
		{
			unsafe {
				if (fn__removeDecal == null) fn__removeDecal = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeDecal");
				fn__removeDecal(_decal);
			}
		}

		public bool IsDecalAlive(int _decal)
		{
			unsafe {
				if (fn__isDecalAlive == null) fn__isDecalAlive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isDecalAlive");
				var result = fn__isDecalAlive(_decal);
				return result;
			}
		}

		public float GetDecalWashLevel(int _decal)
		{
			unsafe {
				if (fn__getDecalWashLevel == null) fn__getDecalWashLevel = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getDecalWashLevel");
				var result = fn__getDecalWashLevel(_decal);
				return result;
			}
		}

		public void _0xD9454B5752C857DC()
		{
			unsafe {
				if (fn__0xD9454B5752C857DC == null) fn__0xD9454B5752C857DC = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xD9454B5752C857DC");
				fn__0xD9454B5752C857DC();
			}
		}

		public void _0x27CFB1B1E078CB2D()
		{
			unsafe {
				if (fn__0x27CFB1B1E078CB2D == null) fn__0x27CFB1B1E078CB2D = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x27CFB1B1E078CB2D");
				fn__0x27CFB1B1E078CB2D();
			}
		}

		public void SetDisableDecalRenderingThisFrame()
		{
			unsafe {
				if (fn__setDisableDecalRenderingThisFrame == null) fn__setDisableDecalRenderingThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setDisableDecalRenderingThisFrame");
				fn__setDisableDecalRenderingThisFrame();
			}
		}

		public bool GetIsPetrolDecalInRange(float _xCoord, float _yCoord, float _zCoord, float _radius)
		{
			unsafe {
				if (fn__getIsPetrolDecalInRange == null) fn__getIsPetrolDecalInRange = (delegate* unmanaged[Cdecl]<float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_getIsPetrolDecalInRange");
				var result = fn__getIsPetrolDecalInRange(_xCoord, _yCoord, _zCoord, _radius);
				return result;
			}
		}

		public void PatchDecalDiffuseMap(int _decalType, string _textureDict, string _textureName)
		{
			unsafe {
				if (fn__patchDecalDiffuseMap == null) fn__patchDecalDiffuseMap = (delegate* unmanaged[Cdecl]<int, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_patchDecalDiffuseMap");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				fn__patchDecalDiffuseMap(_decalType, ptr_textureDict, ptr_textureName);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
			}
		}

		public void UnpatchDecalDiffuseMap(int _decalType)
		{
			unsafe {
				if (fn__unpatchDecalDiffuseMap == null) fn__unpatchDecalDiffuseMap = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_unpatchDecalDiffuseMap");
				fn__unpatchDecalDiffuseMap(_decalType);
			}
		}

		public void MoveVehicleDecals(int _p0, int _p1)
		{
			unsafe {
				if (fn__moveVehicleDecals == null) fn__moveVehicleDecals = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_moveVehicleDecals");
				fn__moveVehicleDecals(_p0, _p1);
			}
		}

		public bool AddVehicleCrewEmblem(int _vehicle, int _ped, int _boneIndex, float _x1, float _x2, float _x3, float _y1, float _y2, float _y3, float _z1, float _z2, float _z3, float _scale, int _p13, int _alpha)
		{
			unsafe {
				if (fn__addVehicleCrewEmblem == null) fn__addVehicleCrewEmblem = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, float, float, float, float, float, int, int, bool>) NativeLibrary.GetExport(handle, "Native_addVehicleCrewEmblem");
				var result = fn__addVehicleCrewEmblem(_vehicle, _ped, _boneIndex, _x1, _x2, _x3, _y1, _y2, _y3, _z1, _z2, _z3, _scale, _p13, _alpha);
				return result;
			}
		}

		public int _0x82ACC484FFA3B05F(int _p0)
		{
			unsafe {
				if (fn__0x82ACC484FFA3B05F == null) fn__0x82ACC484FFA3B05F = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x82ACC484FFA3B05F");
				var result = fn__0x82ACC484FFA3B05F(_p0);
				return result;
			}
		}

		public void RemoveVehicleCrewEmblem(int _vehicle, int _p1)
		{
			unsafe {
				if (fn__removeVehicleCrewEmblem == null) fn__removeVehicleCrewEmblem = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleCrewEmblem");
				fn__removeVehicleCrewEmblem(_vehicle, _p1);
			}
		}

		public int GetVehicleCrewEmblemRequestState(int _vehicle, int _p1)
		{
			unsafe {
				if (fn__getVehicleCrewEmblemRequestState == null) fn__getVehicleCrewEmblemRequestState = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleCrewEmblemRequestState");
				var result = fn__getVehicleCrewEmblemRequestState(_vehicle, _p1);
				return result;
			}
		}

		public bool DoesVehicleHaveCrewEmblem(int _vehicle, int _p1)
		{
			unsafe {
				if (fn__doesVehicleHaveCrewEmblem == null) fn__doesVehicleHaveCrewEmblem = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_doesVehicleHaveCrewEmblem");
				var result = fn__doesVehicleHaveCrewEmblem(_vehicle, _p1);
				return result;
			}
		}

		public void _0x0E4299C549F0D1F1(bool _toggle)
		{
			unsafe {
				if (fn__0x0E4299C549F0D1F1 == null) fn__0x0E4299C549F0D1F1 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x0E4299C549F0D1F1");
				fn__0x0E4299C549F0D1F1(_toggle);
			}
		}

		public void _0x02369D5C8A51FDCF(bool _toggle)
		{
			unsafe {
				if (fn__0x02369D5C8A51FDCF == null) fn__0x02369D5C8A51FDCF = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x02369D5C8A51FDCF");
				fn__0x02369D5C8A51FDCF(_toggle);
			}
		}

		public void _0x46D1A61A21F566FC(float _p0)
		{
			unsafe {
				if (fn__0x46D1A61A21F566FC == null) fn__0x46D1A61A21F566FC = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x46D1A61A21F566FC");
				fn__0x46D1A61A21F566FC(_p0);
			}
		}

		public void OverrideInteriorSmokeName(string _name)
		{
			unsafe {
				if (fn__overrideInteriorSmokeName == null) fn__overrideInteriorSmokeName = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_overrideInteriorSmokeName");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__overrideInteriorSmokeName(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void OverrideInteriorSmokeLevel(float _level)
		{
			unsafe {
				if (fn__overrideInteriorSmokeLevel == null) fn__overrideInteriorSmokeLevel = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_overrideInteriorSmokeLevel");
				fn__overrideInteriorSmokeLevel(_level);
			}
		}

		public void OverrideInteriorSmokeEnd()
		{
			unsafe {
				if (fn__overrideInteriorSmokeEnd == null) fn__overrideInteriorSmokeEnd = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_overrideInteriorSmokeEnd");
				fn__overrideInteriorSmokeEnd();
			}
		}

		public void RegisterNoirScreenEffectThisFrame()
		{
			unsafe {
				if (fn__registerNoirScreenEffectThisFrame == null) fn__registerNoirScreenEffectThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_registerNoirScreenEffectThisFrame");
				fn__registerNoirScreenEffectThisFrame();
			}
		}

		public void DisableVehicleDistantlights(bool _toggle)
		{
			unsafe {
				if (fn__disableVehicleDistantlights == null) fn__disableVehicleDistantlights = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_disableVehicleDistantlights");
				fn__disableVehicleDistantlights(_toggle);
			}
		}

		public void _0x03300B57FCAC6DDB(bool _p0)
		{
			unsafe {
				if (fn__0x03300B57FCAC6DDB == null) fn__0x03300B57FCAC6DDB = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x03300B57FCAC6DDB");
				fn__0x03300B57FCAC6DDB(_p0);
			}
		}

		public void _0x98EDF76A7271E4F2()
		{
			unsafe {
				if (fn__0x98EDF76A7271E4F2 == null) fn__0x98EDF76A7271E4F2 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x98EDF76A7271E4F2");
				fn__0x98EDF76A7271E4F2();
			}
		}

		public void SetForcePedFootstepsTracks(bool _toggle)
		{
			unsafe {
				if (fn__setForcePedFootstepsTracks == null) fn__setForcePedFootstepsTracks = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setForcePedFootstepsTracks");
				fn__setForcePedFootstepsTracks(_toggle);
			}
		}

		public void SetForceVehicleTrails(bool _toggle)
		{
			unsafe {
				if (fn__setForceVehicleTrails == null) fn__setForceVehicleTrails = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setForceVehicleTrails");
				fn__setForceVehicleTrails(_toggle);
			}
		}

		public void DisableScriptAmbientEffects(int _p0)
		{
			unsafe {
				if (fn__disableScriptAmbientEffects == null) fn__disableScriptAmbientEffects = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableScriptAmbientEffects");
				fn__disableScriptAmbientEffects(_p0);
			}
		}

		public void PresetInteriorAmbientCache(string _timecycleModifierName)
		{
			unsafe {
				if (fn__presetInteriorAmbientCache == null) fn__presetInteriorAmbientCache = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_presetInteriorAmbientCache");
				var ptr_timecycleModifierName = MemoryUtils.StringToHGlobalUtf8(_timecycleModifierName);
				fn__presetInteriorAmbientCache(ptr_timecycleModifierName);
				Marshal.FreeHGlobal(ptr_timecycleModifierName);
			}
		}

		public void SetTimecycleModifier(string _modifierName)
		{
			unsafe {
				if (fn__setTimecycleModifier == null) fn__setTimecycleModifier = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setTimecycleModifier");
				var ptr_modifierName = MemoryUtils.StringToHGlobalUtf8(_modifierName);
				fn__setTimecycleModifier(ptr_modifierName);
				Marshal.FreeHGlobal(ptr_modifierName);
			}
		}

		public void SetTimecycleModifierStrength(float _strength)
		{
			unsafe {
				if (fn__setTimecycleModifierStrength == null) fn__setTimecycleModifierStrength = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setTimecycleModifierStrength");
				fn__setTimecycleModifierStrength(_strength);
			}
		}

		public void SetTransitionTimecycleModifier(string _modifierName, float _transition)
		{
			unsafe {
				if (fn__setTransitionTimecycleModifier == null) fn__setTransitionTimecycleModifier = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_setTransitionTimecycleModifier");
				var ptr_modifierName = MemoryUtils.StringToHGlobalUtf8(_modifierName);
				fn__setTransitionTimecycleModifier(ptr_modifierName, _transition);
				Marshal.FreeHGlobal(ptr_modifierName);
			}
		}

		public void _0x1CBA05AE7BD7EE05(float _p0)
		{
			unsafe {
				if (fn__0x1CBA05AE7BD7EE05 == null) fn__0x1CBA05AE7BD7EE05 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x1CBA05AE7BD7EE05");
				fn__0x1CBA05AE7BD7EE05(_p0);
			}
		}

		public void ClearTimecycleModifier()
		{
			unsafe {
				if (fn__clearTimecycleModifier == null) fn__clearTimecycleModifier = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearTimecycleModifier");
				fn__clearTimecycleModifier();
			}
		}

		public int GetTimecycleModifierIndex()
		{
			unsafe {
				if (fn__getTimecycleModifierIndex == null) fn__getTimecycleModifierIndex = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getTimecycleModifierIndex");
				var result = fn__getTimecycleModifierIndex();
				return result;
			}
		}

		public int GetTimecycleTransitionModifierIndex()
		{
			unsafe {
				if (fn__getTimecycleTransitionModifierIndex == null) fn__getTimecycleTransitionModifierIndex = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getTimecycleTransitionModifierIndex");
				var result = fn__getTimecycleTransitionModifierIndex();
				return result;
			}
		}

		public int _0x98D18905BF723B99()
		{
			unsafe {
				if (fn__0x98D18905BF723B99 == null) fn__0x98D18905BF723B99 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x98D18905BF723B99");
				var result = fn__0x98D18905BF723B99();
				return result;
			}
		}

		public void PushTimecycleModifier()
		{
			unsafe {
				if (fn__pushTimecycleModifier == null) fn__pushTimecycleModifier = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_pushTimecycleModifier");
				fn__pushTimecycleModifier();
			}
		}

		public void PopTimecycleModifier()
		{
			unsafe {
				if (fn__popTimecycleModifier == null) fn__popTimecycleModifier = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_popTimecycleModifier");
				fn__popTimecycleModifier();
			}
		}

		public void SetCurrentPlayerTcmodifier(string _modifierName)
		{
			unsafe {
				if (fn__setCurrentPlayerTcmodifier == null) fn__setCurrentPlayerTcmodifier = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setCurrentPlayerTcmodifier");
				var ptr_modifierName = MemoryUtils.StringToHGlobalUtf8(_modifierName);
				fn__setCurrentPlayerTcmodifier(ptr_modifierName);
				Marshal.FreeHGlobal(ptr_modifierName);
			}
		}

		public void SetPlayerTcmodifierTransition(float _value)
		{
			unsafe {
				if (fn__setPlayerTcmodifierTransition == null) fn__setPlayerTcmodifierTransition = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerTcmodifierTransition");
				fn__setPlayerTcmodifierTransition(_value);
			}
		}

		public void SetNextPlayerTcmodifier(string _modifierName)
		{
			unsafe {
				if (fn__setNextPlayerTcmodifier == null) fn__setNextPlayerTcmodifier = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setNextPlayerTcmodifier");
				var ptr_modifierName = MemoryUtils.StringToHGlobalUtf8(_modifierName);
				fn__setNextPlayerTcmodifier(ptr_modifierName);
				Marshal.FreeHGlobal(ptr_modifierName);
			}
		}

		public void AddTcmodifierOverride(string _modifierName1, string _modifierName2)
		{
			unsafe {
				if (fn__addTcmodifierOverride == null) fn__addTcmodifierOverride = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native_addTcmodifierOverride");
				var ptr_modifierName1 = MemoryUtils.StringToHGlobalUtf8(_modifierName1);
				var ptr_modifierName2 = MemoryUtils.StringToHGlobalUtf8(_modifierName2);
				fn__addTcmodifierOverride(ptr_modifierName1, ptr_modifierName2);
				Marshal.FreeHGlobal(ptr_modifierName1);
				Marshal.FreeHGlobal(ptr_modifierName2);
			}
		}

		public void RemoveTcmodifierOverride(string _p0)
		{
			unsafe {
				if (fn__removeTcmodifierOverride == null) fn__removeTcmodifierOverride = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeTcmodifierOverride");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__removeTcmodifierOverride(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void SetExtraTimecycleModifier(string _modifierName)
		{
			unsafe {
				if (fn__setExtraTimecycleModifier == null) fn__setExtraTimecycleModifier = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setExtraTimecycleModifier");
				var ptr_modifierName = MemoryUtils.StringToHGlobalUtf8(_modifierName);
				fn__setExtraTimecycleModifier(ptr_modifierName);
				Marshal.FreeHGlobal(ptr_modifierName);
			}
		}

		public void ClearExtraTimecycleModifier()
		{
			unsafe {
				if (fn__clearExtraTimecycleModifier == null) fn__clearExtraTimecycleModifier = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearExtraTimecycleModifier");
				fn__clearExtraTimecycleModifier();
			}
		}

		public int GetExtraTimecycleModifierIndex()
		{
			unsafe {
				if (fn__getExtraTimecycleModifierIndex == null) fn__getExtraTimecycleModifierIndex = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getExtraTimecycleModifierIndex");
				var result = fn__getExtraTimecycleModifierIndex();
				return result;
			}
		}

		public void SetExtraTimecycleModifierStrength(float _strength)
		{
			unsafe {
				if (fn__setExtraTimecycleModifierStrength == null) fn__setExtraTimecycleModifierStrength = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setExtraTimecycleModifierStrength");
				fn__setExtraTimecycleModifierStrength(_strength);
			}
		}

		public void ResetExtraTimecycleModifierStrength()
		{
			unsafe {
				if (fn__resetExtraTimecycleModifierStrength == null) fn__resetExtraTimecycleModifierStrength = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetExtraTimecycleModifierStrength");
				fn__resetExtraTimecycleModifierStrength();
			}
		}

		public int RequestScaleformMovie(string _scaleformName)
		{
			unsafe {
				if (fn__requestScaleformMovie == null) fn__requestScaleformMovie = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_requestScaleformMovie");
				var ptr_scaleformName = MemoryUtils.StringToHGlobalUtf8(_scaleformName);
				var result = fn__requestScaleformMovie(ptr_scaleformName);
				Marshal.FreeHGlobal(ptr_scaleformName);
				return result;
			}
		}

		public int RequestScaleformMovieInstance(string _scaleformName)
		{
			unsafe {
				if (fn__requestScaleformMovieInstance == null) fn__requestScaleformMovieInstance = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_requestScaleformMovieInstance");
				var ptr_scaleformName = MemoryUtils.StringToHGlobalUtf8(_scaleformName);
				var result = fn__requestScaleformMovieInstance(ptr_scaleformName);
				Marshal.FreeHGlobal(ptr_scaleformName);
				return result;
			}
		}

		public int RequestScaleformMovieInteractive(string _scaleformName)
		{
			unsafe {
				if (fn__requestScaleformMovieInteractive == null) fn__requestScaleformMovieInteractive = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_requestScaleformMovieInteractive");
				var ptr_scaleformName = MemoryUtils.StringToHGlobalUtf8(_scaleformName);
				var result = fn__requestScaleformMovieInteractive(ptr_scaleformName);
				Marshal.FreeHGlobal(ptr_scaleformName);
				return result;
			}
		}

		public bool HasScaleformMovieLoaded(int _scaleformHandle)
		{
			unsafe {
				if (fn__hasScaleformMovieLoaded == null) fn__hasScaleformMovieLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasScaleformMovieLoaded");
				var result = fn__hasScaleformMovieLoaded(_scaleformHandle);
				return result;
			}
		}

		public bool _0x2FCB133CA50A49EB(int _val)
		{
			unsafe {
				if (fn__0x2FCB133CA50A49EB == null) fn__0x2FCB133CA50A49EB = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x2FCB133CA50A49EB");
				var result = fn__0x2FCB133CA50A49EB(_val);
				return result;
			}
		}

		public bool _0x86255B1FC929E33E(int _val)
		{
			unsafe {
				if (fn__0x86255B1FC929E33E == null) fn__0x86255B1FC929E33E = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x86255B1FC929E33E");
				var result = fn__0x86255B1FC929E33E(_val);
				return result;
			}
		}

		public bool HasScaleformMovieFilenameLoaded(string _scaleformName)
		{
			unsafe {
				if (fn__hasScaleformMovieFilenameLoaded == null) fn__hasScaleformMovieFilenameLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasScaleformMovieFilenameLoaded");
				var ptr_scaleformName = MemoryUtils.StringToHGlobalUtf8(_scaleformName);
				var result = fn__hasScaleformMovieFilenameLoaded(ptr_scaleformName);
				Marshal.FreeHGlobal(ptr_scaleformName);
				return result;
			}
		}

		public bool HasScaleformContainerMovieLoadedIntoParent(int _scaleformHandle)
		{
			unsafe {
				if (fn__hasScaleformContainerMovieLoadedIntoParent == null) fn__hasScaleformContainerMovieLoadedIntoParent = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasScaleformContainerMovieLoadedIntoParent");
				var result = fn__hasScaleformContainerMovieLoadedIntoParent(_scaleformHandle);
				return result;
			}
		}

		public void SetScaleformMovieAsNoLongerNeeded(ref int _scaleformHandle)
		{
			unsafe {
				if (fn__setScaleformMovieAsNoLongerNeeded == null) fn__setScaleformMovieAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_setScaleformMovieAsNoLongerNeeded");
				var ref_scaleformHandle = _scaleformHandle;
				fn__setScaleformMovieAsNoLongerNeeded(&ref_scaleformHandle);
				_scaleformHandle = ref_scaleformHandle;
			}
		}

		public void SetScaleformMovieToUseSystemTime(int _scaleform, bool _toggle)
		{
			unsafe {
				if (fn__setScaleformMovieToUseSystemTime == null) fn__setScaleformMovieToUseSystemTime = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setScaleformMovieToUseSystemTime");
				fn__setScaleformMovieToUseSystemTime(_scaleform, _toggle);
			}
		}

		public void _0x32F34FF7F617643B(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x32F34FF7F617643B == null) fn__0x32F34FF7F617643B = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x32F34FF7F617643B");
				fn__0x32F34FF7F617643B(_p0, _p1);
			}
		}

		public void SetScaleformFitRendertarget(int _scaleformHandle, bool _toggle)
		{
			unsafe {
				if (fn__setScaleformFitRendertarget == null) fn__setScaleformFitRendertarget = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setScaleformFitRendertarget");
				fn__setScaleformFitRendertarget(_scaleformHandle, _toggle);
			}
		}

		public void DrawScaleformMovie(int _scaleformHandle, float _x, float _y, float _width, float _height, int _red, int _green, int _blue, int _alpha, int _unk)
		{
			unsafe {
				if (fn__drawScaleformMovie == null) fn__drawScaleformMovie = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawScaleformMovie");
				fn__drawScaleformMovie(_scaleformHandle, _x, _y, _width, _height, _red, _green, _blue, _alpha, _unk);
			}
		}

		public void DrawScaleformMovieFullscreen(int _scaleform, int _red, int _green, int _blue, int _alpha, int _unk)
		{
			unsafe {
				if (fn__drawScaleformMovieFullscreen == null) fn__drawScaleformMovieFullscreen = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawScaleformMovieFullscreen");
				fn__drawScaleformMovieFullscreen(_scaleform, _red, _green, _blue, _alpha, _unk);
			}
		}

		public void DrawScaleformMovieFullscreenMasked(int _scaleform1, int _scaleform2, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawScaleformMovieFullscreenMasked == null) fn__drawScaleformMovieFullscreenMasked = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawScaleformMovieFullscreenMasked");
				fn__drawScaleformMovieFullscreenMasked(_scaleform1, _scaleform2, _red, _green, _blue, _alpha);
			}
		}

		public void DrawScaleformMovie3d(int _scaleform, float _posX, float _posY, float _posZ, float _rotX, float _rotY, float _rotZ, float _p7, float _p8, float _p9, float _scaleX, float _scaleY, float _scaleZ, int _p13)
		{
			unsafe {
				if (fn__drawScaleformMovie3d == null) fn__drawScaleformMovie3d = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_drawScaleformMovie3d");
				fn__drawScaleformMovie3d(_scaleform, _posX, _posY, _posZ, _rotX, _rotY, _rotZ, _p7, _p8, _p9, _scaleX, _scaleY, _scaleZ, _p13);
			}
		}

		public void DrawScaleformMovie3dSolid(int _scaleform, float _posX, float _posY, float _posZ, float _rotX, float _rotY, float _rotZ, float _p7, float _p8, float _p9, float _scaleX, float _scaleY, float _scaleZ, int _p13)
		{
			unsafe {
				if (fn__drawScaleformMovie3dSolid == null) fn__drawScaleformMovie3dSolid = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_drawScaleformMovie3dSolid");
				fn__drawScaleformMovie3dSolid(_scaleform, _posX, _posY, _posZ, _rotX, _rotY, _rotZ, _p7, _p8, _p9, _scaleX, _scaleY, _scaleZ, _p13);
			}
		}

		public void CallScaleformMovieMethod(int _scaleform, string _method)
		{
			unsafe {
				if (fn__callScaleformMovieMethod == null) fn__callScaleformMovieMethod = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_callScaleformMovieMethod");
				var ptr_method = MemoryUtils.StringToHGlobalUtf8(_method);
				fn__callScaleformMovieMethod(_scaleform, ptr_method);
				Marshal.FreeHGlobal(ptr_method);
			}
		}

		public void CallScaleformMovieMethodWithNumber(int _scaleform, string _methodName, float _param1, float _param2, float _param3, float _param4, float _param5)
		{
			unsafe {
				if (fn__callScaleformMovieMethodWithNumber == null) fn__callScaleformMovieMethodWithNumber = (delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_callScaleformMovieMethodWithNumber");
				var ptr_methodName = MemoryUtils.StringToHGlobalUtf8(_methodName);
				fn__callScaleformMovieMethodWithNumber(_scaleform, ptr_methodName, _param1, _param2, _param3, _param4, _param5);
				Marshal.FreeHGlobal(ptr_methodName);
			}
		}

		public void CallScaleformMovieMethodWithString(int _scaleform, string _methodName, string _param1, string _param2, string _param3, string _param4, string _param5)
		{
			unsafe {
				if (fn__callScaleformMovieMethodWithString == null) fn__callScaleformMovieMethodWithString = (delegate* unmanaged[Cdecl]<int, nint, nint, nint, nint, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_callScaleformMovieMethodWithString");
				var ptr_methodName = MemoryUtils.StringToHGlobalUtf8(_methodName);
				var ptr_param1 = MemoryUtils.StringToHGlobalUtf8(_param1);
				var ptr_param2 = MemoryUtils.StringToHGlobalUtf8(_param2);
				var ptr_param3 = MemoryUtils.StringToHGlobalUtf8(_param3);
				var ptr_param4 = MemoryUtils.StringToHGlobalUtf8(_param4);
				var ptr_param5 = MemoryUtils.StringToHGlobalUtf8(_param5);
				fn__callScaleformMovieMethodWithString(_scaleform, ptr_methodName, ptr_param1, ptr_param2, ptr_param3, ptr_param4, ptr_param5);
				Marshal.FreeHGlobal(ptr_methodName);
				Marshal.FreeHGlobal(ptr_param1);
				Marshal.FreeHGlobal(ptr_param2);
				Marshal.FreeHGlobal(ptr_param3);
				Marshal.FreeHGlobal(ptr_param4);
				Marshal.FreeHGlobal(ptr_param5);
			}
		}

		public void CallScaleformMovieMethodWithNumberAndString(int _scaleform, string _methodName, float _floatParam1, float _floatParam2, float _floatParam3, float _floatParam4, float _floatParam5, string _stringParam1, string _stringParam2, string _stringParam3, string _stringParam4, string _stringParam5)
		{
			unsafe {
				if (fn__callScaleformMovieMethodWithNumberAndString == null) fn__callScaleformMovieMethodWithNumberAndString = (delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, float, nint, nint, nint, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_callScaleformMovieMethodWithNumberAndString");
				var ptr_methodName = MemoryUtils.StringToHGlobalUtf8(_methodName);
				var ptr_stringParam1 = MemoryUtils.StringToHGlobalUtf8(_stringParam1);
				var ptr_stringParam2 = MemoryUtils.StringToHGlobalUtf8(_stringParam2);
				var ptr_stringParam3 = MemoryUtils.StringToHGlobalUtf8(_stringParam3);
				var ptr_stringParam4 = MemoryUtils.StringToHGlobalUtf8(_stringParam4);
				var ptr_stringParam5 = MemoryUtils.StringToHGlobalUtf8(_stringParam5);
				fn__callScaleformMovieMethodWithNumberAndString(_scaleform, ptr_methodName, _floatParam1, _floatParam2, _floatParam3, _floatParam4, _floatParam5, ptr_stringParam1, ptr_stringParam2, ptr_stringParam3, ptr_stringParam4, ptr_stringParam5);
				Marshal.FreeHGlobal(ptr_methodName);
				Marshal.FreeHGlobal(ptr_stringParam1);
				Marshal.FreeHGlobal(ptr_stringParam2);
				Marshal.FreeHGlobal(ptr_stringParam3);
				Marshal.FreeHGlobal(ptr_stringParam4);
				Marshal.FreeHGlobal(ptr_stringParam5);
			}
		}

		public bool BeginScaleformScriptHudMovieMethod(int _hudComponent, string _methodName)
		{
			unsafe {
				if (fn__beginScaleformScriptHudMovieMethod == null) fn__beginScaleformScriptHudMovieMethod = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_beginScaleformScriptHudMovieMethod");
				var ptr_methodName = MemoryUtils.StringToHGlobalUtf8(_methodName);
				var result = fn__beginScaleformScriptHudMovieMethod(_hudComponent, ptr_methodName);
				Marshal.FreeHGlobal(ptr_methodName);
				return result;
			}
		}

		public bool BeginScaleformMovieMethod(int _scaleform, string _methodName)
		{
			unsafe {
				if (fn__beginScaleformMovieMethod == null) fn__beginScaleformMovieMethod = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_beginScaleformMovieMethod");
				var ptr_methodName = MemoryUtils.StringToHGlobalUtf8(_methodName);
				var result = fn__beginScaleformMovieMethod(_scaleform, ptr_methodName);
				Marshal.FreeHGlobal(ptr_methodName);
				return result;
			}
		}

		public bool BeginScaleformMovieMethodOnFrontend(string _methodName)
		{
			unsafe {
				if (fn__beginScaleformMovieMethodOnFrontend == null) fn__beginScaleformMovieMethodOnFrontend = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_beginScaleformMovieMethodOnFrontend");
				var ptr_methodName = MemoryUtils.StringToHGlobalUtf8(_methodName);
				var result = fn__beginScaleformMovieMethodOnFrontend(ptr_methodName);
				Marshal.FreeHGlobal(ptr_methodName);
				return result;
			}
		}

		public bool BeginScaleformMovieMethodOnFrontendHeader(string _methodName)
		{
			unsafe {
				if (fn__beginScaleformMovieMethodOnFrontendHeader == null) fn__beginScaleformMovieMethodOnFrontendHeader = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_beginScaleformMovieMethodOnFrontendHeader");
				var ptr_methodName = MemoryUtils.StringToHGlobalUtf8(_methodName);
				var result = fn__beginScaleformMovieMethodOnFrontendHeader(ptr_methodName);
				Marshal.FreeHGlobal(ptr_methodName);
				return result;
			}
		}

		public void EndScaleformMovieMethod()
		{
			unsafe {
				if (fn__endScaleformMovieMethod == null) fn__endScaleformMovieMethod = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_endScaleformMovieMethod");
				fn__endScaleformMovieMethod();
			}
		}

		public int EndScaleformMovieMethodReturnValue()
		{
			unsafe {
				if (fn__endScaleformMovieMethodReturnValue == null) fn__endScaleformMovieMethodReturnValue = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_endScaleformMovieMethodReturnValue");
				var result = fn__endScaleformMovieMethodReturnValue();
				return result;
			}
		}

		public bool IsScaleformMovieMethodReturnValueReady(int _methodReturn)
		{
			unsafe {
				if (fn__isScaleformMovieMethodReturnValueReady == null) fn__isScaleformMovieMethodReturnValueReady = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isScaleformMovieMethodReturnValueReady");
				var result = fn__isScaleformMovieMethodReturnValueReady(_methodReturn);
				return result;
			}
		}

		public int GetScaleformMovieMethodReturnValueInt(int _methodReturn)
		{
			unsafe {
				if (fn__getScaleformMovieMethodReturnValueInt == null) fn__getScaleformMovieMethodReturnValueInt = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getScaleformMovieMethodReturnValueInt");
				var result = fn__getScaleformMovieMethodReturnValueInt(_methodReturn);
				return result;
			}
		}

		public bool GetScaleformMovieMethodReturnValueBool(int _methodReturn)
		{
			unsafe {
				if (fn__getScaleformMovieMethodReturnValueBool == null) fn__getScaleformMovieMethodReturnValueBool = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getScaleformMovieMethodReturnValueBool");
				var result = fn__getScaleformMovieMethodReturnValueBool(_methodReturn);
				return result;
			}
		}

		public string GetScaleformMovieMethodReturnValueString(int _methodReturn)
		{
			unsafe {
				if (fn__getScaleformMovieMethodReturnValueString == null) fn__getScaleformMovieMethodReturnValueString = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getScaleformMovieMethodReturnValueString");
				var result = fn__getScaleformMovieMethodReturnValueString(_methodReturn);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void ScaleformMovieMethodAddParamInt(int _value)
		{
			unsafe {
				if (fn__scaleformMovieMethodAddParamInt == null) fn__scaleformMovieMethodAddParamInt = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_scaleformMovieMethodAddParamInt");
				fn__scaleformMovieMethodAddParamInt(_value);
			}
		}

		public void ScaleformMovieMethodAddParamFloat(float _value)
		{
			unsafe {
				if (fn__scaleformMovieMethodAddParamFloat == null) fn__scaleformMovieMethodAddParamFloat = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_scaleformMovieMethodAddParamFloat");
				fn__scaleformMovieMethodAddParamFloat(_value);
			}
		}

		public void ScaleformMovieMethodAddParamBool(bool _value)
		{
			unsafe {
				if (fn__scaleformMovieMethodAddParamBool == null) fn__scaleformMovieMethodAddParamBool = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_scaleformMovieMethodAddParamBool");
				fn__scaleformMovieMethodAddParamBool(_value);
			}
		}

		public void BeginTextCommandScaleformString(string _componentType)
		{
			unsafe {
				if (fn__beginTextCommandScaleformString == null) fn__beginTextCommandScaleformString = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandScaleformString");
				var ptr_componentType = MemoryUtils.StringToHGlobalUtf8(_componentType);
				fn__beginTextCommandScaleformString(ptr_componentType);
				Marshal.FreeHGlobal(ptr_componentType);
			}
		}

		public void EndTextCommandScaleformString()
		{
			unsafe {
				if (fn__endTextCommandScaleformString == null) fn__endTextCommandScaleformString = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_endTextCommandScaleformString");
				fn__endTextCommandScaleformString();
			}
		}

		public void EndTextCommandScaleformString2()
		{
			unsafe {
				if (fn__endTextCommandScaleformString2 == null) fn__endTextCommandScaleformString2 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_endTextCommandScaleformString2");
				fn__endTextCommandScaleformString2();
			}
		}

		public void ScaleformMovieMethodAddParamTextureNameString2(string _string)
		{
			unsafe {
				if (fn__scaleformMovieMethodAddParamTextureNameString2 == null) fn__scaleformMovieMethodAddParamTextureNameString2 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_scaleformMovieMethodAddParamTextureNameString2");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				fn__scaleformMovieMethodAddParamTextureNameString2(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
			}
		}

		public void ScaleformMovieMethodAddParamTextureNameString(string _string)
		{
			unsafe {
				if (fn__scaleformMovieMethodAddParamTextureNameString == null) fn__scaleformMovieMethodAddParamTextureNameString = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_scaleformMovieMethodAddParamTextureNameString");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				fn__scaleformMovieMethodAddParamTextureNameString(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
			}
		}

		public void ScaleformMovieMethodAddParamPlayerNameString(string _string)
		{
			unsafe {
				if (fn__scaleformMovieMethodAddParamPlayerNameString == null) fn__scaleformMovieMethodAddParamPlayerNameString = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_scaleformMovieMethodAddParamPlayerNameString");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				fn__scaleformMovieMethodAddParamPlayerNameString(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
			}
		}

		public bool DoesLatestBriefStringExist(int _p0)
		{
			unsafe {
				if (fn__doesLatestBriefStringExist == null) fn__doesLatestBriefStringExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesLatestBriefStringExist");
				var result = fn__doesLatestBriefStringExist(_p0);
				return result;
			}
		}

		public void ScaleformMovieMethodAddParamLatestBriefString(int _value)
		{
			unsafe {
				if (fn__scaleformMovieMethodAddParamLatestBriefString == null) fn__scaleformMovieMethodAddParamLatestBriefString = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_scaleformMovieMethodAddParamLatestBriefString");
				fn__scaleformMovieMethodAddParamLatestBriefString(_value);
			}
		}

		public void RequestScaleformScriptHudMovie(int _hudComponent)
		{
			unsafe {
				if (fn__requestScaleformScriptHudMovie == null) fn__requestScaleformScriptHudMovie = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestScaleformScriptHudMovie");
				fn__requestScaleformScriptHudMovie(_hudComponent);
			}
		}

		public bool HasScaleformScriptHudMovieLoaded(int _hudComponent)
		{
			unsafe {
				if (fn__hasScaleformScriptHudMovieLoaded == null) fn__hasScaleformScriptHudMovieLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasScaleformScriptHudMovieLoaded");
				var result = fn__hasScaleformScriptHudMovieLoaded(_hudComponent);
				return result;
			}
		}

		public void RemoveScaleformScriptHudMovie(int _hudComponent)
		{
			unsafe {
				if (fn__removeScaleformScriptHudMovie == null) fn__removeScaleformScriptHudMovie = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeScaleformScriptHudMovie");
				fn__removeScaleformScriptHudMovie(_hudComponent);
			}
		}

		public bool _0xD1C7CB175E012964(int _scaleformHandle)
		{
			unsafe {
				if (fn__0xD1C7CB175E012964 == null) fn__0xD1C7CB175E012964 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xD1C7CB175E012964");
				var result = fn__0xD1C7CB175E012964(_scaleformHandle);
				return result;
			}
		}

		public void SetTvChannel(int _channel)
		{
			unsafe {
				if (fn__setTvChannel == null) fn__setTvChannel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setTvChannel");
				fn__setTvChannel(_channel);
			}
		}

		public int GetTvChannel()
		{
			unsafe {
				if (fn__getTvChannel == null) fn__getTvChannel = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getTvChannel");
				var result = fn__getTvChannel();
				return result;
			}
		}

		public void SetTvVolume(float _volume)
		{
			unsafe {
				if (fn__setTvVolume == null) fn__setTvVolume = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setTvVolume");
				fn__setTvVolume(_volume);
			}
		}

		public float GetTvVolume()
		{
			unsafe {
				if (fn__getTvVolume == null) fn__getTvVolume = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getTvVolume");
				var result = fn__getTvVolume();
				return result;
			}
		}

		public void DrawTvChannel(float _xPos, float _yPos, float _xScale, float _yScale, float _rotation, int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__drawTvChannel == null) fn__drawTvChannel = (delegate* unmanaged[Cdecl]<float, float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_drawTvChannel");
				fn__drawTvChannel(_xPos, _yPos, _xScale, _yScale, _rotation, _red, _green, _blue, _alpha);
			}
		}

		public void SetTvChannelPlaylist(int _tvChannel, string _playlistName, bool _restart)
		{
			unsafe {
				if (fn__setTvChannelPlaylist == null) fn__setTvChannelPlaylist = (delegate* unmanaged[Cdecl]<int, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setTvChannelPlaylist");
				var ptr_playlistName = MemoryUtils.StringToHGlobalUtf8(_playlistName);
				fn__setTvChannelPlaylist(_tvChannel, ptr_playlistName, _restart);
				Marshal.FreeHGlobal(ptr_playlistName);
			}
		}

		public void SetTvChannelPlaylistAtHour(int _tvChannel, string _playlistName, int _hour)
		{
			unsafe {
				if (fn__setTvChannelPlaylistAtHour == null) fn__setTvChannelPlaylistAtHour = (delegate* unmanaged[Cdecl]<int, nint, int, void>) NativeLibrary.GetExport(handle, "Native_setTvChannelPlaylistAtHour");
				var ptr_playlistName = MemoryUtils.StringToHGlobalUtf8(_playlistName);
				fn__setTvChannelPlaylistAtHour(_tvChannel, ptr_playlistName, _hour);
				Marshal.FreeHGlobal(ptr_playlistName);
			}
		}

		public void ClearTvChannelPlaylist(int _tvChannel)
		{
			unsafe {
				if (fn__clearTvChannelPlaylist == null) fn__clearTvChannelPlaylist = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearTvChannelPlaylist");
				fn__clearTvChannelPlaylist(_tvChannel);
			}
		}

		public bool IsPlaylistUnk(int _tvChannel, int _p1)
		{
			unsafe {
				if (fn__isPlaylistUnk == null) fn__isPlaylistUnk = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPlaylistUnk");
				var result = fn__isPlaylistUnk(_tvChannel, _p1);
				return result;
			}
		}

		public bool IsTvPlaylistItemPlaying(int _videoCliphash)
		{
			unsafe {
				if (fn__isTvPlaylistItemPlaying == null) fn__isTvPlaylistItemPlaying = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isTvPlaylistItemPlaying");
				var result = fn__isTvPlaylistItemPlaying(_videoCliphash);
				return result;
			}
		}

		public void EnableMovieKeyframeWait(bool _toggle)
		{
			unsafe {
				if (fn__enableMovieKeyframeWait == null) fn__enableMovieKeyframeWait = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_enableMovieKeyframeWait");
				fn__enableMovieKeyframeWait(_toggle);
			}
		}

		public void _0xD1C55B110E4DF534(int _p0)
		{
			unsafe {
				if (fn__0xD1C55B110E4DF534 == null) fn__0xD1C55B110E4DF534 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xD1C55B110E4DF534");
				fn__0xD1C55B110E4DF534(_p0);
			}
		}

		public int _0x30432A0118736E00()
		{
			unsafe {
				if (fn__0x30432A0118736E00 == null) fn__0x30432A0118736E00 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x30432A0118736E00");
				var result = fn__0x30432A0118736E00();
				return result;
			}
		}

		public void EnableMovieSubtitles(bool _toggle)
		{
			unsafe {
				if (fn__enableMovieSubtitles == null) fn__enableMovieSubtitles = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_enableMovieSubtitles");
				fn__enableMovieSubtitles(_toggle);
			}
		}

		public bool Ui3dsceneIsAvailable()
		{
			unsafe {
				if (fn__ui3dsceneIsAvailable == null) fn__ui3dsceneIsAvailable = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_ui3dsceneIsAvailable");
				var result = fn__ui3dsceneIsAvailable();
				return result;
			}
		}

		public bool Ui3dscenePushPreset(string _presetName)
		{
			unsafe {
				if (fn__ui3dscenePushPreset == null) fn__ui3dscenePushPreset = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_ui3dscenePushPreset");
				var ptr_presetName = MemoryUtils.StringToHGlobalUtf8(_presetName);
				var result = fn__ui3dscenePushPreset(ptr_presetName);
				Marshal.FreeHGlobal(ptr_presetName);
				return result;
			}
		}

		public bool _0x98C4FE6EC34154CA(string _presetName, int _ped, int _p2, float _posX, float _posY, float _posZ)
		{
			unsafe {
				if (fn__0x98C4FE6EC34154CA == null) fn__0x98C4FE6EC34154CA = (delegate* unmanaged[Cdecl]<nint, int, int, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native__0x98C4FE6EC34154CA");
				var ptr_presetName = MemoryUtils.StringToHGlobalUtf8(_presetName);
				var result = fn__0x98C4FE6EC34154CA(ptr_presetName, _ped, _p2, _posX, _posY, _posZ);
				Marshal.FreeHGlobal(ptr_presetName);
				return result;
			}
		}

		public void _0x7A42B2E236E71415()
		{
			unsafe {
				if (fn__0x7A42B2E236E71415 == null) fn__0x7A42B2E236E71415 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x7A42B2E236E71415");
				fn__0x7A42B2E236E71415();
			}
		}

		public void _0x108BE26959A9D9BB(bool _toggle)
		{
			unsafe {
				if (fn__0x108BE26959A9D9BB == null) fn__0x108BE26959A9D9BB = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x108BE26959A9D9BB");
				fn__0x108BE26959A9D9BB(_toggle);
			}
		}

		public void TerraingridActivate(bool _toggle)
		{
			unsafe {
				if (fn__terraingridActivate == null) fn__terraingridActivate = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_terraingridActivate");
				fn__terraingridActivate(_toggle);
			}
		}

		public void TerraingridSetParams(float _x, float _y, float _z, float _p3, float _rotation, float _p5, float _width, float _height, float _p8, float _scale, float _glowIntensity, float _normalHeight, float _heightDiff)
		{
			unsafe {
				if (fn__terraingridSetParams == null) fn__terraingridSetParams = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_terraingridSetParams");
				fn__terraingridSetParams(_x, _y, _z, _p3, _rotation, _p5, _width, _height, _p8, _scale, _glowIntensity, _normalHeight, _heightDiff);
			}
		}

		public void TerraingridSetColours(int _lowR, int _lowG, int _lowB, int _lowAlpha, int _r, int _g, int _b, int _alpha, int _highR, int _highG, int _highB, int _highAlpha)
		{
			unsafe {
				if (fn__terraingridSetColours == null) fn__terraingridSetColours = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_terraingridSetColours");
				fn__terraingridSetColours(_lowR, _lowG, _lowB, _lowAlpha, _r, _g, _b, _alpha, _highR, _highG, _highB, _highAlpha);
			}
		}

		public void AnimpostfxPlay(string _effectName, int _duration, bool _looped)
		{
			unsafe {
				if (fn__animpostfxPlay == null) fn__animpostfxPlay = (delegate* unmanaged[Cdecl]<nint, int, bool, void>) NativeLibrary.GetExport(handle, "Native_animpostfxPlay");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				fn__animpostfxPlay(ptr_effectName, _duration, _looped);
				Marshal.FreeHGlobal(ptr_effectName);
			}
		}

		public void AnimpostfxStop(string _effectName)
		{
			unsafe {
				if (fn__animpostfxStop == null) fn__animpostfxStop = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_animpostfxStop");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				fn__animpostfxStop(ptr_effectName);
				Marshal.FreeHGlobal(ptr_effectName);
			}
		}

		public float AnimpostfxGetUnk(string _effectName)
		{
			unsafe {
				if (fn__animpostfxGetUnk == null) fn__animpostfxGetUnk = (delegate* unmanaged[Cdecl]<nint, float>) NativeLibrary.GetExport(handle, "Native_animpostfxGetUnk");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__animpostfxGetUnk(ptr_effectName);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public bool AnimpostfxIsRunning(string _effectName)
		{
			unsafe {
				if (fn__animpostfxIsRunning == null) fn__animpostfxIsRunning = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_animpostfxIsRunning");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				var result = fn__animpostfxIsRunning(ptr_effectName);
				Marshal.FreeHGlobal(ptr_effectName);
				return result;
			}
		}

		public void AnimpostfxStopAll()
		{
			unsafe {
				if (fn__animpostfxStopAll == null) fn__animpostfxStopAll = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_animpostfxStopAll");
				fn__animpostfxStopAll();
			}
		}

		public void AnimpostfxStopAndDoUnk(string _effectName)
		{
			unsafe {
				if (fn__animpostfxStopAndDoUnk == null) fn__animpostfxStopAndDoUnk = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_animpostfxStopAndDoUnk");
				var ptr_effectName = MemoryUtils.StringToHGlobalUtf8(_effectName);
				fn__animpostfxStopAndDoUnk(ptr_effectName);
				Marshal.FreeHGlobal(ptr_effectName);
			}
		}

		public void PlayPedRingtone(string _ringtoneName, int _ped, bool _p2)
		{
			unsafe {
				if (fn__playPedRingtone == null) fn__playPedRingtone = (delegate* unmanaged[Cdecl]<nint, int, bool, void>) NativeLibrary.GetExport(handle, "Native_playPedRingtone");
				var ptr_ringtoneName = MemoryUtils.StringToHGlobalUtf8(_ringtoneName);
				fn__playPedRingtone(ptr_ringtoneName, _ped, _p2);
				Marshal.FreeHGlobal(ptr_ringtoneName);
			}
		}

		public bool IsPedRingtonePlaying(int _ped)
		{
			unsafe {
				if (fn__isPedRingtonePlaying == null) fn__isPedRingtonePlaying = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedRingtonePlaying");
				var result = fn__isPedRingtonePlaying(_ped);
				return result;
			}
		}

		public void StopPedRingtone(int _ped)
		{
			unsafe {
				if (fn__stopPedRingtone == null) fn__stopPedRingtone = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopPedRingtone");
				fn__stopPedRingtone(_ped);
			}
		}

		public bool IsMobilePhoneCallOngoing()
		{
			unsafe {
				if (fn__isMobilePhoneCallOngoing == null) fn__isMobilePhoneCallOngoing = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMobilePhoneCallOngoing");
				var result = fn__isMobilePhoneCallOngoing();
				return result;
			}
		}

		public bool _0xC8B1B2425604CDD0()
		{
			unsafe {
				if (fn__0xC8B1B2425604CDD0 == null) fn__0xC8B1B2425604CDD0 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xC8B1B2425604CDD0");
				var result = fn__0xC8B1B2425604CDD0();
				return result;
			}
		}

		public void CreateNewScriptedConversation()
		{
			unsafe {
				if (fn__createNewScriptedConversation == null) fn__createNewScriptedConversation = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_createNewScriptedConversation");
				fn__createNewScriptedConversation();
			}
		}

		public void AddLineToConversation(int _index, string _p1, string _p2, int _p3, int _p4, bool _p5, bool _p6, bool _p7, bool _p8, int _p9, bool _p10, bool _p11, bool _p12)
		{
			unsafe {
				if (fn__addLineToConversation == null) fn__addLineToConversation = (delegate* unmanaged[Cdecl]<int, nint, nint, int, int, bool, bool, bool, bool, int, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_addLineToConversation");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				fn__addLineToConversation(_index, ptr_p1, ptr_p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12);
				Marshal.FreeHGlobal(ptr_p1);
				Marshal.FreeHGlobal(ptr_p2);
			}
		}

		public void AddPedToConversation(int _index, int _ped, string _p2)
		{
			unsafe {
				if (fn__addPedToConversation == null) fn__addPedToConversation = (delegate* unmanaged[Cdecl]<int, int, nint, void>) NativeLibrary.GetExport(handle, "Native_addPedToConversation");
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				fn__addPedToConversation(_index, _ped, ptr_p2);
				Marshal.FreeHGlobal(ptr_p2);
			}
		}

		public void _0x33E3C6C6F2F0B506(int _p0, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__0x33E3C6C6F2F0B506 == null) fn__0x33E3C6C6F2F0B506 = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0x33E3C6C6F2F0B506");
				fn__0x33E3C6C6F2F0B506(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x892B6AB8F33606F5(int _p0, int _entity)
		{
			unsafe {
				if (fn__0x892B6AB8F33606F5 == null) fn__0x892B6AB8F33606F5 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x892B6AB8F33606F5");
				fn__0x892B6AB8F33606F5(_p0, _entity);
			}
		}

		public void SetMicrophonePosition(bool _p0, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _x3, float _y3, float _z3)
		{
			unsafe {
				if (fn__setMicrophonePosition == null) fn__setMicrophonePosition = (delegate* unmanaged[Cdecl]<bool, float, float, float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setMicrophonePosition");
				fn__setMicrophonePosition(_p0, _x1, _y1, _z1, _x2, _y2, _z2, _x3, _y3, _z3);
			}
		}

		public void _0x0B568201DD99F0EB(bool _p0)
		{
			unsafe {
				if (fn__0x0B568201DD99F0EB == null) fn__0x0B568201DD99F0EB = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x0B568201DD99F0EB");
				fn__0x0B568201DD99F0EB(_p0);
			}
		}

		public void _0x61631F5DF50D1C34(bool _p0)
		{
			unsafe {
				if (fn__0x61631F5DF50D1C34 == null) fn__0x61631F5DF50D1C34 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x61631F5DF50D1C34");
				fn__0x61631F5DF50D1C34(_p0);
			}
		}

		public void StartScriptPhoneConversation(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__startScriptPhoneConversation == null) fn__startScriptPhoneConversation = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_startScriptPhoneConversation");
				fn__startScriptPhoneConversation(_p0, _p1);
			}
		}

		public void PreloadScriptPhoneConversation(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__preloadScriptPhoneConversation == null) fn__preloadScriptPhoneConversation = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_preloadScriptPhoneConversation");
				fn__preloadScriptPhoneConversation(_p0, _p1);
			}
		}

		public void StartScriptConversation(bool _p0, bool _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__startScriptConversation == null) fn__startScriptConversation = (delegate* unmanaged[Cdecl]<bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_startScriptConversation");
				fn__startScriptConversation(_p0, _p1, _p2, _p3);
			}
		}

		public void PreloadScriptConversation(bool _p0, bool _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__preloadScriptConversation == null) fn__preloadScriptConversation = (delegate* unmanaged[Cdecl]<bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_preloadScriptConversation");
				fn__preloadScriptConversation(_p0, _p1, _p2, _p3);
			}
		}

		public void StartPreloadedConversation()
		{
			unsafe {
				if (fn__startPreloadedConversation == null) fn__startPreloadedConversation = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_startPreloadedConversation");
				fn__startPreloadedConversation();
			}
		}

		public bool GetIsPreloadedConversationReady()
		{
			unsafe {
				if (fn__getIsPreloadedConversationReady == null) fn__getIsPreloadedConversationReady = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getIsPreloadedConversationReady");
				var result = fn__getIsPreloadedConversationReady();
				return result;
			}
		}

		public bool IsScriptedConversationOngoing()
		{
			unsafe {
				if (fn__isScriptedConversationOngoing == null) fn__isScriptedConversationOngoing = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isScriptedConversationOngoing");
				var result = fn__isScriptedConversationOngoing();
				return result;
			}
		}

		public bool IsScriptedConversationLoaded()
		{
			unsafe {
				if (fn__isScriptedConversationLoaded == null) fn__isScriptedConversationLoaded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isScriptedConversationLoaded");
				var result = fn__isScriptedConversationLoaded();
				return result;
			}
		}

		public int GetCurrentScriptedConversationLine()
		{
			unsafe {
				if (fn__getCurrentScriptedConversationLine == null) fn__getCurrentScriptedConversationLine = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCurrentScriptedConversationLine");
				var result = fn__getCurrentScriptedConversationLine();
				return result;
			}
		}

		public void PauseScriptedConversation(bool _p0)
		{
			unsafe {
				if (fn__pauseScriptedConversation == null) fn__pauseScriptedConversation = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_pauseScriptedConversation");
				fn__pauseScriptedConversation(_p0);
			}
		}

		public void RestartScriptedConversation()
		{
			unsafe {
				if (fn__restartScriptedConversation == null) fn__restartScriptedConversation = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_restartScriptedConversation");
				fn__restartScriptedConversation();
			}
		}

		public int StopScriptedConversation(bool _p0)
		{
			unsafe {
				if (fn__stopScriptedConversation == null) fn__stopScriptedConversation = (delegate* unmanaged[Cdecl]<bool, int>) NativeLibrary.GetExport(handle, "Native_stopScriptedConversation");
				var result = fn__stopScriptedConversation(_p0);
				return result;
			}
		}

		public void SkipToNextScriptedConversationLine()
		{
			unsafe {
				if (fn__skipToNextScriptedConversationLine == null) fn__skipToNextScriptedConversationLine = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_skipToNextScriptedConversationLine");
				fn__skipToNextScriptedConversationLine();
			}
		}

		public void InterruptConversation(int _p0, ref int _p1, ref int _p2)
		{
			unsafe {
				if (fn__interruptConversation == null) fn__interruptConversation = (delegate* unmanaged[Cdecl]<int, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_interruptConversation");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				fn__interruptConversation(_p0, &ref_p1, &ref_p2);
				_p1 = ref_p1;
				_p2 = ref_p2;
			}
		}

		public void InterruptConversationAndPause(int _ped, string _p1, string _p2)
		{
			unsafe {
				if (fn__interruptConversationAndPause == null) fn__interruptConversationAndPause = (delegate* unmanaged[Cdecl]<int, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_interruptConversationAndPause");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				fn__interruptConversationAndPause(_ped, ptr_p1, ptr_p2);
				Marshal.FreeHGlobal(ptr_p1);
				Marshal.FreeHGlobal(ptr_p2);
			}
		}

		public int _0xAA19F5572C38B564(ref int _p0)
		{
			unsafe {
				if (fn__0xAA19F5572C38B564 == null) fn__0xAA19F5572C38B564 = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native__0xAA19F5572C38B564");
				var ref_p0 = _p0;
				var result = fn__0xAA19F5572C38B564(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public void _0xB542DE8C3D1CB210(bool _p0)
		{
			unsafe {
				if (fn__0xB542DE8C3D1CB210 == null) fn__0xB542DE8C3D1CB210 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xB542DE8C3D1CB210");
				fn__0xB542DE8C3D1CB210(_p0);
			}
		}

		public void RegisterScriptWithAudio(int _p0)
		{
			unsafe {
				if (fn__registerScriptWithAudio == null) fn__registerScriptWithAudio = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_registerScriptWithAudio");
				fn__registerScriptWithAudio(_p0);
			}
		}

		public void UnregisterScriptWithAudio()
		{
			unsafe {
				if (fn__unregisterScriptWithAudio == null) fn__unregisterScriptWithAudio = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_unregisterScriptWithAudio");
				fn__unregisterScriptWithAudio();
			}
		}

		public bool RequestMissionAudioBank(string _p0, bool _p1, int _p2)
		{
			unsafe {
				if (fn__requestMissionAudioBank == null) fn__requestMissionAudioBank = (delegate* unmanaged[Cdecl]<nint, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_requestMissionAudioBank");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var result = fn__requestMissionAudioBank(ptr_p0, _p1, _p2);
				Marshal.FreeHGlobal(ptr_p0);
				return result;
			}
		}

		public bool RequestAmbientAudioBank(string _p0, bool _p1, int _p2)
		{
			unsafe {
				if (fn__requestAmbientAudioBank == null) fn__requestAmbientAudioBank = (delegate* unmanaged[Cdecl]<nint, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_requestAmbientAudioBank");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var result = fn__requestAmbientAudioBank(ptr_p0, _p1, _p2);
				Marshal.FreeHGlobal(ptr_p0);
				return result;
			}
		}

		public bool RequestScriptAudioBank(string _p0, bool _p1, int _p2)
		{
			unsafe {
				if (fn__requestScriptAudioBank == null) fn__requestScriptAudioBank = (delegate* unmanaged[Cdecl]<nint, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_requestScriptAudioBank");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var result = fn__requestScriptAudioBank(ptr_p0, _p1, _p2);
				Marshal.FreeHGlobal(ptr_p0);
				return result;
			}
		}

		public int _0x40763EA7B9B783E7(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x40763EA7B9B783E7 == null) fn__0x40763EA7B9B783E7 = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x40763EA7B9B783E7");
				var result = fn__0x40763EA7B9B783E7(_p0, _p1, _p2);
				return result;
			}
		}

		public int HintAmbientAudioBank(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__hintAmbientAudioBank == null) fn__hintAmbientAudioBank = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_hintAmbientAudioBank");
				var result = fn__hintAmbientAudioBank(_p0, _p1, _p2);
				return result;
			}
		}

		public int HintScriptAudioBank(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__hintScriptAudioBank == null) fn__hintScriptAudioBank = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_hintScriptAudioBank");
				var result = fn__hintScriptAudioBank(_p0, _p1, _p2);
				return result;
			}
		}

		public void ReleaseMissionAudioBank()
		{
			unsafe {
				if (fn__releaseMissionAudioBank == null) fn__releaseMissionAudioBank = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_releaseMissionAudioBank");
				fn__releaseMissionAudioBank();
			}
		}

		public void ReleaseAmbientAudioBank()
		{
			unsafe {
				if (fn__releaseAmbientAudioBank == null) fn__releaseAmbientAudioBank = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_releaseAmbientAudioBank");
				fn__releaseAmbientAudioBank();
			}
		}

		public void ReleaseNamedScriptAudioBank(string _audioBank)
		{
			unsafe {
				if (fn__releaseNamedScriptAudioBank == null) fn__releaseNamedScriptAudioBank = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_releaseNamedScriptAudioBank");
				var ptr_audioBank = MemoryUtils.StringToHGlobalUtf8(_audioBank);
				fn__releaseNamedScriptAudioBank(ptr_audioBank);
				Marshal.FreeHGlobal(ptr_audioBank);
			}
		}

		public void ReleaseScriptAudioBank()
		{
			unsafe {
				if (fn__releaseScriptAudioBank == null) fn__releaseScriptAudioBank = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_releaseScriptAudioBank");
				fn__releaseScriptAudioBank();
			}
		}

		public void _0x19AF7ED9B9D23058()
		{
			unsafe {
				if (fn__0x19AF7ED9B9D23058 == null) fn__0x19AF7ED9B9D23058 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x19AF7ED9B9D23058");
				fn__0x19AF7ED9B9D23058();
			}
		}

		public void _0x9AC92EED5E4793AB()
		{
			unsafe {
				if (fn__0x9AC92EED5E4793AB == null) fn__0x9AC92EED5E4793AB = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x9AC92EED5E4793AB");
				fn__0x9AC92EED5E4793AB();
			}
		}

		public void _0x11579D940949C49E(int _p0)
		{
			unsafe {
				if (fn__0x11579D940949C49E == null) fn__0x11579D940949C49E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x11579D940949C49E");
				fn__0x11579D940949C49E(_p0);
			}
		}

		public int GetSoundId()
		{
			unsafe {
				if (fn__getSoundId == null) fn__getSoundId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getSoundId");
				var result = fn__getSoundId();
				return result;
			}
		}

		public void ReleaseSoundId(int _soundId)
		{
			unsafe {
				if (fn__releaseSoundId == null) fn__releaseSoundId = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_releaseSoundId");
				fn__releaseSoundId(_soundId);
			}
		}

		public void PlaySound(int _soundId, string _audioName, string _audioRef, bool _p3, int _p4, bool _p5)
		{
			unsafe {
				if (fn__playSound == null) fn__playSound = (delegate* unmanaged[Cdecl]<int, nint, nint, bool, int, bool, void>) NativeLibrary.GetExport(handle, "Native_playSound");
				var ptr_audioName = MemoryUtils.StringToHGlobalUtf8(_audioName);
				var ptr_audioRef = MemoryUtils.StringToHGlobalUtf8(_audioRef);
				fn__playSound(_soundId, ptr_audioName, ptr_audioRef, _p3, _p4, _p5);
				Marshal.FreeHGlobal(ptr_audioName);
				Marshal.FreeHGlobal(ptr_audioRef);
			}
		}

		public void PlaySoundFrontend(int _soundId, string _audioName, string _audioRef, bool _p3)
		{
			unsafe {
				if (fn__playSoundFrontend == null) fn__playSoundFrontend = (delegate* unmanaged[Cdecl]<int, nint, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_playSoundFrontend");
				var ptr_audioName = MemoryUtils.StringToHGlobalUtf8(_audioName);
				var ptr_audioRef = MemoryUtils.StringToHGlobalUtf8(_audioRef);
				fn__playSoundFrontend(_soundId, ptr_audioName, ptr_audioRef, _p3);
				Marshal.FreeHGlobal(ptr_audioName);
				Marshal.FreeHGlobal(ptr_audioRef);
			}
		}

		public void PlayDeferredSoundFrontend(string _soundName, string _soundsetName)
		{
			unsafe {
				if (fn__playDeferredSoundFrontend == null) fn__playDeferredSoundFrontend = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native_playDeferredSoundFrontend");
				var ptr_soundName = MemoryUtils.StringToHGlobalUtf8(_soundName);
				var ptr_soundsetName = MemoryUtils.StringToHGlobalUtf8(_soundsetName);
				fn__playDeferredSoundFrontend(ptr_soundName, ptr_soundsetName);
				Marshal.FreeHGlobal(ptr_soundName);
				Marshal.FreeHGlobal(ptr_soundsetName);
			}
		}

		public void PlaySoundFromEntity(int _soundId, string _audioName, int _entity, string _audioRef, bool _isNetwork, int _p5)
		{
			unsafe {
				if (fn__playSoundFromEntity == null) fn__playSoundFromEntity = (delegate* unmanaged[Cdecl]<int, nint, int, nint, bool, int, void>) NativeLibrary.GetExport(handle, "Native_playSoundFromEntity");
				var ptr_audioName = MemoryUtils.StringToHGlobalUtf8(_audioName);
				var ptr_audioRef = MemoryUtils.StringToHGlobalUtf8(_audioRef);
				fn__playSoundFromEntity(_soundId, ptr_audioName, _entity, ptr_audioRef, _isNetwork, _p5);
				Marshal.FreeHGlobal(ptr_audioName);
				Marshal.FreeHGlobal(ptr_audioRef);
			}
		}

		public void _0x5B9853296731E88D(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__0x5B9853296731E88D == null) fn__0x5B9853296731E88D = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x5B9853296731E88D");
				fn__0x5B9853296731E88D(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void PlaySoundFromCoord(int _soundId, string _audioName, float _x, float _y, float _z, string _audioRef, bool _isNetwork, int _range, bool _p8)
		{
			unsafe {
				if (fn__playSoundFromCoord == null) fn__playSoundFromCoord = (delegate* unmanaged[Cdecl]<int, nint, float, float, float, nint, bool, int, bool, void>) NativeLibrary.GetExport(handle, "Native_playSoundFromCoord");
				var ptr_audioName = MemoryUtils.StringToHGlobalUtf8(_audioName);
				var ptr_audioRef = MemoryUtils.StringToHGlobalUtf8(_audioRef);
				fn__playSoundFromCoord(_soundId, ptr_audioName, _x, _y, _z, ptr_audioRef, _isNetwork, _range, _p8);
				Marshal.FreeHGlobal(ptr_audioName);
				Marshal.FreeHGlobal(ptr_audioRef);
			}
		}

		public void _0x7EC3C679D0E7E46B(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x7EC3C679D0E7E46B == null) fn__0x7EC3C679D0E7E46B = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x7EC3C679D0E7E46B");
				fn__0x7EC3C679D0E7E46B(_p0, _p1, _p2, _p3);
			}
		}

		public void StopSound(int _soundId)
		{
			unsafe {
				if (fn__stopSound == null) fn__stopSound = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopSound");
				fn__stopSound(_soundId);
			}
		}

		public int GetNetworkIdFromSoundId(int _soundId)
		{
			unsafe {
				if (fn__getNetworkIdFromSoundId == null) fn__getNetworkIdFromSoundId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNetworkIdFromSoundId");
				var result = fn__getNetworkIdFromSoundId(_soundId);
				return result;
			}
		}

		public int GetSoundIdFromNetworkId(int _netId)
		{
			unsafe {
				if (fn__getSoundIdFromNetworkId == null) fn__getSoundIdFromNetworkId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getSoundIdFromNetworkId");
				var result = fn__getSoundIdFromNetworkId(_netId);
				return result;
			}
		}

		public void SetVariableOnSound(int _soundId, ref int _p1, float _p2)
		{
			unsafe {
				if (fn__setVariableOnSound == null) fn__setVariableOnSound = (delegate* unmanaged[Cdecl]<int, int*, float, void>) NativeLibrary.GetExport(handle, "Native_setVariableOnSound");
				var ref_p1 = _p1;
				fn__setVariableOnSound(_soundId, &ref_p1, _p2);
				_p1 = ref_p1;
			}
		}

		public void SetVariableOnStream(string _p0, float _p1)
		{
			unsafe {
				if (fn__setVariableOnStream == null) fn__setVariableOnStream = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_setVariableOnStream");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__setVariableOnStream(ptr_p0, _p1);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void OverrideUnderwaterStream(ref int _p0, bool _p1)
		{
			unsafe {
				if (fn__overrideUnderwaterStream == null) fn__overrideUnderwaterStream = (delegate* unmanaged[Cdecl]<int*, bool, void>) NativeLibrary.GetExport(handle, "Native_overrideUnderwaterStream");
				var ref_p0 = _p0;
				fn__overrideUnderwaterStream(&ref_p0, _p1);
				_p0 = ref_p0;
			}
		}

		public void SetVariableOnUnderWaterStream(string _unkVariableName, float _value)
		{
			unsafe {
				if (fn__setVariableOnUnderWaterStream == null) fn__setVariableOnUnderWaterStream = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_setVariableOnUnderWaterStream");
				var ptr_unkVariableName = MemoryUtils.StringToHGlobalUtf8(_unkVariableName);
				fn__setVariableOnUnderWaterStream(ptr_unkVariableName, _value);
				Marshal.FreeHGlobal(ptr_unkVariableName);
			}
		}

		public bool HasSoundFinished(int _soundId)
		{
			unsafe {
				if (fn__hasSoundFinished == null) fn__hasSoundFinished = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasSoundFinished");
				var result = fn__hasSoundFinished(_soundId);
				return result;
			}
		}

		public void PlayPedAmbientSpeechNative(int _ped, string _speechName, string _speechParam, int _p3)
		{
			unsafe {
				if (fn__playPedAmbientSpeechNative == null) fn__playPedAmbientSpeechNative = (delegate* unmanaged[Cdecl]<int, nint, nint, int, void>) NativeLibrary.GetExport(handle, "Native_playPedAmbientSpeechNative");
				var ptr_speechName = MemoryUtils.StringToHGlobalUtf8(_speechName);
				var ptr_speechParam = MemoryUtils.StringToHGlobalUtf8(_speechParam);
				fn__playPedAmbientSpeechNative(_ped, ptr_speechName, ptr_speechParam, _p3);
				Marshal.FreeHGlobal(ptr_speechName);
				Marshal.FreeHGlobal(ptr_speechParam);
			}
		}

		public void PlayPedAmbientSpeechAndCloneNative(int _ped, string _speechName, string _speechParam, int _p3)
		{
			unsafe {
				if (fn__playPedAmbientSpeechAndCloneNative == null) fn__playPedAmbientSpeechAndCloneNative = (delegate* unmanaged[Cdecl]<int, nint, nint, int, void>) NativeLibrary.GetExport(handle, "Native_playPedAmbientSpeechAndCloneNative");
				var ptr_speechName = MemoryUtils.StringToHGlobalUtf8(_speechName);
				var ptr_speechParam = MemoryUtils.StringToHGlobalUtf8(_speechParam);
				fn__playPedAmbientSpeechAndCloneNative(_ped, ptr_speechName, ptr_speechParam, _p3);
				Marshal.FreeHGlobal(ptr_speechName);
				Marshal.FreeHGlobal(ptr_speechParam);
			}
		}

		public void PlayPedAmbientSpeechWithVoiceNative(int _ped, string _speechName, string _voiceName, string _speechParam, bool _p4)
		{
			unsafe {
				if (fn__playPedAmbientSpeechWithVoiceNative == null) fn__playPedAmbientSpeechWithVoiceNative = (delegate* unmanaged[Cdecl]<int, nint, nint, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_playPedAmbientSpeechWithVoiceNative");
				var ptr_speechName = MemoryUtils.StringToHGlobalUtf8(_speechName);
				var ptr_voiceName = MemoryUtils.StringToHGlobalUtf8(_voiceName);
				var ptr_speechParam = MemoryUtils.StringToHGlobalUtf8(_speechParam);
				fn__playPedAmbientSpeechWithVoiceNative(_ped, ptr_speechName, ptr_voiceName, ptr_speechParam, _p4);
				Marshal.FreeHGlobal(ptr_speechName);
				Marshal.FreeHGlobal(ptr_voiceName);
				Marshal.FreeHGlobal(ptr_speechParam);
			}
		}

		public void PlayAmbientSpeechFromPositionNative(string _speechName, string _voiceName, float _x, float _y, float _z, string _speechParam)
		{
			unsafe {
				if (fn__playAmbientSpeechFromPositionNative == null) fn__playAmbientSpeechFromPositionNative = (delegate* unmanaged[Cdecl]<nint, nint, float, float, float, nint, void>) NativeLibrary.GetExport(handle, "Native_playAmbientSpeechFromPositionNative");
				var ptr_speechName = MemoryUtils.StringToHGlobalUtf8(_speechName);
				var ptr_voiceName = MemoryUtils.StringToHGlobalUtf8(_voiceName);
				var ptr_speechParam = MemoryUtils.StringToHGlobalUtf8(_speechParam);
				fn__playAmbientSpeechFromPositionNative(ptr_speechName, ptr_voiceName, _x, _y, _z, ptr_speechParam);
				Marshal.FreeHGlobal(ptr_speechName);
				Marshal.FreeHGlobal(ptr_voiceName);
				Marshal.FreeHGlobal(ptr_speechParam);
			}
		}

		public void OverrideTrevorRage(string _voiceEffect)
		{
			unsafe {
				if (fn__overrideTrevorRage == null) fn__overrideTrevorRage = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_overrideTrevorRage");
				var ptr_voiceEffect = MemoryUtils.StringToHGlobalUtf8(_voiceEffect);
				fn__overrideTrevorRage(ptr_voiceEffect);
				Marshal.FreeHGlobal(ptr_voiceEffect);
			}
		}

		public void ResetTrevorRage()
		{
			unsafe {
				if (fn__resetTrevorRage == null) fn__resetTrevorRage = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetTrevorRage");
				fn__resetTrevorRage();
			}
		}

		public void SetPlayerAngry(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerAngry == null) fn__setPlayerAngry = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerAngry");
				fn__setPlayerAngry(_ped, _toggle);
			}
		}

		public void PlayPain(int _ped, int _painID, int _p1, int _p3)
		{
			unsafe {
				if (fn__playPain == null) fn__playPain = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playPain");
				fn__playPain(_ped, _painID, _p1, _p3);
			}
		}

		public void ReleaseWeaponAudio()
		{
			unsafe {
				if (fn__releaseWeaponAudio == null) fn__releaseWeaponAudio = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_releaseWeaponAudio");
				fn__releaseWeaponAudio();
			}
		}

		public void ActivateAudioSlowmoMode(string _p0)
		{
			unsafe {
				if (fn__activateAudioSlowmoMode == null) fn__activateAudioSlowmoMode = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_activateAudioSlowmoMode");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__activateAudioSlowmoMode(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void DeactivateAudioSlowmoMode(string _p0)
		{
			unsafe {
				if (fn__deactivateAudioSlowmoMode == null) fn__deactivateAudioSlowmoMode = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_deactivateAudioSlowmoMode");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__deactivateAudioSlowmoMode(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void SetAmbientVoiceName(int _ped, string _name)
		{
			unsafe {
				if (fn__setAmbientVoiceName == null) fn__setAmbientVoiceName = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setAmbientVoiceName");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setAmbientVoiceName(_ped, ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void SetAmbientVoiceNameHash(int _ped, int _hash)
		{
			unsafe {
				if (fn__setAmbientVoiceNameHash == null) fn__setAmbientVoiceNameHash = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setAmbientVoiceNameHash");
				fn__setAmbientVoiceNameHash(_ped, _hash);
			}
		}

		public int GetAmbientVoiceNameHash(int _ped)
		{
			unsafe {
				if (fn__getAmbientVoiceNameHash == null) fn__getAmbientVoiceNameHash = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getAmbientVoiceNameHash");
				var result = fn__getAmbientVoiceNameHash(_ped);
				return result;
			}
		}

		public void SetPedScream(int _ped)
		{
			unsafe {
				if (fn__setPedScream == null) fn__setPedScream = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedScream");
				fn__setPedScream(_ped);
			}
		}

		public void _0x1B7ABE26CBCBF8C7(int _ped, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x1B7ABE26CBCBF8C7 == null) fn__0x1B7ABE26CBCBF8C7 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1B7ABE26CBCBF8C7");
				fn__0x1B7ABE26CBCBF8C7(_ped, _p1, _p2);
			}
		}

		public void SetPedVoiceGroup(int _ped, int _voiceGroupHash)
		{
			unsafe {
				if (fn__setPedVoiceGroup == null) fn__setPedVoiceGroup = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedVoiceGroup");
				fn__setPedVoiceGroup(_ped, _voiceGroupHash);
			}
		}

		public void SetPedAudioGender(int _ped, bool _p1)
		{
			unsafe {
				if (fn__setPedAudioGender == null) fn__setPedAudioGender = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAudioGender");
				fn__setPedAudioGender(_ped, _p1);
			}
		}

		public void StopCurrentPlayingSpeech(int _ped)
		{
			unsafe {
				if (fn__stopCurrentPlayingSpeech == null) fn__stopCurrentPlayingSpeech = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopCurrentPlayingSpeech");
				fn__stopCurrentPlayingSpeech(_ped);
			}
		}

		public void StopCurrentPlayingAmbientSpeech(int _ped)
		{
			unsafe {
				if (fn__stopCurrentPlayingAmbientSpeech == null) fn__stopCurrentPlayingAmbientSpeech = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopCurrentPlayingAmbientSpeech");
				fn__stopCurrentPlayingAmbientSpeech(_ped);
			}
		}

		public bool IsAmbientSpeechPlaying(int _ped)
		{
			unsafe {
				if (fn__isAmbientSpeechPlaying == null) fn__isAmbientSpeechPlaying = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isAmbientSpeechPlaying");
				var result = fn__isAmbientSpeechPlaying(_ped);
				return result;
			}
		}

		public bool IsScriptedSpeechPlaying(int _p0)
		{
			unsafe {
				if (fn__isScriptedSpeechPlaying == null) fn__isScriptedSpeechPlaying = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isScriptedSpeechPlaying");
				var result = fn__isScriptedSpeechPlaying(_p0);
				return result;
			}
		}

		public bool IsAnySpeechPlaying(int _ped)
		{
			unsafe {
				if (fn__isAnySpeechPlaying == null) fn__isAnySpeechPlaying = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isAnySpeechPlaying");
				var result = fn__isAnySpeechPlaying(_ped);
				return result;
			}
		}

		public int _0x30CA2EF91D15ADF8()
		{
			unsafe {
				if (fn__0x30CA2EF91D15ADF8 == null) fn__0x30CA2EF91D15ADF8 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x30CA2EF91D15ADF8");
				var result = fn__0x30CA2EF91D15ADF8();
				return result;
			}
		}

		public bool CanPedSpeak(int _ped, string _speechName, bool _unk)
		{
			unsafe {
				if (fn__canPedSpeak == null) fn__canPedSpeak = (delegate* unmanaged[Cdecl]<int, nint, bool, bool>) NativeLibrary.GetExport(handle, "Native_canPedSpeak");
				var ptr_speechName = MemoryUtils.StringToHGlobalUtf8(_speechName);
				var result = fn__canPedSpeak(_ped, ptr_speechName, _unk);
				Marshal.FreeHGlobal(ptr_speechName);
				return result;
			}
		}

		public bool IsPedInCurrentConversation(int _ped)
		{
			unsafe {
				if (fn__isPedInCurrentConversation == null) fn__isPedInCurrentConversation = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInCurrentConversation");
				var result = fn__isPedInCurrentConversation(_ped);
				return result;
			}
		}

		public void SetPedIsDrunk(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedIsDrunk == null) fn__setPedIsDrunk = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedIsDrunk");
				fn__setPedIsDrunk(_ped, _toggle);
			}
		}

		public void PlayAnimalVocalization(int _pedHandle, int _p1, string _speechName)
		{
			unsafe {
				if (fn__playAnimalVocalization == null) fn__playAnimalVocalization = (delegate* unmanaged[Cdecl]<int, int, nint, void>) NativeLibrary.GetExport(handle, "Native_playAnimalVocalization");
				var ptr_speechName = MemoryUtils.StringToHGlobalUtf8(_speechName);
				fn__playAnimalVocalization(_pedHandle, _p1, ptr_speechName);
				Marshal.FreeHGlobal(ptr_speechName);
			}
		}

		public bool IsAnimalVocalizationPlaying(int _pedHandle)
		{
			unsafe {
				if (fn__isAnimalVocalizationPlaying == null) fn__isAnimalVocalizationPlaying = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isAnimalVocalizationPlaying");
				var result = fn__isAnimalVocalizationPlaying(_pedHandle);
				return result;
			}
		}

		public void SetAnimalMood(int _animal, int _mood)
		{
			unsafe {
				if (fn__setAnimalMood == null) fn__setAnimalMood = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setAnimalMood");
				fn__setAnimalMood(_animal, _mood);
			}
		}

		public bool IsMobilePhoneRadioActive()
		{
			unsafe {
				if (fn__isMobilePhoneRadioActive == null) fn__isMobilePhoneRadioActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMobilePhoneRadioActive");
				var result = fn__isMobilePhoneRadioActive();
				return result;
			}
		}

		public void SetMobilePhoneRadioState(bool _state)
		{
			unsafe {
				if (fn__setMobilePhoneRadioState == null) fn__setMobilePhoneRadioState = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMobilePhoneRadioState");
				fn__setMobilePhoneRadioState(_state);
			}
		}

		public int GetPlayerRadioStationIndex()
		{
			unsafe {
				if (fn__getPlayerRadioStationIndex == null) fn__getPlayerRadioStationIndex = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayerRadioStationIndex");
				var result = fn__getPlayerRadioStationIndex();
				return result;
			}
		}

		public string GetPlayerRadioStationName()
		{
			unsafe {
				if (fn__getPlayerRadioStationName == null) fn__getPlayerRadioStationName = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_getPlayerRadioStationName");
				var result = fn__getPlayerRadioStationName();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetRadioStationName(int _radioStation)
		{
			unsafe {
				if (fn__getRadioStationName == null) fn__getRadioStationName = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getRadioStationName");
				var result = fn__getRadioStationName(_radioStation);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int GetPlayerRadioStationGenre()
		{
			unsafe {
				if (fn__getPlayerRadioStationGenre == null) fn__getPlayerRadioStationGenre = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayerRadioStationGenre");
				var result = fn__getPlayerRadioStationGenre();
				return result;
			}
		}

		public bool IsRadioRetuning()
		{
			unsafe {
				if (fn__isRadioRetuning == null) fn__isRadioRetuning = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isRadioRetuning");
				var result = fn__isRadioRetuning();
				return result;
			}
		}

		public bool IsRadioFadedOut()
		{
			unsafe {
				if (fn__isRadioFadedOut == null) fn__isRadioFadedOut = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isRadioFadedOut");
				var result = fn__isRadioFadedOut();
				return result;
			}
		}

		public void _0xFF266D1D0EB1195D()
		{
			unsafe {
				if (fn__0xFF266D1D0EB1195D == null) fn__0xFF266D1D0EB1195D = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xFF266D1D0EB1195D");
				fn__0xFF266D1D0EB1195D();
			}
		}

		public void _0xDD6BCF9E94425DF9()
		{
			unsafe {
				if (fn__0xDD6BCF9E94425DF9 == null) fn__0xDD6BCF9E94425DF9 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xDD6BCF9E94425DF9");
				fn__0xDD6BCF9E94425DF9();
			}
		}

		public void SetRadioToStationName(string _stationName)
		{
			unsafe {
				if (fn__setRadioToStationName == null) fn__setRadioToStationName = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setRadioToStationName");
				var ptr_stationName = MemoryUtils.StringToHGlobalUtf8(_stationName);
				fn__setRadioToStationName(ptr_stationName);
				Marshal.FreeHGlobal(ptr_stationName);
			}
		}

		public void SetVehRadioStation(int _vehicle, string _radioStation)
		{
			unsafe {
				if (fn__setVehRadioStation == null) fn__setVehRadioStation = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setVehRadioStation");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				fn__setVehRadioStation(_vehicle, ptr_radioStation);
				Marshal.FreeHGlobal(ptr_radioStation);
			}
		}

		public void SetVehHasRadioOverride(int _vehicle)
		{
			unsafe {
				if (fn__setVehHasRadioOverride == null) fn__setVehHasRadioOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setVehHasRadioOverride");
				fn__setVehHasRadioOverride(_vehicle);
			}
		}

		public bool IsVehicleRadioEnabled(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleRadioEnabled == null) fn__isVehicleRadioEnabled = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleRadioEnabled");
				var result = fn__isVehicleRadioEnabled(_vehicle);
				return result;
			}
		}

		public void _0xC1805D05E6D4FE10(int _vehicle)
		{
			unsafe {
				if (fn__0xC1805D05E6D4FE10 == null) fn__0xC1805D05E6D4FE10 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC1805D05E6D4FE10");
				fn__0xC1805D05E6D4FE10(_vehicle);
			}
		}

		public void SetEmitterRadioStation(string _emitterName, string _radioStation)
		{
			unsafe {
				if (fn__setEmitterRadioStation == null) fn__setEmitterRadioStation = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native_setEmitterRadioStation");
				var ptr_emitterName = MemoryUtils.StringToHGlobalUtf8(_emitterName);
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				fn__setEmitterRadioStation(ptr_emitterName, ptr_radioStation);
				Marshal.FreeHGlobal(ptr_emitterName);
				Marshal.FreeHGlobal(ptr_radioStation);
			}
		}

		public void SetStaticEmitterEnabled(string _emitterName, bool _toggle)
		{
			unsafe {
				if (fn__setStaticEmitterEnabled == null) fn__setStaticEmitterEnabled = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setStaticEmitterEnabled");
				var ptr_emitterName = MemoryUtils.StringToHGlobalUtf8(_emitterName);
				fn__setStaticEmitterEnabled(ptr_emitterName, _toggle);
				Marshal.FreeHGlobal(ptr_emitterName);
			}
		}

		public void LinkStaticEmitterToEntity(string _emitterName, int _entity)
		{
			unsafe {
				if (fn__linkStaticEmitterToEntity == null) fn__linkStaticEmitterToEntity = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_linkStaticEmitterToEntity");
				var ptr_emitterName = MemoryUtils.StringToHGlobalUtf8(_emitterName);
				fn__linkStaticEmitterToEntity(ptr_emitterName, _entity);
				Marshal.FreeHGlobal(ptr_emitterName);
			}
		}

		public void SetRadioToStationIndex(int _radioStation)
		{
			unsafe {
				if (fn__setRadioToStationIndex == null) fn__setRadioToStationIndex = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setRadioToStationIndex");
				fn__setRadioToStationIndex(_radioStation);
			}
		}

		public void SetFrontendRadioActive(bool _active)
		{
			unsafe {
				if (fn__setFrontendRadioActive == null) fn__setFrontendRadioActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setFrontendRadioActive");
				fn__setFrontendRadioActive(_active);
			}
		}

		public void UnlockMissionNewsStory(int _newsStory)
		{
			unsafe {
				if (fn__unlockMissionNewsStory == null) fn__unlockMissionNewsStory = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_unlockMissionNewsStory");
				fn__unlockMissionNewsStory(_newsStory);
			}
		}

		public bool IsMissionNewsStoryUnlocked(int _newsStory)
		{
			unsafe {
				if (fn__isMissionNewsStoryUnlocked == null) fn__isMissionNewsStoryUnlocked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMissionNewsStoryUnlocked");
				var result = fn__isMissionNewsStoryUnlocked(_newsStory);
				return result;
			}
		}

		public int GetAudibleMusicTrackTextId()
		{
			unsafe {
				if (fn__getAudibleMusicTrackTextId == null) fn__getAudibleMusicTrackTextId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getAudibleMusicTrackTextId");
				var result = fn__getAudibleMusicTrackTextId();
				return result;
			}
		}

		public void PlayEndCreditsMusic(bool _play)
		{
			unsafe {
				if (fn__playEndCreditsMusic == null) fn__playEndCreditsMusic = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_playEndCreditsMusic");
				fn__playEndCreditsMusic(_play);
			}
		}

		public void SkipRadioForward()
		{
			unsafe {
				if (fn__skipRadioForward == null) fn__skipRadioForward = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_skipRadioForward");
				fn__skipRadioForward();
			}
		}

		public void FreezeRadioStation(string _radioStation)
		{
			unsafe {
				if (fn__freezeRadioStation == null) fn__freezeRadioStation = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_freezeRadioStation");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				fn__freezeRadioStation(ptr_radioStation);
				Marshal.FreeHGlobal(ptr_radioStation);
			}
		}

		public void UnfreezeRadioStation(string _radioStation)
		{
			unsafe {
				if (fn__unfreezeRadioStation == null) fn__unfreezeRadioStation = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_unfreezeRadioStation");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				fn__unfreezeRadioStation(ptr_radioStation);
				Marshal.FreeHGlobal(ptr_radioStation);
			}
		}

		public void SetRadioAutoUnfreeze(bool _toggle)
		{
			unsafe {
				if (fn__setRadioAutoUnfreeze == null) fn__setRadioAutoUnfreeze = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setRadioAutoUnfreeze");
				fn__setRadioAutoUnfreeze(_toggle);
			}
		}

		public void SetInitialPlayerStation(string _radioStation)
		{
			unsafe {
				if (fn__setInitialPlayerStation == null) fn__setInitialPlayerStation = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setInitialPlayerStation");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				fn__setInitialPlayerStation(ptr_radioStation);
				Marshal.FreeHGlobal(ptr_radioStation);
			}
		}

		public void SetUserRadioControlEnabled(bool _toggle)
		{
			unsafe {
				if (fn__setUserRadioControlEnabled == null) fn__setUserRadioControlEnabled = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setUserRadioControlEnabled");
				fn__setUserRadioControlEnabled(_toggle);
			}
		}

		public void SetRadioTrack(string _radioStation, string _radioTrack)
		{
			unsafe {
				if (fn__setRadioTrack == null) fn__setRadioTrack = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native_setRadioTrack");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				var ptr_radioTrack = MemoryUtils.StringToHGlobalUtf8(_radioTrack);
				fn__setRadioTrack(ptr_radioStation, ptr_radioTrack);
				Marshal.FreeHGlobal(ptr_radioStation);
				Marshal.FreeHGlobal(ptr_radioTrack);
			}
		}

		public void SetRadioTrackMix(string _radioStationName, string _mixName, int _p2)
		{
			unsafe {
				if (fn__setRadioTrackMix == null) fn__setRadioTrackMix = (delegate* unmanaged[Cdecl]<nint, nint, int, void>) NativeLibrary.GetExport(handle, "Native_setRadioTrackMix");
				var ptr_radioStationName = MemoryUtils.StringToHGlobalUtf8(_radioStationName);
				var ptr_mixName = MemoryUtils.StringToHGlobalUtf8(_mixName);
				fn__setRadioTrackMix(ptr_radioStationName, ptr_mixName, _p2);
				Marshal.FreeHGlobal(ptr_radioStationName);
				Marshal.FreeHGlobal(ptr_mixName);
			}
		}

		public void _0x55ECF4D13D9903B0(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x55ECF4D13D9903B0 == null) fn__0x55ECF4D13D9903B0 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x55ECF4D13D9903B0");
				fn__0x55ECF4D13D9903B0(_p0, _p1, _p2, _p3);
			}
		}

		public void SetVehicleRadioLoud(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleRadioLoud == null) fn__setVehicleRadioLoud = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRadioLoud");
				fn__setVehicleRadioLoud(_vehicle, _toggle);
			}
		}

		public bool IsVehicleRadioLoud(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleRadioLoud == null) fn__isVehicleRadioLoud = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleRadioLoud");
				var result = fn__isVehicleRadioLoud(_vehicle);
				return result;
			}
		}

		public void SetMobileRadioEnabledDuringGameplay(bool _toggle)
		{
			unsafe {
				if (fn__setMobileRadioEnabledDuringGameplay == null) fn__setMobileRadioEnabledDuringGameplay = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMobileRadioEnabledDuringGameplay");
				fn__setMobileRadioEnabledDuringGameplay(_toggle);
			}
		}

		public bool DoesPlayerVehHaveRadio()
		{
			unsafe {
				if (fn__doesPlayerVehHaveRadio == null) fn__doesPlayerVehHaveRadio = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_doesPlayerVehHaveRadio");
				var result = fn__doesPlayerVehHaveRadio();
				return result;
			}
		}

		public bool IsPlayerVehRadioEnable()
		{
			unsafe {
				if (fn__isPlayerVehRadioEnable == null) fn__isPlayerVehRadioEnable = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPlayerVehRadioEnable");
				var result = fn__isPlayerVehRadioEnable();
				return result;
			}
		}

		public void SetVehicleRadioEnabled(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleRadioEnabled == null) fn__setVehicleRadioEnabled = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRadioEnabled");
				fn__setVehicleRadioEnabled(_vehicle, _toggle);
			}
		}

		public void _0xDA07819E452FFE8F(int _p0)
		{
			unsafe {
				if (fn__0xDA07819E452FFE8F == null) fn__0xDA07819E452FFE8F = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xDA07819E452FFE8F");
				fn__0xDA07819E452FFE8F(_p0);
			}
		}

		public void SetCustomRadioTrackList(string _radioStation, string _trackListName, bool _p2)
		{
			unsafe {
				if (fn__setCustomRadioTrackList == null) fn__setCustomRadioTrackList = (delegate* unmanaged[Cdecl]<nint, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setCustomRadioTrackList");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				var ptr_trackListName = MemoryUtils.StringToHGlobalUtf8(_trackListName);
				fn__setCustomRadioTrackList(ptr_radioStation, ptr_trackListName, _p2);
				Marshal.FreeHGlobal(ptr_radioStation);
				Marshal.FreeHGlobal(ptr_trackListName);
			}
		}

		public void ClearCustomRadioTrackList(string _radioStation)
		{
			unsafe {
				if (fn__clearCustomRadioTrackList == null) fn__clearCustomRadioTrackList = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_clearCustomRadioTrackList");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				fn__clearCustomRadioTrackList(ptr_radioStation);
				Marshal.FreeHGlobal(ptr_radioStation);
			}
		}

		public int GetNumUnlockedRadioStations()
		{
			unsafe {
				if (fn__getNumUnlockedRadioStations == null) fn__getNumUnlockedRadioStations = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumUnlockedRadioStations");
				var result = fn__getNumUnlockedRadioStations();
				return result;
			}
		}

		public int FindRadioStationIndex(int _stationNameHash)
		{
			unsafe {
				if (fn__findRadioStationIndex == null) fn__findRadioStationIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_findRadioStationIndex");
				var result = fn__findRadioStationIndex(_stationNameHash);
				return result;
			}
		}

		public void SetRadioStationMusicOnly(string _radioStation, bool _toggle)
		{
			unsafe {
				if (fn__setRadioStationMusicOnly == null) fn__setRadioStationMusicOnly = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setRadioStationMusicOnly");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				fn__setRadioStationMusicOnly(ptr_radioStation, _toggle);
				Marshal.FreeHGlobal(ptr_radioStation);
			}
		}

		public void SetRadioFrontendFadeTime(float _fadeTime)
		{
			unsafe {
				if (fn__setRadioFrontendFadeTime == null) fn__setRadioFrontendFadeTime = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setRadioFrontendFadeTime");
				fn__setRadioFrontendFadeTime(_fadeTime);
			}
		}

		public void UnlockRadioStationTrackList(string _radioStation, string _trackListName)
		{
			unsafe {
				if (fn__unlockRadioStationTrackList == null) fn__unlockRadioStationTrackList = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native_unlockRadioStationTrackList");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				var ptr_trackListName = MemoryUtils.StringToHGlobalUtf8(_trackListName);
				fn__unlockRadioStationTrackList(ptr_radioStation, ptr_trackListName);
				Marshal.FreeHGlobal(ptr_radioStation);
				Marshal.FreeHGlobal(ptr_trackListName);
			}
		}

		public void LockRadioStationTrackList(string _radioStation, string _trackListName)
		{
			unsafe {
				if (fn__lockRadioStationTrackList == null) fn__lockRadioStationTrackList = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native_lockRadioStationTrackList");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				var ptr_trackListName = MemoryUtils.StringToHGlobalUtf8(_trackListName);
				fn__lockRadioStationTrackList(ptr_radioStation, ptr_trackListName);
				Marshal.FreeHGlobal(ptr_radioStation);
				Marshal.FreeHGlobal(ptr_trackListName);
			}
		}

		public void UpdateLsur(bool _enableMixes)
		{
			unsafe {
				if (fn__updateLsur == null) fn__updateLsur = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_updateLsur");
				fn__updateLsur(_enableMixes);
			}
		}

		public void LockRadioStation(string _radioStationName, bool _toggle)
		{
			unsafe {
				if (fn__lockRadioStation == null) fn__lockRadioStation = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_lockRadioStation");
				var ptr_radioStationName = MemoryUtils.StringToHGlobalUtf8(_radioStationName);
				fn__lockRadioStation(ptr_radioStationName, _toggle);
				Marshal.FreeHGlobal(ptr_radioStationName);
			}
		}

		public void SetRadioStationIsVisible(string _radioStation, bool _toggle)
		{
			unsafe {
				if (fn__setRadioStationIsVisible == null) fn__setRadioStationIsVisible = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setRadioStationIsVisible");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				fn__setRadioStationIsVisible(ptr_radioStation, _toggle);
				Marshal.FreeHGlobal(ptr_radioStation);
			}
		}

		public bool _0xC64A06D939F826F5(ref float _p0, ref float _p1, ref int _p2)
		{
			unsafe {
				if (fn__0xC64A06D939F826F5 == null) fn__0xC64A06D939F826F5 = (delegate* unmanaged[Cdecl]<float*, float*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0xC64A06D939F826F5");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var result = fn__0xC64A06D939F826F5(&ref_p0, &ref_p1, &ref_p2);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p2 = ref_p2;
				return result;
			}
		}

		public void ForceRadioTrackListPosition(string _radioStation, string _trackListName, int _milliseconds)
		{
			unsafe {
				if (fn__forceRadioTrackListPosition == null) fn__forceRadioTrackListPosition = (delegate* unmanaged[Cdecl]<nint, nint, int, void>) NativeLibrary.GetExport(handle, "Native_forceRadioTrackListPosition");
				var ptr_radioStation = MemoryUtils.StringToHGlobalUtf8(_radioStation);
				var ptr_trackListName = MemoryUtils.StringToHGlobalUtf8(_trackListName);
				fn__forceRadioTrackListPosition(ptr_radioStation, ptr_trackListName, _milliseconds);
				Marshal.FreeHGlobal(ptr_radioStation);
				Marshal.FreeHGlobal(ptr_trackListName);
			}
		}

		public int GetCurrentRadioStationHash(string _radioStationName)
		{
			unsafe {
				if (fn__getCurrentRadioStationHash == null) fn__getCurrentRadioStationHash = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_getCurrentRadioStationHash");
				var ptr_radioStationName = MemoryUtils.StringToHGlobalUtf8(_radioStationName);
				var result = fn__getCurrentRadioStationHash(ptr_radioStationName);
				Marshal.FreeHGlobal(ptr_radioStationName);
				return result;
			}
		}

		public int _0x34D66BC058019CE0(string _radioStationName)
		{
			unsafe {
				if (fn__0x34D66BC058019CE0 == null) fn__0x34D66BC058019CE0 = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native__0x34D66BC058019CE0");
				var ptr_radioStationName = MemoryUtils.StringToHGlobalUtf8(_radioStationName);
				var result = fn__0x34D66BC058019CE0(ptr_radioStationName);
				Marshal.FreeHGlobal(ptr_radioStationName);
				return result;
			}
		}

		public void _0xF3365489E0DD50F9(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0xF3365489E0DD50F9 == null) fn__0xF3365489E0DD50F9 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xF3365489E0DD50F9");
				fn__0xF3365489E0DD50F9(_vehicle, _toggle);
			}
		}

		public void SetAmbientZoneState(string _zoneName, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setAmbientZoneState == null) fn__setAmbientZoneState = (delegate* unmanaged[Cdecl]<nint, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setAmbientZoneState");
				var ptr_zoneName = MemoryUtils.StringToHGlobalUtf8(_zoneName);
				fn__setAmbientZoneState(ptr_zoneName, _p1, _p2);
				Marshal.FreeHGlobal(ptr_zoneName);
			}
		}

		public void ClearAmbientZoneState(string _zoneName, bool _p1)
		{
			unsafe {
				if (fn__clearAmbientZoneState == null) fn__clearAmbientZoneState = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_clearAmbientZoneState");
				var ptr_zoneName = MemoryUtils.StringToHGlobalUtf8(_zoneName);
				fn__clearAmbientZoneState(ptr_zoneName, _p1);
				Marshal.FreeHGlobal(ptr_zoneName);
			}
		}

		public void SetAmbientZoneListState(ref int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setAmbientZoneListState == null) fn__setAmbientZoneListState = (delegate* unmanaged[Cdecl]<int*, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setAmbientZoneListState");
				var ref_p0 = _p0;
				fn__setAmbientZoneListState(&ref_p0, _p1, _p2);
				_p0 = ref_p0;
			}
		}

		public void ClearAmbientZoneListState(ref int _p0, bool _p1)
		{
			unsafe {
				if (fn__clearAmbientZoneListState == null) fn__clearAmbientZoneListState = (delegate* unmanaged[Cdecl]<int*, bool, void>) NativeLibrary.GetExport(handle, "Native_clearAmbientZoneListState");
				var ref_p0 = _p0;
				fn__clearAmbientZoneListState(&ref_p0, _p1);
				_p0 = ref_p0;
			}
		}

		public void SetAmbientZoneStatePersistent(string _ambientZone, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setAmbientZoneStatePersistent == null) fn__setAmbientZoneStatePersistent = (delegate* unmanaged[Cdecl]<nint, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setAmbientZoneStatePersistent");
				var ptr_ambientZone = MemoryUtils.StringToHGlobalUtf8(_ambientZone);
				fn__setAmbientZoneStatePersistent(ptr_ambientZone, _p1, _p2);
				Marshal.FreeHGlobal(ptr_ambientZone);
			}
		}

		public void SetAmbientZoneListStatePersistent(string _ambientZone, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setAmbientZoneListStatePersistent == null) fn__setAmbientZoneListStatePersistent = (delegate* unmanaged[Cdecl]<nint, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setAmbientZoneListStatePersistent");
				var ptr_ambientZone = MemoryUtils.StringToHGlobalUtf8(_ambientZone);
				fn__setAmbientZoneListStatePersistent(ptr_ambientZone, _p1, _p2);
				Marshal.FreeHGlobal(ptr_ambientZone);
			}
		}

		public bool IsAmbientZoneEnabled(string _ambientZone)
		{
			unsafe {
				if (fn__isAmbientZoneEnabled == null) fn__isAmbientZoneEnabled = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isAmbientZoneEnabled");
				var ptr_ambientZone = MemoryUtils.StringToHGlobalUtf8(_ambientZone);
				var result = fn__isAmbientZoneEnabled(ptr_ambientZone);
				Marshal.FreeHGlobal(ptr_ambientZone);
				return result;
			}
		}

		public void _0x5D2BFAAB8D956E0E()
		{
			unsafe {
				if (fn__0x5D2BFAAB8D956E0E == null) fn__0x5D2BFAAB8D956E0E = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x5D2BFAAB8D956E0E");
				fn__0x5D2BFAAB8D956E0E();
			}
		}

		public void SetCutsceneAudioOverride(string _name)
		{
			unsafe {
				if (fn__setCutsceneAudioOverride == null) fn__setCutsceneAudioOverride = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setCutsceneAudioOverride");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setCutsceneAudioOverride(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void SetVariableOnCutsceneAudio(string _unkVariableName, float _value)
		{
			unsafe {
				if (fn__setVariableOnCutsceneAudio == null) fn__setVariableOnCutsceneAudio = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_setVariableOnCutsceneAudio");
				var ptr_unkVariableName = MemoryUtils.StringToHGlobalUtf8(_unkVariableName);
				fn__setVariableOnCutsceneAudio(ptr_unkVariableName, _value);
				Marshal.FreeHGlobal(ptr_unkVariableName);
			}
		}

		public int PlayPoliceReport(string _name, float _p1)
		{
			unsafe {
				if (fn__playPoliceReport == null) fn__playPoliceReport = (delegate* unmanaged[Cdecl]<nint, float, int>) NativeLibrary.GetExport(handle, "Native_playPoliceReport");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__playPoliceReport(ptr_name, _p1);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public void CancelCurrentPoliceReport()
		{
			unsafe {
				if (fn__cancelCurrentPoliceReport == null) fn__cancelCurrentPoliceReport = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_cancelCurrentPoliceReport");
				fn__cancelCurrentPoliceReport();
			}
		}

		public void BlipSiren(int _vehicle)
		{
			unsafe {
				if (fn__blipSiren == null) fn__blipSiren = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_blipSiren");
				fn__blipSiren(_vehicle);
			}
		}

		public void OverrideVehHorn(int _vehicle, bool _override, int _hornHash)
		{
			unsafe {
				if (fn__overrideVehHorn == null) fn__overrideVehHorn = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_overrideVehHorn");
				fn__overrideVehHorn(_vehicle, _override, _hornHash);
			}
		}

		public bool IsHornActive(int _vehicle)
		{
			unsafe {
				if (fn__isHornActive == null) fn__isHornActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isHornActive");
				var result = fn__isHornActive(_vehicle);
				return result;
			}
		}

		public void SetAggressiveHorns(bool _toggle)
		{
			unsafe {
				if (fn__setAggressiveHorns == null) fn__setAggressiveHorns = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setAggressiveHorns");
				fn__setAggressiveHorns(_toggle);
			}
		}

		public void _0x02E93C796ABD3A97(bool _p0)
		{
			unsafe {
				if (fn__0x02E93C796ABD3A97 == null) fn__0x02E93C796ABD3A97 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x02E93C796ABD3A97");
				fn__0x02E93C796ABD3A97(_p0);
			}
		}

		public void _0x58BB377BEC7CD5F4(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__0x58BB377BEC7CD5F4 == null) fn__0x58BB377BEC7CD5F4 = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native__0x58BB377BEC7CD5F4");
				fn__0x58BB377BEC7CD5F4(_p0, _p1);
			}
		}

		public void _0x9BD7BD55E4533183(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x9BD7BD55E4533183 == null) fn__0x9BD7BD55E4533183 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x9BD7BD55E4533183");
				fn__0x9BD7BD55E4533183(_p0, _p1, _p2);
			}
		}

		public bool IsStreamPlaying()
		{
			unsafe {
				if (fn__isStreamPlaying == null) fn__isStreamPlaying = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isStreamPlaying");
				var result = fn__isStreamPlaying();
				return result;
			}
		}

		public int GetStreamPlayTime()
		{
			unsafe {
				if (fn__getStreamPlayTime == null) fn__getStreamPlayTime = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getStreamPlayTime");
				var result = fn__getStreamPlayTime();
				return result;
			}
		}

		public bool LoadStream(string _streamName, string _soundSet)
		{
			unsafe {
				if (fn__loadStream == null) fn__loadStream = (delegate* unmanaged[Cdecl]<nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_loadStream");
				var ptr_streamName = MemoryUtils.StringToHGlobalUtf8(_streamName);
				var ptr_soundSet = MemoryUtils.StringToHGlobalUtf8(_soundSet);
				var result = fn__loadStream(ptr_streamName, ptr_soundSet);
				Marshal.FreeHGlobal(ptr_streamName);
				Marshal.FreeHGlobal(ptr_soundSet);
				return result;
			}
		}

		public bool LoadStreamWithStartOffset(string _streamName, int _startOffset, string _soundSet)
		{
			unsafe {
				if (fn__loadStreamWithStartOffset == null) fn__loadStreamWithStartOffset = (delegate* unmanaged[Cdecl]<nint, int, nint, bool>) NativeLibrary.GetExport(handle, "Native_loadStreamWithStartOffset");
				var ptr_streamName = MemoryUtils.StringToHGlobalUtf8(_streamName);
				var ptr_soundSet = MemoryUtils.StringToHGlobalUtf8(_soundSet);
				var result = fn__loadStreamWithStartOffset(ptr_streamName, _startOffset, ptr_soundSet);
				Marshal.FreeHGlobal(ptr_streamName);
				Marshal.FreeHGlobal(ptr_soundSet);
				return result;
			}
		}

		public void PlayStreamFromPed(int _ped)
		{
			unsafe {
				if (fn__playStreamFromPed == null) fn__playStreamFromPed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playStreamFromPed");
				fn__playStreamFromPed(_ped);
			}
		}

		public void PlayStreamFromVehicle(int _vehicle)
		{
			unsafe {
				if (fn__playStreamFromVehicle == null) fn__playStreamFromVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playStreamFromVehicle");
				fn__playStreamFromVehicle(_vehicle);
			}
		}

		public void PlayStreamFromObject(int _object)
		{
			unsafe {
				if (fn__playStreamFromObject == null) fn__playStreamFromObject = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playStreamFromObject");
				fn__playStreamFromObject(_object);
			}
		}

		public void PlayStreamFrontend()
		{
			unsafe {
				if (fn__playStreamFrontend == null) fn__playStreamFrontend = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_playStreamFrontend");
				fn__playStreamFrontend();
			}
		}

		public void PlayStreamFromPosition(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__playStreamFromPosition == null) fn__playStreamFromPosition = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_playStreamFromPosition");
				fn__playStreamFromPosition(_x, _y, _z);
			}
		}

		public void StopStream()
		{
			unsafe {
				if (fn__stopStream == null) fn__stopStream = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopStream");
				fn__stopStream();
			}
		}

		public void StopPedSpeaking(int _ped, bool _shaking)
		{
			unsafe {
				if (fn__stopPedSpeaking == null) fn__stopPedSpeaking = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_stopPedSpeaking");
				fn__stopPedSpeaking(_ped, _shaking);
			}
		}

		public void _0xF8AD2EED7C47E8FE(int _ped, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__0xF8AD2EED7C47E8FE == null) fn__0xF8AD2EED7C47E8FE = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native__0xF8AD2EED7C47E8FE");
				fn__0xF8AD2EED7C47E8FE(_ped, _p1, _p2);
			}
		}

		public void _0xAB6781A5F3101470(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xAB6781A5F3101470 == null) fn__0xAB6781A5F3101470 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xAB6781A5F3101470");
				fn__0xAB6781A5F3101470(_p0, _p1);
			}
		}

		public void DisablePedPainAudio(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__disablePedPainAudio == null) fn__disablePedPainAudio = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_disablePedPainAudio");
				fn__disablePedPainAudio(_ped, _toggle);
			}
		}

		public bool IsAmbientSpeechDisabled(int _ped)
		{
			unsafe {
				if (fn__isAmbientSpeechDisabled == null) fn__isAmbientSpeechDisabled = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isAmbientSpeechDisabled");
				var result = fn__isAmbientSpeechDisabled(_ped);
				return result;
			}
		}

		public void _0xA8A7D434AFB4B97B(string _p0, int _p1)
		{
			unsafe {
				if (fn__0xA8A7D434AFB4B97B == null) fn__0xA8A7D434AFB4B97B = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native__0xA8A7D434AFB4B97B");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0xA8A7D434AFB4B97B(ptr_p0, _p1);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void _0x2ACABED337622DF2(string _p0)
		{
			unsafe {
				if (fn__0x2ACABED337622DF2 == null) fn__0x2ACABED337622DF2 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0x2ACABED337622DF2");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0x2ACABED337622DF2(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void SetSirenWithNoDriver(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setSirenWithNoDriver == null) fn__setSirenWithNoDriver = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setSirenWithNoDriver");
				fn__setSirenWithNoDriver(_vehicle, _toggle);
			}
		}

		public void SetSirenKeepOn(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setSirenKeepOn == null) fn__setSirenKeepOn = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setSirenKeepOn");
				fn__setSirenKeepOn(_vehicle, _toggle);
			}
		}

		public void TriggerSiren(int _vehicle)
		{
			unsafe {
				if (fn__triggerSiren == null) fn__triggerSiren = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_triggerSiren");
				fn__triggerSiren(_vehicle);
			}
		}

		public void SoundVehicleHornThisFrame(int _vehicle)
		{
			unsafe {
				if (fn__soundVehicleHornThisFrame == null) fn__soundVehicleHornThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_soundVehicleHornThisFrame");
				fn__soundVehicleHornThisFrame(_vehicle);
			}
		}

		public void SetHornEnabled(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setHornEnabled == null) fn__setHornEnabled = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setHornEnabled");
				fn__setHornEnabled(_vehicle, _toggle);
			}
		}

		public void SetAudioVehiclePriority(int _vehicle, int _p1)
		{
			unsafe {
				if (fn__setAudioVehiclePriority == null) fn__setAudioVehiclePriority = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setAudioVehiclePriority");
				fn__setAudioVehiclePriority(_vehicle, _p1);
			}
		}

		public void _0x9D3AF56E94C9AE98(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__0x9D3AF56E94C9AE98 == null) fn__0x9D3AF56E94C9AE98 = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x9D3AF56E94C9AE98");
				fn__0x9D3AF56E94C9AE98(_vehicle, _p1);
			}
		}

		public void UseSirenAsHorn(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__useSirenAsHorn == null) fn__useSirenAsHorn = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_useSirenAsHorn");
				fn__useSirenAsHorn(_vehicle, _toggle);
			}
		}

		public void ForceVehicleEngineAudio(int _vehicle, string _audioName)
		{
			unsafe {
				if (fn__forceVehicleEngineAudio == null) fn__forceVehicleEngineAudio = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_forceVehicleEngineAudio");
				var ptr_audioName = MemoryUtils.StringToHGlobalUtf8(_audioName);
				fn__forceVehicleEngineAudio(_vehicle, ptr_audioName);
				Marshal.FreeHGlobal(ptr_audioName);
			}
		}

		public void PreloadVehicleAudio(int _vehicleModel)
		{
			unsafe {
				if (fn__preloadVehicleAudio == null) fn__preloadVehicleAudio = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_preloadVehicleAudio");
				fn__preloadVehicleAudio(_vehicleModel);
			}
		}

		public void SetVehicleStartupRevSound(int _vehicle, string _p1, string _p2)
		{
			unsafe {
				if (fn__setVehicleStartupRevSound == null) fn__setVehicleStartupRevSound = (delegate* unmanaged[Cdecl]<int, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_setVehicleStartupRevSound");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				fn__setVehicleStartupRevSound(_vehicle, ptr_p1, ptr_p2);
				Marshal.FreeHGlobal(ptr_p1);
				Marshal.FreeHGlobal(ptr_p2);
			}
		}

		public void ResetVehicleStartupRevSound(int _vehicle)
		{
			unsafe {
				if (fn__resetVehicleStartupRevSound == null) fn__resetVehicleStartupRevSound = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetVehicleStartupRevSound");
				fn__resetVehicleStartupRevSound(_vehicle);
			}
		}

		public void _0x97FFB4ADEED08066(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x97FFB4ADEED08066 == null) fn__0x97FFB4ADEED08066 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x97FFB4ADEED08066");
				fn__0x97FFB4ADEED08066(_p0, _p1);
			}
		}

		public bool IsVehicleAudiblyDamaged(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleAudiblyDamaged == null) fn__isVehicleAudiblyDamaged = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleAudiblyDamaged");
				var result = fn__isVehicleAudiblyDamaged(_vehicle);
				return result;
			}
		}

		public void SetVehicleAudioEngineDamageFactor(int _vehicle, float _damageFactor)
		{
			unsafe {
				if (fn__setVehicleAudioEngineDamageFactor == null) fn__setVehicleAudioEngineDamageFactor = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleAudioEngineDamageFactor");
				fn__setVehicleAudioEngineDamageFactor(_vehicle, _damageFactor);
			}
		}

		public void SetVehicleAudioBodyDamageFactor(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__setVehicleAudioBodyDamageFactor == null) fn__setVehicleAudioBodyDamageFactor = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleAudioBodyDamageFactor");
				fn__setVehicleAudioBodyDamageFactor(_vehicle, _p1);
			}
		}

		public void EnableVehicleFanbeltDamage(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__enableVehicleFanbeltDamage == null) fn__enableVehicleFanbeltDamage = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_enableVehicleFanbeltDamage");
				fn__enableVehicleFanbeltDamage(_vehicle, _toggle);
			}
		}

		public void EnableVehicleExhaustPops(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__enableVehicleExhaustPops == null) fn__enableVehicleExhaustPops = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_enableVehicleExhaustPops");
				fn__enableVehicleExhaustPops(_vehicle, _toggle);
			}
		}

		public void SetVehicleBoostActive(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleBoostActive == null) fn__setVehicleBoostActive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleBoostActive");
				fn__setVehicleBoostActive(_vehicle, _toggle);
			}
		}

		public void _0x6FDDAD856E36988A(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0x6FDDAD856E36988A == null) fn__0x6FDDAD856E36988A = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x6FDDAD856E36988A");
				fn__0x6FDDAD856E36988A(_vehicle, _toggle);
			}
		}

		public void SetScriptUpdateDoorAudio(int _doorHash, bool _toggle)
		{
			unsafe {
				if (fn__setScriptUpdateDoorAudio == null) fn__setScriptUpdateDoorAudio = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setScriptUpdateDoorAudio");
				fn__setScriptUpdateDoorAudio(_doorHash, _toggle);
			}
		}

		public void PlayVehicleDoorOpenSound(int _vehicle, int _doorId)
		{
			unsafe {
				if (fn__playVehicleDoorOpenSound == null) fn__playVehicleDoorOpenSound = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_playVehicleDoorOpenSound");
				fn__playVehicleDoorOpenSound(_vehicle, _doorId);
			}
		}

		public void PlayVehicleDoorCloseSound(int _vehicle, int _doorId)
		{
			unsafe {
				if (fn__playVehicleDoorCloseSound == null) fn__playVehicleDoorCloseSound = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_playVehicleDoorCloseSound");
				fn__playVehicleDoorCloseSound(_vehicle, _doorId);
			}
		}

		public void EnableStallWarningSounds(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__enableStallWarningSounds == null) fn__enableStallWarningSounds = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_enableStallWarningSounds");
				fn__enableStallWarningSounds(_vehicle, _toggle);
			}
		}

		public bool IsGameInControlOfMusic()
		{
			unsafe {
				if (fn__isGameInControlOfMusic == null) fn__isGameInControlOfMusic = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isGameInControlOfMusic");
				var result = fn__isGameInControlOfMusic();
				return result;
			}
		}

		public void SetGpsActive(bool _active)
		{
			unsafe {
				if (fn__setGpsActive == null) fn__setGpsActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setGpsActive");
				fn__setGpsActive(_active);
			}
		}

		public void PlayMissionCompleteAudio(string _audioName)
		{
			unsafe {
				if (fn__playMissionCompleteAudio == null) fn__playMissionCompleteAudio = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_playMissionCompleteAudio");
				var ptr_audioName = MemoryUtils.StringToHGlobalUtf8(_audioName);
				fn__playMissionCompleteAudio(ptr_audioName);
				Marshal.FreeHGlobal(ptr_audioName);
			}
		}

		public bool IsMissionCompletePlaying()
		{
			unsafe {
				if (fn__isMissionCompletePlaying == null) fn__isMissionCompletePlaying = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMissionCompletePlaying");
				var result = fn__isMissionCompletePlaying();
				return result;
			}
		}

		public bool IsMissionCompleteReadyForUi()
		{
			unsafe {
				if (fn__isMissionCompleteReadyForUi == null) fn__isMissionCompleteReadyForUi = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMissionCompleteReadyForUi");
				var result = fn__isMissionCompleteReadyForUi();
				return result;
			}
		}

		public void BlockDeathJingle(bool _toggle)
		{
			unsafe {
				if (fn__blockDeathJingle == null) fn__blockDeathJingle = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_blockDeathJingle");
				fn__blockDeathJingle(_toggle);
			}
		}

		public bool StartAudioScene(string _scene)
		{
			unsafe {
				if (fn__startAudioScene == null) fn__startAudioScene = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_startAudioScene");
				var ptr_scene = MemoryUtils.StringToHGlobalUtf8(_scene);
				var result = fn__startAudioScene(ptr_scene);
				Marshal.FreeHGlobal(ptr_scene);
				return result;
			}
		}

		public void StopAudioScene(string _scene)
		{
			unsafe {
				if (fn__stopAudioScene == null) fn__stopAudioScene = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_stopAudioScene");
				var ptr_scene = MemoryUtils.StringToHGlobalUtf8(_scene);
				fn__stopAudioScene(ptr_scene);
				Marshal.FreeHGlobal(ptr_scene);
			}
		}

		public void StopAudioScenes()
		{
			unsafe {
				if (fn__stopAudioScenes == null) fn__stopAudioScenes = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopAudioScenes");
				fn__stopAudioScenes();
			}
		}

		public bool IsAudioSceneActive(string _scene)
		{
			unsafe {
				if (fn__isAudioSceneActive == null) fn__isAudioSceneActive = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isAudioSceneActive");
				var ptr_scene = MemoryUtils.StringToHGlobalUtf8(_scene);
				var result = fn__isAudioSceneActive(ptr_scene);
				Marshal.FreeHGlobal(ptr_scene);
				return result;
			}
		}

		public void SetAudioSceneVariable(string _scene, string _unkVariable, float _value)
		{
			unsafe {
				if (fn__setAudioSceneVariable == null) fn__setAudioSceneVariable = (delegate* unmanaged[Cdecl]<nint, nint, float, void>) NativeLibrary.GetExport(handle, "Native_setAudioSceneVariable");
				var ptr_scene = MemoryUtils.StringToHGlobalUtf8(_scene);
				var ptr_unkVariable = MemoryUtils.StringToHGlobalUtf8(_unkVariable);
				fn__setAudioSceneVariable(ptr_scene, ptr_unkVariable, _value);
				Marshal.FreeHGlobal(ptr_scene);
				Marshal.FreeHGlobal(ptr_unkVariable);
			}
		}

		public void SetAudioScriptCleanupTime(int _time)
		{
			unsafe {
				if (fn__setAudioScriptCleanupTime == null) fn__setAudioScriptCleanupTime = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setAudioScriptCleanupTime");
				fn__setAudioScriptCleanupTime(_time);
			}
		}

		public void AddEntityToAudioMixGroup(int _entity, string _groupName, float _p2)
		{
			unsafe {
				if (fn__addEntityToAudioMixGroup == null) fn__addEntityToAudioMixGroup = (delegate* unmanaged[Cdecl]<int, nint, float, void>) NativeLibrary.GetExport(handle, "Native_addEntityToAudioMixGroup");
				var ptr_groupName = MemoryUtils.StringToHGlobalUtf8(_groupName);
				fn__addEntityToAudioMixGroup(_entity, ptr_groupName, _p2);
				Marshal.FreeHGlobal(ptr_groupName);
			}
		}

		public void RemoveEntityFromAudioMixGroup(int _entity, float _p1)
		{
			unsafe {
				if (fn__removeEntityFromAudioMixGroup == null) fn__removeEntityFromAudioMixGroup = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_removeEntityFromAudioMixGroup");
				fn__removeEntityFromAudioMixGroup(_entity, _p1);
			}
		}

		public bool AudioIsScriptedMusicPlaying()
		{
			unsafe {
				if (fn__audioIsScriptedMusicPlaying == null) fn__audioIsScriptedMusicPlaying = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_audioIsScriptedMusicPlaying");
				var result = fn__audioIsScriptedMusicPlaying();
				return result;
			}
		}

		public int _0x2DD39BF3E2F9C47F()
		{
			unsafe {
				if (fn__0x2DD39BF3E2F9C47F == null) fn__0x2DD39BF3E2F9C47F = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x2DD39BF3E2F9C47F");
				var result = fn__0x2DD39BF3E2F9C47F();
				return result;
			}
		}

		public bool PrepareMusicEvent(string _eventName)
		{
			unsafe {
				if (fn__prepareMusicEvent == null) fn__prepareMusicEvent = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_prepareMusicEvent");
				var ptr_eventName = MemoryUtils.StringToHGlobalUtf8(_eventName);
				var result = fn__prepareMusicEvent(ptr_eventName);
				Marshal.FreeHGlobal(ptr_eventName);
				return result;
			}
		}

		public bool CancelMusicEvent(string _eventName)
		{
			unsafe {
				if (fn__cancelMusicEvent == null) fn__cancelMusicEvent = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_cancelMusicEvent");
				var ptr_eventName = MemoryUtils.StringToHGlobalUtf8(_eventName);
				var result = fn__cancelMusicEvent(ptr_eventName);
				Marshal.FreeHGlobal(ptr_eventName);
				return result;
			}
		}

		public bool TriggerMusicEvent(string _eventName)
		{
			unsafe {
				if (fn__triggerMusicEvent == null) fn__triggerMusicEvent = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_triggerMusicEvent");
				var ptr_eventName = MemoryUtils.StringToHGlobalUtf8(_eventName);
				var result = fn__triggerMusicEvent(ptr_eventName);
				Marshal.FreeHGlobal(ptr_eventName);
				return result;
			}
		}

		public bool IsMusicOneshotPlaying()
		{
			unsafe {
				if (fn__isMusicOneshotPlaying == null) fn__isMusicOneshotPlaying = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMusicOneshotPlaying");
				var result = fn__isMusicOneshotPlaying();
				return result;
			}
		}

		public int GetMusicPlaytime()
		{
			unsafe {
				if (fn__getMusicPlaytime == null) fn__getMusicPlaytime = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMusicPlaytime");
				var result = fn__getMusicPlaytime();
				return result;
			}
		}

		public void _0x159B7318403A1CD8(int _p0)
		{
			unsafe {
				if (fn__0x159B7318403A1CD8 == null) fn__0x159B7318403A1CD8 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x159B7318403A1CD8");
				fn__0x159B7318403A1CD8(_p0);
			}
		}

		public void RecordBrokenGlass(float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__recordBrokenGlass == null) fn__recordBrokenGlass = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_recordBrokenGlass");
				fn__recordBrokenGlass(_x, _y, _z, _radius);
			}
		}

		public void ClearAllBrokenGlass()
		{
			unsafe {
				if (fn__clearAllBrokenGlass == null) fn__clearAllBrokenGlass = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearAllBrokenGlass");
				fn__clearAllBrokenGlass();
			}
		}

		public void _0x70B8EC8FC108A634(bool _p0, int _p1)
		{
			unsafe {
				if (fn__0x70B8EC8FC108A634 == null) fn__0x70B8EC8FC108A634 = (delegate* unmanaged[Cdecl]<bool, int, void>) NativeLibrary.GetExport(handle, "Native__0x70B8EC8FC108A634");
				fn__0x70B8EC8FC108A634(_p0, _p1);
			}
		}

		public void _0x149AEE66F0CB3A99(float _p0, float _p1)
		{
			unsafe {
				if (fn__0x149AEE66F0CB3A99 == null) fn__0x149AEE66F0CB3A99 = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native__0x149AEE66F0CB3A99");
				fn__0x149AEE66F0CB3A99(_p0, _p1);
			}
		}

		public void _0x8BF907833BE275DE(float _p0, float _p1)
		{
			unsafe {
				if (fn__0x8BF907833BE275DE == null) fn__0x8BF907833BE275DE = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native__0x8BF907833BE275DE");
				fn__0x8BF907833BE275DE(_p0, _p1);
			}
		}

		public void ForcePedPanicWalla()
		{
			unsafe {
				if (fn__forcePedPanicWalla == null) fn__forcePedPanicWalla = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_forcePedPanicWalla");
				fn__forcePedPanicWalla();
			}
		}

		public bool PrepareAlarm(string _alarmName)
		{
			unsafe {
				if (fn__prepareAlarm == null) fn__prepareAlarm = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_prepareAlarm");
				var ptr_alarmName = MemoryUtils.StringToHGlobalUtf8(_alarmName);
				var result = fn__prepareAlarm(ptr_alarmName);
				Marshal.FreeHGlobal(ptr_alarmName);
				return result;
			}
		}

		public void StartAlarm(string _alarmName, bool _p2)
		{
			unsafe {
				if (fn__startAlarm == null) fn__startAlarm = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_startAlarm");
				var ptr_alarmName = MemoryUtils.StringToHGlobalUtf8(_alarmName);
				fn__startAlarm(ptr_alarmName, _p2);
				Marshal.FreeHGlobal(ptr_alarmName);
			}
		}

		public void StopAlarm(string _alarmName, bool _toggle)
		{
			unsafe {
				if (fn__stopAlarm == null) fn__stopAlarm = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_stopAlarm");
				var ptr_alarmName = MemoryUtils.StringToHGlobalUtf8(_alarmName);
				fn__stopAlarm(ptr_alarmName, _toggle);
				Marshal.FreeHGlobal(ptr_alarmName);
			}
		}

		public void StopAllAlarms(bool _stop)
		{
			unsafe {
				if (fn__stopAllAlarms == null) fn__stopAllAlarms = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_stopAllAlarms");
				fn__stopAllAlarms(_stop);
			}
		}

		public bool IsAlarmPlaying(string _alarmName)
		{
			unsafe {
				if (fn__isAlarmPlaying == null) fn__isAlarmPlaying = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isAlarmPlaying");
				var ptr_alarmName = MemoryUtils.StringToHGlobalUtf8(_alarmName);
				var result = fn__isAlarmPlaying(ptr_alarmName);
				Marshal.FreeHGlobal(ptr_alarmName);
				return result;
			}
		}

		public int GetVehicleDefaultHorn(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleDefaultHorn == null) fn__getVehicleDefaultHorn = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleDefaultHorn");
				var result = fn__getVehicleDefaultHorn(_vehicle);
				return result;
			}
		}

		public int GetVehicleDefaultHornIgnoreMods(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleDefaultHornIgnoreMods == null) fn__getVehicleDefaultHornIgnoreMods = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleDefaultHornIgnoreMods");
				var result = fn__getVehicleDefaultHornIgnoreMods(_vehicle);
				return result;
			}
		}

		public void ResetPedAudioFlags(int _ped)
		{
			unsafe {
				if (fn__resetPedAudioFlags == null) fn__resetPedAudioFlags = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPedAudioFlags");
				fn__resetPedAudioFlags(_ped);
			}
		}

		public void SetPedAudioFootstepLoud(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedAudioFootstepLoud == null) fn__setPedAudioFootstepLoud = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAudioFootstepLoud");
				fn__setPedAudioFootstepLoud(_ped, _toggle);
			}
		}

		public void SetPedAudioFootstepQuiet(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedAudioFootstepQuiet == null) fn__setPedAudioFootstepQuiet = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAudioFootstepQuiet");
				fn__setPedAudioFootstepQuiet(_ped, _toggle);
			}
		}

		public void OverridePlayerGroundMaterial(int _hash, bool _toggle)
		{
			unsafe {
				if (fn__overridePlayerGroundMaterial == null) fn__overridePlayerGroundMaterial = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_overridePlayerGroundMaterial");
				fn__overridePlayerGroundMaterial(_hash, _toggle);
			}
		}

		public void _0xBF4DC1784BE94DFA(int _ped, bool _p1, int _hash)
		{
			unsafe {
				if (fn__0xBF4DC1784BE94DFA == null) fn__0xBF4DC1784BE94DFA = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native__0xBF4DC1784BE94DFA");
				fn__0xBF4DC1784BE94DFA(_ped, _p1, _hash);
			}
		}

		public void OverrideMicrophoneSettings(int _hash, bool _toggle)
		{
			unsafe {
				if (fn__overrideMicrophoneSettings == null) fn__overrideMicrophoneSettings = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_overrideMicrophoneSettings");
				fn__overrideMicrophoneSettings(_hash, _toggle);
			}
		}

		public void FreezeMicrophone()
		{
			unsafe {
				if (fn__freezeMicrophone == null) fn__freezeMicrophone = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_freezeMicrophone");
				fn__freezeMicrophone();
			}
		}

		public void DistantCopCarSirens(bool _value)
		{
			unsafe {
				if (fn__distantCopCarSirens == null) fn__distantCopCarSirens = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_distantCopCarSirens");
				fn__distantCopCarSirens(_value);
			}
		}

		public void _0x43FA0DFC5DF87815(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x43FA0DFC5DF87815 == null) fn__0x43FA0DFC5DF87815 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x43FA0DFC5DF87815");
				fn__0x43FA0DFC5DF87815(_vehicle, _p1);
			}
		}

		public void _0xB81CF134AEB56FFB()
		{
			unsafe {
				if (fn__0xB81CF134AEB56FFB == null) fn__0xB81CF134AEB56FFB = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xB81CF134AEB56FFB");
				fn__0xB81CF134AEB56FFB();
			}
		}

		public void SetAudioFlag(string _flagName, bool _toggle)
		{
			unsafe {
				if (fn__setAudioFlag == null) fn__setAudioFlag = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setAudioFlag");
				var ptr_flagName = MemoryUtils.StringToHGlobalUtf8(_flagName);
				fn__setAudioFlag(ptr_flagName, _toggle);
				Marshal.FreeHGlobal(ptr_flagName);
			}
		}

		public int PrepareSynchronizedAudioEvent(string _p0, int _p1)
		{
			unsafe {
				if (fn__prepareSynchronizedAudioEvent == null) fn__prepareSynchronizedAudioEvent = (delegate* unmanaged[Cdecl]<nint, int, int>) NativeLibrary.GetExport(handle, "Native_prepareSynchronizedAudioEvent");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var result = fn__prepareSynchronizedAudioEvent(ptr_p0, _p1);
				Marshal.FreeHGlobal(ptr_p0);
				return result;
			}
		}

		public bool PrepareSynchronizedAudioEventForScene(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__prepareSynchronizedAudioEventForScene == null) fn__prepareSynchronizedAudioEventForScene = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_prepareSynchronizedAudioEventForScene");
				var ref_p1 = _p1;
				var result = fn__prepareSynchronizedAudioEventForScene(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool PlaySynchronizedAudioEvent(int _p0)
		{
			unsafe {
				if (fn__playSynchronizedAudioEvent == null) fn__playSynchronizedAudioEvent = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_playSynchronizedAudioEvent");
				var result = fn__playSynchronizedAudioEvent(_p0);
				return result;
			}
		}

		public bool StopSynchronizedAudioEvent(int _p0)
		{
			unsafe {
				if (fn__stopSynchronizedAudioEvent == null) fn__stopSynchronizedAudioEvent = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_stopSynchronizedAudioEvent");
				var result = fn__stopSynchronizedAudioEvent(_p0);
				return result;
			}
		}

		public void _0xC8EDE9BDBCCBA6D4(ref int _p0, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__0xC8EDE9BDBCCBA6D4 == null) fn__0xC8EDE9BDBCCBA6D4 = (delegate* unmanaged[Cdecl]<int*, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0xC8EDE9BDBCCBA6D4");
				var ref_p0 = _p0;
				fn__0xC8EDE9BDBCCBA6D4(&ref_p0, _p1, _p2, _p3);
				_p0 = ref_p0;
			}
		}

		public void SetSynchronizedAudioEventPositionThisFrame(string _p0, int _p1)
		{
			unsafe {
				if (fn__setSynchronizedAudioEventPositionThisFrame == null) fn__setSynchronizedAudioEventPositionThisFrame = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_setSynchronizedAudioEventPositionThisFrame");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__setSynchronizedAudioEventPositionThisFrame(ptr_p0, _p1);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void SetAudioSpecialEffectMode(int _mode)
		{
			unsafe {
				if (fn__setAudioSpecialEffectMode == null) fn__setAudioSpecialEffectMode = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setAudioSpecialEffectMode");
				fn__setAudioSpecialEffectMode(_mode);
			}
		}

		public void SetPortalSettingsOverride(string _p0, string _p1)
		{
			unsafe {
				if (fn__setPortalSettingsOverride == null) fn__setPortalSettingsOverride = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native_setPortalSettingsOverride");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__setPortalSettingsOverride(ptr_p0, ptr_p1);
				Marshal.FreeHGlobal(ptr_p0);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void RemovePortalSettingsOverride(string _p0)
		{
			unsafe {
				if (fn__removePortalSettingsOverride == null) fn__removePortalSettingsOverride = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removePortalSettingsOverride");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__removePortalSettingsOverride(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void _0xE4E6DD5566D28C82()
		{
			unsafe {
				if (fn__0xE4E6DD5566D28C82 == null) fn__0xE4E6DD5566D28C82 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xE4E6DD5566D28C82");
				fn__0xE4E6DD5566D28C82();
			}
		}

		public int GetMusicVolSlider()
		{
			unsafe {
				if (fn__getMusicVolSlider == null) fn__getMusicVolSlider = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMusicVolSlider");
				var result = fn__getMusicVolSlider();
				return result;
			}
		}

		public void RequestTennisBanks(int _ped)
		{
			unsafe {
				if (fn__requestTennisBanks == null) fn__requestTennisBanks = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestTennisBanks");
				fn__requestTennisBanks(_ped);
			}
		}

		public void UnrequestTennisBanks()
		{
			unsafe {
				if (fn__unrequestTennisBanks == null) fn__unrequestTennisBanks = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_unrequestTennisBanks");
				fn__unrequestTennisBanks();
			}
		}

		public void _0xBEF34B1D9624D5DD(bool _p0)
		{
			unsafe {
				if (fn__0xBEF34B1D9624D5DD == null) fn__0xBEF34B1D9624D5DD = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xBEF34B1D9624D5DD");
				fn__0xBEF34B1D9624D5DD(_p0);
			}
		}

		public void StopCutsceneAudio()
		{
			unsafe {
				if (fn__stopCutsceneAudio == null) fn__stopCutsceneAudio = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopCutsceneAudio");
				fn__stopCutsceneAudio();
			}
		}

		public bool HasMultiplayerAudioDataLoaded()
		{
			unsafe {
				if (fn__hasMultiplayerAudioDataLoaded == null) fn__hasMultiplayerAudioDataLoaded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasMultiplayerAudioDataLoaded");
				var result = fn__hasMultiplayerAudioDataLoaded();
				return result;
			}
		}

		public bool HasMultiplayerAudioDataUnloaded()
		{
			unsafe {
				if (fn__hasMultiplayerAudioDataUnloaded == null) fn__hasMultiplayerAudioDataUnloaded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasMultiplayerAudioDataUnloaded");
				var result = fn__hasMultiplayerAudioDataUnloaded();
				return result;
			}
		}

		public int GetVehicleDefaultHornVariation(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleDefaultHornVariation == null) fn__getVehicleDefaultHornVariation = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleDefaultHornVariation");
				var result = fn__getVehicleDefaultHornVariation(_vehicle);
				return result;
			}
		}

		public void SetVehicleHornVariation(int _vehicle, int _value)
		{
			unsafe {
				if (fn__setVehicleHornVariation == null) fn__setVehicleHornVariation = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHornVariation");
				fn__setVehicleHornVariation(_vehicle, _value);
			}
		}

		public void AddScriptToRandomPed(string _name, int _model, float _p2, float _p3)
		{
			unsafe {
				if (fn__addScriptToRandomPed == null) fn__addScriptToRandomPed = (delegate* unmanaged[Cdecl]<nint, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_addScriptToRandomPed");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__addScriptToRandomPed(ptr_name, _model, _p2, _p3);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void RegisterObjectScriptBrain(string _scriptName, int _modelHash, int _p2, float _activationRange, int _p4, int _p5)
		{
			unsafe {
				if (fn__registerObjectScriptBrain == null) fn__registerObjectScriptBrain = (delegate* unmanaged[Cdecl]<nint, int, int, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_registerObjectScriptBrain");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				fn__registerObjectScriptBrain(ptr_scriptName, _modelHash, _p2, _activationRange, _p4, _p5);
				Marshal.FreeHGlobal(ptr_scriptName);
			}
		}

		public bool IsObjectWithinBrainActivationRange(int _object)
		{
			unsafe {
				if (fn__isObjectWithinBrainActivationRange == null) fn__isObjectWithinBrainActivationRange = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isObjectWithinBrainActivationRange");
				var result = fn__isObjectWithinBrainActivationRange(_object);
				return result;
			}
		}

		public void RegisterWorldPointScriptBrain(string _scriptName, float _activationRange, int _p2)
		{
			unsafe {
				if (fn__registerWorldPointScriptBrain == null) fn__registerWorldPointScriptBrain = (delegate* unmanaged[Cdecl]<nint, float, int, void>) NativeLibrary.GetExport(handle, "Native_registerWorldPointScriptBrain");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				fn__registerWorldPointScriptBrain(ptr_scriptName, _activationRange, _p2);
				Marshal.FreeHGlobal(ptr_scriptName);
			}
		}

		public bool IsWorldPointWithinBrainActivationRange()
		{
			unsafe {
				if (fn__isWorldPointWithinBrainActivationRange == null) fn__isWorldPointWithinBrainActivationRange = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isWorldPointWithinBrainActivationRange");
				var result = fn__isWorldPointWithinBrainActivationRange();
				return result;
			}
		}

		public void EnableScriptBrainSet(int _brainSet)
		{
			unsafe {
				if (fn__enableScriptBrainSet == null) fn__enableScriptBrainSet = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_enableScriptBrainSet");
				fn__enableScriptBrainSet(_brainSet);
			}
		}

		public void DisableScriptBrainSet(int _brainSet)
		{
			unsafe {
				if (fn__disableScriptBrainSet == null) fn__disableScriptBrainSet = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableScriptBrainSet");
				fn__disableScriptBrainSet(_brainSet);
			}
		}

		public void _0x0B40ED49D7D6FF84()
		{
			unsafe {
				if (fn__0x0B40ED49D7D6FF84 == null) fn__0x0B40ED49D7D6FF84 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x0B40ED49D7D6FF84");
				fn__0x0B40ED49D7D6FF84();
			}
		}

		public void _0x4D953DF78EBF8158()
		{
			unsafe {
				if (fn__0x4D953DF78EBF8158 == null) fn__0x4D953DF78EBF8158 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x4D953DF78EBF8158");
				fn__0x4D953DF78EBF8158();
			}
		}

		public void _0x6D6840CEE8845831(string _action)
		{
			unsafe {
				if (fn__0x6D6840CEE8845831 == null) fn__0x6D6840CEE8845831 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0x6D6840CEE8845831");
				var ptr_action = MemoryUtils.StringToHGlobalUtf8(_action);
				fn__0x6D6840CEE8845831(ptr_action);
				Marshal.FreeHGlobal(ptr_action);
			}
		}

		public void _0x6E91B04E08773030(string _action)
		{
			unsafe {
				if (fn__0x6E91B04E08773030 == null) fn__0x6E91B04E08773030 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0x6E91B04E08773030");
				var ptr_action = MemoryUtils.StringToHGlobalUtf8(_action);
				fn__0x6E91B04E08773030(ptr_action);
				Marshal.FreeHGlobal(ptr_action);
			}
		}

		public void RenderScriptCams(bool _render, bool _ease, int _easeTime, bool _p3, bool _p4, int _p5)
		{
			unsafe {
				if (fn__renderScriptCams == null) fn__renderScriptCams = (delegate* unmanaged[Cdecl]<bool, bool, int, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_renderScriptCams");
				fn__renderScriptCams(_render, _ease, _easeTime, _p3, _p4, _p5);
			}
		}

		public void StopRenderingScriptCamsUsingCatchUp(bool _render, float _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__stopRenderingScriptCamsUsingCatchUp == null) fn__stopRenderingScriptCamsUsingCatchUp = (delegate* unmanaged[Cdecl]<bool, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_stopRenderingScriptCamsUsingCatchUp");
				fn__stopRenderingScriptCamsUsingCatchUp(_render, _p1, _p2, _p3);
			}
		}

		public int CreateCam(string _camName, bool _p1)
		{
			unsafe {
				if (fn__createCam == null) fn__createCam = (delegate* unmanaged[Cdecl]<nint, bool, int>) NativeLibrary.GetExport(handle, "Native_createCam");
				var ptr_camName = MemoryUtils.StringToHGlobalUtf8(_camName);
				var result = fn__createCam(ptr_camName, _p1);
				Marshal.FreeHGlobal(ptr_camName);
				return result;
			}
		}

		public int CreateCamWithParams(string _camName, float _posX, float _posY, float _posZ, float _rotX, float _rotY, float _rotZ, float _fov, bool _p8, int _p9)
		{
			unsafe {
				if (fn__createCamWithParams == null) fn__createCamWithParams = (delegate* unmanaged[Cdecl]<nint, float, float, float, float, float, float, float, bool, int, int>) NativeLibrary.GetExport(handle, "Native_createCamWithParams");
				var ptr_camName = MemoryUtils.StringToHGlobalUtf8(_camName);
				var result = fn__createCamWithParams(ptr_camName, _posX, _posY, _posZ, _rotX, _rotY, _rotZ, _fov, _p8, _p9);
				Marshal.FreeHGlobal(ptr_camName);
				return result;
			}
		}

		public int CreateCamera(int _camHash, bool _p1)
		{
			unsafe {
				if (fn__createCamera == null) fn__createCamera = (delegate* unmanaged[Cdecl]<int, bool, int>) NativeLibrary.GetExport(handle, "Native_createCamera");
				var result = fn__createCamera(_camHash, _p1);
				return result;
			}
		}

		public int CreateCameraWithParams(int _camHash, float _posX, float _posY, float _posZ, float _rotX, float _rotY, float _rotZ, float _fov, bool _p8, int _p9)
		{
			unsafe {
				if (fn__createCameraWithParams == null) fn__createCameraWithParams = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, int, int>) NativeLibrary.GetExport(handle, "Native_createCameraWithParams");
				var result = fn__createCameraWithParams(_camHash, _posX, _posY, _posZ, _rotX, _rotY, _rotZ, _fov, _p8, _p9);
				return result;
			}
		}

		public void DestroyCam(int _cam, bool _bScriptHostCam)
		{
			unsafe {
				if (fn__destroyCam == null) fn__destroyCam = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_destroyCam");
				fn__destroyCam(_cam, _bScriptHostCam);
			}
		}

		public void DestroyAllCams(bool _bScriptHostCam)
		{
			unsafe {
				if (fn__destroyAllCams == null) fn__destroyAllCams = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_destroyAllCams");
				fn__destroyAllCams(_bScriptHostCam);
			}
		}

		public bool DoesCamExist(int _cam)
		{
			unsafe {
				if (fn__doesCamExist == null) fn__doesCamExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesCamExist");
				var result = fn__doesCamExist(_cam);
				return result;
			}
		}

		public void SetCamActive(int _cam, bool _active)
		{
			unsafe {
				if (fn__setCamActive == null) fn__setCamActive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCamActive");
				fn__setCamActive(_cam, _active);
			}
		}

		public bool IsCamActive(int _cam)
		{
			unsafe {
				if (fn__isCamActive == null) fn__isCamActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isCamActive");
				var result = fn__isCamActive(_cam);
				return result;
			}
		}

		public bool IsCamRendering(int _cam)
		{
			unsafe {
				if (fn__isCamRendering == null) fn__isCamRendering = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isCamRendering");
				var result = fn__isCamRendering(_cam);
				return result;
			}
		}

		public int GetRenderingCam()
		{
			unsafe {
				if (fn__getRenderingCam == null) fn__getRenderingCam = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getRenderingCam");
				var result = fn__getRenderingCam();
				return result;
			}
		}

		public Vector3 GetCamCoord(int _cam)
		{
			unsafe {
				if (fn__getCamCoord == null) fn__getCamCoord = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getCamCoord");
				var result = fn__getCamCoord(_cam);
				return result;
			}
		}

		public Vector3 GetCamRot(int _cam, int _rotationOrder)
		{
			unsafe {
				if (fn__getCamRot == null) fn__getCamRot = (delegate* unmanaged[Cdecl]<int, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getCamRot");
				var result = fn__getCamRot(_cam, _rotationOrder);
				return result;
			}
		}

		public float GetCamFov(int _cam)
		{
			unsafe {
				if (fn__getCamFov == null) fn__getCamFov = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getCamFov");
				var result = fn__getCamFov(_cam);
				return result;
			}
		}

		public float GetCamNearClip(int _cam)
		{
			unsafe {
				if (fn__getCamNearClip == null) fn__getCamNearClip = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getCamNearClip");
				var result = fn__getCamNearClip(_cam);
				return result;
			}
		}

		public float GetCamFarClip(int _cam)
		{
			unsafe {
				if (fn__getCamFarClip == null) fn__getCamFarClip = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getCamFarClip");
				var result = fn__getCamFarClip(_cam);
				return result;
			}
		}

		public float GetCamFarDof(int _cam)
		{
			unsafe {
				if (fn__getCamFarDof == null) fn__getCamFarDof = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getCamFarDof");
				var result = fn__getCamFarDof(_cam);
				return result;
			}
		}

		public void SetCamParams(int _cam, float _posX, float _posY, float _posZ, float _rotX, float _rotY, float _rotZ, float _fieldOfView, int _p8, int _p9, int _p10, int _p11)
		{
			unsafe {
				if (fn__setCamParams == null) fn__setCamParams = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setCamParams");
				fn__setCamParams(_cam, _posX, _posY, _posZ, _rotX, _rotY, _rotZ, _fieldOfView, _p8, _p9, _p10, _p11);
			}
		}

		public void SetCamCoord(int _cam, float _posX, float _posY, float _posZ)
		{
			unsafe {
				if (fn__setCamCoord == null) fn__setCamCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setCamCoord");
				fn__setCamCoord(_cam, _posX, _posY, _posZ);
			}
		}

		public void SetCamRot(int _cam, float _rotX, float _rotY, float _rotZ, int _rotationOrder)
		{
			unsafe {
				if (fn__setCamRot == null) fn__setCamRot = (delegate* unmanaged[Cdecl]<int, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setCamRot");
				fn__setCamRot(_cam, _rotX, _rotY, _rotZ, _rotationOrder);
			}
		}

		public void SetCamFov(int _cam, float _fieldOfView)
		{
			unsafe {
				if (fn__setCamFov == null) fn__setCamFov = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamFov");
				fn__setCamFov(_cam, _fieldOfView);
			}
		}

		public void SetCamNearClip(int _cam, float _nearClip)
		{
			unsafe {
				if (fn__setCamNearClip == null) fn__setCamNearClip = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamNearClip");
				fn__setCamNearClip(_cam, _nearClip);
			}
		}

		public void SetCamFarClip(int _cam, float _farClip)
		{
			unsafe {
				if (fn__setCamFarClip == null) fn__setCamFarClip = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamFarClip");
				fn__setCamFarClip(_cam, _farClip);
			}
		}

		public void _0xAABD62873FFB1A33(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xAABD62873FFB1A33 == null) fn__0xAABD62873FFB1A33 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xAABD62873FFB1A33");
				fn__0xAABD62873FFB1A33(_p0, _p1);
			}
		}

		public void SetCamMotionBlurStrength(int _cam, float _strength)
		{
			unsafe {
				if (fn__setCamMotionBlurStrength == null) fn__setCamMotionBlurStrength = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamMotionBlurStrength");
				fn__setCamMotionBlurStrength(_cam, _strength);
			}
		}

		public void SetCamNearDof(int _cam, float _nearDOF)
		{
			unsafe {
				if (fn__setCamNearDof == null) fn__setCamNearDof = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamNearDof");
				fn__setCamNearDof(_cam, _nearDOF);
			}
		}

		public void SetCamFarDof(int _cam, float _farDOF)
		{
			unsafe {
				if (fn__setCamFarDof == null) fn__setCamFarDof = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamFarDof");
				fn__setCamFarDof(_cam, _farDOF);
			}
		}

		public void SetCamDofStrength(int _cam, float _dofStrength)
		{
			unsafe {
				if (fn__setCamDofStrength == null) fn__setCamDofStrength = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamDofStrength");
				fn__setCamDofStrength(_cam, _dofStrength);
			}
		}

		public void SetCamDofPlanes(int _cam, float _p1, float _p2, float _p3, float _p4)
		{
			unsafe {
				if (fn__setCamDofPlanes == null) fn__setCamDofPlanes = (delegate* unmanaged[Cdecl]<int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setCamDofPlanes");
				fn__setCamDofPlanes(_cam, _p1, _p2, _p3, _p4);
			}
		}

		public void SetCamUseShallowDofMode(int _cam, bool _toggle)
		{
			unsafe {
				if (fn__setCamUseShallowDofMode == null) fn__setCamUseShallowDofMode = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCamUseShallowDofMode");
				fn__setCamUseShallowDofMode(_cam, _toggle);
			}
		}

		public void SetUseHiDof()
		{
			unsafe {
				if (fn__setUseHiDof == null) fn__setUseHiDof = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setUseHiDof");
				fn__setUseHiDof();
			}
		}

		public void _0xF55E4046F6F831DC(int _p0, float _p1)
		{
			unsafe {
				if (fn__0xF55E4046F6F831DC == null) fn__0xF55E4046F6F831DC = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0xF55E4046F6F831DC");
				fn__0xF55E4046F6F831DC(_p0, _p1);
			}
		}

		public void _0xE111A7C0D200CBC5(int _p0, float _p1)
		{
			unsafe {
				if (fn__0xE111A7C0D200CBC5 == null) fn__0xE111A7C0D200CBC5 = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0xE111A7C0D200CBC5");
				fn__0xE111A7C0D200CBC5(_p0, _p1);
			}
		}

		public void SetCamDofFnumberOfLens(int _camera, float _p1)
		{
			unsafe {
				if (fn__setCamDofFnumberOfLens == null) fn__setCamDofFnumberOfLens = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamDofFnumberOfLens");
				fn__setCamDofFnumberOfLens(_camera, _p1);
			}
		}

		public void SetCamDofFocalLengthMultiplier(int _camera, float _multiplier)
		{
			unsafe {
				if (fn__setCamDofFocalLengthMultiplier == null) fn__setCamDofFocalLengthMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamDofFocalLengthMultiplier");
				fn__setCamDofFocalLengthMultiplier(_camera, _multiplier);
			}
		}

		public void SetCamDofFocusDistanceBias(int _camera, float _p1)
		{
			unsafe {
				if (fn__setCamDofFocusDistanceBias == null) fn__setCamDofFocusDistanceBias = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamDofFocusDistanceBias");
				fn__setCamDofFocusDistanceBias(_camera, _p1);
			}
		}

		public void SetCamDofMaxNearInFocusDistance(int _camera, float _p1)
		{
			unsafe {
				if (fn__setCamDofMaxNearInFocusDistance == null) fn__setCamDofMaxNearInFocusDistance = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamDofMaxNearInFocusDistance");
				fn__setCamDofMaxNearInFocusDistance(_camera, _p1);
			}
		}

		public void SetCamDofMaxNearInFocusDistanceBlendLevel(int _camera, float _p1)
		{
			unsafe {
				if (fn__setCamDofMaxNearInFocusDistanceBlendLevel == null) fn__setCamDofMaxNearInFocusDistanceBlendLevel = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamDofMaxNearInFocusDistanceBlendLevel");
				fn__setCamDofMaxNearInFocusDistanceBlendLevel(_camera, _p1);
			}
		}

		public void AttachCamToEntity(int _cam, int _entity, float _xOffset, float _yOffset, float _zOffset, bool _isRelative)
		{
			unsafe {
				if (fn__attachCamToEntity == null) fn__attachCamToEntity = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_attachCamToEntity");
				fn__attachCamToEntity(_cam, _entity, _xOffset, _yOffset, _zOffset, _isRelative);
			}
		}

		public void AttachCamToPedBone(int _cam, int _ped, int _boneIndex, float _x, float _y, float _z, bool _heading)
		{
			unsafe {
				if (fn__attachCamToPedBone == null) fn__attachCamToPedBone = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_attachCamToPedBone");
				fn__attachCamToPedBone(_cam, _ped, _boneIndex, _x, _y, _z, _heading);
			}
		}

		public void AttachCamToPedBone2(int _cam, int _ped, int _boneIndex, float _p3, float _p4, float _p5, float _p6, float _p7, float _p8, bool _p9)
		{
			unsafe {
				if (fn__attachCamToPedBone2 == null) fn__attachCamToPedBone2 = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_attachCamToPedBone2");
				fn__attachCamToPedBone2(_cam, _ped, _boneIndex, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void _0x202A5ED9CE01D6E7(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8)
		{
			unsafe {
				if (fn__0x202A5ED9CE01D6E7 == null) fn__0x202A5ED9CE01D6E7 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x202A5ED9CE01D6E7");
				fn__0x202A5ED9CE01D6E7(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
			}
		}

		public void AttachCamToVehicleBone(int _cam, int _vehicle, int _boneIndex, bool _relativeRotation, float _rotX, float _rotY, float _rotZ, float _offsetX, float _offsetY, float _offsetZ, bool _fixedDirection)
		{
			unsafe {
				if (fn__attachCamToVehicleBone == null) fn__attachCamToVehicleBone = (delegate* unmanaged[Cdecl]<int, int, int, bool, float, float, float, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_attachCamToVehicleBone");
				fn__attachCamToVehicleBone(_cam, _vehicle, _boneIndex, _relativeRotation, _rotX, _rotY, _rotZ, _offsetX, _offsetY, _offsetZ, _fixedDirection);
			}
		}

		public void DetachCam(int _cam)
		{
			unsafe {
				if (fn__detachCam == null) fn__detachCam = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_detachCam");
				fn__detachCam(_cam);
			}
		}

		public void SetCamInheritRollVehicle(int _cam, bool _p1)
		{
			unsafe {
				if (fn__setCamInheritRollVehicle == null) fn__setCamInheritRollVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCamInheritRollVehicle");
				fn__setCamInheritRollVehicle(_cam, _p1);
			}
		}

		public void PointCamAtCoord(int _cam, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__pointCamAtCoord == null) fn__pointCamAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_pointCamAtCoord");
				fn__pointCamAtCoord(_cam, _x, _y, _z);
			}
		}

		public void PointCamAtEntity(int _cam, int _entity, float _p2, float _p3, float _p4, bool _p5)
		{
			unsafe {
				if (fn__pointCamAtEntity == null) fn__pointCamAtEntity = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_pointCamAtEntity");
				fn__pointCamAtEntity(_cam, _entity, _p2, _p3, _p4, _p5);
			}
		}

		public void PointCamAtPedBone(int _cam, int _ped, int _boneIndex, float _x, float _y, float _z, bool _p6)
		{
			unsafe {
				if (fn__pointCamAtPedBone == null) fn__pointCamAtPedBone = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_pointCamAtPedBone");
				fn__pointCamAtPedBone(_cam, _ped, _boneIndex, _x, _y, _z, _p6);
			}
		}

		public void StopCamPointing(int _cam)
		{
			unsafe {
				if (fn__stopCamPointing == null) fn__stopCamPointing = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopCamPointing");
				fn__stopCamPointing(_cam);
			}
		}

		public void SetCamAffectsAiming(int _cam, bool _toggle)
		{
			unsafe {
				if (fn__setCamAffectsAiming == null) fn__setCamAffectsAiming = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCamAffectsAiming");
				fn__setCamAffectsAiming(_cam, _toggle);
			}
		}

		public void _0x661B5C8654ADD825(int _cam, bool _p1)
		{
			unsafe {
				if (fn__0x661B5C8654ADD825 == null) fn__0x661B5C8654ADD825 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x661B5C8654ADD825");
				fn__0x661B5C8654ADD825(_cam, _p1);
			}
		}

		public void _0xA2767257A320FC82(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0xA2767257A320FC82 == null) fn__0xA2767257A320FC82 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xA2767257A320FC82");
				fn__0xA2767257A320FC82(_p0, _p1);
			}
		}

		public void _0x271017B9BA825366(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0x271017B9BA825366 == null) fn__0x271017B9BA825366 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x271017B9BA825366");
				fn__0x271017B9BA825366(_p0, _p1);
			}
		}

		public void SetCamDebugName(int _camera, string _name)
		{
			unsafe {
				if (fn__setCamDebugName == null) fn__setCamDebugName = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setCamDebugName");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setCamDebugName(_camera, ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public int GetDebugCamera()
		{
			unsafe {
				if (fn__getDebugCamera == null) fn__getDebugCamera = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getDebugCamera");
				var result = fn__getDebugCamera();
				return result;
			}
		}

		public void AddCamSplineNode(int _camera, float _x, float _y, float _z, float _xRot, float _yRot, float _zRot, int _length, int _p8, int _p9)
		{
			unsafe {
				if (fn__addCamSplineNode == null) fn__addCamSplineNode = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_addCamSplineNode");
				fn__addCamSplineNode(_camera, _x, _y, _z, _xRot, _yRot, _zRot, _length, _p8, _p9);
			}
		}

		public void AddCamSplineNodeUsingCameraFrame(int _cam, int _cam2, int _p2, int _p3)
		{
			unsafe {
				if (fn__addCamSplineNodeUsingCameraFrame == null) fn__addCamSplineNodeUsingCameraFrame = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_addCamSplineNodeUsingCameraFrame");
				fn__addCamSplineNodeUsingCameraFrame(_cam, _cam2, _p2, _p3);
			}
		}

		public void AddCamSplineNodeUsingCamera(int _cam, int _cam2, int _p2, int _p3)
		{
			unsafe {
				if (fn__addCamSplineNodeUsingCamera == null) fn__addCamSplineNodeUsingCamera = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_addCamSplineNodeUsingCamera");
				fn__addCamSplineNodeUsingCamera(_cam, _cam2, _p2, _p3);
			}
		}

		public void AddCamSplineNodeUsingGameplayFrame(int _cam, int _p1, int _p2)
		{
			unsafe {
				if (fn__addCamSplineNodeUsingGameplayFrame == null) fn__addCamSplineNodeUsingGameplayFrame = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_addCamSplineNodeUsingGameplayFrame");
				fn__addCamSplineNodeUsingGameplayFrame(_cam, _p1, _p2);
			}
		}

		public void SetCamSplinePhase(int _cam, float _p1)
		{
			unsafe {
				if (fn__setCamSplinePhase == null) fn__setCamSplinePhase = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamSplinePhase");
				fn__setCamSplinePhase(_cam, _p1);
			}
		}

		public float GetCamSplinePhase(int _cam)
		{
			unsafe {
				if (fn__getCamSplinePhase == null) fn__getCamSplinePhase = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getCamSplinePhase");
				var result = fn__getCamSplinePhase(_cam);
				return result;
			}
		}

		public float GetCamSplineNodePhase(int _cam)
		{
			unsafe {
				if (fn__getCamSplineNodePhase == null) fn__getCamSplineNodePhase = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getCamSplineNodePhase");
				var result = fn__getCamSplineNodePhase(_cam);
				return result;
			}
		}

		public void SetCamSplineDuration(int _cam, int _timeDuration)
		{
			unsafe {
				if (fn__setCamSplineDuration == null) fn__setCamSplineDuration = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setCamSplineDuration");
				fn__setCamSplineDuration(_cam, _timeDuration);
			}
		}

		public void SetCamSplineSmoothingStyle(int _cam, int _smoothingStyle)
		{
			unsafe {
				if (fn__setCamSplineSmoothingStyle == null) fn__setCamSplineSmoothingStyle = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setCamSplineSmoothingStyle");
				fn__setCamSplineSmoothingStyle(_cam, _smoothingStyle);
			}
		}

		public int GetCamSplineNodeIndex(int _cam)
		{
			unsafe {
				if (fn__getCamSplineNodeIndex == null) fn__getCamSplineNodeIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getCamSplineNodeIndex");
				var result = fn__getCamSplineNodeIndex(_cam);
				return result;
			}
		}

		public void SetCamSplineNodeEase(int _cam, int _p1, int _p2, float _p3)
		{
			unsafe {
				if (fn__setCamSplineNodeEase == null) fn__setCamSplineNodeEase = (delegate* unmanaged[Cdecl]<int, int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamSplineNodeEase");
				fn__setCamSplineNodeEase(_cam, _p1, _p2, _p3);
			}
		}

		public void SetCamSplineNodeVelocityScale(int _cam, int _p1, float _scale)
		{
			unsafe {
				if (fn__setCamSplineNodeVelocityScale == null) fn__setCamSplineNodeVelocityScale = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamSplineNodeVelocityScale");
				fn__setCamSplineNodeVelocityScale(_cam, _p1, _scale);
			}
		}

		public void OverrideCamSplineVelocity(int _cam, int _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__overrideCamSplineVelocity == null) fn__overrideCamSplineVelocity = (delegate* unmanaged[Cdecl]<int, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_overrideCamSplineVelocity");
				fn__overrideCamSplineVelocity(_cam, _p1, _p2, _p3);
			}
		}

		public void OverrideCamSplineMotionBlur(int _cam, int _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__overrideCamSplineMotionBlur == null) fn__overrideCamSplineMotionBlur = (delegate* unmanaged[Cdecl]<int, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_overrideCamSplineMotionBlur");
				fn__overrideCamSplineMotionBlur(_cam, _p1, _p2, _p3);
			}
		}

		public void SetCamSplineNodeExtraFlags(int _cam, int _p1, int _flags)
		{
			unsafe {
				if (fn__setCamSplineNodeExtraFlags == null) fn__setCamSplineNodeExtraFlags = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setCamSplineNodeExtraFlags");
				fn__setCamSplineNodeExtraFlags(_cam, _p1, _flags);
			}
		}

		public bool IsCamSplinePaused(int _p0)
		{
			unsafe {
				if (fn__isCamSplinePaused == null) fn__isCamSplinePaused = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isCamSplinePaused");
				var result = fn__isCamSplinePaused(_p0);
				return result;
			}
		}

		public void SetCamActiveWithInterp(int _camTo, int _camFrom, int _duration, int _easeLocation, int _easeRotation)
		{
			unsafe {
				if (fn__setCamActiveWithInterp == null) fn__setCamActiveWithInterp = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setCamActiveWithInterp");
				fn__setCamActiveWithInterp(_camTo, _camFrom, _duration, _easeLocation, _easeRotation);
			}
		}

		public bool IsCamInterpolating(int _cam)
		{
			unsafe {
				if (fn__isCamInterpolating == null) fn__isCamInterpolating = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isCamInterpolating");
				var result = fn__isCamInterpolating(_cam);
				return result;
			}
		}

		public void ShakeCam(int _cam, string _type, float _amplitude)
		{
			unsafe {
				if (fn__shakeCam == null) fn__shakeCam = (delegate* unmanaged[Cdecl]<int, nint, float, void>) NativeLibrary.GetExport(handle, "Native_shakeCam");
				var ptr_type = MemoryUtils.StringToHGlobalUtf8(_type);
				fn__shakeCam(_cam, ptr_type, _amplitude);
				Marshal.FreeHGlobal(ptr_type);
			}
		}

		public void AnimatedShakeCam(int _cam, string _p1, string _p2, string _p3, float _amplitude)
		{
			unsafe {
				if (fn__animatedShakeCam == null) fn__animatedShakeCam = (delegate* unmanaged[Cdecl]<int, nint, nint, nint, float, void>) NativeLibrary.GetExport(handle, "Native_animatedShakeCam");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var ptr_p3 = MemoryUtils.StringToHGlobalUtf8(_p3);
				fn__animatedShakeCam(_cam, ptr_p1, ptr_p2, ptr_p3, _amplitude);
				Marshal.FreeHGlobal(ptr_p1);
				Marshal.FreeHGlobal(ptr_p2);
				Marshal.FreeHGlobal(ptr_p3);
			}
		}

		public bool IsCamShaking(int _cam)
		{
			unsafe {
				if (fn__isCamShaking == null) fn__isCamShaking = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isCamShaking");
				var result = fn__isCamShaking(_cam);
				return result;
			}
		}

		public void SetCamShakeAmplitude(int _cam, float _amplitude)
		{
			unsafe {
				if (fn__setCamShakeAmplitude == null) fn__setCamShakeAmplitude = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamShakeAmplitude");
				fn__setCamShakeAmplitude(_cam, _amplitude);
			}
		}

		public void StopCamShaking(int _cam, bool _p1)
		{
			unsafe {
				if (fn__stopCamShaking == null) fn__stopCamShaking = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_stopCamShaking");
				fn__stopCamShaking(_cam, _p1);
			}
		}

		public void ShakeScriptGlobal(string _p0, float _p1)
		{
			unsafe {
				if (fn__shakeScriptGlobal == null) fn__shakeScriptGlobal = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_shakeScriptGlobal");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__shakeScriptGlobal(ptr_p0, _p1);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void AnimatedShakeScriptGlobal(string _p0, string _p1, string _p2, float _p3)
		{
			unsafe {
				if (fn__animatedShakeScriptGlobal == null) fn__animatedShakeScriptGlobal = (delegate* unmanaged[Cdecl]<nint, nint, nint, float, void>) NativeLibrary.GetExport(handle, "Native_animatedShakeScriptGlobal");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				fn__animatedShakeScriptGlobal(ptr_p0, ptr_p1, ptr_p2, _p3);
				Marshal.FreeHGlobal(ptr_p0);
				Marshal.FreeHGlobal(ptr_p1);
				Marshal.FreeHGlobal(ptr_p2);
			}
		}

		public bool IsScriptGlobalShaking()
		{
			unsafe {
				if (fn__isScriptGlobalShaking == null) fn__isScriptGlobalShaking = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isScriptGlobalShaking");
				var result = fn__isScriptGlobalShaking();
				return result;
			}
		}

		public void StopScriptGlobalShaking(bool _p0)
		{
			unsafe {
				if (fn__stopScriptGlobalShaking == null) fn__stopScriptGlobalShaking = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_stopScriptGlobalShaking");
				fn__stopScriptGlobalShaking(_p0);
			}
		}

		public void _0x5D96CFB59DA076A0(int _vehicle, int _p1, float _p2)
		{
			unsafe {
				if (fn__0x5D96CFB59DA076A0 == null) fn__0x5D96CFB59DA076A0 = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native__0x5D96CFB59DA076A0");
				fn__0x5D96CFB59DA076A0(_vehicle, _p1, _p2);
			}
		}

		public bool PlayCamAnim(int _cam, string _animName, string _animDictionary, float _x, float _y, float _z, float _xRot, float _yRot, float _zRot, bool _p9, int _p10)
		{
			unsafe {
				if (fn__playCamAnim == null) fn__playCamAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, float, float, float, float, float, float, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_playCamAnim");
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var result = fn__playCamAnim(_cam, ptr_animName, ptr_animDictionary, _x, _y, _z, _xRot, _yRot, _zRot, _p9, _p10);
				Marshal.FreeHGlobal(ptr_animName);
				Marshal.FreeHGlobal(ptr_animDictionary);
				return result;
			}
		}

		public bool IsCamPlayingAnim(int _cam, string _animName, string _animDictionary)
		{
			unsafe {
				if (fn__isCamPlayingAnim == null) fn__isCamPlayingAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_isCamPlayingAnim");
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var result = fn__isCamPlayingAnim(_cam, ptr_animName, ptr_animDictionary);
				Marshal.FreeHGlobal(ptr_animName);
				Marshal.FreeHGlobal(ptr_animDictionary);
				return result;
			}
		}

		public void SetCamAnimCurrentPhase(int _cam, float _phase)
		{
			unsafe {
				if (fn__setCamAnimCurrentPhase == null) fn__setCamAnimCurrentPhase = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCamAnimCurrentPhase");
				fn__setCamAnimCurrentPhase(_cam, _phase);
			}
		}

		public float GetCamAnimCurrentPhase(int _cam)
		{
			unsafe {
				if (fn__getCamAnimCurrentPhase == null) fn__getCamAnimCurrentPhase = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getCamAnimCurrentPhase");
				var result = fn__getCamAnimCurrentPhase(_cam);
				return result;
			}
		}

		public bool PlaySynchronizedCamAnim(int _p0, int _p1, string _animName, string _animDictionary)
		{
			unsafe {
				if (fn__playSynchronizedCamAnim == null) fn__playSynchronizedCamAnim = (delegate* unmanaged[Cdecl]<int, int, nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_playSynchronizedCamAnim");
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var result = fn__playSynchronizedCamAnim(_p0, _p1, ptr_animName, ptr_animDictionary);
				Marshal.FreeHGlobal(ptr_animName);
				Marshal.FreeHGlobal(ptr_animDictionary);
				return result;
			}
		}

		public void SetFlyCamHorizontalResponse(int _cam, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__setFlyCamHorizontalResponse == null) fn__setFlyCamHorizontalResponse = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setFlyCamHorizontalResponse");
				fn__setFlyCamHorizontalResponse(_cam, _p1, _p2, _p3);
			}
		}

		public void SetFlyCamVerticalSpeedMultiplier(int _cam, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__setFlyCamVerticalSpeedMultiplier == null) fn__setFlyCamVerticalSpeedMultiplier = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setFlyCamVerticalSpeedMultiplier");
				fn__setFlyCamVerticalSpeedMultiplier(_cam, _p1, _p2, _p3);
			}
		}

		public void SetFlyCamMaxHeight(int _cam, float _height)
		{
			unsafe {
				if (fn__setFlyCamMaxHeight == null) fn__setFlyCamMaxHeight = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setFlyCamMaxHeight");
				fn__setFlyCamMaxHeight(_cam, _height);
			}
		}

		public void SetFlyCamCoordAndConstrain(int _cam, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setFlyCamCoordAndConstrain == null) fn__setFlyCamCoordAndConstrain = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setFlyCamCoordAndConstrain");
				fn__setFlyCamCoordAndConstrain(_cam, _x, _y, _z);
			}
		}

		public void _0xC8B5C4A79CC18B94(int _cam)
		{
			unsafe {
				if (fn__0xC8B5C4A79CC18B94 == null) fn__0xC8B5C4A79CC18B94 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC8B5C4A79CC18B94");
				fn__0xC8B5C4A79CC18B94(_cam);
			}
		}

		public bool _0x5C48A1D6E3B33179(int _cam)
		{
			unsafe {
				if (fn__0x5C48A1D6E3B33179 == null) fn__0x5C48A1D6E3B33179 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x5C48A1D6E3B33179");
				var result = fn__0x5C48A1D6E3B33179(_cam);
				return result;
			}
		}

		public bool IsScreenFadedOut()
		{
			unsafe {
				if (fn__isScreenFadedOut == null) fn__isScreenFadedOut = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isScreenFadedOut");
				var result = fn__isScreenFadedOut();
				return result;
			}
		}

		public bool IsScreenFadedIn()
		{
			unsafe {
				if (fn__isScreenFadedIn == null) fn__isScreenFadedIn = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isScreenFadedIn");
				var result = fn__isScreenFadedIn();
				return result;
			}
		}

		public bool IsScreenFadingOut()
		{
			unsafe {
				if (fn__isScreenFadingOut == null) fn__isScreenFadingOut = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isScreenFadingOut");
				var result = fn__isScreenFadingOut();
				return result;
			}
		}

		public bool IsScreenFadingIn()
		{
			unsafe {
				if (fn__isScreenFadingIn == null) fn__isScreenFadingIn = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isScreenFadingIn");
				var result = fn__isScreenFadingIn();
				return result;
			}
		}

		public void DoScreenFadeIn(int _duration)
		{
			unsafe {
				if (fn__doScreenFadeIn == null) fn__doScreenFadeIn = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_doScreenFadeIn");
				fn__doScreenFadeIn(_duration);
			}
		}

		public void DoScreenFadeOut(int _duration)
		{
			unsafe {
				if (fn__doScreenFadeOut == null) fn__doScreenFadeOut = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_doScreenFadeOut");
				fn__doScreenFadeOut(_duration);
			}
		}

		public void SetWidescreenBorders(bool _p0, int _p1)
		{
			unsafe {
				if (fn__setWidescreenBorders == null) fn__setWidescreenBorders = (delegate* unmanaged[Cdecl]<bool, int, void>) NativeLibrary.GetExport(handle, "Native_setWidescreenBorders");
				fn__setWidescreenBorders(_p0, _p1);
			}
		}

		public bool _0x4879E4FE39074CDF()
		{
			unsafe {
				if (fn__0x4879E4FE39074CDF == null) fn__0x4879E4FE39074CDF = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x4879E4FE39074CDF");
				var result = fn__0x4879E4FE39074CDF();
				return result;
			}
		}

		public Vector3 GetGameplayCamCoord()
		{
			unsafe {
				if (fn__getGameplayCamCoord == null) fn__getGameplayCamCoord = (delegate* unmanaged[Cdecl]<Vector3>) NativeLibrary.GetExport(handle, "Native_getGameplayCamCoord");
				var result = fn__getGameplayCamCoord();
				return result;
			}
		}

		public Vector3 GetGameplayCamRot(int _rotationOrder)
		{
			unsafe {
				if (fn__getGameplayCamRot == null) fn__getGameplayCamRot = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getGameplayCamRot");
				var result = fn__getGameplayCamRot(_rotationOrder);
				return result;
			}
		}

		public float GetGameplayCamFov()
		{
			unsafe {
				if (fn__getGameplayCamFov == null) fn__getGameplayCamFov = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getGameplayCamFov");
				var result = fn__getGameplayCamFov();
				return result;
			}
		}

		public void _0x487A82C650EB7799(float _p0)
		{
			unsafe {
				if (fn__0x487A82C650EB7799 == null) fn__0x487A82C650EB7799 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x487A82C650EB7799");
				fn__0x487A82C650EB7799(_p0);
			}
		}

		public void _0x0225778816FDC28C(float _p0)
		{
			unsafe {
				if (fn__0x0225778816FDC28C == null) fn__0x0225778816FDC28C = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x0225778816FDC28C");
				fn__0x0225778816FDC28C(_p0);
			}
		}

		public float GetGameplayCamRelativeHeading()
		{
			unsafe {
				if (fn__getGameplayCamRelativeHeading == null) fn__getGameplayCamRelativeHeading = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getGameplayCamRelativeHeading");
				var result = fn__getGameplayCamRelativeHeading();
				return result;
			}
		}

		public void SetGameplayCamRelativeHeading(float _heading)
		{
			unsafe {
				if (fn__setGameplayCamRelativeHeading == null) fn__setGameplayCamRelativeHeading = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamRelativeHeading");
				fn__setGameplayCamRelativeHeading(_heading);
			}
		}

		public float GetGameplayCamRelativePitch()
		{
			unsafe {
				if (fn__getGameplayCamRelativePitch == null) fn__getGameplayCamRelativePitch = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getGameplayCamRelativePitch");
				var result = fn__getGameplayCamRelativePitch();
				return result;
			}
		}

		public void SetGameplayCamRelativePitch(float _angle, float _scalingFactor)
		{
			unsafe {
				if (fn__setGameplayCamRelativePitch == null) fn__setGameplayCamRelativePitch = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamRelativePitch");
				fn__setGameplayCamRelativePitch(_angle, _scalingFactor);
			}
		}

		public void SetGameplayCamRelativeRotation(float _roll, float _pitch, float _yaw)
		{
			unsafe {
				if (fn__setGameplayCamRelativeRotation == null) fn__setGameplayCamRelativeRotation = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamRelativeRotation");
				fn__setGameplayCamRelativeRotation(_roll, _pitch, _yaw);
			}
		}

		public void _0x28B022A17B068A3A(float _p0, float _p1)
		{
			unsafe {
				if (fn__0x28B022A17B068A3A == null) fn__0x28B022A17B068A3A = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native__0x28B022A17B068A3A");
				fn__0x28B022A17B068A3A(_p0, _p1);
			}
		}

		public void SetGameplayCamRawYaw(float _yaw)
		{
			unsafe {
				if (fn__setGameplayCamRawYaw == null) fn__setGameplayCamRawYaw = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamRawYaw");
				fn__setGameplayCamRawYaw(_yaw);
			}
		}

		public void SetGameplayCamRawPitch(float _pitch)
		{
			unsafe {
				if (fn__setGameplayCamRawPitch == null) fn__setGameplayCamRawPitch = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamRawPitch");
				fn__setGameplayCamRawPitch(_pitch);
			}
		}

		public void _0x469F2ECDEC046337(bool _p0)
		{
			unsafe {
				if (fn__0x469F2ECDEC046337 == null) fn__0x469F2ECDEC046337 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x469F2ECDEC046337");
				fn__0x469F2ECDEC046337(_p0);
			}
		}

		public void ShakeGameplayCam(string _shakeName, float _intensity)
		{
			unsafe {
				if (fn__shakeGameplayCam == null) fn__shakeGameplayCam = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_shakeGameplayCam");
				var ptr_shakeName = MemoryUtils.StringToHGlobalUtf8(_shakeName);
				fn__shakeGameplayCam(ptr_shakeName, _intensity);
				Marshal.FreeHGlobal(ptr_shakeName);
			}
		}

		public bool IsGameplayCamShaking()
		{
			unsafe {
				if (fn__isGameplayCamShaking == null) fn__isGameplayCamShaking = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isGameplayCamShaking");
				var result = fn__isGameplayCamShaking();
				return result;
			}
		}

		public void SetGameplayCamShakeAmplitude(float _amplitude)
		{
			unsafe {
				if (fn__setGameplayCamShakeAmplitude == null) fn__setGameplayCamShakeAmplitude = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamShakeAmplitude");
				fn__setGameplayCamShakeAmplitude(_amplitude);
			}
		}

		public void StopGameplayCamShaking(bool _p0)
		{
			unsafe {
				if (fn__stopGameplayCamShaking == null) fn__stopGameplayCamShaking = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_stopGameplayCamShaking");
				fn__stopGameplayCamShaking(_p0);
			}
		}

		public void SetGameplayCamFollowPedThisUpdate(int _ped)
		{
			unsafe {
				if (fn__setGameplayCamFollowPedThisUpdate == null) fn__setGameplayCamFollowPedThisUpdate = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamFollowPedThisUpdate");
				fn__setGameplayCamFollowPedThisUpdate(_ped);
			}
		}

		public bool IsGameplayCamRendering()
		{
			unsafe {
				if (fn__isGameplayCamRendering == null) fn__isGameplayCamRendering = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isGameplayCamRendering");
				var result = fn__isGameplayCamRendering();
				return result;
			}
		}

		public bool _0x3044240D2E0FA842()
		{
			unsafe {
				if (fn__0x3044240D2E0FA842 == null) fn__0x3044240D2E0FA842 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x3044240D2E0FA842");
				var result = fn__0x3044240D2E0FA842();
				return result;
			}
		}

		public bool _0x705A276EBFF3133D()
		{
			unsafe {
				if (fn__0x705A276EBFF3133D == null) fn__0x705A276EBFF3133D = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x705A276EBFF3133D");
				var result = fn__0x705A276EBFF3133D();
				return result;
			}
		}

		public void _0xDB90C6CCA48940F1(bool _p0)
		{
			unsafe {
				if (fn__0xDB90C6CCA48940F1 == null) fn__0xDB90C6CCA48940F1 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xDB90C6CCA48940F1");
				fn__0xDB90C6CCA48940F1(_p0);
			}
		}

		public void EnableCrosshairThisFrame()
		{
			unsafe {
				if (fn__enableCrosshairThisFrame == null) fn__enableCrosshairThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_enableCrosshairThisFrame");
				fn__enableCrosshairThisFrame();
			}
		}

		public bool IsGameplayCamLookingBehind()
		{
			unsafe {
				if (fn__isGameplayCamLookingBehind == null) fn__isGameplayCamLookingBehind = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isGameplayCamLookingBehind");
				var result = fn__isGameplayCamLookingBehind();
				return result;
			}
		}

		public void DisableCamCollisionForEntity(int _entity)
		{
			unsafe {
				if (fn__disableCamCollisionForEntity == null) fn__disableCamCollisionForEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableCamCollisionForEntity");
				fn__disableCamCollisionForEntity(_entity);
			}
		}

		public void DisableCamCollisionForObject(int _entity)
		{
			unsafe {
				if (fn__disableCamCollisionForObject == null) fn__disableCamCollisionForObject = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableCamCollisionForObject");
				fn__disableCamCollisionForObject(_entity);
			}
		}

		public void _0xA7092AFE81944852()
		{
			unsafe {
				if (fn__0xA7092AFE81944852 == null) fn__0xA7092AFE81944852 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xA7092AFE81944852");
				fn__0xA7092AFE81944852();
			}
		}

		public void _0xFD3151CD37EA2245(int _entity)
		{
			unsafe {
				if (fn__0xFD3151CD37EA2245 == null) fn__0xFD3151CD37EA2245 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xFD3151CD37EA2245");
				fn__0xFD3151CD37EA2245(_entity);
			}
		}

		public void _0xB1381B97F70C7B30()
		{
			unsafe {
				if (fn__0xB1381B97F70C7B30 == null) fn__0xB1381B97F70C7B30 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xB1381B97F70C7B30");
				fn__0xB1381B97F70C7B30();
			}
		}

		public void _0xDD79DF9F4D26E1C9()
		{
			unsafe {
				if (fn__0xDD79DF9F4D26E1C9 == null) fn__0xDD79DF9F4D26E1C9 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xDD79DF9F4D26E1C9");
				fn__0xDD79DF9F4D26E1C9();
			}
		}

		public bool IsSphereVisible(float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__isSphereVisible == null) fn__isSphereVisible = (delegate* unmanaged[Cdecl]<float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isSphereVisible");
				var result = fn__isSphereVisible(_x, _y, _z, _radius);
				return result;
			}
		}

		public bool IsFollowPedCamActive()
		{
			unsafe {
				if (fn__isFollowPedCamActive == null) fn__isFollowPedCamActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isFollowPedCamActive");
				var result = fn__isFollowPedCamActive();
				return result;
			}
		}

		public bool SetFollowPedCamThisUpdate(string _camName, int _p1)
		{
			unsafe {
				if (fn__setFollowPedCamThisUpdate == null) fn__setFollowPedCamThisUpdate = (delegate* unmanaged[Cdecl]<nint, int, bool>) NativeLibrary.GetExport(handle, "Native_setFollowPedCamThisUpdate");
				var ptr_camName = MemoryUtils.StringToHGlobalUtf8(_camName);
				var result = fn__setFollowPedCamThisUpdate(ptr_camName, _p1);
				Marshal.FreeHGlobal(ptr_camName);
				return result;
			}
		}

		public void _0x271401846BD26E92(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__0x271401846BD26E92 == null) fn__0x271401846BD26E92 = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native__0x271401846BD26E92");
				fn__0x271401846BD26E92(_p0, _p1);
			}
		}

		public void _0xC8391C309684595A()
		{
			unsafe {
				if (fn__0xC8391C309684595A == null) fn__0xC8391C309684595A = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xC8391C309684595A");
				fn__0xC8391C309684595A();
			}
		}

		public void ClampGameplayCamYaw(float _minimum, float _maximum)
		{
			unsafe {
				if (fn__clampGameplayCamYaw == null) fn__clampGameplayCamYaw = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_clampGameplayCamYaw");
				fn__clampGameplayCamYaw(_minimum, _maximum);
			}
		}

		public void ClampGameplayCamPitch(float _minimum, float _maximum)
		{
			unsafe {
				if (fn__clampGameplayCamPitch == null) fn__clampGameplayCamPitch = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_clampGameplayCamPitch");
				fn__clampGameplayCamPitch(_minimum, _maximum);
			}
		}

		public void AnimateGameplayCamZoom(float _p0, float _distance)
		{
			unsafe {
				if (fn__animateGameplayCamZoom == null) fn__animateGameplayCamZoom = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_animateGameplayCamZoom");
				fn__animateGameplayCamZoom(_p0, _distance);
			}
		}

		public void SetInVehicleCamStateThisUpdate(int _p0, int _p1)
		{
			unsafe {
				if (fn__setInVehicleCamStateThisUpdate == null) fn__setInVehicleCamStateThisUpdate = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setInVehicleCamStateThisUpdate");
				fn__setInVehicleCamStateThisUpdate(_p0, _p1);
			}
		}

		public void DisableFirstPersonCamThisFrame()
		{
			unsafe {
				if (fn__disableFirstPersonCamThisFrame == null) fn__disableFirstPersonCamThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_disableFirstPersonCamThisFrame");
				fn__disableFirstPersonCamThisFrame();
			}
		}

		public void _0x59424BD75174C9B1()
		{
			unsafe {
				if (fn__0x59424BD75174C9B1 == null) fn__0x59424BD75174C9B1 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x59424BD75174C9B1");
				fn__0x59424BD75174C9B1();
			}
		}

		public void _0x9F97DA93681F87EA()
		{
			unsafe {
				if (fn__0x9F97DA93681F87EA == null) fn__0x9F97DA93681F87EA = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x9F97DA93681F87EA");
				fn__0x9F97DA93681F87EA();
			}
		}

		public int GetFollowPedCamZoomLevel()
		{
			unsafe {
				if (fn__getFollowPedCamZoomLevel == null) fn__getFollowPedCamZoomLevel = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getFollowPedCamZoomLevel");
				var result = fn__getFollowPedCamZoomLevel();
				return result;
			}
		}

		public int GetFollowPedCamViewMode()
		{
			unsafe {
				if (fn__getFollowPedCamViewMode == null) fn__getFollowPedCamViewMode = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getFollowPedCamViewMode");
				var result = fn__getFollowPedCamViewMode();
				return result;
			}
		}

		public void SetFollowPedCamViewMode(int _viewMode)
		{
			unsafe {
				if (fn__setFollowPedCamViewMode == null) fn__setFollowPedCamViewMode = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setFollowPedCamViewMode");
				fn__setFollowPedCamViewMode(_viewMode);
			}
		}

		public bool IsFollowVehicleCamActive()
		{
			unsafe {
				if (fn__isFollowVehicleCamActive == null) fn__isFollowVehicleCamActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isFollowVehicleCamActive");
				var result = fn__isFollowVehicleCamActive();
				return result;
			}
		}

		public void _0x91EF6EE6419E5B97(bool _p0)
		{
			unsafe {
				if (fn__0x91EF6EE6419E5B97 == null) fn__0x91EF6EE6419E5B97 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x91EF6EE6419E5B97");
				fn__0x91EF6EE6419E5B97(_p0);
			}
		}

		public void _0x9DFE13ECDC1EC196(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__0x9DFE13ECDC1EC196 == null) fn__0x9DFE13ECDC1EC196 = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native__0x9DFE13ECDC1EC196");
				fn__0x9DFE13ECDC1EC196(_p0, _p1);
			}
		}

		public bool _0x79C0E43EB9B944E2(int _hash)
		{
			unsafe {
				if (fn__0x79C0E43EB9B944E2 == null) fn__0x79C0E43EB9B944E2 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x79C0E43EB9B944E2");
				var result = fn__0x79C0E43EB9B944E2(_hash);
				return result;
			}
		}

		public int GetFollowVehicleCamZoomLevel()
		{
			unsafe {
				if (fn__getFollowVehicleCamZoomLevel == null) fn__getFollowVehicleCamZoomLevel = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getFollowVehicleCamZoomLevel");
				var result = fn__getFollowVehicleCamZoomLevel();
				return result;
			}
		}

		public void SetFollowVehicleCamZoomLevel(int _zoomLevel)
		{
			unsafe {
				if (fn__setFollowVehicleCamZoomLevel == null) fn__setFollowVehicleCamZoomLevel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setFollowVehicleCamZoomLevel");
				fn__setFollowVehicleCamZoomLevel(_zoomLevel);
			}
		}

		public int GetFollowVehicleCamViewMode()
		{
			unsafe {
				if (fn__getFollowVehicleCamViewMode == null) fn__getFollowVehicleCamViewMode = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getFollowVehicleCamViewMode");
				var result = fn__getFollowVehicleCamViewMode();
				return result;
			}
		}

		public void SetFollowVehicleCamViewMode(int _viewMode)
		{
			unsafe {
				if (fn__setFollowVehicleCamViewMode == null) fn__setFollowVehicleCamViewMode = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setFollowVehicleCamViewMode");
				fn__setFollowVehicleCamViewMode(_viewMode);
			}
		}

		public int GetCamViewModeForContext(int _context)
		{
			unsafe {
				if (fn__getCamViewModeForContext == null) fn__getCamViewModeForContext = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getCamViewModeForContext");
				var result = fn__getCamViewModeForContext(_context);
				return result;
			}
		}

		public void SetCamViewModeForContext(int _context, int _viewMode)
		{
			unsafe {
				if (fn__setCamViewModeForContext == null) fn__setCamViewModeForContext = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setCamViewModeForContext");
				fn__setCamViewModeForContext(_context, _viewMode);
			}
		}

		public int GetCamActiveViewModeContext()
		{
			unsafe {
				if (fn__getCamActiveViewModeContext == null) fn__getCamActiveViewModeContext = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCamActiveViewModeContext");
				var result = fn__getCamActiveViewModeContext();
				return result;
			}
		}

		public void UseStuntCameraThisFrame()
		{
			unsafe {
				if (fn__useStuntCameraThisFrame == null) fn__useStuntCameraThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_useStuntCameraThisFrame");
				fn__useStuntCameraThisFrame();
			}
		}

		public void SetGameplayCamHash(string _camName)
		{
			unsafe {
				if (fn__setGameplayCamHash == null) fn__setGameplayCamHash = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamHash");
				var ptr_camName = MemoryUtils.StringToHGlobalUtf8(_camName);
				fn__setGameplayCamHash(ptr_camName);
				Marshal.FreeHGlobal(ptr_camName);
			}
		}

		public void _0x0AA27680A0BD43FA()
		{
			unsafe {
				if (fn__0x0AA27680A0BD43FA == null) fn__0x0AA27680A0BD43FA = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x0AA27680A0BD43FA");
				fn__0x0AA27680A0BD43FA();
			}
		}

		public void SetFollowTurretSeatCam(int _seatIndex)
		{
			unsafe {
				if (fn__setFollowTurretSeatCam == null) fn__setFollowTurretSeatCam = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setFollowTurretSeatCam");
				fn__setFollowTurretSeatCam(_seatIndex);
			}
		}

		public bool IsAimCamActive()
		{
			unsafe {
				if (fn__isAimCamActive == null) fn__isAimCamActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isAimCamActive");
				var result = fn__isAimCamActive();
				return result;
			}
		}

		public bool IsAimCamThirdPersonActive()
		{
			unsafe {
				if (fn__isAimCamThirdPersonActive == null) fn__isAimCamThirdPersonActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isAimCamThirdPersonActive");
				var result = fn__isAimCamThirdPersonActive();
				return result;
			}
		}

		public bool IsFirstPersonAimCamActive()
		{
			unsafe {
				if (fn__isFirstPersonAimCamActive == null) fn__isFirstPersonAimCamActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isFirstPersonAimCamActive");
				var result = fn__isFirstPersonAimCamActive();
				return result;
			}
		}

		public void DisableAimCamThisUpdate()
		{
			unsafe {
				if (fn__disableAimCamThisUpdate == null) fn__disableAimCamThisUpdate = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_disableAimCamThisUpdate");
				fn__disableAimCamThisUpdate();
			}
		}

		public float GetFirstPersonAimCamZoomFactor()
		{
			unsafe {
				if (fn__getFirstPersonAimCamZoomFactor == null) fn__getFirstPersonAimCamZoomFactor = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getFirstPersonAimCamZoomFactor");
				var result = fn__getFirstPersonAimCamZoomFactor();
				return result;
			}
		}

		public void SetFirstPersonAimCamZoomFactor(float _zoomFactor)
		{
			unsafe {
				if (fn__setFirstPersonAimCamZoomFactor == null) fn__setFirstPersonAimCamZoomFactor = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setFirstPersonAimCamZoomFactor");
				fn__setFirstPersonAimCamZoomFactor(_zoomFactor);
			}
		}

		public void _0xCED08CBE8EBB97C7(float _p0, float _p1)
		{
			unsafe {
				if (fn__0xCED08CBE8EBB97C7 == null) fn__0xCED08CBE8EBB97C7 = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native__0xCED08CBE8EBB97C7");
				fn__0xCED08CBE8EBB97C7(_p0, _p1);
			}
		}

		public void _0x2F7F2B26DD3F18EE(float _p0, float _p1)
		{
			unsafe {
				if (fn__0x2F7F2B26DD3F18EE == null) fn__0x2F7F2B26DD3F18EE = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native__0x2F7F2B26DD3F18EE");
				fn__0x2F7F2B26DD3F18EE(_p0, _p1);
			}
		}

		public void SetFirstPersonCamPitchRange(float _p0, float _p1)
		{
			unsafe {
				if (fn__setFirstPersonCamPitchRange == null) fn__setFirstPersonCamPitchRange = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_setFirstPersonCamPitchRange");
				fn__setFirstPersonCamPitchRange(_p0, _p1);
			}
		}

		public void SetFirstPersonAimCamNearClipThisUpdate(float _p0)
		{
			unsafe {
				if (fn__setFirstPersonAimCamNearClipThisUpdate == null) fn__setFirstPersonAimCamNearClipThisUpdate = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setFirstPersonAimCamNearClipThisUpdate");
				fn__setFirstPersonAimCamNearClipThisUpdate(_p0);
			}
		}

		public void SetThirdPersonAimCamNearClipThisUpdate(float _p0)
		{
			unsafe {
				if (fn__setThirdPersonAimCamNearClipThisUpdate == null) fn__setThirdPersonAimCamNearClipThisUpdate = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setThirdPersonAimCamNearClipThisUpdate");
				fn__setThirdPersonAimCamNearClipThisUpdate(_p0);
			}
		}

		public void _0x4008EDF7D6E48175(bool _p0)
		{
			unsafe {
				if (fn__0x4008EDF7D6E48175 == null) fn__0x4008EDF7D6E48175 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x4008EDF7D6E48175");
				fn__0x4008EDF7D6E48175(_p0);
			}
		}

		public void _0x380B4968D1E09E55()
		{
			unsafe {
				if (fn__0x380B4968D1E09E55 == null) fn__0x380B4968D1E09E55 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x380B4968D1E09E55");
				fn__0x380B4968D1E09E55();
			}
		}

		public Vector3 GetFinalRenderedCamCoord()
		{
			unsafe {
				if (fn__getFinalRenderedCamCoord == null) fn__getFinalRenderedCamCoord = (delegate* unmanaged[Cdecl]<Vector3>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedCamCoord");
				var result = fn__getFinalRenderedCamCoord();
				return result;
			}
		}

		public Vector3 GetFinalRenderedCamRot(int _rotationOrder)
		{
			unsafe {
				if (fn__getFinalRenderedCamRot == null) fn__getFinalRenderedCamRot = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedCamRot");
				var result = fn__getFinalRenderedCamRot(_rotationOrder);
				return result;
			}
		}

		public Vector3 GetFinalRenderedInWhenFriendlyRot(int _player, int _rotationOrder)
		{
			unsafe {
				if (fn__getFinalRenderedInWhenFriendlyRot == null) fn__getFinalRenderedInWhenFriendlyRot = (delegate* unmanaged[Cdecl]<int, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedInWhenFriendlyRot");
				var result = fn__getFinalRenderedInWhenFriendlyRot(_player, _rotationOrder);
				return result;
			}
		}

		public float GetFinalRenderedCamFov()
		{
			unsafe {
				if (fn__getFinalRenderedCamFov == null) fn__getFinalRenderedCamFov = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedCamFov");
				var result = fn__getFinalRenderedCamFov();
				return result;
			}
		}

		public float GetFinalRenderedInWhenFriendlyFov(int _player)
		{
			unsafe {
				if (fn__getFinalRenderedInWhenFriendlyFov == null) fn__getFinalRenderedInWhenFriendlyFov = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedInWhenFriendlyFov");
				var result = fn__getFinalRenderedInWhenFriendlyFov(_player);
				return result;
			}
		}

		public float GetFinalRenderedCamNearClip()
		{
			unsafe {
				if (fn__getFinalRenderedCamNearClip == null) fn__getFinalRenderedCamNearClip = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedCamNearClip");
				var result = fn__getFinalRenderedCamNearClip();
				return result;
			}
		}

		public float GetFinalRenderedCamFarClip()
		{
			unsafe {
				if (fn__getFinalRenderedCamFarClip == null) fn__getFinalRenderedCamFarClip = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedCamFarClip");
				var result = fn__getFinalRenderedCamFarClip();
				return result;
			}
		}

		public float GetFinalRenderedCamNearDof()
		{
			unsafe {
				if (fn__getFinalRenderedCamNearDof == null) fn__getFinalRenderedCamNearDof = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedCamNearDof");
				var result = fn__getFinalRenderedCamNearDof();
				return result;
			}
		}

		public float GetFinalRenderedCamFarDof()
		{
			unsafe {
				if (fn__getFinalRenderedCamFarDof == null) fn__getFinalRenderedCamFarDof = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedCamFarDof");
				var result = fn__getFinalRenderedCamFarDof();
				return result;
			}
		}

		public float GetFinalRenderedCamMotionBlurStrength()
		{
			unsafe {
				if (fn__getFinalRenderedCamMotionBlurStrength == null) fn__getFinalRenderedCamMotionBlurStrength = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getFinalRenderedCamMotionBlurStrength");
				var result = fn__getFinalRenderedCamMotionBlurStrength();
				return result;
			}
		}

		public void SetGameplayCoordHint(float _x, float _y, float _z, int _duration, int _blendOutDuration, int _blendInDuration, int _unk)
		{
			unsafe {
				if (fn__setGameplayCoordHint == null) fn__setGameplayCoordHint = (delegate* unmanaged[Cdecl]<float, float, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCoordHint");
				fn__setGameplayCoordHint(_x, _y, _z, _duration, _blendOutDuration, _blendInDuration, _unk);
			}
		}

		public void SetGameplayPedHint(int _p0, float _x1, float _y1, float _z1, bool _p4, int _p5, int _p6, int _p7)
		{
			unsafe {
				if (fn__setGameplayPedHint == null) fn__setGameplayPedHint = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setGameplayPedHint");
				fn__setGameplayPedHint(_p0, _x1, _y1, _z1, _p4, _p5, _p6, _p7);
			}
		}

		public void SetGameplayVehicleHint(int _vehicle, float _offsetX, float _offsetY, float _offsetZ, bool _p4, int _time, int _easeInTime, int _easeOutTime)
		{
			unsafe {
				if (fn__setGameplayVehicleHint == null) fn__setGameplayVehicleHint = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setGameplayVehicleHint");
				fn__setGameplayVehicleHint(_vehicle, _offsetX, _offsetY, _offsetZ, _p4, _time, _easeInTime, _easeOutTime);
			}
		}

		public void SetGameplayObjectHint(int _p0, float _p1, float _p2, float _p3, bool _p4, int _p5, int _p6, int _p7)
		{
			unsafe {
				if (fn__setGameplayObjectHint == null) fn__setGameplayObjectHint = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setGameplayObjectHint");
				fn__setGameplayObjectHint(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
			}
		}

		public void SetGameplayEntityHint(int _entity, float _xOffset, float _yOffset, float _zOffset, bool _p4, int _p5, int _p6, int _p7, int _p8)
		{
			unsafe {
				if (fn__setGameplayEntityHint == null) fn__setGameplayEntityHint = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setGameplayEntityHint");
				fn__setGameplayEntityHint(_entity, _xOffset, _yOffset, _zOffset, _p4, _p5, _p6, _p7, _p8);
			}
		}

		public bool IsGameplayHintActive()
		{
			unsafe {
				if (fn__isGameplayHintActive == null) fn__isGameplayHintActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isGameplayHintActive");
				var result = fn__isGameplayHintActive();
				return result;
			}
		}

		public void StopGameplayHint(bool _p0)
		{
			unsafe {
				if (fn__stopGameplayHint == null) fn__stopGameplayHint = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_stopGameplayHint");
				fn__stopGameplayHint(_p0);
			}
		}

		public void _0xCCD078C2665D2973(bool _p0)
		{
			unsafe {
				if (fn__0xCCD078C2665D2973 == null) fn__0xCCD078C2665D2973 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xCCD078C2665D2973");
				fn__0xCCD078C2665D2973(_p0);
			}
		}

		public void _0x247ACBC4ABBC9D1C(bool _p0)
		{
			unsafe {
				if (fn__0x247ACBC4ABBC9D1C == null) fn__0x247ACBC4ABBC9D1C = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x247ACBC4ABBC9D1C");
				fn__0x247ACBC4ABBC9D1C(_p0);
			}
		}

		public int _0xBF72910D0F26F025()
		{
			unsafe {
				if (fn__0xBF72910D0F26F025 == null) fn__0xBF72910D0F26F025 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xBF72910D0F26F025");
				var result = fn__0xBF72910D0F26F025();
				return result;
			}
		}

		public void SetGameplayHintFov(float _FOV)
		{
			unsafe {
				if (fn__setGameplayHintFov == null) fn__setGameplayHintFov = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayHintFov");
				fn__setGameplayHintFov(_FOV);
			}
		}

		public void SetGameplayHintFollowDistanceScalar(float _value)
		{
			unsafe {
				if (fn__setGameplayHintFollowDistanceScalar == null) fn__setGameplayHintFollowDistanceScalar = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayHintFollowDistanceScalar");
				fn__setGameplayHintFollowDistanceScalar(_value);
			}
		}

		public void SetGameplayHintBaseOrbitPitchOffset(float _value)
		{
			unsafe {
				if (fn__setGameplayHintBaseOrbitPitchOffset == null) fn__setGameplayHintBaseOrbitPitchOffset = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayHintBaseOrbitPitchOffset");
				fn__setGameplayHintBaseOrbitPitchOffset(_value);
			}
		}

		public void SetGameplayHintAnimOffsetx(float _xOffset)
		{
			unsafe {
				if (fn__setGameplayHintAnimOffsetx == null) fn__setGameplayHintAnimOffsetx = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayHintAnimOffsetx");
				fn__setGameplayHintAnimOffsetx(_xOffset);
			}
		}

		public void SetGameplayHintAnimOffsety(float _yOffset)
		{
			unsafe {
				if (fn__setGameplayHintAnimOffsety == null) fn__setGameplayHintAnimOffsety = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGameplayHintAnimOffsety");
				fn__setGameplayHintAnimOffsety(_yOffset);
			}
		}

		public void SetGameplayHintAnimCloseup(bool _toggle)
		{
			unsafe {
				if (fn__setGameplayHintAnimCloseup == null) fn__setGameplayHintAnimCloseup = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setGameplayHintAnimCloseup");
				fn__setGameplayHintAnimCloseup(_toggle);
			}
		}

		public void SetCinematicButtonActive(bool _p0)
		{
			unsafe {
				if (fn__setCinematicButtonActive == null) fn__setCinematicButtonActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setCinematicButtonActive");
				fn__setCinematicButtonActive(_p0);
			}
		}

		public bool IsCinematicCamRendering()
		{
			unsafe {
				if (fn__isCinematicCamRendering == null) fn__isCinematicCamRendering = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isCinematicCamRendering");
				var result = fn__isCinematicCamRendering();
				return result;
			}
		}

		public void ShakeCinematicCam(string _p0, float _p1)
		{
			unsafe {
				if (fn__shakeCinematicCam == null) fn__shakeCinematicCam = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_shakeCinematicCam");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__shakeCinematicCam(ptr_p0, _p1);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public bool IsCinematicCamShaking()
		{
			unsafe {
				if (fn__isCinematicCamShaking == null) fn__isCinematicCamShaking = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isCinematicCamShaking");
				var result = fn__isCinematicCamShaking();
				return result;
			}
		}

		public void SetCinematicCamShakeAmplitude(float _p0)
		{
			unsafe {
				if (fn__setCinematicCamShakeAmplitude == null) fn__setCinematicCamShakeAmplitude = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setCinematicCamShakeAmplitude");
				fn__setCinematicCamShakeAmplitude(_p0);
			}
		}

		public void StopCinematicCamShaking(bool _p0)
		{
			unsafe {
				if (fn__stopCinematicCamShaking == null) fn__stopCinematicCamShaking = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_stopCinematicCamShaking");
				fn__stopCinematicCamShaking(_p0);
			}
		}

		public void DisableVehicleFirstPersonCamThisFrame()
		{
			unsafe {
				if (fn__disableVehicleFirstPersonCamThisFrame == null) fn__disableVehicleFirstPersonCamThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_disableVehicleFirstPersonCamThisFrame");
				fn__disableVehicleFirstPersonCamThisFrame();
			}
		}

		public void _0x62ECFCFDEE7885D6()
		{
			unsafe {
				if (fn__0x62ECFCFDEE7885D6 == null) fn__0x62ECFCFDEE7885D6 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x62ECFCFDEE7885D6");
				fn__0x62ECFCFDEE7885D6();
			}
		}

		public void InvalidateVehicleIdleCam()
		{
			unsafe {
				if (fn__invalidateVehicleIdleCam == null) fn__invalidateVehicleIdleCam = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_invalidateVehicleIdleCam");
				fn__invalidateVehicleIdleCam();
			}
		}

		public void InvalidateIdleCam()
		{
			unsafe {
				if (fn__invalidateIdleCam == null) fn__invalidateIdleCam = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_invalidateIdleCam");
				fn__invalidateIdleCam();
			}
		}

		public bool IsCinematicIdleCamRendering()
		{
			unsafe {
				if (fn__isCinematicIdleCamRendering == null) fn__isCinematicIdleCamRendering = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isCinematicIdleCamRendering");
				var result = fn__isCinematicIdleCamRendering();
				return result;
			}
		}

		public bool IsInVehicleCamDisabled()
		{
			unsafe {
				if (fn__isInVehicleCamDisabled == null) fn__isInVehicleCamDisabled = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isInVehicleCamDisabled");
				var result = fn__isInVehicleCamDisabled();
				return result;
			}
		}

		public void CreateCinematicShot(int _p0, int _p1, int _p2, int _entity)
		{
			unsafe {
				if (fn__createCinematicShot == null) fn__createCinematicShot = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_createCinematicShot");
				fn__createCinematicShot(_p0, _p1, _p2, _entity);
			}
		}

		public bool IsCinematicShotActive(int _p0)
		{
			unsafe {
				if (fn__isCinematicShotActive == null) fn__isCinematicShotActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isCinematicShotActive");
				var result = fn__isCinematicShotActive(_p0);
				return result;
			}
		}

		public void StopCinematicShot(int _p0)
		{
			unsafe {
				if (fn__stopCinematicShot == null) fn__stopCinematicShot = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopCinematicShot");
				fn__stopCinematicShot(_p0);
			}
		}

		public void ForceCinematicRenderingThisUpdate(bool _p0)
		{
			unsafe {
				if (fn__forceCinematicRenderingThisUpdate == null) fn__forceCinematicRenderingThisUpdate = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_forceCinematicRenderingThisUpdate");
				fn__forceCinematicRenderingThisUpdate(_p0);
			}
		}

		public void _0xDC9DA9E8789F5246()
		{
			unsafe {
				if (fn__0xDC9DA9E8789F5246 == null) fn__0xDC9DA9E8789F5246 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xDC9DA9E8789F5246");
				fn__0xDC9DA9E8789F5246();
			}
		}

		public void SetCinematicModeActive(bool _toggle)
		{
			unsafe {
				if (fn__setCinematicModeActive == null) fn__setCinematicModeActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setCinematicModeActive");
				fn__setCinematicModeActive(_toggle);
			}
		}

		public int _0x1F2300CB7FA7B7F6()
		{
			unsafe {
				if (fn__0x1F2300CB7FA7B7F6 == null) fn__0x1F2300CB7FA7B7F6 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x1F2300CB7FA7B7F6");
				var result = fn__0x1F2300CB7FA7B7F6();
				return result;
			}
		}

		public int _0x17FCA7199A530203()
		{
			unsafe {
				if (fn__0x17FCA7199A530203 == null) fn__0x17FCA7199A530203 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x17FCA7199A530203");
				var result = fn__0x17FCA7199A530203();
				return result;
			}
		}

		public int _0xD7360051C885628B()
		{
			unsafe {
				if (fn__0xD7360051C885628B == null) fn__0xD7360051C885628B = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xD7360051C885628B");
				var result = fn__0xD7360051C885628B();
				return result;
			}
		}

		public bool IsCinematicCamActive()
		{
			unsafe {
				if (fn__isCinematicCamActive == null) fn__isCinematicCamActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isCinematicCamActive");
				var result = fn__isCinematicCamActive();
				return result;
			}
		}

		public void _0x7B8A361C1813FBEF()
		{
			unsafe {
				if (fn__0x7B8A361C1813FBEF == null) fn__0x7B8A361C1813FBEF = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x7B8A361C1813FBEF");
				fn__0x7B8A361C1813FBEF();
			}
		}

		public void StopCutsceneCamShaking()
		{
			unsafe {
				if (fn__stopCutsceneCamShaking == null) fn__stopCutsceneCamShaking = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopCutsceneCamShaking");
				fn__stopCutsceneCamShaking();
			}
		}

		public void _0x324C5AA411DA7737(int _p0)
		{
			unsafe {
				if (fn__0x324C5AA411DA7737 == null) fn__0x324C5AA411DA7737 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x324C5AA411DA7737");
				fn__0x324C5AA411DA7737(_p0);
			}
		}

		public void _0x12DED8CA53D47EA5(float _p0)
		{
			unsafe {
				if (fn__0x12DED8CA53D47EA5 == null) fn__0x12DED8CA53D47EA5 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x12DED8CA53D47EA5");
				fn__0x12DED8CA53D47EA5(_p0);
			}
		}

		public int GetFocusPedOnScreen(float _p0, int _p1, float _p2, float _p3, float _p4, float _p5, float _p6, int _p7, int _p8)
		{
			unsafe {
				if (fn__getFocusPedOnScreen == null) fn__getFocusPedOnScreen = (delegate* unmanaged[Cdecl]<float, int, float, float, float, float, float, int, int, int>) NativeLibrary.GetExport(handle, "Native_getFocusPedOnScreen");
				var result = fn__getFocusPedOnScreen(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
				return result;
			}
		}

		public void _0x5A43C76F7FC7BA5F()
		{
			unsafe {
				if (fn__0x5A43C76F7FC7BA5F == null) fn__0x5A43C76F7FC7BA5F = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x5A43C76F7FC7BA5F");
				fn__0x5A43C76F7FC7BA5F();
			}
		}

		public void SetCamEffect(int _p0)
		{
			unsafe {
				if (fn__setCamEffect == null) fn__setCamEffect = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setCamEffect");
				fn__setCamEffect(_p0);
			}
		}

		public void _0x5C41E6BABC9E2112(int _p0)
		{
			unsafe {
				if (fn__0x5C41E6BABC9E2112 == null) fn__0x5C41E6BABC9E2112 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x5C41E6BABC9E2112");
				fn__0x5C41E6BABC9E2112(_p0);
			}
		}

		public void SetGameplayCamVehicleCamera(string _vehicleName)
		{
			unsafe {
				if (fn__setGameplayCamVehicleCamera == null) fn__setGameplayCamVehicleCamera = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamVehicleCamera");
				var ptr_vehicleName = MemoryUtils.StringToHGlobalUtf8(_vehicleName);
				fn__setGameplayCamVehicleCamera(ptr_vehicleName);
				Marshal.FreeHGlobal(ptr_vehicleName);
			}
		}

		public void SetGameplayCamVehicleCameraName(int _vehicleModel)
		{
			unsafe {
				if (fn__setGameplayCamVehicleCameraName == null) fn__setGameplayCamVehicleCameraName = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setGameplayCamVehicleCameraName");
				fn__setGameplayCamVehicleCameraName(_vehicleModel);
			}
		}

		public int _0xEAF0FA793D05C592()
		{
			unsafe {
				if (fn__0xEAF0FA793D05C592 == null) fn__0xEAF0FA793D05C592 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xEAF0FA793D05C592");
				var result = fn__0xEAF0FA793D05C592();
				return result;
			}
		}

		public void _0x62374889A4D59F72()
		{
			unsafe {
				if (fn__0x62374889A4D59F72 == null) fn__0x62374889A4D59F72 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x62374889A4D59F72");
				fn__0x62374889A4D59F72();
			}
		}

		public float ReplayFreeCamGetMaxRange()
		{
			unsafe {
				if (fn__replayFreeCamGetMaxRange == null) fn__replayFreeCamGetMaxRange = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_replayFreeCamGetMaxRange");
				var result = fn__replayFreeCamGetMaxRange();
				return result;
			}
		}

		public void SetClockTime(int _hour, int _minute, int _second)
		{
			unsafe {
				if (fn__setClockTime == null) fn__setClockTime = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setClockTime");
				fn__setClockTime(_hour, _minute, _second);
			}
		}

		public void PauseClock(bool _toggle)
		{
			unsafe {
				if (fn__pauseClock == null) fn__pauseClock = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_pauseClock");
				fn__pauseClock(_toggle);
			}
		}

		public void AdvanceClockTimeTo(int _hour, int _minute, int _second)
		{
			unsafe {
				if (fn__advanceClockTimeTo == null) fn__advanceClockTimeTo = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_advanceClockTimeTo");
				fn__advanceClockTimeTo(_hour, _minute, _second);
			}
		}

		public void AddToClockTime(int _hours, int _minutes, int _seconds)
		{
			unsafe {
				if (fn__addToClockTime == null) fn__addToClockTime = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_addToClockTime");
				fn__addToClockTime(_hours, _minutes, _seconds);
			}
		}

		public int GetClockHours()
		{
			unsafe {
				if (fn__getClockHours == null) fn__getClockHours = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getClockHours");
				var result = fn__getClockHours();
				return result;
			}
		}

		public int GetClockMinutes()
		{
			unsafe {
				if (fn__getClockMinutes == null) fn__getClockMinutes = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getClockMinutes");
				var result = fn__getClockMinutes();
				return result;
			}
		}

		public int GetClockSeconds()
		{
			unsafe {
				if (fn__getClockSeconds == null) fn__getClockSeconds = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getClockSeconds");
				var result = fn__getClockSeconds();
				return result;
			}
		}

		public void SetClockDate(int _day, int _month, int _year)
		{
			unsafe {
				if (fn__setClockDate == null) fn__setClockDate = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setClockDate");
				fn__setClockDate(_day, _month, _year);
			}
		}

		public int GetClockDayOfWeek()
		{
			unsafe {
				if (fn__getClockDayOfWeek == null) fn__getClockDayOfWeek = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getClockDayOfWeek");
				var result = fn__getClockDayOfWeek();
				return result;
			}
		}

		public int GetClockDayOfMonth()
		{
			unsafe {
				if (fn__getClockDayOfMonth == null) fn__getClockDayOfMonth = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getClockDayOfMonth");
				var result = fn__getClockDayOfMonth();
				return result;
			}
		}

		public int GetClockMonth()
		{
			unsafe {
				if (fn__getClockMonth == null) fn__getClockMonth = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getClockMonth");
				var result = fn__getClockMonth();
				return result;
			}
		}

		public int GetClockYear()
		{
			unsafe {
				if (fn__getClockYear == null) fn__getClockYear = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getClockYear");
				var result = fn__getClockYear();
				return result;
			}
		}

		public int GetMillisecondsPerGameMinute()
		{
			unsafe {
				if (fn__getMillisecondsPerGameMinute == null) fn__getMillisecondsPerGameMinute = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMillisecondsPerGameMinute");
				var result = fn__getMillisecondsPerGameMinute();
				return result;
			}
		}

		public void GetPosixTime(ref int _year, ref int _month, ref int _day, ref int _hour, ref int _minute, ref int _second)
		{
			unsafe {
				if (fn__getPosixTime == null) fn__getPosixTime = (delegate* unmanaged[Cdecl]<int*, int*, int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getPosixTime");
				var ref_year = _year;
				var ref_month = _month;
				var ref_day = _day;
				var ref_hour = _hour;
				var ref_minute = _minute;
				var ref_second = _second;
				fn__getPosixTime(&ref_year, &ref_month, &ref_day, &ref_hour, &ref_minute, &ref_second);
				_year = ref_year;
				_month = ref_month;
				_day = ref_day;
				_hour = ref_hour;
				_minute = ref_minute;
				_second = ref_second;
			}
		}

		public void GetUtcTime(ref int _year, ref int _month, ref int _day, ref int _hour, ref int _minute, ref int _second)
		{
			unsafe {
				if (fn__getUtcTime == null) fn__getUtcTime = (delegate* unmanaged[Cdecl]<int*, int*, int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getUtcTime");
				var ref_year = _year;
				var ref_month = _month;
				var ref_day = _day;
				var ref_hour = _hour;
				var ref_minute = _minute;
				var ref_second = _second;
				fn__getUtcTime(&ref_year, &ref_month, &ref_day, &ref_hour, &ref_minute, &ref_second);
				_year = ref_year;
				_month = ref_month;
				_day = ref_day;
				_hour = ref_hour;
				_minute = ref_minute;
				_second = ref_second;
			}
		}

		public void GetLocalTime(ref int _year, ref int _month, ref int _day, ref int _hour, ref int _minute, ref int _second)
		{
			unsafe {
				if (fn__getLocalTime == null) fn__getLocalTime = (delegate* unmanaged[Cdecl]<int*, int*, int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getLocalTime");
				var ref_year = _year;
				var ref_month = _month;
				var ref_day = _day;
				var ref_hour = _hour;
				var ref_minute = _minute;
				var ref_second = _second;
				fn__getLocalTime(&ref_year, &ref_month, &ref_day, &ref_hour, &ref_minute, &ref_second);
				_year = ref_year;
				_month = ref_month;
				_day = ref_day;
				_hour = ref_hour;
				_minute = ref_minute;
				_second = ref_second;
			}
		}

		public void RequestCutscene(string _cutsceneName, int _flags)
		{
			unsafe {
				if (fn__requestCutscene == null) fn__requestCutscene = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_requestCutscene");
				var ptr_cutsceneName = MemoryUtils.StringToHGlobalUtf8(_cutsceneName);
				fn__requestCutscene(ptr_cutsceneName, _flags);
				Marshal.FreeHGlobal(ptr_cutsceneName);
			}
		}

		public void RequestCutsceneWithPlaybackList(string _cutsceneName, int _playbackFlags, int _flags)
		{
			unsafe {
				if (fn__requestCutsceneWithPlaybackList == null) fn__requestCutsceneWithPlaybackList = (delegate* unmanaged[Cdecl]<nint, int, int, void>) NativeLibrary.GetExport(handle, "Native_requestCutsceneWithPlaybackList");
				var ptr_cutsceneName = MemoryUtils.StringToHGlobalUtf8(_cutsceneName);
				fn__requestCutsceneWithPlaybackList(ptr_cutsceneName, _playbackFlags, _flags);
				Marshal.FreeHGlobal(ptr_cutsceneName);
			}
		}

		public void RemoveCutscene()
		{
			unsafe {
				if (fn__removeCutscene == null) fn__removeCutscene = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeCutscene");
				fn__removeCutscene();
			}
		}

		public bool HasCutsceneLoaded()
		{
			unsafe {
				if (fn__hasCutsceneLoaded == null) fn__hasCutsceneLoaded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasCutsceneLoaded");
				var result = fn__hasCutsceneLoaded();
				return result;
			}
		}

		public bool HasThisCutsceneLoaded(string _cutsceneName)
		{
			unsafe {
				if (fn__hasThisCutsceneLoaded == null) fn__hasThisCutsceneLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasThisCutsceneLoaded");
				var ptr_cutsceneName = MemoryUtils.StringToHGlobalUtf8(_cutsceneName);
				var result = fn__hasThisCutsceneLoaded(ptr_cutsceneName);
				Marshal.FreeHGlobal(ptr_cutsceneName);
				return result;
			}
		}

		public void _0x8D9DF6ECA8768583(int _threadId)
		{
			unsafe {
				if (fn__0x8D9DF6ECA8768583 == null) fn__0x8D9DF6ECA8768583 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x8D9DF6ECA8768583");
				fn__0x8D9DF6ECA8768583(_threadId);
			}
		}

		public bool CanRequestAssetsForCutsceneEntity()
		{
			unsafe {
				if (fn__canRequestAssetsForCutsceneEntity == null) fn__canRequestAssetsForCutsceneEntity = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_canRequestAssetsForCutsceneEntity");
				var result = fn__canRequestAssetsForCutsceneEntity();
				return result;
			}
		}

		public bool IsCutscenePlaybackFlagSet(int _flag)
		{
			unsafe {
				if (fn__isCutscenePlaybackFlagSet == null) fn__isCutscenePlaybackFlagSet = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isCutscenePlaybackFlagSet");
				var result = fn__isCutscenePlaybackFlagSet(_flag);
				return result;
			}
		}

		public void SetCutsceneEntityStreamingFlags(string _cutsceneEntName, int _p1, int _p2)
		{
			unsafe {
				if (fn__setCutsceneEntityStreamingFlags == null) fn__setCutsceneEntityStreamingFlags = (delegate* unmanaged[Cdecl]<nint, int, int, void>) NativeLibrary.GetExport(handle, "Native_setCutsceneEntityStreamingFlags");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				fn__setCutsceneEntityStreamingFlags(ptr_cutsceneEntName, _p1, _p2);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
			}
		}

		public void RequestCutFile(string _cutsceneName)
		{
			unsafe {
				if (fn__requestCutFile == null) fn__requestCutFile = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestCutFile");
				var ptr_cutsceneName = MemoryUtils.StringToHGlobalUtf8(_cutsceneName);
				fn__requestCutFile(ptr_cutsceneName);
				Marshal.FreeHGlobal(ptr_cutsceneName);
			}
		}

		public bool HasCutFileLoaded(string _cutsceneName)
		{
			unsafe {
				if (fn__hasCutFileLoaded == null) fn__hasCutFileLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasCutFileLoaded");
				var ptr_cutsceneName = MemoryUtils.StringToHGlobalUtf8(_cutsceneName);
				var result = fn__hasCutFileLoaded(ptr_cutsceneName);
				Marshal.FreeHGlobal(ptr_cutsceneName);
				return result;
			}
		}

		public void RemoveCutFile(string _cutsceneName)
		{
			unsafe {
				if (fn__removeCutFile == null) fn__removeCutFile = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeCutFile");
				var ptr_cutsceneName = MemoryUtils.StringToHGlobalUtf8(_cutsceneName);
				fn__removeCutFile(ptr_cutsceneName);
				Marshal.FreeHGlobal(ptr_cutsceneName);
			}
		}

		public int GetCutFileNumSections(string _cutsceneName)
		{
			unsafe {
				if (fn__getCutFileNumSections == null) fn__getCutFileNumSections = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_getCutFileNumSections");
				var ptr_cutsceneName = MemoryUtils.StringToHGlobalUtf8(_cutsceneName);
				var result = fn__getCutFileNumSections(ptr_cutsceneName);
				Marshal.FreeHGlobal(ptr_cutsceneName);
				return result;
			}
		}

		public void StartCutscene(int _flags)
		{
			unsafe {
				if (fn__startCutscene == null) fn__startCutscene = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_startCutscene");
				fn__startCutscene(_flags);
			}
		}

		public void StartCutsceneAtCoords(float _x, float _y, float _z, int _flags)
		{
			unsafe {
				if (fn__startCutsceneAtCoords == null) fn__startCutsceneAtCoords = (delegate* unmanaged[Cdecl]<float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_startCutsceneAtCoords");
				fn__startCutsceneAtCoords(_x, _y, _z, _flags);
			}
		}

		public void StopCutscene(bool _p0)
		{
			unsafe {
				if (fn__stopCutscene == null) fn__stopCutscene = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_stopCutscene");
				fn__stopCutscene(_p0);
			}
		}

		public void StopCutsceneImmediately()
		{
			unsafe {
				if (fn__stopCutsceneImmediately == null) fn__stopCutsceneImmediately = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopCutsceneImmediately");
				fn__stopCutsceneImmediately();
			}
		}

		public void SetCutsceneOrigin(float _x, float _y, float _z, float _p3, int _p4)
		{
			unsafe {
				if (fn__setCutsceneOrigin == null) fn__setCutsceneOrigin = (delegate* unmanaged[Cdecl]<float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setCutsceneOrigin");
				fn__setCutsceneOrigin(_x, _y, _z, _p3, _p4);
			}
		}

		public void _0x011883F41211432A(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _p6)
		{
			unsafe {
				if (fn__0x011883F41211432A == null) fn__0x011883F41211432A = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native__0x011883F41211432A");
				fn__0x011883F41211432A(_x1, _y1, _z1, _x2, _y2, _z2, _p6);
			}
		}

		public int GetCutsceneTime()
		{
			unsafe {
				if (fn__getCutsceneTime == null) fn__getCutsceneTime = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCutsceneTime");
				var result = fn__getCutsceneTime();
				return result;
			}
		}

		public int GetCutsceneTotalDuration()
		{
			unsafe {
				if (fn__getCutsceneTotalDuration == null) fn__getCutsceneTotalDuration = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCutsceneTotalDuration");
				var result = fn__getCutsceneTotalDuration();
				return result;
			}
		}

		public int _0x971D7B15BCDBEF99()
		{
			unsafe {
				if (fn__0x971D7B15BCDBEF99 == null) fn__0x971D7B15BCDBEF99 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x971D7B15BCDBEF99");
				var result = fn__0x971D7B15BCDBEF99();
				return result;
			}
		}

		public bool WasCutsceneSkipped()
		{
			unsafe {
				if (fn__wasCutsceneSkipped == null) fn__wasCutsceneSkipped = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_wasCutsceneSkipped");
				var result = fn__wasCutsceneSkipped();
				return result;
			}
		}

		public bool HasCutsceneFinished()
		{
			unsafe {
				if (fn__hasCutsceneFinished == null) fn__hasCutsceneFinished = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasCutsceneFinished");
				var result = fn__hasCutsceneFinished();
				return result;
			}
		}

		public bool IsCutsceneActive()
		{
			unsafe {
				if (fn__isCutsceneActive == null) fn__isCutsceneActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isCutsceneActive");
				var result = fn__isCutsceneActive();
				return result;
			}
		}

		public bool IsCutscenePlaying()
		{
			unsafe {
				if (fn__isCutscenePlaying == null) fn__isCutscenePlaying = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isCutscenePlaying");
				var result = fn__isCutscenePlaying();
				return result;
			}
		}

		public int GetCutsceneSectionPlaying()
		{
			unsafe {
				if (fn__getCutsceneSectionPlaying == null) fn__getCutsceneSectionPlaying = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCutsceneSectionPlaying");
				var result = fn__getCutsceneSectionPlaying();
				return result;
			}
		}

		public int GetEntityIndexOfCutsceneEntity(string _cutsceneEntName, int _modelHash)
		{
			unsafe {
				if (fn__getEntityIndexOfCutsceneEntity == null) fn__getEntityIndexOfCutsceneEntity = (delegate* unmanaged[Cdecl]<nint, int, int>) NativeLibrary.GetExport(handle, "Native_getEntityIndexOfCutsceneEntity");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				var result = fn__getEntityIndexOfCutsceneEntity(ptr_cutsceneEntName, _modelHash);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
				return result;
			}
		}

		public int _0x583DF8E3D4AFBD98()
		{
			unsafe {
				if (fn__0x583DF8E3D4AFBD98 == null) fn__0x583DF8E3D4AFBD98 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x583DF8E3D4AFBD98");
				var result = fn__0x583DF8E3D4AFBD98();
				return result;
			}
		}

		public bool _0x4CEBC1ED31E8925E(string _cutsceneName)
		{
			unsafe {
				if (fn__0x4CEBC1ED31E8925E == null) fn__0x4CEBC1ED31E8925E = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native__0x4CEBC1ED31E8925E");
				var ptr_cutsceneName = MemoryUtils.StringToHGlobalUtf8(_cutsceneName);
				var result = fn__0x4CEBC1ED31E8925E(ptr_cutsceneName);
				Marshal.FreeHGlobal(ptr_cutsceneName);
				return result;
			}
		}

		public int _0x4FCD976DA686580C(int _p0)
		{
			unsafe {
				if (fn__0x4FCD976DA686580C == null) fn__0x4FCD976DA686580C = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x4FCD976DA686580C");
				var result = fn__0x4FCD976DA686580C(_p0);
				return result;
			}
		}

		public void RegisterEntityForCutscene(int _cutscenePed, string _cutsceneEntName, int _p2, int _modelHash, int _p4)
		{
			unsafe {
				if (fn__registerEntityForCutscene == null) fn__registerEntityForCutscene = (delegate* unmanaged[Cdecl]<int, nint, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_registerEntityForCutscene");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				fn__registerEntityForCutscene(_cutscenePed, ptr_cutsceneEntName, _p2, _modelHash, _p4);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
			}
		}

		public int GetEntityIndexOfRegisteredEntity(string _cutsceneEntName, int _modelHash)
		{
			unsafe {
				if (fn__getEntityIndexOfRegisteredEntity == null) fn__getEntityIndexOfRegisteredEntity = (delegate* unmanaged[Cdecl]<nint, int, int>) NativeLibrary.GetExport(handle, "Native_getEntityIndexOfRegisteredEntity");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				var result = fn__getEntityIndexOfRegisteredEntity(ptr_cutsceneEntName, _modelHash);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
				return result;
			}
		}

		public void _0x7F96F23FA9B73327(int _modelHash)
		{
			unsafe {
				if (fn__0x7F96F23FA9B73327 == null) fn__0x7F96F23FA9B73327 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x7F96F23FA9B73327");
				fn__0x7F96F23FA9B73327(_modelHash);
			}
		}

		public void SetCutsceneTriggerArea(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5)
		{
			unsafe {
				if (fn__setCutsceneTriggerArea == null) fn__setCutsceneTriggerArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setCutsceneTriggerArea");
				fn__setCutsceneTriggerArea(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public bool CanSetEnterStateForRegisteredEntity(string _cutsceneEntName, int _modelHash)
		{
			unsafe {
				if (fn__canSetEnterStateForRegisteredEntity == null) fn__canSetEnterStateForRegisteredEntity = (delegate* unmanaged[Cdecl]<nint, int, bool>) NativeLibrary.GetExport(handle, "Native_canSetEnterStateForRegisteredEntity");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				var result = fn__canSetEnterStateForRegisteredEntity(ptr_cutsceneEntName, _modelHash);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
				return result;
			}
		}

		public bool CanSetExitStateForRegisteredEntity(string _cutsceneEntName, int _modelHash)
		{
			unsafe {
				if (fn__canSetExitStateForRegisteredEntity == null) fn__canSetExitStateForRegisteredEntity = (delegate* unmanaged[Cdecl]<nint, int, bool>) NativeLibrary.GetExport(handle, "Native_canSetExitStateForRegisteredEntity");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				var result = fn__canSetExitStateForRegisteredEntity(ptr_cutsceneEntName, _modelHash);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
				return result;
			}
		}

		public bool CanSetExitStateForCamera(bool _p0)
		{
			unsafe {
				if (fn__canSetExitStateForCamera == null) fn__canSetExitStateForCamera = (delegate* unmanaged[Cdecl]<bool, bool>) NativeLibrary.GetExport(handle, "Native_canSetExitStateForCamera");
				var result = fn__canSetExitStateForCamera(_p0);
				return result;
			}
		}

		public void _0xC61B86C9F61EB404(bool _toggle)
		{
			unsafe {
				if (fn__0xC61B86C9F61EB404 == null) fn__0xC61B86C9F61EB404 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xC61B86C9F61EB404");
				fn__0xC61B86C9F61EB404(_toggle);
			}
		}

		public void SetCutsceneFadeValues(bool _p0, bool _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__setCutsceneFadeValues == null) fn__setCutsceneFadeValues = (delegate* unmanaged[Cdecl]<bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setCutsceneFadeValues");
				fn__setCutsceneFadeValues(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x20746F7B1032A3C7(bool _p0, bool _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__0x20746F7B1032A3C7 == null) fn__0x20746F7B1032A3C7 = (delegate* unmanaged[Cdecl]<bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native__0x20746F7B1032A3C7");
				fn__0x20746F7B1032A3C7(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x06EE9048FD080382(bool _p0)
		{
			unsafe {
				if (fn__0x06EE9048FD080382 == null) fn__0x06EE9048FD080382 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x06EE9048FD080382");
				fn__0x06EE9048FD080382(_p0);
			}
		}

		public int _0xA0FE76168A189DDB()
		{
			unsafe {
				if (fn__0xA0FE76168A189DDB == null) fn__0xA0FE76168A189DDB = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xA0FE76168A189DDB");
				var result = fn__0xA0FE76168A189DDB();
				return result;
			}
		}

		public void _0x2F137B508DE238F2(bool _p0)
		{
			unsafe {
				if (fn__0x2F137B508DE238F2 == null) fn__0x2F137B508DE238F2 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x2F137B508DE238F2");
				fn__0x2F137B508DE238F2(_p0);
			}
		}

		public void _0xE36A98D8AB3D3C66(bool _p0)
		{
			unsafe {
				if (fn__0xE36A98D8AB3D3C66 == null) fn__0xE36A98D8AB3D3C66 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xE36A98D8AB3D3C66");
				fn__0xE36A98D8AB3D3C66(_p0);
			}
		}

		public int _0x5EDEF0CF8C1DAB3C()
		{
			unsafe {
				if (fn__0x5EDEF0CF8C1DAB3C == null) fn__0x5EDEF0CF8C1DAB3C = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x5EDEF0CF8C1DAB3C");
				var result = fn__0x5EDEF0CF8C1DAB3C();
				return result;
			}
		}

		public void SetCutsceneCanBeSkipped(bool _p0)
		{
			unsafe {
				if (fn__setCutsceneCanBeSkipped == null) fn__setCutsceneCanBeSkipped = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setCutsceneCanBeSkipped");
				fn__setCutsceneCanBeSkipped(_p0);
			}
		}

		public void RegisterSynchronisedScriptSpeech()
		{
			unsafe {
				if (fn__registerSynchronisedScriptSpeech == null) fn__registerSynchronisedScriptSpeech = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_registerSynchronisedScriptSpeech");
				fn__registerSynchronisedScriptSpeech();
			}
		}

		public void SetCutscenePedComponentVariation(string _cutsceneEntName, int _p1, int _p2, int _p3, int _modelHash)
		{
			unsafe {
				if (fn__setCutscenePedComponentVariation == null) fn__setCutscenePedComponentVariation = (delegate* unmanaged[Cdecl]<nint, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setCutscenePedComponentVariation");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				fn__setCutscenePedComponentVariation(ptr_cutsceneEntName, _p1, _p2, _p3, _modelHash);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
			}
		}

		public void SetCutscenePedComponentVariationFromPed(string _cutsceneEntName, int _ped, int _modelHash)
		{
			unsafe {
				if (fn__setCutscenePedComponentVariationFromPed == null) fn__setCutscenePedComponentVariationFromPed = (delegate* unmanaged[Cdecl]<nint, int, int, void>) NativeLibrary.GetExport(handle, "Native_setCutscenePedComponentVariationFromPed");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				fn__setCutscenePedComponentVariationFromPed(ptr_cutsceneEntName, _ped, _modelHash);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
			}
		}

		public bool DoesCutsceneEntityExist(string _cutsceneEntName, int _modelHash)
		{
			unsafe {
				if (fn__doesCutsceneEntityExist == null) fn__doesCutsceneEntityExist = (delegate* unmanaged[Cdecl]<nint, int, bool>) NativeLibrary.GetExport(handle, "Native_doesCutsceneEntityExist");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				var result = fn__doesCutsceneEntityExist(ptr_cutsceneEntName, _modelHash);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
				return result;
			}
		}

		public void SetCutscenePedPropVariation(string _cutsceneEntName, int _p1, int _p2, int _p3, int _modelHash)
		{
			unsafe {
				if (fn__setCutscenePedPropVariation == null) fn__setCutscenePedPropVariation = (delegate* unmanaged[Cdecl]<nint, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setCutscenePedPropVariation");
				var ptr_cutsceneEntName = MemoryUtils.StringToHGlobalUtf8(_cutsceneEntName);
				fn__setCutscenePedPropVariation(ptr_cutsceneEntName, _p1, _p2, _p3, _modelHash);
				Marshal.FreeHGlobal(ptr_cutsceneEntName);
			}
		}

		public bool HasCutsceneCutThisFrame()
		{
			unsafe {
				if (fn__hasCutsceneCutThisFrame == null) fn__hasCutsceneCutThisFrame = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasCutsceneCutThisFrame");
				var result = fn__hasCutsceneCutThisFrame();
				return result;
			}
		}

		public void DatafileWatchRequestId(int _id)
		{
			unsafe {
				if (fn__datafileWatchRequestId == null) fn__datafileWatchRequestId = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_datafileWatchRequestId");
				fn__datafileWatchRequestId(_id);
			}
		}

		public void DatafileClearWatchList()
		{
			unsafe {
				if (fn__datafileClearWatchList == null) fn__datafileClearWatchList = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_datafileClearWatchList");
				fn__datafileClearWatchList();
			}
		}

		public bool DatafileIsValidRequestId(int _index)
		{
			unsafe {
				if (fn__datafileIsValidRequestId == null) fn__datafileIsValidRequestId = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_datafileIsValidRequestId");
				var result = fn__datafileIsValidRequestId(_index);
				return result;
			}
		}

		public bool DatafileHasLoadedFileData(int _p0)
		{
			unsafe {
				if (fn__datafileHasLoadedFileData == null) fn__datafileHasLoadedFileData = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_datafileHasLoadedFileData");
				var result = fn__datafileHasLoadedFileData(_p0);
				return result;
			}
		}

		public bool DatafileHasValidFileData(int _p0)
		{
			unsafe {
				if (fn__datafileHasValidFileData == null) fn__datafileHasValidFileData = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_datafileHasValidFileData");
				var result = fn__datafileHasValidFileData(_p0);
				return result;
			}
		}

		public bool DatafileSelectActiveFile(int _p0, int _p1)
		{
			unsafe {
				if (fn__datafileSelectActiveFile == null) fn__datafileSelectActiveFile = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_datafileSelectActiveFile");
				var result = fn__datafileSelectActiveFile(_p0, _p1);
				return result;
			}
		}

		public bool DatafileDeleteRequestedFile(int _p0)
		{
			unsafe {
				if (fn__datafileDeleteRequestedFile == null) fn__datafileDeleteRequestedFile = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_datafileDeleteRequestedFile");
				var result = fn__datafileDeleteRequestedFile(_p0);
				return result;
			}
		}

		public bool UgcCreateContent(ref int _data, int _dataCount, string _contentName, string _description, string _tagsCsv, string _contentTypeName, bool _publish, int _p7)
		{
			unsafe {
				if (fn__ugcCreateContent == null) fn__ugcCreateContent = (delegate* unmanaged[Cdecl]<int*, int, nint, nint, nint, nint, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_ugcCreateContent");
				var ref_data = _data;
				var ptr_contentName = MemoryUtils.StringToHGlobalUtf8(_contentName);
				var ptr_description = MemoryUtils.StringToHGlobalUtf8(_description);
				var ptr_tagsCsv = MemoryUtils.StringToHGlobalUtf8(_tagsCsv);
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcCreateContent(&ref_data, _dataCount, ptr_contentName, ptr_description, ptr_tagsCsv, ptr_contentTypeName, _publish, _p7);
				_data = ref_data;
				Marshal.FreeHGlobal(ptr_contentName);
				Marshal.FreeHGlobal(ptr_description);
				Marshal.FreeHGlobal(ptr_tagsCsv);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool UgcCreateMission(string _contentName, string _description, string _tagsCsv, string _contentTypeName, bool _publish, int _p5)
		{
			unsafe {
				if (fn__ugcCreateMission == null) fn__ugcCreateMission = (delegate* unmanaged[Cdecl]<nint, nint, nint, nint, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_ugcCreateMission");
				var ptr_contentName = MemoryUtils.StringToHGlobalUtf8(_contentName);
				var ptr_description = MemoryUtils.StringToHGlobalUtf8(_description);
				var ptr_tagsCsv = MemoryUtils.StringToHGlobalUtf8(_tagsCsv);
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcCreateMission(ptr_contentName, ptr_description, ptr_tagsCsv, ptr_contentTypeName, _publish, _p5);
				Marshal.FreeHGlobal(ptr_contentName);
				Marshal.FreeHGlobal(ptr_description);
				Marshal.FreeHGlobal(ptr_tagsCsv);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool UgcUpdateContent(string _contentId, ref int _data, int _dataCount, string _contentName, string _description, string _tagsCsv, string _contentTypeName, int _p7)
		{
			unsafe {
				if (fn__ugcUpdateContent == null) fn__ugcUpdateContent = (delegate* unmanaged[Cdecl]<nint, int*, int, nint, nint, nint, nint, int, bool>) NativeLibrary.GetExport(handle, "Native_ugcUpdateContent");
				var ptr_contentId = MemoryUtils.StringToHGlobalUtf8(_contentId);
				var ref_data = _data;
				var ptr_contentName = MemoryUtils.StringToHGlobalUtf8(_contentName);
				var ptr_description = MemoryUtils.StringToHGlobalUtf8(_description);
				var ptr_tagsCsv = MemoryUtils.StringToHGlobalUtf8(_tagsCsv);
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcUpdateContent(ptr_contentId, &ref_data, _dataCount, ptr_contentName, ptr_description, ptr_tagsCsv, ptr_contentTypeName, _p7);
				Marshal.FreeHGlobal(ptr_contentId);
				_data = ref_data;
				Marshal.FreeHGlobal(ptr_contentName);
				Marshal.FreeHGlobal(ptr_description);
				Marshal.FreeHGlobal(ptr_tagsCsv);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool UgcUpdateMission(string _contentId, string _contentName, string _description, string _tagsCsv, string _contentTypeName, int _p5)
		{
			unsafe {
				if (fn__ugcUpdateMission == null) fn__ugcUpdateMission = (delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int, bool>) NativeLibrary.GetExport(handle, "Native_ugcUpdateMission");
				var ptr_contentId = MemoryUtils.StringToHGlobalUtf8(_contentId);
				var ptr_contentName = MemoryUtils.StringToHGlobalUtf8(_contentName);
				var ptr_description = MemoryUtils.StringToHGlobalUtf8(_description);
				var ptr_tagsCsv = MemoryUtils.StringToHGlobalUtf8(_tagsCsv);
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcUpdateMission(ptr_contentId, ptr_contentName, ptr_description, ptr_tagsCsv, ptr_contentTypeName, _p5);
				Marshal.FreeHGlobal(ptr_contentId);
				Marshal.FreeHGlobal(ptr_contentName);
				Marshal.FreeHGlobal(ptr_description);
				Marshal.FreeHGlobal(ptr_tagsCsv);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool UgcSetPlayerData(string _contentId, float _rating, string _contentTypeName, int _p3)
		{
			unsafe {
				if (fn__ugcSetPlayerData == null) fn__ugcSetPlayerData = (delegate* unmanaged[Cdecl]<nint, float, nint, int, bool>) NativeLibrary.GetExport(handle, "Native_ugcSetPlayerData");
				var ptr_contentId = MemoryUtils.StringToHGlobalUtf8(_contentId);
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcSetPlayerData(ptr_contentId, _rating, ptr_contentTypeName, _p3);
				Marshal.FreeHGlobal(ptr_contentId);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool DatafileSelectUgcData(int _p0, int _p1)
		{
			unsafe {
				if (fn__datafileSelectUgcData == null) fn__datafileSelectUgcData = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_datafileSelectUgcData");
				var result = fn__datafileSelectUgcData(_p0, _p1);
				return result;
			}
		}

		public bool DatafileSelectUgcStats(int _p0, bool _p1, int _p2)
		{
			unsafe {
				if (fn__datafileSelectUgcStats == null) fn__datafileSelectUgcStats = (delegate* unmanaged[Cdecl]<int, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_datafileSelectUgcStats");
				var result = fn__datafileSelectUgcStats(_p0, _p1, _p2);
				return result;
			}
		}

		public bool DatafileSelectUgcPlayerData(int _p0, int _p1)
		{
			unsafe {
				if (fn__datafileSelectUgcPlayerData == null) fn__datafileSelectUgcPlayerData = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_datafileSelectUgcPlayerData");
				var result = fn__datafileSelectUgcPlayerData(_p0, _p1);
				return result;
			}
		}

		public bool DatafileSelectCreatorStats(int _p0, int _p1)
		{
			unsafe {
				if (fn__datafileSelectCreatorStats == null) fn__datafileSelectCreatorStats = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_datafileSelectCreatorStats");
				var result = fn__datafileSelectCreatorStats(_p0, _p1);
				return result;
			}
		}

		public bool DatafileLoadOfflineUgc(string _filename, int _p1)
		{
			unsafe {
				if (fn__datafileLoadOfflineUgc == null) fn__datafileLoadOfflineUgc = (delegate* unmanaged[Cdecl]<nint, int, bool>) NativeLibrary.GetExport(handle, "Native_datafileLoadOfflineUgc");
				var ptr_filename = MemoryUtils.StringToHGlobalUtf8(_filename);
				var result = fn__datafileLoadOfflineUgc(ptr_filename, _p1);
				Marshal.FreeHGlobal(ptr_filename);
				return result;
			}
		}

		public void DatafileCreate(int _p0)
		{
			unsafe {
				if (fn__datafileCreate == null) fn__datafileCreate = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_datafileCreate");
				fn__datafileCreate(_p0);
			}
		}

		public void DatafileDelete(int _p0)
		{
			unsafe {
				if (fn__datafileDelete == null) fn__datafileDelete = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_datafileDelete");
				fn__datafileDelete(_p0);
			}
		}

		public void DatafileStoreMissionHeader(int _p0)
		{
			unsafe {
				if (fn__datafileStoreMissionHeader == null) fn__datafileStoreMissionHeader = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_datafileStoreMissionHeader");
				fn__datafileStoreMissionHeader(_p0);
			}
		}

		public void DatafileFlushMissionHeader()
		{
			unsafe {
				if (fn__datafileFlushMissionHeader == null) fn__datafileFlushMissionHeader = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_datafileFlushMissionHeader");
				fn__datafileFlushMissionHeader();
			}
		}

		public string DatafileGetFileDict(int _p0)
		{
			unsafe {
				if (fn__datafileGetFileDict == null) fn__datafileGetFileDict = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_datafileGetFileDict");
				var result = fn__datafileGetFileDict(_p0);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool DatafileStartSaveToCloud(string _filename, int _p1)
		{
			unsafe {
				if (fn__datafileStartSaveToCloud == null) fn__datafileStartSaveToCloud = (delegate* unmanaged[Cdecl]<nint, int, bool>) NativeLibrary.GetExport(handle, "Native_datafileStartSaveToCloud");
				var ptr_filename = MemoryUtils.StringToHGlobalUtf8(_filename);
				var result = fn__datafileStartSaveToCloud(ptr_filename, _p1);
				Marshal.FreeHGlobal(ptr_filename);
				return result;
			}
		}

		public bool DatafileUpdateSaveToCloud(ref bool _p0)
		{
			unsafe {
				if (fn__datafileUpdateSaveToCloud == null) fn__datafileUpdateSaveToCloud = (delegate* unmanaged[Cdecl]<bool*, bool>) NativeLibrary.GetExport(handle, "Native_datafileUpdateSaveToCloud");
				var ref_p0 = _p0;
				var result = fn__datafileUpdateSaveToCloud(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool DatafileIsSavePending()
		{
			unsafe {
				if (fn__datafileIsSavePending == null) fn__datafileIsSavePending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_datafileIsSavePending");
				var result = fn__datafileIsSavePending();
				return result;
			}
		}

		public int _0xA6EEF01087181EDD(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xA6EEF01087181EDD == null) fn__0xA6EEF01087181EDD = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0xA6EEF01087181EDD");
				var result = fn__0xA6EEF01087181EDD(_p0, _p1);
				return result;
			}
		}

		public void _0x6AD0BD5E087866CB(int _p0)
		{
			unsafe {
				if (fn__0x6AD0BD5E087866CB == null) fn__0x6AD0BD5E087866CB = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x6AD0BD5E087866CB");
				fn__0x6AD0BD5E087866CB(_p0);
			}
		}

		public int _0xDBF860CF1DB8E599(int _p0)
		{
			unsafe {
				if (fn__0xDBF860CF1DB8E599 == null) fn__0xDBF860CF1DB8E599 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xDBF860CF1DB8E599");
				var result = fn__0xDBF860CF1DB8E599(_p0);
				return result;
			}
		}

		public void DatadictSetBool(ref int _objectData, string _key, bool _value)
		{
			unsafe {
				if (fn__datadictSetBool == null) fn__datadictSetBool = (delegate* unmanaged[Cdecl]<int*, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_datadictSetBool");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				fn__datadictSetBool(&ref_objectData, ptr_key, _value);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
			}
		}

		public void DatadictSetInt(ref int _objectData, string _key, int _value)
		{
			unsafe {
				if (fn__datadictSetInt == null) fn__datadictSetInt = (delegate* unmanaged[Cdecl]<int*, nint, int, void>) NativeLibrary.GetExport(handle, "Native_datadictSetInt");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				fn__datadictSetInt(&ref_objectData, ptr_key, _value);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
			}
		}

		public void DatadictSetFloat(ref int _objectData, string _key, float _value)
		{
			unsafe {
				if (fn__datadictSetFloat == null) fn__datadictSetFloat = (delegate* unmanaged[Cdecl]<int*, nint, float, void>) NativeLibrary.GetExport(handle, "Native_datadictSetFloat");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				fn__datadictSetFloat(&ref_objectData, ptr_key, _value);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
			}
		}

		public void DatadictSetString(ref int _objectData, string _key, string _value)
		{
			unsafe {
				if (fn__datadictSetString == null) fn__datadictSetString = (delegate* unmanaged[Cdecl]<int*, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_datadictSetString");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var ptr_value = MemoryUtils.StringToHGlobalUtf8(_value);
				fn__datadictSetString(&ref_objectData, ptr_key, ptr_value);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				Marshal.FreeHGlobal(ptr_value);
			}
		}

		public void DatadictSetVector(ref int _objectData, string _key, float _valueX, float _valueY, float _valueZ)
		{
			unsafe {
				if (fn__datadictSetVector == null) fn__datadictSetVector = (delegate* unmanaged[Cdecl]<int*, nint, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_datadictSetVector");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				fn__datadictSetVector(&ref_objectData, ptr_key, _valueX, _valueY, _valueZ);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
			}
		}

		public int DatadictCreateDict(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictCreateDict == null) fn__datadictCreateDict = (delegate* unmanaged[Cdecl]<int*, nint, int>) NativeLibrary.GetExport(handle, "Native_datadictCreateDict");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictCreateDict(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return result;
			}
		}

		public int DatadictCreateArray(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictCreateArray == null) fn__datadictCreateArray = (delegate* unmanaged[Cdecl]<int*, nint, int>) NativeLibrary.GetExport(handle, "Native_datadictCreateArray");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictCreateArray(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return result;
			}
		}

		public bool DatadictGetBool(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictGetBool == null) fn__datadictGetBool = (delegate* unmanaged[Cdecl]<int*, nint, bool>) NativeLibrary.GetExport(handle, "Native_datadictGetBool");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictGetBool(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return result;
			}
		}

		public int DatadictGetInt(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictGetInt == null) fn__datadictGetInt = (delegate* unmanaged[Cdecl]<int*, nint, int>) NativeLibrary.GetExport(handle, "Native_datadictGetInt");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictGetInt(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return result;
			}
		}

		public float DatadictGetFloat(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictGetFloat == null) fn__datadictGetFloat = (delegate* unmanaged[Cdecl]<int*, nint, float>) NativeLibrary.GetExport(handle, "Native_datadictGetFloat");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictGetFloat(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return result;
			}
		}

		public string DatadictGetString(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictGetString == null) fn__datadictGetString = (delegate* unmanaged[Cdecl]<int*, nint, nint>) NativeLibrary.GetExport(handle, "Native_datadictGetString");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictGetString(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public Vector3 DatadictGetVector(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictGetVector == null) fn__datadictGetVector = (delegate* unmanaged[Cdecl]<int*, nint, Vector3>) NativeLibrary.GetExport(handle, "Native_datadictGetVector");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictGetVector(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return result;
			}
		}

		public int DatadictGetDict(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictGetDict == null) fn__datadictGetDict = (delegate* unmanaged[Cdecl]<int*, nint, int>) NativeLibrary.GetExport(handle, "Native_datadictGetDict");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictGetDict(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return result;
			}
		}

		public int DatadictGetArray(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictGetArray == null) fn__datadictGetArray = (delegate* unmanaged[Cdecl]<int*, nint, int>) NativeLibrary.GetExport(handle, "Native_datadictGetArray");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictGetArray(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return result;
			}
		}

		public int DatadictGetType(ref int _objectData, string _key)
		{
			unsafe {
				if (fn__datadictGetType == null) fn__datadictGetType = (delegate* unmanaged[Cdecl]<int*, nint, int>) NativeLibrary.GetExport(handle, "Native_datadictGetType");
				var ref_objectData = _objectData;
				var ptr_key = MemoryUtils.StringToHGlobalUtf8(_key);
				var result = fn__datadictGetType(&ref_objectData, ptr_key);
				_objectData = ref_objectData;
				Marshal.FreeHGlobal(ptr_key);
				return result;
			}
		}

		public void DataarrayAddBool(ref int _arrayData, bool _value)
		{
			unsafe {
				if (fn__dataarrayAddBool == null) fn__dataarrayAddBool = (delegate* unmanaged[Cdecl]<int*, bool, void>) NativeLibrary.GetExport(handle, "Native_dataarrayAddBool");
				var ref_arrayData = _arrayData;
				fn__dataarrayAddBool(&ref_arrayData, _value);
				_arrayData = ref_arrayData;
			}
		}

		public void DataarrayAddInt(ref int _arrayData, int _value)
		{
			unsafe {
				if (fn__dataarrayAddInt == null) fn__dataarrayAddInt = (delegate* unmanaged[Cdecl]<int*, int, void>) NativeLibrary.GetExport(handle, "Native_dataarrayAddInt");
				var ref_arrayData = _arrayData;
				fn__dataarrayAddInt(&ref_arrayData, _value);
				_arrayData = ref_arrayData;
			}
		}

		public void DataarrayAddFloat(ref int _arrayData, float _value)
		{
			unsafe {
				if (fn__dataarrayAddFloat == null) fn__dataarrayAddFloat = (delegate* unmanaged[Cdecl]<int*, float, void>) NativeLibrary.GetExport(handle, "Native_dataarrayAddFloat");
				var ref_arrayData = _arrayData;
				fn__dataarrayAddFloat(&ref_arrayData, _value);
				_arrayData = ref_arrayData;
			}
		}

		public void DataarrayAddString(ref int _arrayData, string _value)
		{
			unsafe {
				if (fn__dataarrayAddString == null) fn__dataarrayAddString = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native_dataarrayAddString");
				var ref_arrayData = _arrayData;
				var ptr_value = MemoryUtils.StringToHGlobalUtf8(_value);
				fn__dataarrayAddString(&ref_arrayData, ptr_value);
				_arrayData = ref_arrayData;
				Marshal.FreeHGlobal(ptr_value);
			}
		}

		public void DataarrayAddVector(ref int _arrayData, float _valueX, float _valueY, float _valueZ)
		{
			unsafe {
				if (fn__dataarrayAddVector == null) fn__dataarrayAddVector = (delegate* unmanaged[Cdecl]<int*, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_dataarrayAddVector");
				var ref_arrayData = _arrayData;
				fn__dataarrayAddVector(&ref_arrayData, _valueX, _valueY, _valueZ);
				_arrayData = ref_arrayData;
			}
		}

		public int DataarrayAddDict(ref int _arrayData)
		{
			unsafe {
				if (fn__dataarrayAddDict == null) fn__dataarrayAddDict = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_dataarrayAddDict");
				var ref_arrayData = _arrayData;
				var result = fn__dataarrayAddDict(&ref_arrayData);
				_arrayData = ref_arrayData;
				return result;
			}
		}

		public bool DataarrayGetBool(ref int _arrayData, int _arrayIndex)
		{
			unsafe {
				if (fn__dataarrayGetBool == null) fn__dataarrayGetBool = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_dataarrayGetBool");
				var ref_arrayData = _arrayData;
				var result = fn__dataarrayGetBool(&ref_arrayData, _arrayIndex);
				_arrayData = ref_arrayData;
				return result;
			}
		}

		public int DataarrayGetInt(ref int _arrayData, int _arrayIndex)
		{
			unsafe {
				if (fn__dataarrayGetInt == null) fn__dataarrayGetInt = (delegate* unmanaged[Cdecl]<int*, int, int>) NativeLibrary.GetExport(handle, "Native_dataarrayGetInt");
				var ref_arrayData = _arrayData;
				var result = fn__dataarrayGetInt(&ref_arrayData, _arrayIndex);
				_arrayData = ref_arrayData;
				return result;
			}
		}

		public float DataarrayGetFloat(ref int _arrayData, int _arrayIndex)
		{
			unsafe {
				if (fn__dataarrayGetFloat == null) fn__dataarrayGetFloat = (delegate* unmanaged[Cdecl]<int*, int, float>) NativeLibrary.GetExport(handle, "Native_dataarrayGetFloat");
				var ref_arrayData = _arrayData;
				var result = fn__dataarrayGetFloat(&ref_arrayData, _arrayIndex);
				_arrayData = ref_arrayData;
				return result;
			}
		}

		public string DataarrayGetString(ref int _arrayData, int _arrayIndex)
		{
			unsafe {
				if (fn__dataarrayGetString == null) fn__dataarrayGetString = (delegate* unmanaged[Cdecl]<int*, int, nint>) NativeLibrary.GetExport(handle, "Native_dataarrayGetString");
				var ref_arrayData = _arrayData;
				var result = fn__dataarrayGetString(&ref_arrayData, _arrayIndex);
				_arrayData = ref_arrayData;
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public Vector3 DataarrayGetVector(ref int _arrayData, int _arrayIndex)
		{
			unsafe {
				if (fn__dataarrayGetVector == null) fn__dataarrayGetVector = (delegate* unmanaged[Cdecl]<int*, int, Vector3>) NativeLibrary.GetExport(handle, "Native_dataarrayGetVector");
				var ref_arrayData = _arrayData;
				var result = fn__dataarrayGetVector(&ref_arrayData, _arrayIndex);
				_arrayData = ref_arrayData;
				return result;
			}
		}

		public int DataarrayGetDict(ref int _arrayData, int _arrayIndex)
		{
			unsafe {
				if (fn__dataarrayGetDict == null) fn__dataarrayGetDict = (delegate* unmanaged[Cdecl]<int*, int, int>) NativeLibrary.GetExport(handle, "Native_dataarrayGetDict");
				var ref_arrayData = _arrayData;
				var result = fn__dataarrayGetDict(&ref_arrayData, _arrayIndex);
				_arrayData = ref_arrayData;
				return result;
			}
		}

		public int DataarrayGetCount(ref int _arrayData)
		{
			unsafe {
				if (fn__dataarrayGetCount == null) fn__dataarrayGetCount = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_dataarrayGetCount");
				var ref_arrayData = _arrayData;
				var result = fn__dataarrayGetCount(&ref_arrayData);
				_arrayData = ref_arrayData;
				return result;
			}
		}

		public int DataarrayGetType(ref int _arrayData, int _arrayIndex)
		{
			unsafe {
				if (fn__dataarrayGetType == null) fn__dataarrayGetType = (delegate* unmanaged[Cdecl]<int*, int, int>) NativeLibrary.GetExport(handle, "Native_dataarrayGetType");
				var ref_arrayData = _arrayData;
				var result = fn__dataarrayGetType(&ref_arrayData, _arrayIndex);
				_arrayData = ref_arrayData;
				return result;
			}
		}

		public bool DecorSetTime(int _entity, string _propertyName, int _timestamp)
		{
			unsafe {
				if (fn__decorSetTime == null) fn__decorSetTime = (delegate* unmanaged[Cdecl]<int, nint, int, bool>) NativeLibrary.GetExport(handle, "Native_decorSetTime");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorSetTime(_entity, ptr_propertyName, _timestamp);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public bool DecorSetBool(int _entity, string _propertyName, bool _value)
		{
			unsafe {
				if (fn__decorSetBool == null) fn__decorSetBool = (delegate* unmanaged[Cdecl]<int, nint, bool, bool>) NativeLibrary.GetExport(handle, "Native_decorSetBool");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorSetBool(_entity, ptr_propertyName, _value);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public bool DecorSetFloat(int _entity, string _propertyName, float _value)
		{
			unsafe {
				if (fn__decorSetFloat == null) fn__decorSetFloat = (delegate* unmanaged[Cdecl]<int, nint, float, bool>) NativeLibrary.GetExport(handle, "Native_decorSetFloat");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorSetFloat(_entity, ptr_propertyName, _value);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public bool DecorSetInt(int _entity, string _propertyName, int _value)
		{
			unsafe {
				if (fn__decorSetInt == null) fn__decorSetInt = (delegate* unmanaged[Cdecl]<int, nint, int, bool>) NativeLibrary.GetExport(handle, "Native_decorSetInt");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorSetInt(_entity, ptr_propertyName, _value);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public bool DecorGetBool(int _entity, string _propertyName)
		{
			unsafe {
				if (fn__decorGetBool == null) fn__decorGetBool = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_decorGetBool");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorGetBool(_entity, ptr_propertyName);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public float DecorGetFloat(int _entity, string _propertyName)
		{
			unsafe {
				if (fn__decorGetFloat == null) fn__decorGetFloat = (delegate* unmanaged[Cdecl]<int, nint, float>) NativeLibrary.GetExport(handle, "Native_decorGetFloat");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorGetFloat(_entity, ptr_propertyName);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public int DecorGetInt(int _entity, string _propertyName)
		{
			unsafe {
				if (fn__decorGetInt == null) fn__decorGetInt = (delegate* unmanaged[Cdecl]<int, nint, int>) NativeLibrary.GetExport(handle, "Native_decorGetInt");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorGetInt(_entity, ptr_propertyName);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public bool DecorExistOn(int _entity, string _propertyName)
		{
			unsafe {
				if (fn__decorExistOn == null) fn__decorExistOn = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_decorExistOn");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorExistOn(_entity, ptr_propertyName);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public bool DecorRemove(int _entity, string _propertyName)
		{
			unsafe {
				if (fn__decorRemove == null) fn__decorRemove = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_decorRemove");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorRemove(_entity, ptr_propertyName);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public void DecorRegister(string _propertyName, int _type)
		{
			unsafe {
				if (fn__decorRegister == null) fn__decorRegister = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_decorRegister");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				fn__decorRegister(ptr_propertyName, _type);
				Marshal.FreeHGlobal(ptr_propertyName);
			}
		}

		public bool DecorIsRegisteredAsType(string _propertyName, int _type)
		{
			unsafe {
				if (fn__decorIsRegisteredAsType == null) fn__decorIsRegisteredAsType = (delegate* unmanaged[Cdecl]<nint, int, bool>) NativeLibrary.GetExport(handle, "Native_decorIsRegisteredAsType");
				var ptr_propertyName = MemoryUtils.StringToHGlobalUtf8(_propertyName);
				var result = fn__decorIsRegisteredAsType(ptr_propertyName, _type);
				Marshal.FreeHGlobal(ptr_propertyName);
				return result;
			}
		}

		public void DecorRegisterLock()
		{
			unsafe {
				if (fn__decorRegisterLock == null) fn__decorRegisterLock = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_decorRegisterLock");
				fn__decorRegisterLock();
			}
		}

		public bool _0x241FCA5B1AA14F75()
		{
			unsafe {
				if (fn__0x241FCA5B1AA14F75 == null) fn__0x241FCA5B1AA14F75 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x241FCA5B1AA14F75");
				var result = fn__0x241FCA5B1AA14F75();
				return result;
			}
		}

		public bool IsDlcPresent(int _dlcHash)
		{
			unsafe {
				if (fn__isDlcPresent == null) fn__isDlcPresent = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isDlcPresent");
				var result = fn__isDlcPresent(_dlcHash);
				return result;
			}
		}

		public bool _0xF2E07819EF1A5289()
		{
			unsafe {
				if (fn__0xF2E07819EF1A5289 == null) fn__0xF2E07819EF1A5289 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xF2E07819EF1A5289");
				var result = fn__0xF2E07819EF1A5289();
				return result;
			}
		}

		public bool _0x9489659372A81585()
		{
			unsafe {
				if (fn__0x9489659372A81585 == null) fn__0x9489659372A81585 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x9489659372A81585");
				var result = fn__0x9489659372A81585();
				return result;
			}
		}

		public bool _0xA213B11DFF526300()
		{
			unsafe {
				if (fn__0xA213B11DFF526300 == null) fn__0xA213B11DFF526300 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xA213B11DFF526300");
				var result = fn__0xA213B11DFF526300();
				return result;
			}
		}

		public bool GetExtraContentPackHasBeenInstalled()
		{
			unsafe {
				if (fn__getExtraContentPackHasBeenInstalled == null) fn__getExtraContentPackHasBeenInstalled = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getExtraContentPackHasBeenInstalled");
				var result = fn__getExtraContentPackHasBeenInstalled();
				return result;
			}
		}

		public bool GetIsLoadingScreenActive()
		{
			unsafe {
				if (fn__getIsLoadingScreenActive == null) fn__getIsLoadingScreenActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getIsLoadingScreenActive");
				var result = fn__getIsLoadingScreenActive();
				return result;
			}
		}

		public bool _0xC4637A6D03C24CC3()
		{
			unsafe {
				if (fn__0xC4637A6D03C24CC3 == null) fn__0xC4637A6D03C24CC3 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xC4637A6D03C24CC3");
				var result = fn__0xC4637A6D03C24CC3();
				return result;
			}
		}

		public bool HasCloudRequestsFinished(ref bool _p0, int _unused)
		{
			unsafe {
				if (fn__hasCloudRequestsFinished == null) fn__hasCloudRequestsFinished = (delegate* unmanaged[Cdecl]<bool*, int, bool>) NativeLibrary.GetExport(handle, "Native_hasCloudRequestsFinished");
				var ref_p0 = _p0;
				var result = fn__hasCloudRequestsFinished(&ref_p0, _unused);
				_p0 = ref_p0;
				return result;
			}
		}

		public void OnEnterSp()
		{
			unsafe {
				if (fn__onEnterSp == null) fn__onEnterSp = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_onEnterSp");
				fn__onEnterSp();
			}
		}

		public void OnEnterMp()
		{
			unsafe {
				if (fn__onEnterMp == null) fn__onEnterMp = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_onEnterMp");
				fn__onEnterMp();
			}
		}

		public bool DoesEntityExist(int _entity)
		{
			unsafe {
				if (fn__doesEntityExist == null) fn__doesEntityExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesEntityExist");
				var result = fn__doesEntityExist(_entity);
				return result;
			}
		}

		public bool DoesEntityBelongToThisScript(int _entity, bool _p1)
		{
			unsafe {
				if (fn__doesEntityBelongToThisScript == null) fn__doesEntityBelongToThisScript = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_doesEntityBelongToThisScript");
				var result = fn__doesEntityBelongToThisScript(_entity, _p1);
				return result;
			}
		}

		public bool DoesEntityHaveDrawable(int _entity)
		{
			unsafe {
				if (fn__doesEntityHaveDrawable == null) fn__doesEntityHaveDrawable = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesEntityHaveDrawable");
				var result = fn__doesEntityHaveDrawable(_entity);
				return result;
			}
		}

		public bool DoesEntityHavePhysics(int _entity)
		{
			unsafe {
				if (fn__doesEntityHavePhysics == null) fn__doesEntityHavePhysics = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesEntityHavePhysics");
				var result = fn__doesEntityHavePhysics(_entity);
				return result;
			}
		}

		public bool HasEntityAnimFinished(int _entity, string _animDict, string _animName, int _p3)
		{
			unsafe {
				if (fn__hasEntityAnimFinished == null) fn__hasEntityAnimFinished = (delegate* unmanaged[Cdecl]<int, nint, nint, int, bool>) NativeLibrary.GetExport(handle, "Native_hasEntityAnimFinished");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var result = fn__hasEntityAnimFinished(_entity, ptr_animDict, ptr_animName, _p3);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				return result;
			}
		}

		public bool HasEntityBeenDamagedByAnyObject(int _entity)
		{
			unsafe {
				if (fn__hasEntityBeenDamagedByAnyObject == null) fn__hasEntityBeenDamagedByAnyObject = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasEntityBeenDamagedByAnyObject");
				var result = fn__hasEntityBeenDamagedByAnyObject(_entity);
				return result;
			}
		}

		public bool HasEntityBeenDamagedByAnyPed(int _entity)
		{
			unsafe {
				if (fn__hasEntityBeenDamagedByAnyPed == null) fn__hasEntityBeenDamagedByAnyPed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasEntityBeenDamagedByAnyPed");
				var result = fn__hasEntityBeenDamagedByAnyPed(_entity);
				return result;
			}
		}

		public bool HasEntityBeenDamagedByAnyVehicle(int _entity)
		{
			unsafe {
				if (fn__hasEntityBeenDamagedByAnyVehicle == null) fn__hasEntityBeenDamagedByAnyVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasEntityBeenDamagedByAnyVehicle");
				var result = fn__hasEntityBeenDamagedByAnyVehicle(_entity);
				return result;
			}
		}

		public bool HasEntityBeenDamagedByEntity(int _entity1, int _entity2, bool _p2)
		{
			unsafe {
				if (fn__hasEntityBeenDamagedByEntity == null) fn__hasEntityBeenDamagedByEntity = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_hasEntityBeenDamagedByEntity");
				var result = fn__hasEntityBeenDamagedByEntity(_entity1, _entity2, _p2);
				return result;
			}
		}

		public bool HasEntityClearLosToEntity(int _entity1, int _entity2, int _traceType)
		{
			unsafe {
				if (fn__hasEntityClearLosToEntity == null) fn__hasEntityClearLosToEntity = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasEntityClearLosToEntity");
				var result = fn__hasEntityClearLosToEntity(_entity1, _entity2, _traceType);
				return result;
			}
		}

		public int HasEntityClearLosToEntity2(int _entity1, int _entity2, int _traceType)
		{
			unsafe {
				if (fn__hasEntityClearLosToEntity2 == null) fn__hasEntityClearLosToEntity2 = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_hasEntityClearLosToEntity2");
				var result = fn__hasEntityClearLosToEntity2(_entity1, _entity2, _traceType);
				return result;
			}
		}

		public bool HasEntityClearLosToEntityInFront(int _entity1, int _entity2)
		{
			unsafe {
				if (fn__hasEntityClearLosToEntityInFront == null) fn__hasEntityClearLosToEntityInFront = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasEntityClearLosToEntityInFront");
				var result = fn__hasEntityClearLosToEntityInFront(_entity1, _entity2);
				return result;
			}
		}

		public bool HasEntityCollidedWithAnything(int _entity)
		{
			unsafe {
				if (fn__hasEntityCollidedWithAnything == null) fn__hasEntityCollidedWithAnything = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasEntityCollidedWithAnything");
				var result = fn__hasEntityCollidedWithAnything(_entity);
				return result;
			}
		}

		public int GetLastMaterialHitByEntity(int _entity)
		{
			unsafe {
				if (fn__getLastMaterialHitByEntity == null) fn__getLastMaterialHitByEntity = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getLastMaterialHitByEntity");
				var result = fn__getLastMaterialHitByEntity(_entity);
				return result;
			}
		}

		public Vector3 GetCollisionNormalOfLastHitForEntity(int _entity)
		{
			unsafe {
				if (fn__getCollisionNormalOfLastHitForEntity == null) fn__getCollisionNormalOfLastHitForEntity = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getCollisionNormalOfLastHitForEntity");
				var result = fn__getCollisionNormalOfLastHitForEntity(_entity);
				return result;
			}
		}

		public void ForceEntityAiAndAnimationUpdate(int _entity)
		{
			unsafe {
				if (fn__forceEntityAiAndAnimationUpdate == null) fn__forceEntityAiAndAnimationUpdate = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_forceEntityAiAndAnimationUpdate");
				fn__forceEntityAiAndAnimationUpdate(_entity);
			}
		}

		public float GetEntityAnimCurrentTime(int _entity, string _animDict, string _animName)
		{
			unsafe {
				if (fn__getEntityAnimCurrentTime == null) fn__getEntityAnimCurrentTime = (delegate* unmanaged[Cdecl]<int, nint, nint, float>) NativeLibrary.GetExport(handle, "Native_getEntityAnimCurrentTime");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var result = fn__getEntityAnimCurrentTime(_entity, ptr_animDict, ptr_animName);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				return result;
			}
		}

		public float GetEntityAnimTotalTime(int _entity, string _animDict, string _animName)
		{
			unsafe {
				if (fn__getEntityAnimTotalTime == null) fn__getEntityAnimTotalTime = (delegate* unmanaged[Cdecl]<int, nint, nint, float>) NativeLibrary.GetExport(handle, "Native_getEntityAnimTotalTime");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var result = fn__getEntityAnimTotalTime(_entity, ptr_animDict, ptr_animName);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				return result;
			}
		}

		public float GetAnimDuration(string _animDict, string _animName)
		{
			unsafe {
				if (fn__getAnimDuration == null) fn__getAnimDuration = (delegate* unmanaged[Cdecl]<nint, nint, float>) NativeLibrary.GetExport(handle, "Native_getAnimDuration");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var result = fn__getAnimDuration(ptr_animDict, ptr_animName);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				return result;
			}
		}

		public int GetEntityAttachedTo(int _entity)
		{
			unsafe {
				if (fn__getEntityAttachedTo == null) fn__getEntityAttachedTo = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityAttachedTo");
				var result = fn__getEntityAttachedTo(_entity);
				return result;
			}
		}

		public Vector3 GetEntityCoords(int _entity, bool _alive)
		{
			unsafe {
				if (fn__getEntityCoords == null) fn__getEntityCoords = (delegate* unmanaged[Cdecl]<int, bool, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntityCoords");
				var result = fn__getEntityCoords(_entity, _alive);
				return result;
			}
		}

		public Vector3 GetEntityForwardVector(int _entity)
		{
			unsafe {
				if (fn__getEntityForwardVector == null) fn__getEntityForwardVector = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntityForwardVector");
				var result = fn__getEntityForwardVector(_entity);
				return result;
			}
		}

		public float GetEntityForwardX(int _entity)
		{
			unsafe {
				if (fn__getEntityForwardX == null) fn__getEntityForwardX = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntityForwardX");
				var result = fn__getEntityForwardX(_entity);
				return result;
			}
		}

		public float GetEntityForwardY(int _entity)
		{
			unsafe {
				if (fn__getEntityForwardY == null) fn__getEntityForwardY = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntityForwardY");
				var result = fn__getEntityForwardY(_entity);
				return result;
			}
		}

		public float GetEntityHeading(int _entity)
		{
			unsafe {
				if (fn__getEntityHeading == null) fn__getEntityHeading = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntityHeading");
				var result = fn__getEntityHeading(_entity);
				return result;
			}
		}

		public float GetEntityPhysicsHeading(int _entity)
		{
			unsafe {
				if (fn__getEntityPhysicsHeading == null) fn__getEntityPhysicsHeading = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntityPhysicsHeading");
				var result = fn__getEntityPhysicsHeading(_entity);
				return result;
			}
		}

		public int GetEntityHealth(int _entity)
		{
			unsafe {
				if (fn__getEntityHealth == null) fn__getEntityHealth = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityHealth");
				var result = fn__getEntityHealth(_entity);
				return result;
			}
		}

		public int GetEntityMaxHealth(int _entity)
		{
			unsafe {
				if (fn__getEntityMaxHealth == null) fn__getEntityMaxHealth = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityMaxHealth");
				var result = fn__getEntityMaxHealth(_entity);
				return result;
			}
		}

		public void SetEntityMaxHealth(int _entity, int _value)
		{
			unsafe {
				if (fn__setEntityMaxHealth == null) fn__setEntityMaxHealth = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setEntityMaxHealth");
				fn__setEntityMaxHealth(_entity, _value);
			}
		}

		public float GetEntityHeight(int _entity, float _X, float _Y, float _Z, bool _atTop, bool _inWorldCoords)
		{
			unsafe {
				if (fn__getEntityHeight == null) fn__getEntityHeight = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, float>) NativeLibrary.GetExport(handle, "Native_getEntityHeight");
				var result = fn__getEntityHeight(_entity, _X, _Y, _Z, _atTop, _inWorldCoords);
				return result;
			}
		}

		public float GetEntityHeightAboveGround(int _entity)
		{
			unsafe {
				if (fn__getEntityHeightAboveGround == null) fn__getEntityHeightAboveGround = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntityHeightAboveGround");
				var result = fn__getEntityHeightAboveGround(_entity);
				return result;
			}
		}

		public void GetEntityMatrix(int _entity, ref Vector3 _forwardVector, ref Vector3 _rightVector, ref Vector3 _upVector, ref Vector3 _position)
		{
			unsafe {
				if (fn__getEntityMatrix == null) fn__getEntityMatrix = (delegate* unmanaged[Cdecl]<int, Vector3*, Vector3*, Vector3*, Vector3*, void>) NativeLibrary.GetExport(handle, "Native_getEntityMatrix");
				var ref_forwardVector = _forwardVector;
				var ref_rightVector = _rightVector;
				var ref_upVector = _upVector;
				var ref_position = _position;
				fn__getEntityMatrix(_entity, &ref_forwardVector, &ref_rightVector, &ref_upVector, &ref_position);
				_forwardVector = ref_forwardVector;
				_rightVector = ref_rightVector;
				_upVector = ref_upVector;
				_position = ref_position;
			}
		}

		public int GetEntityModel(int _entity)
		{
			unsafe {
				if (fn__getEntityModel == null) fn__getEntityModel = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityModel");
				var result = fn__getEntityModel(_entity);
				return result;
			}
		}

		public Vector3 GetOffsetFromEntityGivenWorldCoords(int _entity, float _posX, float _posY, float _posZ)
		{
			unsafe {
				if (fn__getOffsetFromEntityGivenWorldCoords == null) fn__getOffsetFromEntityGivenWorldCoords = (delegate* unmanaged[Cdecl]<int, float, float, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getOffsetFromEntityGivenWorldCoords");
				var result = fn__getOffsetFromEntityGivenWorldCoords(_entity, _posX, _posY, _posZ);
				return result;
			}
		}

		public Vector3 GetOffsetFromEntityInWorldCoords(int _entity, float _offsetX, float _offsetY, float _offsetZ)
		{
			unsafe {
				if (fn__getOffsetFromEntityInWorldCoords == null) fn__getOffsetFromEntityInWorldCoords = (delegate* unmanaged[Cdecl]<int, float, float, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getOffsetFromEntityInWorldCoords");
				var result = fn__getOffsetFromEntityInWorldCoords(_entity, _offsetX, _offsetY, _offsetZ);
				return result;
			}
		}

		public float GetEntityPitch(int _entity)
		{
			unsafe {
				if (fn__getEntityPitch == null) fn__getEntityPitch = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntityPitch");
				var result = fn__getEntityPitch(_entity);
				return result;
			}
		}

		public void GetEntityQuaternion(int _entity, ref float _x, ref float _y, ref float _z, ref float _w)
		{
			unsafe {
				if (fn__getEntityQuaternion == null) fn__getEntityQuaternion = (delegate* unmanaged[Cdecl]<int, float*, float*, float*, float*, void>) NativeLibrary.GetExport(handle, "Native_getEntityQuaternion");
				var ref_x = _x;
				var ref_y = _y;
				var ref_z = _z;
				var ref_w = _w;
				fn__getEntityQuaternion(_entity, &ref_x, &ref_y, &ref_z, &ref_w);
				_x = ref_x;
				_y = ref_y;
				_z = ref_z;
				_w = ref_w;
			}
		}

		public float GetEntityRoll(int _entity)
		{
			unsafe {
				if (fn__getEntityRoll == null) fn__getEntityRoll = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntityRoll");
				var result = fn__getEntityRoll(_entity);
				return result;
			}
		}

		public Vector3 GetEntityRotation(int _entity, int _rotationOrder)
		{
			unsafe {
				if (fn__getEntityRotation == null) fn__getEntityRotation = (delegate* unmanaged[Cdecl]<int, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntityRotation");
				var result = fn__getEntityRotation(_entity, _rotationOrder);
				return result;
			}
		}

		public Vector3 GetEntityRotationVelocity(int _entity)
		{
			unsafe {
				if (fn__getEntityRotationVelocity == null) fn__getEntityRotationVelocity = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntityRotationVelocity");
				var result = fn__getEntityRotationVelocity(_entity);
				return result;
			}
		}

		public string GetEntityScript(int _entity, ref int _script)
		{
			unsafe {
				if (fn__getEntityScript == null) fn__getEntityScript = (delegate* unmanaged[Cdecl]<int, int*, nint>) NativeLibrary.GetExport(handle, "Native_getEntityScript");
				var ref_script = _script;
				var result = fn__getEntityScript(_entity, &ref_script);
				_script = ref_script;
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public float GetEntitySpeed(int _entity)
		{
			unsafe {
				if (fn__getEntitySpeed == null) fn__getEntitySpeed = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntitySpeed");
				var result = fn__getEntitySpeed(_entity);
				return result;
			}
		}

		public Vector3 GetEntitySpeedVector(int _entity, bool _relative)
		{
			unsafe {
				if (fn__getEntitySpeedVector == null) fn__getEntitySpeedVector = (delegate* unmanaged[Cdecl]<int, bool, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntitySpeedVector");
				var result = fn__getEntitySpeedVector(_entity, _relative);
				return result;
			}
		}

		public float GetEntityUprightValue(int _entity)
		{
			unsafe {
				if (fn__getEntityUprightValue == null) fn__getEntityUprightValue = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntityUprightValue");
				var result = fn__getEntityUprightValue(_entity);
				return result;
			}
		}

		public Vector3 GetEntityVelocity(int _entity)
		{
			unsafe {
				if (fn__getEntityVelocity == null) fn__getEntityVelocity = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntityVelocity");
				var result = fn__getEntityVelocity(_entity);
				return result;
			}
		}

		public int GetObjectIndexFromEntityIndex(int _entity)
		{
			unsafe {
				if (fn__getObjectIndexFromEntityIndex == null) fn__getObjectIndexFromEntityIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getObjectIndexFromEntityIndex");
				var result = fn__getObjectIndexFromEntityIndex(_entity);
				return result;
			}
		}

		public int GetPedIndexFromEntityIndex(int _entity)
		{
			unsafe {
				if (fn__getPedIndexFromEntityIndex == null) fn__getPedIndexFromEntityIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedIndexFromEntityIndex");
				var result = fn__getPedIndexFromEntityIndex(_entity);
				return result;
			}
		}

		public int GetVehicleIndexFromEntityIndex(int _entity)
		{
			unsafe {
				if (fn__getVehicleIndexFromEntityIndex == null) fn__getVehicleIndexFromEntityIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleIndexFromEntityIndex");
				var result = fn__getVehicleIndexFromEntityIndex(_entity);
				return result;
			}
		}

		public Vector3 GetWorldPositionOfEntityBone(int _entity, int _boneIndex)
		{
			unsafe {
				if (fn__getWorldPositionOfEntityBone == null) fn__getWorldPositionOfEntityBone = (delegate* unmanaged[Cdecl]<int, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getWorldPositionOfEntityBone");
				var result = fn__getWorldPositionOfEntityBone(_entity, _boneIndex);
				return result;
			}
		}

		public int GetNearestPlayerToEntity(int _entity)
		{
			unsafe {
				if (fn__getNearestPlayerToEntity == null) fn__getNearestPlayerToEntity = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNearestPlayerToEntity");
				var result = fn__getNearestPlayerToEntity(_entity);
				return result;
			}
		}

		public int GetNearestPlayerToEntityOnTeam(int _entity, int _team)
		{
			unsafe {
				if (fn__getNearestPlayerToEntityOnTeam == null) fn__getNearestPlayerToEntityOnTeam = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getNearestPlayerToEntityOnTeam");
				var result = fn__getNearestPlayerToEntityOnTeam(_entity, _team);
				return result;
			}
		}

		public int GetEntityType(int _entity)
		{
			unsafe {
				if (fn__getEntityType == null) fn__getEntityType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityType");
				var result = fn__getEntityType(_entity);
				return result;
			}
		}

		public int GetEntityPopulationType(int _entity)
		{
			unsafe {
				if (fn__getEntityPopulationType == null) fn__getEntityPopulationType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityPopulationType");
				var result = fn__getEntityPopulationType(_entity);
				return result;
			}
		}

		public bool IsAnEntity(int _handle)
		{
			unsafe {
				if (fn__isAnEntity == null) fn__isAnEntity = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isAnEntity");
				var result = fn__isAnEntity(_handle);
				return result;
			}
		}

		public bool IsEntityAPed(int _entity)
		{
			unsafe {
				if (fn__isEntityAPed == null) fn__isEntityAPed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAPed");
				var result = fn__isEntityAPed(_entity);
				return result;
			}
		}

		public bool IsEntityAMissionEntity(int _entity)
		{
			unsafe {
				if (fn__isEntityAMissionEntity == null) fn__isEntityAMissionEntity = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAMissionEntity");
				var result = fn__isEntityAMissionEntity(_entity);
				return result;
			}
		}

		public bool IsEntityAVehicle(int _entity)
		{
			unsafe {
				if (fn__isEntityAVehicle == null) fn__isEntityAVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAVehicle");
				var result = fn__isEntityAVehicle(_entity);
				return result;
			}
		}

		public bool IsEntityAnObject(int _entity)
		{
			unsafe {
				if (fn__isEntityAnObject == null) fn__isEntityAnObject = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAnObject");
				var result = fn__isEntityAnObject(_entity);
				return result;
			}
		}

		public bool IsEntityAtCoord(int _entity, float _xPos, float _yPos, float _zPos, float _xSize, float _ySize, float _zSize, bool _p7, bool _p8, int _p9)
		{
			unsafe {
				if (fn__isEntityAtCoord == null) fn__isEntityAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAtCoord");
				var result = fn__isEntityAtCoord(_entity, _xPos, _yPos, _zPos, _xSize, _ySize, _zSize, _p7, _p8, _p9);
				return result;
			}
		}

		public bool IsEntityAtEntity(int _entity1, int _entity2, float _xSize, float _ySize, float _zSize, bool _p5, bool _p6, int _p7)
		{
			unsafe {
				if (fn__isEntityAtEntity == null) fn__isEntityAtEntity = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAtEntity");
				var result = fn__isEntityAtEntity(_entity1, _entity2, _xSize, _ySize, _zSize, _p5, _p6, _p7);
				return result;
			}
		}

		public bool IsEntityAttached(int _entity)
		{
			unsafe {
				if (fn__isEntityAttached == null) fn__isEntityAttached = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAttached");
				var result = fn__isEntityAttached(_entity);
				return result;
			}
		}

		public bool IsEntityAttachedToAnyObject(int _entity)
		{
			unsafe {
				if (fn__isEntityAttachedToAnyObject == null) fn__isEntityAttachedToAnyObject = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAttachedToAnyObject");
				var result = fn__isEntityAttachedToAnyObject(_entity);
				return result;
			}
		}

		public bool IsEntityAttachedToAnyPed(int _entity)
		{
			unsafe {
				if (fn__isEntityAttachedToAnyPed == null) fn__isEntityAttachedToAnyPed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAttachedToAnyPed");
				var result = fn__isEntityAttachedToAnyPed(_entity);
				return result;
			}
		}

		public bool IsEntityAttachedToAnyVehicle(int _entity)
		{
			unsafe {
				if (fn__isEntityAttachedToAnyVehicle == null) fn__isEntityAttachedToAnyVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAttachedToAnyVehicle");
				var result = fn__isEntityAttachedToAnyVehicle(_entity);
				return result;
			}
		}

		public bool IsEntityAttachedToEntity(int _from, int _to)
		{
			unsafe {
				if (fn__isEntityAttachedToEntity == null) fn__isEntityAttachedToEntity = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAttachedToEntity");
				var result = fn__isEntityAttachedToEntity(_from, _to);
				return result;
			}
		}

		public bool IsEntityDead(int _entity, bool _p1)
		{
			unsafe {
				if (fn__isEntityDead == null) fn__isEntityDead = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isEntityDead");
				var result = fn__isEntityDead(_entity, _p1);
				return result;
			}
		}

		public bool IsEntityInAir(int _entity)
		{
			unsafe {
				if (fn__isEntityInAir == null) fn__isEntityInAir = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityInAir");
				var result = fn__isEntityInAir(_entity);
				return result;
			}
		}

		public bool IsEntityInAngledArea(int _entity, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width, bool _debug, bool _includeZ, int _p10)
		{
			unsafe {
				if (fn__isEntityInAngledArea == null) fn__isEntityInAngledArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityInAngledArea");
				var result = fn__isEntityInAngledArea(_entity, _x1, _y1, _z1, _x2, _y2, _z2, _width, _debug, _includeZ, _p10);
				return result;
			}
		}

		public bool IsEntityInArea(int _entity, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _p7, bool _p8, int _p9)
		{
			unsafe {
				if (fn__isEntityInArea == null) fn__isEntityInArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityInArea");
				var result = fn__isEntityInArea(_entity, _x1, _y1, _z1, _x2, _y2, _z2, _p7, _p8, _p9);
				return result;
			}
		}

		public bool IsEntityInZone(int _entity, string _zone)
		{
			unsafe {
				if (fn__isEntityInZone == null) fn__isEntityInZone = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_isEntityInZone");
				var ptr_zone = MemoryUtils.StringToHGlobalUtf8(_zone);
				var result = fn__isEntityInZone(_entity, ptr_zone);
				Marshal.FreeHGlobal(ptr_zone);
				return result;
			}
		}

		public bool IsEntityInWater(int _entity)
		{
			unsafe {
				if (fn__isEntityInWater == null) fn__isEntityInWater = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityInWater");
				var result = fn__isEntityInWater(_entity);
				return result;
			}
		}

		public float GetEntitySubmergedLevel(int _entity)
		{
			unsafe {
				if (fn__getEntitySubmergedLevel == null) fn__getEntitySubmergedLevel = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getEntitySubmergedLevel");
				var result = fn__getEntitySubmergedLevel(_entity);
				return result;
			}
		}

		public void _0x694E00132F2823ED(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__0x694E00132F2823ED == null) fn__0x694E00132F2823ED = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x694E00132F2823ED");
				fn__0x694E00132F2823ED(_entity, _toggle);
			}
		}

		public bool IsEntityOnScreen(int _entity)
		{
			unsafe {
				if (fn__isEntityOnScreen == null) fn__isEntityOnScreen = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityOnScreen");
				var result = fn__isEntityOnScreen(_entity);
				return result;
			}
		}

		public bool IsEntityPlayingAnim(int _entity, string _animDict, string _animName, int _taskFlag)
		{
			unsafe {
				if (fn__isEntityPlayingAnim == null) fn__isEntityPlayingAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityPlayingAnim");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var result = fn__isEntityPlayingAnim(_entity, ptr_animDict, ptr_animName, _taskFlag);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				return result;
			}
		}

		public bool IsEntityStatic(int _entity)
		{
			unsafe {
				if (fn__isEntityStatic == null) fn__isEntityStatic = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityStatic");
				var result = fn__isEntityStatic(_entity);
				return result;
			}
		}

		public bool IsEntityTouchingEntity(int _entity, int _targetEntity)
		{
			unsafe {
				if (fn__isEntityTouchingEntity == null) fn__isEntityTouchingEntity = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityTouchingEntity");
				var result = fn__isEntityTouchingEntity(_entity, _targetEntity);
				return result;
			}
		}

		public bool IsEntityTouchingModel(int _entity, int _modelHash)
		{
			unsafe {
				if (fn__isEntityTouchingModel == null) fn__isEntityTouchingModel = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityTouchingModel");
				var result = fn__isEntityTouchingModel(_entity, _modelHash);
				return result;
			}
		}

		public bool IsEntityUpright(int _entity, float _angle)
		{
			unsafe {
				if (fn__isEntityUpright == null) fn__isEntityUpright = (delegate* unmanaged[Cdecl]<int, float, bool>) NativeLibrary.GetExport(handle, "Native_isEntityUpright");
				var result = fn__isEntityUpright(_entity, _angle);
				return result;
			}
		}

		public bool IsEntityUpsidedown(int _entity)
		{
			unsafe {
				if (fn__isEntityUpsidedown == null) fn__isEntityUpsidedown = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityUpsidedown");
				var result = fn__isEntityUpsidedown(_entity);
				return result;
			}
		}

		public bool IsEntityVisible(int _entity)
		{
			unsafe {
				if (fn__isEntityVisible == null) fn__isEntityVisible = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityVisible");
				var result = fn__isEntityVisible(_entity);
				return result;
			}
		}

		public bool IsEntityVisibleToScript(int _entity)
		{
			unsafe {
				if (fn__isEntityVisibleToScript == null) fn__isEntityVisibleToScript = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityVisibleToScript");
				var result = fn__isEntityVisibleToScript(_entity);
				return result;
			}
		}

		public bool IsEntityOccluded(int _entity)
		{
			unsafe {
				if (fn__isEntityOccluded == null) fn__isEntityOccluded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityOccluded");
				var result = fn__isEntityOccluded(_entity);
				return result;
			}
		}

		public bool WouldEntityBeOccluded(int _entityModelHash, float _x, float _y, float _z, bool _p4)
		{
			unsafe {
				if (fn__wouldEntityBeOccluded == null) fn__wouldEntityBeOccluded = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_wouldEntityBeOccluded");
				var result = fn__wouldEntityBeOccluded(_entityModelHash, _x, _y, _z, _p4);
				return result;
			}
		}

		public bool IsEntityWaitingForWorldCollision(int _entity)
		{
			unsafe {
				if (fn__isEntityWaitingForWorldCollision == null) fn__isEntityWaitingForWorldCollision = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityWaitingForWorldCollision");
				var result = fn__isEntityWaitingForWorldCollision(_entity);
				return result;
			}
		}

		public void ApplyForceToEntityCenterOfMass(int _entity, int _forceType, float _x, float _y, float _z, bool _p5, bool _isDirectionRel, bool _isForceRel, bool _p8)
		{
			unsafe {
				if (fn__applyForceToEntityCenterOfMass == null) fn__applyForceToEntityCenterOfMass = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_applyForceToEntityCenterOfMass");
				fn__applyForceToEntityCenterOfMass(_entity, _forceType, _x, _y, _z, _p5, _isDirectionRel, _isForceRel, _p8);
			}
		}

		public void ApplyForceToEntity(int _entity, int _forceFlags, float _x, float _y, float _z, float _offX, float _offY, float _offZ, int _boneIndex, bool _isDirectionRel, bool _ignoreUpVec, bool _isForceRel, bool _p12, bool _p13)
		{
			unsafe {
				if (fn__applyForceToEntity == null) fn__applyForceToEntity = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, int, bool, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_applyForceToEntity");
				fn__applyForceToEntity(_entity, _forceFlags, _x, _y, _z, _offX, _offY, _offZ, _boneIndex, _isDirectionRel, _ignoreUpVec, _isForceRel, _p12, _p13);
			}
		}

		public void AttachEntityToEntity(int _entity1, int _entity2, int _boneIndex, float _xPos, float _yPos, float _zPos, float _xRot, float _yRot, float _zRot, bool _p9, bool _useSoftPinning, bool _collision, bool _isPed, int _vertexIndex, bool _fixedRot)
		{
			unsafe {
				if (fn__attachEntityToEntity == null) fn__attachEntityToEntity = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, float, bool, bool, bool, bool, int, bool, void>) NativeLibrary.GetExport(handle, "Native_attachEntityToEntity");
				fn__attachEntityToEntity(_entity1, _entity2, _boneIndex, _xPos, _yPos, _zPos, _xRot, _yRot, _zRot, _p9, _useSoftPinning, _collision, _isPed, _vertexIndex, _fixedRot);
			}
		}

		public void AttachEntityBoneToEntityBone(int _entity1, int _entity2, int _boneIndex1, int _boneIndex2, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__attachEntityBoneToEntityBone == null) fn__attachEntityBoneToEntityBone = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_attachEntityBoneToEntityBone");
				fn__attachEntityBoneToEntityBone(_entity1, _entity2, _boneIndex1, _boneIndex2, _p4, _p5);
			}
		}

		public void AttachEntityBoneToEntityBonePhysically(int _entity1, int _entity2, int _boneIndex1, int _boneIndex2, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__attachEntityBoneToEntityBonePhysically == null) fn__attachEntityBoneToEntityBonePhysically = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_attachEntityBoneToEntityBonePhysically");
				fn__attachEntityBoneToEntityBonePhysically(_entity1, _entity2, _boneIndex1, _boneIndex2, _p4, _p5);
			}
		}

		public void AttachEntityToEntityPhysically(int _entity1, int _entity2, int _boneIndex1, int _boneIndex2, float _xPos1, float _yPos1, float _zPos1, float _xPos2, float _yPos2, float _zPos2, float _xRot, float _yRot, float _zRot, float _breakForce, bool _fixedRot, bool _p15, bool _collision, bool _p17, int _p18)
		{
			unsafe {
				if (fn__attachEntityToEntityPhysically == null) fn__attachEntityToEntityPhysically = (delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, float, float, float, float, float, float, float, bool, bool, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_attachEntityToEntityPhysically");
				fn__attachEntityToEntityPhysically(_entity1, _entity2, _boneIndex1, _boneIndex2, _xPos1, _yPos1, _zPos1, _xPos2, _yPos2, _zPos2, _xRot, _yRot, _zRot, _breakForce, _fixedRot, _p15, _collision, _p17, _p18);
			}
		}

		public void ProcessEntityAttachments(int _entity)
		{
			unsafe {
				if (fn__processEntityAttachments == null) fn__processEntityAttachments = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_processEntityAttachments");
				fn__processEntityAttachments(_entity);
			}
		}

		public int GetEntityBoneIndexByName(int _entity, string _boneName)
		{
			unsafe {
				if (fn__getEntityBoneIndexByName == null) fn__getEntityBoneIndexByName = (delegate* unmanaged[Cdecl]<int, nint, int>) NativeLibrary.GetExport(handle, "Native_getEntityBoneIndexByName");
				var ptr_boneName = MemoryUtils.StringToHGlobalUtf8(_boneName);
				var result = fn__getEntityBoneIndexByName(_entity, ptr_boneName);
				Marshal.FreeHGlobal(ptr_boneName);
				return result;
			}
		}

		public void ClearEntityLastDamageEntity(int _entity)
		{
			unsafe {
				if (fn__clearEntityLastDamageEntity == null) fn__clearEntityLastDamageEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearEntityLastDamageEntity");
				fn__clearEntityLastDamageEntity(_entity);
			}
		}

		public void DeleteEntity(ref int _entity)
		{
			unsafe {
				if (fn__deleteEntity == null) fn__deleteEntity = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_deleteEntity");
				var ref_entity = _entity;
				fn__deleteEntity(&ref_entity);
				_entity = ref_entity;
			}
		}

		public void DetachEntity(int _entity, bool _dynamic, bool _collision)
		{
			unsafe {
				if (fn__detachEntity == null) fn__detachEntity = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_detachEntity");
				fn__detachEntity(_entity, _dynamic, _collision);
			}
		}

		public void FreezeEntityPosition(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__freezeEntityPosition == null) fn__freezeEntityPosition = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_freezeEntityPosition");
				fn__freezeEntityPosition(_entity, _toggle);
			}
		}

		public void SetEntityCleanupByEngine(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityCleanupByEngine == null) fn__setEntityCleanupByEngine = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityCleanupByEngine");
				fn__setEntityCleanupByEngine(_entity, _toggle);
			}
		}

		public bool PlayEntityAnim(int _entity, string _animName, string _animDict, float _p3, bool _loop, bool _stayInAnim, bool _p6, float _delta, int _bitset)
		{
			unsafe {
				if (fn__playEntityAnim == null) fn__playEntityAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, float, bool, bool, bool, float, int, bool>) NativeLibrary.GetExport(handle, "Native_playEntityAnim");
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var result = fn__playEntityAnim(_entity, ptr_animName, ptr_animDict, _p3, _loop, _stayInAnim, _p6, _delta, _bitset);
				Marshal.FreeHGlobal(ptr_animName);
				Marshal.FreeHGlobal(ptr_animDict);
				return result;
			}
		}

		public bool PlaySynchronizedEntityAnim(int _entity, int _syncedScene, string _animation, string _propName, float _p4, float _p5, int _p6, float _p7)
		{
			unsafe {
				if (fn__playSynchronizedEntityAnim == null) fn__playSynchronizedEntityAnim = (delegate* unmanaged[Cdecl]<int, int, nint, nint, float, float, int, float, bool>) NativeLibrary.GetExport(handle, "Native_playSynchronizedEntityAnim");
				var ptr_animation = MemoryUtils.StringToHGlobalUtf8(_animation);
				var ptr_propName = MemoryUtils.StringToHGlobalUtf8(_propName);
				var result = fn__playSynchronizedEntityAnim(_entity, _syncedScene, ptr_animation, ptr_propName, _p4, _p5, _p6, _p7);
				Marshal.FreeHGlobal(ptr_animation);
				Marshal.FreeHGlobal(ptr_propName);
				return result;
			}
		}

		public bool PlaySynchronizedMapEntityAnim(float _p0, float _p1, float _p2, float _p3, int _p4, int _p5, ref int _p6, ref int _p7, float _p8, float _p9, int _p10, float _p11)
		{
			unsafe {
				if (fn__playSynchronizedMapEntityAnim == null) fn__playSynchronizedMapEntityAnim = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int*, int*, float, float, int, float, bool>) NativeLibrary.GetExport(handle, "Native_playSynchronizedMapEntityAnim");
				var ref_p6 = _p6;
				var ref_p7 = _p7;
				var result = fn__playSynchronizedMapEntityAnim(_p0, _p1, _p2, _p3, _p4, _p5, &ref_p6, &ref_p7, _p8, _p9, _p10, _p11);
				_p6 = ref_p6;
				_p7 = ref_p7;
				return result;
			}
		}

		public bool StopSynchronizedMapEntityAnim(float _p0, float _p1, float _p2, float _p3, int _p4, float _p5)
		{
			unsafe {
				if (fn__stopSynchronizedMapEntityAnim == null) fn__stopSynchronizedMapEntityAnim = (delegate* unmanaged[Cdecl]<float, float, float, float, int, float, bool>) NativeLibrary.GetExport(handle, "Native_stopSynchronizedMapEntityAnim");
				var result = fn__stopSynchronizedMapEntityAnim(_p0, _p1, _p2, _p3, _p4, _p5);
				return result;
			}
		}

		public int StopEntityAnim(int _entity, string _animation, string _animGroup, float _p3)
		{
			unsafe {
				if (fn__stopEntityAnim == null) fn__stopEntityAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, float, int>) NativeLibrary.GetExport(handle, "Native_stopEntityAnim");
				var ptr_animation = MemoryUtils.StringToHGlobalUtf8(_animation);
				var ptr_animGroup = MemoryUtils.StringToHGlobalUtf8(_animGroup);
				var result = fn__stopEntityAnim(_entity, ptr_animation, ptr_animGroup, _p3);
				Marshal.FreeHGlobal(ptr_animation);
				Marshal.FreeHGlobal(ptr_animGroup);
				return result;
			}
		}

		public bool StopSynchronizedEntityAnim(int _entity, float _p1, bool _p2)
		{
			unsafe {
				if (fn__stopSynchronizedEntityAnim == null) fn__stopSynchronizedEntityAnim = (delegate* unmanaged[Cdecl]<int, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_stopSynchronizedEntityAnim");
				var result = fn__stopSynchronizedEntityAnim(_entity, _p1, _p2);
				return result;
			}
		}

		public bool HasAnimEventFired(int _entity, int _actionHash)
		{
			unsafe {
				if (fn__hasAnimEventFired == null) fn__hasAnimEventFired = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasAnimEventFired");
				var result = fn__hasAnimEventFired(_entity, _actionHash);
				return result;
			}
		}

		public bool FindAnimEventPhase(string _animDictionary, string _animName, string _p2, ref int _p3, ref int _p4)
		{
			unsafe {
				if (fn__findAnimEventPhase == null) fn__findAnimEventPhase = (delegate* unmanaged[Cdecl]<nint, nint, nint, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_findAnimEventPhase");
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var ref_p3 = _p3;
				var ref_p4 = _p4;
				var result = fn__findAnimEventPhase(ptr_animDictionary, ptr_animName, ptr_p2, &ref_p3, &ref_p4);
				Marshal.FreeHGlobal(ptr_animDictionary);
				Marshal.FreeHGlobal(ptr_animName);
				Marshal.FreeHGlobal(ptr_p2);
				_p3 = ref_p3;
				_p4 = ref_p4;
				return result;
			}
		}

		public void SetEntityAnimCurrentTime(int _entity, string _animDictionary, string _animName, float _time)
		{
			unsafe {
				if (fn__setEntityAnimCurrentTime == null) fn__setEntityAnimCurrentTime = (delegate* unmanaged[Cdecl]<int, nint, nint, float, void>) NativeLibrary.GetExport(handle, "Native_setEntityAnimCurrentTime");
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				fn__setEntityAnimCurrentTime(_entity, ptr_animDictionary, ptr_animName, _time);
				Marshal.FreeHGlobal(ptr_animDictionary);
				Marshal.FreeHGlobal(ptr_animName);
			}
		}

		public void SetEntityAnimSpeed(int _entity, string _animDictionary, string _animName, float _speedMultiplier)
		{
			unsafe {
				if (fn__setEntityAnimSpeed == null) fn__setEntityAnimSpeed = (delegate* unmanaged[Cdecl]<int, nint, nint, float, void>) NativeLibrary.GetExport(handle, "Native_setEntityAnimSpeed");
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				fn__setEntityAnimSpeed(_entity, ptr_animDictionary, ptr_animName, _speedMultiplier);
				Marshal.FreeHGlobal(ptr_animDictionary);
				Marshal.FreeHGlobal(ptr_animName);
			}
		}

		public void SetEntityAsMissionEntity(int _entity, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setEntityAsMissionEntity == null) fn__setEntityAsMissionEntity = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityAsMissionEntity");
				fn__setEntityAsMissionEntity(_entity, _p1, _p2);
			}
		}

		public void SetEntityAsNoLongerNeeded(ref int _entity)
		{
			unsafe {
				if (fn__setEntityAsNoLongerNeeded == null) fn__setEntityAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_setEntityAsNoLongerNeeded");
				var ref_entity = _entity;
				fn__setEntityAsNoLongerNeeded(&ref_entity);
				_entity = ref_entity;
			}
		}

		public void SetPedAsNoLongerNeeded(ref int _ped)
		{
			unsafe {
				if (fn__setPedAsNoLongerNeeded == null) fn__setPedAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_setPedAsNoLongerNeeded");
				var ref_ped = _ped;
				fn__setPedAsNoLongerNeeded(&ref_ped);
				_ped = ref_ped;
			}
		}

		public void SetVehicleAsNoLongerNeeded(ref int _vehicle)
		{
			unsafe {
				if (fn__setVehicleAsNoLongerNeeded == null) fn__setVehicleAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_setVehicleAsNoLongerNeeded");
				var ref_vehicle = _vehicle;
				fn__setVehicleAsNoLongerNeeded(&ref_vehicle);
				_vehicle = ref_vehicle;
			}
		}

		public void SetObjectAsNoLongerNeeded(ref int _object)
		{
			unsafe {
				if (fn__setObjectAsNoLongerNeeded == null) fn__setObjectAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_setObjectAsNoLongerNeeded");
				var ref_object = _object;
				fn__setObjectAsNoLongerNeeded(&ref_object);
				_object = ref_object;
			}
		}

		public void SetEntityCanBeDamaged(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityCanBeDamaged == null) fn__setEntityCanBeDamaged = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityCanBeDamaged");
				fn__setEntityCanBeDamaged(_entity, _toggle);
			}
		}

		public bool GetEntityCanBeDamaged(int _entity)
		{
			unsafe {
				if (fn__getEntityCanBeDamaged == null) fn__getEntityCanBeDamaged = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getEntityCanBeDamaged");
				var result = fn__getEntityCanBeDamaged(_entity);
				return result;
			}
		}

		public void SetEntityCanBeDamagedByRelationshipGroup(int _entity, bool _bCanBeDamaged, int _relGroup)
		{
			unsafe {
				if (fn__setEntityCanBeDamagedByRelationshipGroup == null) fn__setEntityCanBeDamagedByRelationshipGroup = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setEntityCanBeDamagedByRelationshipGroup");
				fn__setEntityCanBeDamagedByRelationshipGroup(_entity, _bCanBeDamaged, _relGroup);
			}
		}

		public void _0x352E2B5CF420BF3B(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x352E2B5CF420BF3B == null) fn__0x352E2B5CF420BF3B = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x352E2B5CF420BF3B");
				fn__0x352E2B5CF420BF3B(_p0, _p1);
			}
		}

		public void SetEntityCanBeTargetedWithoutLos(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityCanBeTargetedWithoutLos == null) fn__setEntityCanBeTargetedWithoutLos = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityCanBeTargetedWithoutLos");
				fn__setEntityCanBeTargetedWithoutLos(_entity, _toggle);
			}
		}

		public void SetEntityCollision(int _entity, bool _toggle, bool _keepPhysics)
		{
			unsafe {
				if (fn__setEntityCollision == null) fn__setEntityCollision = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityCollision");
				fn__setEntityCollision(_entity, _toggle, _keepPhysics);
			}
		}

		public bool GetEntityCollisionDisabled(int _entity)
		{
			unsafe {
				if (fn__getEntityCollisionDisabled == null) fn__getEntityCollisionDisabled = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getEntityCollisionDisabled");
				var result = fn__getEntityCollisionDisabled(_entity);
				return result;
			}
		}

		public void SetEntityCompletelyDisableCollision(int _entity, bool _toggle, bool _keepPhysics)
		{
			unsafe {
				if (fn__setEntityCompletelyDisableCollision == null) fn__setEntityCompletelyDisableCollision = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityCompletelyDisableCollision");
				fn__setEntityCompletelyDisableCollision(_entity, _toggle, _keepPhysics);
			}
		}

		public void SetEntityCoords(int _entity, float _xPos, float _yPos, float _zPos, bool _xAxis, bool _yAxis, bool _zAxis, bool _clearArea)
		{
			unsafe {
				if (fn__setEntityCoords == null) fn__setEntityCoords = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityCoords");
				fn__setEntityCoords(_entity, _xPos, _yPos, _zPos, _xAxis, _yAxis, _zAxis, _clearArea);
			}
		}

		public void SetEntityCoordsWithoutPlantsReset(int _entity, float _xPos, float _yPos, float _zPos, bool _alive, bool _deadFlag, bool _ragdollFlag, bool _clearArea)
		{
			unsafe {
				if (fn__setEntityCoordsWithoutPlantsReset == null) fn__setEntityCoordsWithoutPlantsReset = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityCoordsWithoutPlantsReset");
				fn__setEntityCoordsWithoutPlantsReset(_entity, _xPos, _yPos, _zPos, _alive, _deadFlag, _ragdollFlag, _clearArea);
			}
		}

		public void SetEntityCoordsNoOffset(int _entity, float _xPos, float _yPos, float _zPos, bool _xAxis, bool _yAxis, bool _zAxis)
		{
			unsafe {
				if (fn__setEntityCoordsNoOffset == null) fn__setEntityCoordsNoOffset = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityCoordsNoOffset");
				fn__setEntityCoordsNoOffset(_entity, _xPos, _yPos, _zPos, _xAxis, _yAxis, _zAxis);
			}
		}

		public void SetEntityDynamic(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityDynamic == null) fn__setEntityDynamic = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityDynamic");
				fn__setEntityDynamic(_entity, _toggle);
			}
		}

		public void SetEntityHeading(int _entity, float _heading)
		{
			unsafe {
				if (fn__setEntityHeading == null) fn__setEntityHeading = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setEntityHeading");
				fn__setEntityHeading(_entity, _heading);
			}
		}

		public void SetEntityHealth(int _entity, int _health, int _p2)
		{
			unsafe {
				if (fn__setEntityHealth == null) fn__setEntityHealth = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setEntityHealth");
				fn__setEntityHealth(_entity, _health, _p2);
			}
		}

		public void SetEntityInvincible(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityInvincible == null) fn__setEntityInvincible = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityInvincible");
				fn__setEntityInvincible(_entity, _toggle);
			}
		}

		public void SetEntityIsTargetPriority(int _entity, bool _p1, float _p2)
		{
			unsafe {
				if (fn__setEntityIsTargetPriority == null) fn__setEntityIsTargetPriority = (delegate* unmanaged[Cdecl]<int, bool, float, void>) NativeLibrary.GetExport(handle, "Native_setEntityIsTargetPriority");
				fn__setEntityIsTargetPriority(_entity, _p1, _p2);
			}
		}

		public void SetEntityLights(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityLights == null) fn__setEntityLights = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityLights");
				fn__setEntityLights(_entity, _toggle);
			}
		}

		public void SetEntityLoadCollisionFlag(int _entity, bool _toggle, int _p2)
		{
			unsafe {
				if (fn__setEntityLoadCollisionFlag == null) fn__setEntityLoadCollisionFlag = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setEntityLoadCollisionFlag");
				fn__setEntityLoadCollisionFlag(_entity, _toggle, _p2);
			}
		}

		public bool HasCollisionLoadedAroundEntity(int _entity)
		{
			unsafe {
				if (fn__hasCollisionLoadedAroundEntity == null) fn__hasCollisionLoadedAroundEntity = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasCollisionLoadedAroundEntity");
				var result = fn__hasCollisionLoadedAroundEntity(_entity);
				return result;
			}
		}

		public void SetEntityMaxSpeed(int _entity, float _speed)
		{
			unsafe {
				if (fn__setEntityMaxSpeed == null) fn__setEntityMaxSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setEntityMaxSpeed");
				fn__setEntityMaxSpeed(_entity, _speed);
			}
		}

		public void SetEntityOnlyDamagedByPlayer(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityOnlyDamagedByPlayer == null) fn__setEntityOnlyDamagedByPlayer = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityOnlyDamagedByPlayer");
				fn__setEntityOnlyDamagedByPlayer(_entity, _toggle);
			}
		}

		public void SetEntityOnlyDamagedByRelationshipGroup(int _entity, bool _p1, int _p2)
		{
			unsafe {
				if (fn__setEntityOnlyDamagedByRelationshipGroup == null) fn__setEntityOnlyDamagedByRelationshipGroup = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setEntityOnlyDamagedByRelationshipGroup");
				fn__setEntityOnlyDamagedByRelationshipGroup(_entity, _p1, _p2);
			}
		}

		public void SetEntityProofs(int _entity, bool _bulletProof, bool _fireProof, bool _explosionProof, bool _collisionProof, bool _meleeProof, bool _p6, bool _p7, bool _drownProof)
		{
			unsafe {
				if (fn__setEntityProofs == null) fn__setEntityProofs = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityProofs");
				fn__setEntityProofs(_entity, _bulletProof, _fireProof, _explosionProof, _collisionProof, _meleeProof, _p6, _p7, _drownProof);
			}
		}

		public bool GetEntityProofs(int _entity, ref bool _bulletProof, ref bool _fireProof, ref bool _explosionProof, ref bool _collisionProof, ref bool _meleeProof, ref bool _steamProof, ref bool _p7, ref bool _drownProof)
		{
			unsafe {
				if (fn__getEntityProofs == null) fn__getEntityProofs = (delegate* unmanaged[Cdecl]<int, bool*, bool*, bool*, bool*, bool*, bool*, bool*, bool*, bool>) NativeLibrary.GetExport(handle, "Native_getEntityProofs");
				var ref_bulletProof = _bulletProof;
				var ref_fireProof = _fireProof;
				var ref_explosionProof = _explosionProof;
				var ref_collisionProof = _collisionProof;
				var ref_meleeProof = _meleeProof;
				var ref_steamProof = _steamProof;
				var ref_p7 = _p7;
				var ref_drownProof = _drownProof;
				var result = fn__getEntityProofs(_entity, &ref_bulletProof, &ref_fireProof, &ref_explosionProof, &ref_collisionProof, &ref_meleeProof, &ref_steamProof, &ref_p7, &ref_drownProof);
				_bulletProof = ref_bulletProof;
				_fireProof = ref_fireProof;
				_explosionProof = ref_explosionProof;
				_collisionProof = ref_collisionProof;
				_meleeProof = ref_meleeProof;
				_steamProof = ref_steamProof;
				_p7 = ref_p7;
				_drownProof = ref_drownProof;
				return result;
			}
		}

		public void SetEntityQuaternion(int _entity, float _x, float _y, float _z, float _w)
		{
			unsafe {
				if (fn__setEntityQuaternion == null) fn__setEntityQuaternion = (delegate* unmanaged[Cdecl]<int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setEntityQuaternion");
				fn__setEntityQuaternion(_entity, _x, _y, _z, _w);
			}
		}

		public void SetEntityRecordsCollisions(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityRecordsCollisions == null) fn__setEntityRecordsCollisions = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityRecordsCollisions");
				fn__setEntityRecordsCollisions(_entity, _toggle);
			}
		}

		public void SetEntityRotation(int _entity, float _pitch, float _roll, float _yaw, int _rotationOrder, bool _p5)
		{
			unsafe {
				if (fn__setEntityRotation == null) fn__setEntityRotation = (delegate* unmanaged[Cdecl]<int, float, float, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityRotation");
				fn__setEntityRotation(_entity, _pitch, _roll, _yaw, _rotationOrder, _p5);
			}
		}

		public void SetEntityVisible(int _entity, bool _toggle, bool _unk)
		{
			unsafe {
				if (fn__setEntityVisible == null) fn__setEntityVisible = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityVisible");
				fn__setEntityVisible(_entity, _toggle, _unk);
			}
		}

		public void _0xC34BC448DA29F5E9(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__0xC34BC448DA29F5E9 == null) fn__0xC34BC448DA29F5E9 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xC34BC448DA29F5E9");
				fn__0xC34BC448DA29F5E9(_entity, _toggle);
			}
		}

		public void _0xE66377CDDADA4810(int _entity, bool _p1)
		{
			unsafe {
				if (fn__0xE66377CDDADA4810 == null) fn__0xE66377CDDADA4810 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xE66377CDDADA4810");
				fn__0xE66377CDDADA4810(_entity, _p1);
			}
		}

		public void SetEntityVelocity(int _entity, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setEntityVelocity == null) fn__setEntityVelocity = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setEntityVelocity");
				fn__setEntityVelocity(_entity, _x, _y, _z);
			}
		}

		public void SetEntityAngularVelocity(int _entity, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setEntityAngularVelocity == null) fn__setEntityAngularVelocity = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setEntityAngularVelocity");
				fn__setEntityAngularVelocity(_entity, _x, _y, _z);
			}
		}

		public void SetEntityHasGravity(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityHasGravity == null) fn__setEntityHasGravity = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityHasGravity");
				fn__setEntityHasGravity(_entity, _toggle);
			}
		}

		public void SetEntityLodDist(int _entity, int _value)
		{
			unsafe {
				if (fn__setEntityLodDist == null) fn__setEntityLodDist = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setEntityLodDist");
				fn__setEntityLodDist(_entity, _value);
			}
		}

		public int GetEntityLodDist(int _entity)
		{
			unsafe {
				if (fn__getEntityLodDist == null) fn__getEntityLodDist = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityLodDist");
				var result = fn__getEntityLodDist(_entity);
				return result;
			}
		}

		public void SetEntityAlpha(int _entity, int _alphaLevel, bool _skin)
		{
			unsafe {
				if (fn__setEntityAlpha == null) fn__setEntityAlpha = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityAlpha");
				fn__setEntityAlpha(_entity, _alphaLevel, _skin);
			}
		}

		public int GetEntityAlpha(int _entity)
		{
			unsafe {
				if (fn__getEntityAlpha == null) fn__getEntityAlpha = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityAlpha");
				var result = fn__getEntityAlpha(_entity);
				return result;
			}
		}

		public void ResetEntityAlpha(int _entity)
		{
			unsafe {
				if (fn__resetEntityAlpha == null) fn__resetEntityAlpha = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetEntityAlpha");
				fn__resetEntityAlpha(_entity);
			}
		}

		public void _0x490861B88F4FD846(int _p0)
		{
			unsafe {
				if (fn__0x490861B88F4FD846 == null) fn__0x490861B88F4FD846 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x490861B88F4FD846");
				fn__0x490861B88F4FD846(_p0);
			}
		}

		public void _0xCEA7C8E1B48FF68C(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xCEA7C8E1B48FF68C == null) fn__0xCEA7C8E1B48FF68C = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xCEA7C8E1B48FF68C");
				fn__0xCEA7C8E1B48FF68C(_p0, _p1);
			}
		}

		public void _0x5C3B791D580E0BC2(int _entity, float _p1)
		{
			unsafe {
				if (fn__0x5C3B791D580E0BC2 == null) fn__0x5C3B791D580E0BC2 = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x5C3B791D580E0BC2");
				fn__0x5C3B791D580E0BC2(_entity, _p1);
			}
		}

		public void SetEntityAlwaysPrerender(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityAlwaysPrerender == null) fn__setEntityAlwaysPrerender = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityAlwaysPrerender");
				fn__setEntityAlwaysPrerender(_entity, _toggle);
			}
		}

		public void SetEntityRenderScorched(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityRenderScorched == null) fn__setEntityRenderScorched = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityRenderScorched");
				fn__setEntityRenderScorched(_entity, _toggle);
			}
		}

		public void SetEntityTrafficlightOverride(int _entity, int _state)
		{
			unsafe {
				if (fn__setEntityTrafficlightOverride == null) fn__setEntityTrafficlightOverride = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setEntityTrafficlightOverride");
				fn__setEntityTrafficlightOverride(_entity, _state);
			}
		}

		public void _0x78E8E3A640178255(int _entity)
		{
			unsafe {
				if (fn__0x78E8E3A640178255 == null) fn__0x78E8E3A640178255 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x78E8E3A640178255");
				fn__0x78E8E3A640178255(_entity);
			}
		}

		public void CreateModelSwap(float _x, float _y, float _z, float _radius, int _originalModel, int _newModel, bool _p6)
		{
			unsafe {
				if (fn__createModelSwap == null) fn__createModelSwap = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_createModelSwap");
				fn__createModelSwap(_x, _y, _z, _radius, _originalModel, _newModel, _p6);
			}
		}

		public void RemoveModelSwap(float _x, float _y, float _z, float _radius, int _originalModel, int _newModel, bool _p6)
		{
			unsafe {
				if (fn__removeModelSwap == null) fn__removeModelSwap = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_removeModelSwap");
				fn__removeModelSwap(_x, _y, _z, _radius, _originalModel, _newModel, _p6);
			}
		}

		public void CreateModelHide(float _x, float _y, float _z, float _radius, int _modelHash, bool _p5)
		{
			unsafe {
				if (fn__createModelHide == null) fn__createModelHide = (delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_createModelHide");
				fn__createModelHide(_x, _y, _z, _radius, _modelHash, _p5);
			}
		}

		public void CreateModelHideExcludingScriptObjects(float _x, float _y, float _z, float _radius, int _modelHash, bool _p5)
		{
			unsafe {
				if (fn__createModelHideExcludingScriptObjects == null) fn__createModelHideExcludingScriptObjects = (delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_createModelHideExcludingScriptObjects");
				fn__createModelHideExcludingScriptObjects(_x, _y, _z, _radius, _modelHash, _p5);
			}
		}

		public void RemoveModelHide(float _x, float _y, float _z, float _radius, int _modelHash, bool _p5)
		{
			unsafe {
				if (fn__removeModelHide == null) fn__removeModelHide = (delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_removeModelHide");
				fn__removeModelHide(_x, _y, _z, _radius, _modelHash, _p5);
			}
		}

		public void CreateForcedObject(float _x, float _y, float _z, int _p3, int _modelHash, bool _p5)
		{
			unsafe {
				if (fn__createForcedObject == null) fn__createForcedObject = (delegate* unmanaged[Cdecl]<float, float, float, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_createForcedObject");
				fn__createForcedObject(_x, _y, _z, _p3, _modelHash, _p5);
			}
		}

		public void RemoveForcedObject(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__removeForcedObject == null) fn__removeForcedObject = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_removeForcedObject");
				fn__removeForcedObject(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void SetEntityNoCollisionEntity(int _entity1, int _entity2, bool _thisFrameOnly)
		{
			unsafe {
				if (fn__setEntityNoCollisionEntity == null) fn__setEntityNoCollisionEntity = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityNoCollisionEntity");
				fn__setEntityNoCollisionEntity(_entity1, _entity2, _thisFrameOnly);
			}
		}

		public void SetEntityMotionBlur(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityMotionBlur == null) fn__setEntityMotionBlur = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityMotionBlur");
				fn__setEntityMotionBlur(_entity, _toggle);
			}
		}

		public void SetCanAutoVaultOnEntity(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setCanAutoVaultOnEntity == null) fn__setCanAutoVaultOnEntity = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCanAutoVaultOnEntity");
				fn__setCanAutoVaultOnEntity(_entity, _toggle);
			}
		}

		public void SetCanClimbOnEntity(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setCanClimbOnEntity == null) fn__setCanClimbOnEntity = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCanClimbOnEntity");
				fn__setCanClimbOnEntity(_entity, _toggle);
			}
		}

		public void _0xDC6F8601FAF2E893(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__0xDC6F8601FAF2E893 == null) fn__0xDC6F8601FAF2E893 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xDC6F8601FAF2E893");
				fn__0xDC6F8601FAF2E893(_entity, _toggle);
			}
		}

		public void SetEntityDecalsDisabled(int _entity, bool _p1)
		{
			unsafe {
				if (fn__setEntityDecalsDisabled == null) fn__setEntityDecalsDisabled = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityDecalsDisabled");
				fn__setEntityDecalsDisabled(_entity, _p1);
			}
		}

		public void _0x1A092BB0C3808B96(int _entity, bool _p1)
		{
			unsafe {
				if (fn__0x1A092BB0C3808B96 == null) fn__0x1A092BB0C3808B96 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x1A092BB0C3808B96");
				fn__0x1A092BB0C3808B96(_entity, _p1);
			}
		}

		public Vector3 GetEntityBoneRotation(int _entity, int _boneIndex)
		{
			unsafe {
				if (fn__getEntityBoneRotation == null) fn__getEntityBoneRotation = (delegate* unmanaged[Cdecl]<int, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntityBoneRotation");
				var result = fn__getEntityBoneRotation(_entity, _boneIndex);
				return result;
			}
		}

		public Vector3 GetEntityBonePosition2(int _entity, int _boneIndex)
		{
			unsafe {
				if (fn__getEntityBonePosition2 == null) fn__getEntityBonePosition2 = (delegate* unmanaged[Cdecl]<int, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntityBonePosition2");
				var result = fn__getEntityBonePosition2(_entity, _boneIndex);
				return result;
			}
		}

		public Vector3 GetEntityBoneRotationLocal(int _entity, int _boneIndex)
		{
			unsafe {
				if (fn__getEntityBoneRotationLocal == null) fn__getEntityBoneRotationLocal = (delegate* unmanaged[Cdecl]<int, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntityBoneRotationLocal");
				var result = fn__getEntityBoneRotationLocal(_entity, _boneIndex);
				return result;
			}
		}

		public int GetEntityBoneCount(int _entity)
		{
			unsafe {
				if (fn__getEntityBoneCount == null) fn__getEntityBoneCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityBoneCount");
				var result = fn__getEntityBoneCount(_entity);
				return result;
			}
		}

		public void EnableEntityUnk(int _entity)
		{
			unsafe {
				if (fn__enableEntityUnk == null) fn__enableEntityUnk = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_enableEntityUnk");
				fn__enableEntityUnk(_entity);
			}
		}

		public void _0xB17BC6453F6CF5AC(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xB17BC6453F6CF5AC == null) fn__0xB17BC6453F6CF5AC = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xB17BC6453F6CF5AC");
				fn__0xB17BC6453F6CF5AC(_p0, _p1);
			}
		}

		public void _0x68B562E124CC0AEF(int _pickup, int _pickup2)
		{
			unsafe {
				if (fn__0x68B562E124CC0AEF == null) fn__0x68B562E124CC0AEF = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x68B562E124CC0AEF");
				fn__0x68B562E124CC0AEF(_pickup, _pickup2);
			}
		}

		public void _0x36F32DE87082343E(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x36F32DE87082343E == null) fn__0x36F32DE87082343E = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x36F32DE87082343E");
				fn__0x36F32DE87082343E(_p0, _p1);
			}
		}

		public int GetEntityPickup(int _entity, int _modelHash)
		{
			unsafe {
				if (fn__getEntityPickup == null) fn__getEntityPickup = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getEntityPickup");
				var result = fn__getEntityPickup(_entity, _modelHash);
				return result;
			}
		}

		public void _0xD7B80E7C3BEFC396(int _pickup, bool _toggle)
		{
			unsafe {
				if (fn__0xD7B80E7C3BEFC396 == null) fn__0xD7B80E7C3BEFC396 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xD7B80E7C3BEFC396");
				fn__0xD7B80E7C3BEFC396(_pickup, _toggle);
			}
		}

		public void SetDecisionMaker(int _ped, int _name)
		{
			unsafe {
				if (fn__setDecisionMaker == null) fn__setDecisionMaker = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setDecisionMaker");
				fn__setDecisionMaker(_ped, _name);
			}
		}

		public void ClearDecisionMakerEventResponse(int _name, int _eventType)
		{
			unsafe {
				if (fn__clearDecisionMakerEventResponse == null) fn__clearDecisionMakerEventResponse = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_clearDecisionMakerEventResponse");
				fn__clearDecisionMakerEventResponse(_name, _eventType);
			}
		}

		public void BlockDecisionMakerEvent(int _name, int _eventType)
		{
			unsafe {
				if (fn__blockDecisionMakerEvent == null) fn__blockDecisionMakerEvent = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_blockDecisionMakerEvent");
				fn__blockDecisionMakerEvent(_name, _eventType);
			}
		}

		public void UnblockDecisionMakerEvent(int _name, int _eventType)
		{
			unsafe {
				if (fn__unblockDecisionMakerEvent == null) fn__unblockDecisionMakerEvent = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_unblockDecisionMakerEvent");
				fn__unblockDecisionMakerEvent(_name, _eventType);
			}
		}

		public int AddShockingEventAtPosition(int _eventType, float _x, float _y, float _z, float _duration)
		{
			unsafe {
				if (fn__addShockingEventAtPosition == null) fn__addShockingEventAtPosition = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_addShockingEventAtPosition");
				var result = fn__addShockingEventAtPosition(_eventType, _x, _y, _z, _duration);
				return result;
			}
		}

		public int AddShockingEventForEntity(int _eventType, int _entity, float _duration)
		{
			unsafe {
				if (fn__addShockingEventForEntity == null) fn__addShockingEventForEntity = (delegate* unmanaged[Cdecl]<int, int, float, int>) NativeLibrary.GetExport(handle, "Native_addShockingEventForEntity");
				var result = fn__addShockingEventForEntity(_eventType, _entity, _duration);
				return result;
			}
		}

		public bool IsShockingEventInSphere(int _eventType, float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__isShockingEventInSphere == null) fn__isShockingEventInSphere = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isShockingEventInSphere");
				var result = fn__isShockingEventInSphere(_eventType, _x, _y, _z, _radius);
				return result;
			}
		}

		public bool RemoveShockingEvent(int _event)
		{
			unsafe {
				if (fn__removeShockingEvent == null) fn__removeShockingEvent = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_removeShockingEvent");
				var result = fn__removeShockingEvent(_event);
				return result;
			}
		}

		public void RemoveAllShockingEvents(bool _p0)
		{
			unsafe {
				if (fn__removeAllShockingEvents == null) fn__removeAllShockingEvents = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_removeAllShockingEvents");
				fn__removeAllShockingEvents(_p0);
			}
		}

		public void RemoveShockingEventSpawnBlockingAreas()
		{
			unsafe {
				if (fn__removeShockingEventSpawnBlockingAreas == null) fn__removeShockingEventSpawnBlockingAreas = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeShockingEventSpawnBlockingAreas");
				fn__removeShockingEventSpawnBlockingAreas();
			}
		}

		public void SuppressShockingEventsNextFrame()
		{
			unsafe {
				if (fn__suppressShockingEventsNextFrame == null) fn__suppressShockingEventsNextFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_suppressShockingEventsNextFrame");
				fn__suppressShockingEventsNextFrame();
			}
		}

		public void SuppressShockingEventTypeNextFrame(int _eventType)
		{
			unsafe {
				if (fn__suppressShockingEventTypeNextFrame == null) fn__suppressShockingEventTypeNextFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_suppressShockingEventTypeNextFrame");
				fn__suppressShockingEventTypeNextFrame(_eventType);
			}
		}

		public void SuppressAgitationEventsNextFrame()
		{
			unsafe {
				if (fn__suppressAgitationEventsNextFrame == null) fn__suppressAgitationEventsNextFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_suppressAgitationEventsNextFrame");
				fn__suppressAgitationEventsNextFrame();
			}
		}

		public int GetNumTattooShopDlcItems(int _character)
		{
			unsafe {
				if (fn__getNumTattooShopDlcItems == null) fn__getNumTattooShopDlcItems = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumTattooShopDlcItems");
				var result = fn__getNumTattooShopDlcItems(_character);
				return result;
			}
		}

		public bool GetTattooShopDlcItemData(int _characterType, int _decorationIndex, ref int _outComponent)
		{
			unsafe {
				if (fn__getTattooShopDlcItemData == null) fn__getTattooShopDlcItemData = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getTattooShopDlcItemData");
				var ref_outComponent = _outComponent;
				var result = fn__getTattooShopDlcItemData(_characterType, _decorationIndex, &ref_outComponent);
				_outComponent = ref_outComponent;
				return result;
			}
		}

		public int _0x10144267DD22866C(int _overlayHash, int _p1, int _character)
		{
			unsafe {
				if (fn__0x10144267DD22866C == null) fn__0x10144267DD22866C = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x10144267DD22866C");
				var result = fn__0x10144267DD22866C(_overlayHash, _p1, _character);
				return result;
			}
		}

		public void InitShopPedComponent(ref int _outComponent)
		{
			unsafe {
				if (fn__initShopPedComponent == null) fn__initShopPedComponent = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_initShopPedComponent");
				var ref_outComponent = _outComponent;
				fn__initShopPedComponent(&ref_outComponent);
				_outComponent = ref_outComponent;
			}
		}

		public void InitShopPedProp(ref int _outProp)
		{
			unsafe {
				if (fn__initShopPedProp == null) fn__initShopPedProp = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_initShopPedProp");
				var ref_outProp = _outProp;
				fn__initShopPedProp(&ref_outProp);
				_outProp = ref_outProp;
			}
		}

		public int SetupShopPedApparelQuery(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__setupShopPedApparelQuery == null) fn__setupShopPedApparelQuery = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_setupShopPedApparelQuery");
				var result = fn__setupShopPedApparelQuery(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public int SetupShopPedApparelQueryTu(int _character, int _p1, int _p2, bool _p3, int _p4, int _componentId)
		{
			unsafe {
				if (fn__setupShopPedApparelQueryTu == null) fn__setupShopPedApparelQueryTu = (delegate* unmanaged[Cdecl]<int, int, int, bool, int, int, int>) NativeLibrary.GetExport(handle, "Native_setupShopPedApparelQueryTu");
				var result = fn__setupShopPedApparelQueryTu(_character, _p1, _p2, _p3, _p4, _componentId);
				return result;
			}
		}

		public void GetShopPedQueryComponent(int _componentId, ref int _outComponent)
		{
			unsafe {
				if (fn__getShopPedQueryComponent == null) fn__getShopPedQueryComponent = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getShopPedQueryComponent");
				var ref_outComponent = _outComponent;
				fn__getShopPedQueryComponent(_componentId, &ref_outComponent);
				_outComponent = ref_outComponent;
			}
		}

		public int _0x96E2929292A4DB77(int _componentHash)
		{
			unsafe {
				if (fn__0x96E2929292A4DB77 == null) fn__0x96E2929292A4DB77 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x96E2929292A4DB77");
				var result = fn__0x96E2929292A4DB77(_componentHash);
				return result;
			}
		}

		public void GetShopPedComponent(int _componentHash, ref int _outComponent)
		{
			unsafe {
				if (fn__getShopPedComponent == null) fn__getShopPedComponent = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getShopPedComponent");
				var ref_outComponent = _outComponent;
				fn__getShopPedComponent(_componentHash, &ref_outComponent);
				_outComponent = ref_outComponent;
			}
		}

		public void GetShopPedQueryProp(int _componentId, ref int _outProp)
		{
			unsafe {
				if (fn__getShopPedQueryProp == null) fn__getShopPedQueryProp = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getShopPedQueryProp");
				var ref_outProp = _outProp;
				fn__getShopPedQueryProp(_componentId, &ref_outProp);
				_outProp = ref_outProp;
			}
		}

		public int _0x6CEBE002E58DEE97(int _componentHash)
		{
			unsafe {
				if (fn__0x6CEBE002E58DEE97 == null) fn__0x6CEBE002E58DEE97 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x6CEBE002E58DEE97");
				var result = fn__0x6CEBE002E58DEE97(_componentHash);
				return result;
			}
		}

		public void GetShopPedProp(int _componentHash, ref int _outProp)
		{
			unsafe {
				if (fn__getShopPedProp == null) fn__getShopPedProp = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getShopPedProp");
				var ref_outProp = _outProp;
				fn__getShopPedProp(_componentHash, &ref_outProp);
				_outProp = ref_outProp;
			}
		}

		public int GetHashNameForComponent(int _entity, int _componentId, int _drawableVariant, int _textureVariant)
		{
			unsafe {
				if (fn__getHashNameForComponent == null) fn__getHashNameForComponent = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getHashNameForComponent");
				var result = fn__getHashNameForComponent(_entity, _componentId, _drawableVariant, _textureVariant);
				return result;
			}
		}

		public int GetHashNameForProp(int _entity, int _componentId, int _propIndex, int _propTextureIndex)
		{
			unsafe {
				if (fn__getHashNameForProp == null) fn__getHashNameForProp = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getHashNameForProp");
				var result = fn__getHashNameForProp(_entity, _componentId, _propIndex, _propTextureIndex);
				return result;
			}
		}

		public int GetItemVariantsCount(int _componentHash)
		{
			unsafe {
				if (fn__getItemVariantsCount == null) fn__getItemVariantsCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getItemVariantsCount");
				var result = fn__getItemVariantsCount(_componentHash);
				return result;
			}
		}

		public int GetShopPedApparelVariantPropCount(int _propHash)
		{
			unsafe {
				if (fn__getShopPedApparelVariantPropCount == null) fn__getShopPedApparelVariantPropCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getShopPedApparelVariantPropCount");
				var result = fn__getShopPedApparelVariantPropCount(_propHash);
				return result;
			}
		}

		public void GetVariantComponent(int _componentHash, int _unkVariantComponentIndex, ref int _nameHash, ref int _enumValue, ref int _componentType)
		{
			unsafe {
				if (fn__getVariantComponent == null) fn__getVariantComponent = (delegate* unmanaged[Cdecl]<int, int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVariantComponent");
				var ref_nameHash = _nameHash;
				var ref_enumValue = _enumValue;
				var ref_componentType = _componentType;
				fn__getVariantComponent(_componentHash, _unkVariantComponentIndex, &ref_nameHash, &ref_enumValue, &ref_componentType);
				_nameHash = ref_nameHash;
				_enumValue = ref_enumValue;
				_componentType = ref_componentType;
			}
		}

		public void GetVariantProp(int _componentHash, int _unkVariantPropIndex, ref int _nameHash, ref int _enumValue, ref int _anchorPoint)
		{
			unsafe {
				if (fn__getVariantProp == null) fn__getVariantProp = (delegate* unmanaged[Cdecl]<int, int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVariantProp");
				var ref_nameHash = _nameHash;
				var ref_enumValue = _enumValue;
				var ref_anchorPoint = _anchorPoint;
				fn__getVariantProp(_componentHash, _unkVariantPropIndex, &ref_nameHash, &ref_enumValue, &ref_anchorPoint);
				_nameHash = ref_nameHash;
				_enumValue = ref_enumValue;
				_anchorPoint = ref_anchorPoint;
			}
		}

		public int GetShopPedApparelForcedComponentCount(int _componentHash)
		{
			unsafe {
				if (fn__getShopPedApparelForcedComponentCount == null) fn__getShopPedApparelForcedComponentCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getShopPedApparelForcedComponentCount");
				var result = fn__getShopPedApparelForcedComponentCount(_componentHash);
				return result;
			}
		}

		public int GetShopPedApparelForcedPropCount(int _componentHash)
		{
			unsafe {
				if (fn__getShopPedApparelForcedPropCount == null) fn__getShopPedApparelForcedPropCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getShopPedApparelForcedPropCount");
				var result = fn__getShopPedApparelForcedPropCount(_componentHash);
				return result;
			}
		}

		public void GetForcedComponent(int _componentHash, int _forcedComponentIndex, ref int _nameHash, ref int _enumValue, ref int _componentType)
		{
			unsafe {
				if (fn__getForcedComponent == null) fn__getForcedComponent = (delegate* unmanaged[Cdecl]<int, int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getForcedComponent");
				var ref_nameHash = _nameHash;
				var ref_enumValue = _enumValue;
				var ref_componentType = _componentType;
				fn__getForcedComponent(_componentHash, _forcedComponentIndex, &ref_nameHash, &ref_enumValue, &ref_componentType);
				_nameHash = ref_nameHash;
				_enumValue = ref_enumValue;
				_componentType = ref_componentType;
			}
		}

		public void GetForcedProp(int _componentHash, int _forcedPropIndex, ref int _nameHash, ref int _enumValue, ref int _anchorPoint)
		{
			unsafe {
				if (fn__getForcedProp == null) fn__getForcedProp = (delegate* unmanaged[Cdecl]<int, int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getForcedProp");
				var ref_nameHash = _nameHash;
				var ref_enumValue = _enumValue;
				var ref_anchorPoint = _anchorPoint;
				fn__getForcedProp(_componentHash, _forcedPropIndex, &ref_nameHash, &ref_enumValue, &ref_anchorPoint);
				_nameHash = ref_nameHash;
				_enumValue = ref_enumValue;
				_anchorPoint = ref_anchorPoint;
			}
		}

		public bool IsTagRestricted(int _componentHash, int _restrictionTagHash, int _componentId)
		{
			unsafe {
				if (fn__isTagRestricted == null) fn__isTagRestricted = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_isTagRestricted");
				var result = fn__isTagRestricted(_componentHash, _restrictionTagHash, _componentId);
				return result;
			}
		}

		public int SetupShopPedOutfitQuery(int _character, bool _p1)
		{
			unsafe {
				if (fn__setupShopPedOutfitQuery == null) fn__setupShopPedOutfitQuery = (delegate* unmanaged[Cdecl]<int, bool, int>) NativeLibrary.GetExport(handle, "Native_setupShopPedOutfitQuery");
				var result = fn__setupShopPedOutfitQuery(_character, _p1);
				return result;
			}
		}

		public void GetShopPedQueryOutfit(int _outfitIndex, ref int _outfit)
		{
			unsafe {
				if (fn__getShopPedQueryOutfit == null) fn__getShopPedQueryOutfit = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getShopPedQueryOutfit");
				var ref_outfit = _outfit;
				fn__getShopPedQueryOutfit(_outfitIndex, &ref_outfit);
				_outfit = ref_outfit;
			}
		}

		public void GetShopPedOutfit(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__getShopPedOutfit == null) fn__getShopPedOutfit = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getShopPedOutfit");
				var ref_p1 = _p1;
				fn__getShopPedOutfit(_p0, &ref_p1);
				_p1 = ref_p1;
			}
		}

		public int GetShopPedOutfitLocate(int _p0)
		{
			unsafe {
				if (fn__getShopPedOutfitLocate == null) fn__getShopPedOutfitLocate = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getShopPedOutfitLocate");
				var result = fn__getShopPedOutfitLocate(_p0);
				return result;
			}
		}

		public bool GetShopPedOutfitPropVariant(int _outfitHash, int _unkVariantIndex, ref int _outPropVariant)
		{
			unsafe {
				if (fn__getShopPedOutfitPropVariant == null) fn__getShopPedOutfitPropVariant = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getShopPedOutfitPropVariant");
				var ref_outPropVariant = _outPropVariant;
				var result = fn__getShopPedOutfitPropVariant(_outfitHash, _unkVariantIndex, &ref_outPropVariant);
				_outPropVariant = ref_outPropVariant;
				return result;
			}
		}

		public bool GetShopPedOutfitComponentVariant(int _outfitHash, int _unkVariantIndex, ref int _outComponentVariant)
		{
			unsafe {
				if (fn__getShopPedOutfitComponentVariant == null) fn__getShopPedOutfitComponentVariant = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getShopPedOutfitComponentVariant");
				var ref_outComponentVariant = _outComponentVariant;
				var result = fn__getShopPedOutfitComponentVariant(_outfitHash, _unkVariantIndex, &ref_outComponentVariant);
				_outComponentVariant = ref_outComponentVariant;
				return result;
			}
		}

		public int GetNumDlcVehicles()
		{
			unsafe {
				if (fn__getNumDlcVehicles == null) fn__getNumDlcVehicles = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumDlcVehicles");
				var result = fn__getNumDlcVehicles();
				return result;
			}
		}

		public int GetDlcVehicleModel(int _dlcVehicleIndex)
		{
			unsafe {
				if (fn__getDlcVehicleModel == null) fn__getDlcVehicleModel = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getDlcVehicleModel");
				var result = fn__getDlcVehicleModel(_dlcVehicleIndex);
				return result;
			}
		}

		public bool GetDlcVehicleData(int _dlcVehicleIndex, ref int _outData)
		{
			unsafe {
				if (fn__getDlcVehicleData == null) fn__getDlcVehicleData = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getDlcVehicleData");
				var ref_outData = _outData;
				var result = fn__getDlcVehicleData(_dlcVehicleIndex, &ref_outData);
				_outData = ref_outData;
				return result;
			}
		}

		public int GetDlcVehicleFlags(int _dlcVehicleIndex)
		{
			unsafe {
				if (fn__getDlcVehicleFlags == null) fn__getDlcVehicleFlags = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getDlcVehicleFlags");
				var result = fn__getDlcVehicleFlags(_dlcVehicleIndex);
				return result;
			}
		}

		public int GetNumDlcWeapons()
		{
			unsafe {
				if (fn__getNumDlcWeapons == null) fn__getNumDlcWeapons = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumDlcWeapons");
				var result = fn__getNumDlcWeapons();
				return result;
			}
		}

		public int GetNumDlcWeaponsSp()
		{
			unsafe {
				if (fn__getNumDlcWeaponsSp == null) fn__getNumDlcWeaponsSp = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumDlcWeaponsSp");
				var result = fn__getNumDlcWeaponsSp();
				return result;
			}
		}

		public bool GetDlcWeaponData(int _dlcWeaponIndex, ref int _outData)
		{
			unsafe {
				if (fn__getDlcWeaponData == null) fn__getDlcWeaponData = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getDlcWeaponData");
				var ref_outData = _outData;
				var result = fn__getDlcWeaponData(_dlcWeaponIndex, &ref_outData);
				_outData = ref_outData;
				return result;
			}
		}

		public bool GetDlcWeaponDataSp(int _dlcWeaponIndex, ref int _outData)
		{
			unsafe {
				if (fn__getDlcWeaponDataSp == null) fn__getDlcWeaponDataSp = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getDlcWeaponDataSp");
				var ref_outData = _outData;
				var result = fn__getDlcWeaponDataSp(_dlcWeaponIndex, &ref_outData);
				_outData = ref_outData;
				return result;
			}
		}

		public int GetNumDlcWeaponComponents(int _dlcWeaponIndex)
		{
			unsafe {
				if (fn__getNumDlcWeaponComponents == null) fn__getNumDlcWeaponComponents = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumDlcWeaponComponents");
				var result = fn__getNumDlcWeaponComponents(_dlcWeaponIndex);
				return result;
			}
		}

		public int GetNumDlcWeaponComponentsSp(int _dlcWeaponIndex)
		{
			unsafe {
				if (fn__getNumDlcWeaponComponentsSp == null) fn__getNumDlcWeaponComponentsSp = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumDlcWeaponComponentsSp");
				var result = fn__getNumDlcWeaponComponentsSp(_dlcWeaponIndex);
				return result;
			}
		}

		public bool GetDlcWeaponComponentData(int _dlcWeaponIndex, int _dlcWeapCompIndex, ref int _ComponentDataPtr)
		{
			unsafe {
				if (fn__getDlcWeaponComponentData == null) fn__getDlcWeaponComponentData = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getDlcWeaponComponentData");
				var ref_ComponentDataPtr = _ComponentDataPtr;
				var result = fn__getDlcWeaponComponentData(_dlcWeaponIndex, _dlcWeapCompIndex, &ref_ComponentDataPtr);
				_ComponentDataPtr = ref_ComponentDataPtr;
				return result;
			}
		}

		public bool GetDlcWeaponComponentDataSp(int _dlcWeaponIndex, int _dlcWeapCompIndex, ref int _ComponentDataPtr)
		{
			unsafe {
				if (fn__getDlcWeaponComponentDataSp == null) fn__getDlcWeaponComponentDataSp = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getDlcWeaponComponentDataSp");
				var ref_ComponentDataPtr = _ComponentDataPtr;
				var result = fn__getDlcWeaponComponentDataSp(_dlcWeaponIndex, _dlcWeapCompIndex, &ref_ComponentDataPtr);
				_ComponentDataPtr = ref_ComponentDataPtr;
				return result;
			}
		}

		public bool IsContentItemLocked(int _itemHash)
		{
			unsafe {
				if (fn__isContentItemLocked == null) fn__isContentItemLocked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isContentItemLocked");
				var result = fn__isContentItemLocked(_itemHash);
				return result;
			}
		}

		public bool IsDlcVehicleMod(int _hash)
		{
			unsafe {
				if (fn__isDlcVehicleMod == null) fn__isDlcVehicleMod = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isDlcVehicleMod");
				var result = fn__isDlcVehicleMod(_hash);
				return result;
			}
		}

		public int GetDlcVehicleModLockHash(int _hash)
		{
			unsafe {
				if (fn__getDlcVehicleModLockHash == null) fn__getDlcVehicleModLockHash = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getDlcVehicleModLockHash");
				var result = fn__getDlcVehicleModLockHash(_hash);
				return result;
			}
		}

		public void LoadContentChangeSetGroup(int _hash)
		{
			unsafe {
				if (fn__loadContentChangeSetGroup == null) fn__loadContentChangeSetGroup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_loadContentChangeSetGroup");
				fn__loadContentChangeSetGroup(_hash);
			}
		}

		public void UnloadContentChangeSetGroup(int _hash)
		{
			unsafe {
				if (fn__unloadContentChangeSetGroup == null) fn__unloadContentChangeSetGroup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_unloadContentChangeSetGroup");
				fn__unloadContentChangeSetGroup(_hash);
			}
		}

		public int StartScriptFire(float _X, float _Y, float _Z, int _maxChildren, bool _isGasFire)
		{
			unsafe {
				if (fn__startScriptFire == null) fn__startScriptFire = (delegate* unmanaged[Cdecl]<float, float, float, int, bool, int>) NativeLibrary.GetExport(handle, "Native_startScriptFire");
				var result = fn__startScriptFire(_X, _Y, _Z, _maxChildren, _isGasFire);
				return result;
			}
		}

		public void RemoveScriptFire(int _fireHandle)
		{
			unsafe {
				if (fn__removeScriptFire == null) fn__removeScriptFire = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeScriptFire");
				fn__removeScriptFire(_fireHandle);
			}
		}

		public int StartEntityFire(int _entity)
		{
			unsafe {
				if (fn__startEntityFire == null) fn__startEntityFire = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_startEntityFire");
				var result = fn__startEntityFire(_entity);
				return result;
			}
		}

		public void StopEntityFire(int _entity)
		{
			unsafe {
				if (fn__stopEntityFire == null) fn__stopEntityFire = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopEntityFire");
				fn__stopEntityFire(_entity);
			}
		}

		public bool IsEntityOnFire(int _entity)
		{
			unsafe {
				if (fn__isEntityOnFire == null) fn__isEntityOnFire = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityOnFire");
				var result = fn__isEntityOnFire(_entity);
				return result;
			}
		}

		public int GetNumberOfFiresInRange(float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__getNumberOfFiresInRange == null) fn__getNumberOfFiresInRange = (delegate* unmanaged[Cdecl]<float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfFiresInRange");
				var result = fn__getNumberOfFiresInRange(_x, _y, _z, _radius);
				return result;
			}
		}

		public void SetFireSpreadRate(float _p0)
		{
			unsafe {
				if (fn__setFireSpreadRate == null) fn__setFireSpreadRate = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setFireSpreadRate");
				fn__setFireSpreadRate(_p0);
			}
		}

		public void StopFireInRange(float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__stopFireInRange == null) fn__stopFireInRange = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_stopFireInRange");
				fn__stopFireInRange(_x, _y, _z, _radius);
			}
		}

		public bool GetClosestFirePos(ref Vector3 _outPosition, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__getClosestFirePos == null) fn__getClosestFirePos = (delegate* unmanaged[Cdecl]<Vector3*, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_getClosestFirePos");
				var ref_outPosition = _outPosition;
				var result = fn__getClosestFirePos(&ref_outPosition, _x, _y, _z);
				_outPosition = ref_outPosition;
				return result;
			}
		}

		public void AddExplosion(float _x, float _y, float _z, int _explosionType, float _damageScale, bool _isAudible, bool _isInvisible, float _cameraShake, bool _noDamage)
		{
			unsafe {
				if (fn__addExplosion == null) fn__addExplosion = (delegate* unmanaged[Cdecl]<float, float, float, int, float, bool, bool, float, bool, void>) NativeLibrary.GetExport(handle, "Native_addExplosion");
				fn__addExplosion(_x, _y, _z, _explosionType, _damageScale, _isAudible, _isInvisible, _cameraShake, _noDamage);
			}
		}

		public void AddOwnedExplosion(int _ped, float _x, float _y, float _z, int _explosionType, float _damageScale, bool _isAudible, bool _isInvisible, float _cameraShake)
		{
			unsafe {
				if (fn__addOwnedExplosion == null) fn__addOwnedExplosion = (delegate* unmanaged[Cdecl]<int, float, float, float, int, float, bool, bool, float, void>) NativeLibrary.GetExport(handle, "Native_addOwnedExplosion");
				fn__addOwnedExplosion(_ped, _x, _y, _z, _explosionType, _damageScale, _isAudible, _isInvisible, _cameraShake);
			}
		}

		public void AddExplosionWithUserVfx(float _x, float _y, float _z, int _explosionType, int _explosionFx, float _damageScale, bool _isAudible, bool _isInvisible, float _cameraShake)
		{
			unsafe {
				if (fn__addExplosionWithUserVfx == null) fn__addExplosionWithUserVfx = (delegate* unmanaged[Cdecl]<float, float, float, int, int, float, bool, bool, float, void>) NativeLibrary.GetExport(handle, "Native_addExplosionWithUserVfx");
				fn__addExplosionWithUserVfx(_x, _y, _z, _explosionType, _explosionFx, _damageScale, _isAudible, _isInvisible, _cameraShake);
			}
		}

		public bool IsExplosionInArea(int _explosionType, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__isExplosionInArea == null) fn__isExplosionInArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isExplosionInArea");
				var result = fn__isExplosionInArea(_explosionType, _x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public bool IsExplosionActiveInArea(int _explosionType, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__isExplosionActiveInArea == null) fn__isExplosionActiveInArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isExplosionActiveInArea");
				var result = fn__isExplosionActiveInArea(_explosionType, _x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public bool IsExplosionInSphere(int _explosionType, float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__isExplosionInSphere == null) fn__isExplosionInSphere = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isExplosionInSphere");
				var result = fn__isExplosionInSphere(_explosionType, _x, _y, _z, _radius);
				return result;
			}
		}

		public int GetEntityInsideExplosionSphere(int _explosionType, float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__getEntityInsideExplosionSphere == null) fn__getEntityInsideExplosionSphere = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_getEntityInsideExplosionSphere");
				var result = fn__getEntityInsideExplosionSphere(_explosionType, _x, _y, _z, _radius);
				return result;
			}
		}

		public bool IsExplosionInAngledArea(int _explosionType, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width)
		{
			unsafe {
				if (fn__isExplosionInAngledArea == null) fn__isExplosionInAngledArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isExplosionInAngledArea");
				var result = fn__isExplosionInAngledArea(_explosionType, _x1, _y1, _z1, _x2, _y2, _z2, _width);
				return result;
			}
		}

		public int GetEntityInsideExplosionArea(int _explosionType, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _radius)
		{
			unsafe {
				if (fn__getEntityInsideExplosionArea == null) fn__getEntityInsideExplosionArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_getEntityInsideExplosionArea");
				var result = fn__getEntityInsideExplosionArea(_explosionType, _x1, _y1, _z1, _x2, _y2, _z2, _radius);
				return result;
			}
		}

		public void BeginTextCommandBusyspinnerOn(string _string)
		{
			unsafe {
				if (fn__beginTextCommandBusyspinnerOn == null) fn__beginTextCommandBusyspinnerOn = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandBusyspinnerOn");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				fn__beginTextCommandBusyspinnerOn(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
			}
		}

		public void EndTextCommandBusyspinnerOn(int _busySpinnerType)
		{
			unsafe {
				if (fn__endTextCommandBusyspinnerOn == null) fn__endTextCommandBusyspinnerOn = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_endTextCommandBusyspinnerOn");
				fn__endTextCommandBusyspinnerOn(_busySpinnerType);
			}
		}

		public void BusyspinnerOff()
		{
			unsafe {
				if (fn__busyspinnerOff == null) fn__busyspinnerOff = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_busyspinnerOff");
				fn__busyspinnerOff();
			}
		}

		public void PreloadBusyspinner()
		{
			unsafe {
				if (fn__preloadBusyspinner == null) fn__preloadBusyspinner = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_preloadBusyspinner");
				fn__preloadBusyspinner();
			}
		}

		public bool BusyspinnerIsOn()
		{
			unsafe {
				if (fn__busyspinnerIsOn == null) fn__busyspinnerIsOn = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_busyspinnerIsOn");
				var result = fn__busyspinnerIsOn();
				return result;
			}
		}

		public bool BusyspinnerIsDisplaying()
		{
			unsafe {
				if (fn__busyspinnerIsDisplaying == null) fn__busyspinnerIsDisplaying = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_busyspinnerIsDisplaying");
				var result = fn__busyspinnerIsDisplaying();
				return result;
			}
		}

		public void _0x9245E81072704B8A(bool _p0)
		{
			unsafe {
				if (fn__0x9245E81072704B8A == null) fn__0x9245E81072704B8A = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x9245E81072704B8A");
				fn__0x9245E81072704B8A(_p0);
			}
		}

		public void SetMouseCursorActiveThisFrame()
		{
			unsafe {
				if (fn__setMouseCursorActiveThisFrame == null) fn__setMouseCursorActiveThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setMouseCursorActiveThisFrame");
				fn__setMouseCursorActiveThisFrame();
			}
		}

		public void SetMouseCursorSprite(int _spriteId)
		{
			unsafe {
				if (fn__setMouseCursorSprite == null) fn__setMouseCursorSprite = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setMouseCursorSprite");
				fn__setMouseCursorSprite(_spriteId);
			}
		}

		public void SetMouseCursorVisibleInMenus(bool _toggle)
		{
			unsafe {
				if (fn__setMouseCursorVisibleInMenus == null) fn__setMouseCursorVisibleInMenus = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMouseCursorVisibleInMenus");
				fn__setMouseCursorVisibleInMenus(_toggle);
			}
		}

		public int _0x3D9ACB1EB139E702()
		{
			unsafe {
				if (fn__0x3D9ACB1EB139E702 == null) fn__0x3D9ACB1EB139E702 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x3D9ACB1EB139E702");
				var result = fn__0x3D9ACB1EB139E702();
				return result;
			}
		}

		public bool _0x632B2940C67F4EA9(int _scaleformHandle, ref int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__0x632B2940C67F4EA9 == null) fn__0x632B2940C67F4EA9 = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x632B2940C67F4EA9");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				var result = fn__0x632B2940C67F4EA9(_scaleformHandle, &ref_p1, &ref_p2, &ref_p3);
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
				return result;
			}
		}

		public void ThefeedOnlyShowTooltips(bool _toggle)
		{
			unsafe {
				if (fn__thefeedOnlyShowTooltips == null) fn__thefeedOnlyShowTooltips = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_thefeedOnlyShowTooltips");
				fn__thefeedOnlyShowTooltips(_toggle);
			}
		}

		public void ThefeedSetScriptedMenuHeight(float _pos)
		{
			unsafe {
				if (fn__thefeedSetScriptedMenuHeight == null) fn__thefeedSetScriptedMenuHeight = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_thefeedSetScriptedMenuHeight");
				fn__thefeedSetScriptedMenuHeight(_pos);
			}
		}

		public void ThefeedDisableLoadingScreenTips()
		{
			unsafe {
				if (fn__thefeedDisableLoadingScreenTips == null) fn__thefeedDisableLoadingScreenTips = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedDisableLoadingScreenTips");
				fn__thefeedDisableLoadingScreenTips();
			}
		}

		public void ThefeedHideThisFrame()
		{
			unsafe {
				if (fn__thefeedHideThisFrame == null) fn__thefeedHideThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedHideThisFrame");
				fn__thefeedHideThisFrame();
			}
		}

		public void ThefeedDisplayLoadingScreenTips()
		{
			unsafe {
				if (fn__thefeedDisplayLoadingScreenTips == null) fn__thefeedDisplayLoadingScreenTips = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedDisplayLoadingScreenTips");
				fn__thefeedDisplayLoadingScreenTips();
			}
		}

		public void ThefeedFlushQueue()
		{
			unsafe {
				if (fn__thefeedFlushQueue == null) fn__thefeedFlushQueue = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedFlushQueue");
				fn__thefeedFlushQueue();
			}
		}

		public void ThefeedRemoveItem(int _notificationId)
		{
			unsafe {
				if (fn__thefeedRemoveItem == null) fn__thefeedRemoveItem = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_thefeedRemoveItem");
				fn__thefeedRemoveItem(_notificationId);
			}
		}

		public void ThefeedForceRenderOn()
		{
			unsafe {
				if (fn__thefeedForceRenderOn == null) fn__thefeedForceRenderOn = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedForceRenderOn");
				fn__thefeedForceRenderOn();
			}
		}

		public void ThefeedForceRenderOff()
		{
			unsafe {
				if (fn__thefeedForceRenderOff == null) fn__thefeedForceRenderOff = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedForceRenderOff");
				fn__thefeedForceRenderOff();
			}
		}

		public void ThefeedPause()
		{
			unsafe {
				if (fn__thefeedPause == null) fn__thefeedPause = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedPause");
				fn__thefeedPause();
			}
		}

		public void ThefeedResume()
		{
			unsafe {
				if (fn__thefeedResume == null) fn__thefeedResume = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedResume");
				fn__thefeedResume();
			}
		}

		public bool ThefeedIsPaused()
		{
			unsafe {
				if (fn__thefeedIsPaused == null) fn__thefeedIsPaused = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_thefeedIsPaused");
				var result = fn__thefeedIsPaused();
				return result;
			}
		}

		public void ThefeedSpsExtendWidescreenOn()
		{
			unsafe {
				if (fn__thefeedSpsExtendWidescreenOn == null) fn__thefeedSpsExtendWidescreenOn = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedSpsExtendWidescreenOn");
				fn__thefeedSpsExtendWidescreenOn();
			}
		}

		public void ThefeedSpsExtendWidescreenOff()
		{
			unsafe {
				if (fn__thefeedSpsExtendWidescreenOff == null) fn__thefeedSpsExtendWidescreenOff = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedSpsExtendWidescreenOff");
				fn__thefeedSpsExtendWidescreenOff();
			}
		}

		public int ThefeedGetFirstVisibleDeleteRemaining()
		{
			unsafe {
				if (fn__thefeedGetFirstVisibleDeleteRemaining == null) fn__thefeedGetFirstVisibleDeleteRemaining = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_thefeedGetFirstVisibleDeleteRemaining");
				var result = fn__thefeedGetFirstVisibleDeleteRemaining();
				return result;
			}
		}

		public void ThefeedCommentTeleportPoolOn()
		{
			unsafe {
				if (fn__thefeedCommentTeleportPoolOn == null) fn__thefeedCommentTeleportPoolOn = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedCommentTeleportPoolOn");
				fn__thefeedCommentTeleportPoolOn();
			}
		}

		public void ThefeedCommentTeleportPoolOff()
		{
			unsafe {
				if (fn__thefeedCommentTeleportPoolOff == null) fn__thefeedCommentTeleportPoolOff = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedCommentTeleportPoolOff");
				fn__thefeedCommentTeleportPoolOff();
			}
		}

		public void ThefeedSetNextPostBackgroundColor(int _hudColorIndex)
		{
			unsafe {
				if (fn__thefeedSetNextPostBackgroundColor == null) fn__thefeedSetNextPostBackgroundColor = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_thefeedSetNextPostBackgroundColor");
				fn__thefeedSetNextPostBackgroundColor(_hudColorIndex);
			}
		}

		public void ThefeedSetAnimpostfxColor(int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__thefeedSetAnimpostfxColor == null) fn__thefeedSetAnimpostfxColor = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_thefeedSetAnimpostfxColor");
				fn__thefeedSetAnimpostfxColor(_red, _green, _blue, _alpha);
			}
		}

		public void ThefeedSetAnimpostfxCount(int _count)
		{
			unsafe {
				if (fn__thefeedSetAnimpostfxCount == null) fn__thefeedSetAnimpostfxCount = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_thefeedSetAnimpostfxCount");
				fn__thefeedSetAnimpostfxCount(_count);
			}
		}

		public void ThefeedSetAnimpostfxSound(bool _toggle)
		{
			unsafe {
				if (fn__thefeedSetAnimpostfxSound == null) fn__thefeedSetAnimpostfxSound = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_thefeedSetAnimpostfxSound");
				fn__thefeedSetAnimpostfxSound(_toggle);
			}
		}

		public void ThefeedResetAllParameters()
		{
			unsafe {
				if (fn__thefeedResetAllParameters == null) fn__thefeedResetAllParameters = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedResetAllParameters");
				fn__thefeedResetAllParameters();
			}
		}

		public void ThefeedFreezeNextPost()
		{
			unsafe {
				if (fn__thefeedFreezeNextPost == null) fn__thefeedFreezeNextPost = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedFreezeNextPost");
				fn__thefeedFreezeNextPost();
			}
		}

		public void ThefeedClearFrozenPost()
		{
			unsafe {
				if (fn__thefeedClearFrozenPost == null) fn__thefeedClearFrozenPost = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_thefeedClearFrozenPost");
				fn__thefeedClearFrozenPost();
			}
		}

		public void ThefeedSetFlushAnimpostfx(bool _p0)
		{
			unsafe {
				if (fn__thefeedSetFlushAnimpostfx == null) fn__thefeedSetFlushAnimpostfx = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_thefeedSetFlushAnimpostfx");
				fn__thefeedSetFlushAnimpostfx(_p0);
			}
		}

		public void ThefeedAddTxdRef(ref int _p0, ref int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__thefeedAddTxdRef == null) fn__thefeedAddTxdRef = (delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_thefeedAddTxdRef");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				fn__thefeedAddTxdRef(&ref_p0, &ref_p1, &ref_p2, &ref_p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
			}
		}

		public void BeginTextCommandThefeedPost(string _text)
		{
			unsafe {
				if (fn__beginTextCommandThefeedPost == null) fn__beginTextCommandThefeedPost = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandThefeedPost");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				fn__beginTextCommandThefeedPost(ptr_text);
				Marshal.FreeHGlobal(ptr_text);
			}
		}

		public int EndTextCommandThefeedPostStats(string _statTitle, int _iconEnum, bool _stepVal, int _barValue, bool _isImportant, string _pictureTextureDict, string _pictureTextureName)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostStats == null) fn__endTextCommandThefeedPostStats = (delegate* unmanaged[Cdecl]<nint, int, bool, int, bool, nint, nint, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostStats");
				var ptr_statTitle = MemoryUtils.StringToHGlobalUtf8(_statTitle);
				var ptr_pictureTextureDict = MemoryUtils.StringToHGlobalUtf8(_pictureTextureDict);
				var ptr_pictureTextureName = MemoryUtils.StringToHGlobalUtf8(_pictureTextureName);
				var result = fn__endTextCommandThefeedPostStats(ptr_statTitle, _iconEnum, _stepVal, _barValue, _isImportant, ptr_pictureTextureDict, ptr_pictureTextureName);
				Marshal.FreeHGlobal(ptr_statTitle);
				Marshal.FreeHGlobal(ptr_pictureTextureDict);
				Marshal.FreeHGlobal(ptr_pictureTextureName);
				return result;
			}
		}

		public int EndTextCommandThefeedPostMessagetext(string _txdName, string _textureName, bool _flash, int _iconType, string _sender, string _subject)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostMessagetext == null) fn__endTextCommandThefeedPostMessagetext = (delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostMessagetext");
				var ptr_txdName = MemoryUtils.StringToHGlobalUtf8(_txdName);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				var ptr_sender = MemoryUtils.StringToHGlobalUtf8(_sender);
				var ptr_subject = MemoryUtils.StringToHGlobalUtf8(_subject);
				var result = fn__endTextCommandThefeedPostMessagetext(ptr_txdName, ptr_textureName, _flash, _iconType, ptr_sender, ptr_subject);
				Marshal.FreeHGlobal(ptr_txdName);
				Marshal.FreeHGlobal(ptr_textureName);
				Marshal.FreeHGlobal(ptr_sender);
				Marshal.FreeHGlobal(ptr_subject);
				return result;
			}
		}

		public int EndTextCommandThefeedPostMessagetextGxtEntry(string _txdName, string _textureName, bool _flash, int _iconType, string _sender, string _subject)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostMessagetextGxtEntry == null) fn__endTextCommandThefeedPostMessagetextGxtEntry = (delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostMessagetextGxtEntry");
				var ptr_txdName = MemoryUtils.StringToHGlobalUtf8(_txdName);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				var ptr_sender = MemoryUtils.StringToHGlobalUtf8(_sender);
				var ptr_subject = MemoryUtils.StringToHGlobalUtf8(_subject);
				var result = fn__endTextCommandThefeedPostMessagetextGxtEntry(ptr_txdName, ptr_textureName, _flash, _iconType, ptr_sender, ptr_subject);
				Marshal.FreeHGlobal(ptr_txdName);
				Marshal.FreeHGlobal(ptr_textureName);
				Marshal.FreeHGlobal(ptr_sender);
				Marshal.FreeHGlobal(ptr_subject);
				return result;
			}
		}

		public int EndTextCommandThefeedPostMessagetextTu(string _txdName, string _textureName, bool _flash, int _iconType, string _sender, string _subject, float _duration)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostMessagetextTu == null) fn__endTextCommandThefeedPostMessagetextTu = (delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, float, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostMessagetextTu");
				var ptr_txdName = MemoryUtils.StringToHGlobalUtf8(_txdName);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				var ptr_sender = MemoryUtils.StringToHGlobalUtf8(_sender);
				var ptr_subject = MemoryUtils.StringToHGlobalUtf8(_subject);
				var result = fn__endTextCommandThefeedPostMessagetextTu(ptr_txdName, ptr_textureName, _flash, _iconType, ptr_sender, ptr_subject, _duration);
				Marshal.FreeHGlobal(ptr_txdName);
				Marshal.FreeHGlobal(ptr_textureName);
				Marshal.FreeHGlobal(ptr_sender);
				Marshal.FreeHGlobal(ptr_subject);
				return result;
			}
		}

		public int EndTextCommandThefeedPostMessagetextWithCrewTag(string _txdName, string _textureName, bool _flash, int _iconType, string _sender, string _subject, float _duration, string _clanTag)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostMessagetextWithCrewTag == null) fn__endTextCommandThefeedPostMessagetextWithCrewTag = (delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, float, nint, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostMessagetextWithCrewTag");
				var ptr_txdName = MemoryUtils.StringToHGlobalUtf8(_txdName);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				var ptr_sender = MemoryUtils.StringToHGlobalUtf8(_sender);
				var ptr_subject = MemoryUtils.StringToHGlobalUtf8(_subject);
				var ptr_clanTag = MemoryUtils.StringToHGlobalUtf8(_clanTag);
				var result = fn__endTextCommandThefeedPostMessagetextWithCrewTag(ptr_txdName, ptr_textureName, _flash, _iconType, ptr_sender, ptr_subject, _duration, ptr_clanTag);
				Marshal.FreeHGlobal(ptr_txdName);
				Marshal.FreeHGlobal(ptr_textureName);
				Marshal.FreeHGlobal(ptr_sender);
				Marshal.FreeHGlobal(ptr_subject);
				Marshal.FreeHGlobal(ptr_clanTag);
				return result;
			}
		}

		public int EndTextCommandThefeedPostMessagetextWithCrewTagAndAdditionalIcon(string _txdName, string _textureName, bool _flash, int _iconType1, string _sender, string _subject, float _duration, string _clanTag, int _iconType2, int _p9)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostMessagetextWithCrewTagAndAdditionalIcon == null) fn__endTextCommandThefeedPostMessagetextWithCrewTagAndAdditionalIcon = (delegate* unmanaged[Cdecl]<nint, nint, bool, int, nint, nint, float, nint, int, int, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostMessagetextWithCrewTagAndAdditionalIcon");
				var ptr_txdName = MemoryUtils.StringToHGlobalUtf8(_txdName);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				var ptr_sender = MemoryUtils.StringToHGlobalUtf8(_sender);
				var ptr_subject = MemoryUtils.StringToHGlobalUtf8(_subject);
				var ptr_clanTag = MemoryUtils.StringToHGlobalUtf8(_clanTag);
				var result = fn__endTextCommandThefeedPostMessagetextWithCrewTagAndAdditionalIcon(ptr_txdName, ptr_textureName, _flash, _iconType1, ptr_sender, ptr_subject, _duration, ptr_clanTag, _iconType2, _p9);
				Marshal.FreeHGlobal(ptr_txdName);
				Marshal.FreeHGlobal(ptr_textureName);
				Marshal.FreeHGlobal(ptr_sender);
				Marshal.FreeHGlobal(ptr_subject);
				Marshal.FreeHGlobal(ptr_clanTag);
				return result;
			}
		}

		public int EndTextCommandThefeedPostTicker(bool _blink, bool _p1)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostTicker == null) fn__endTextCommandThefeedPostTicker = (delegate* unmanaged[Cdecl]<bool, bool, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostTicker");
				var result = fn__endTextCommandThefeedPostTicker(_blink, _p1);
				return result;
			}
		}

		public int EndTextCommandThefeedPostTickerForced(bool _blink, bool _p1)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostTickerForced == null) fn__endTextCommandThefeedPostTickerForced = (delegate* unmanaged[Cdecl]<bool, bool, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostTickerForced");
				var result = fn__endTextCommandThefeedPostTickerForced(_blink, _p1);
				return result;
			}
		}

		public int EndTextCommandThefeedPostTickerWithTokens(bool _blink, bool _p1)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostTickerWithTokens == null) fn__endTextCommandThefeedPostTickerWithTokens = (delegate* unmanaged[Cdecl]<bool, bool, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostTickerWithTokens");
				var result = fn__endTextCommandThefeedPostTickerWithTokens(_blink, _p1);
				return result;
			}
		}

		public int EndTextCommandThefeedPostAward(string _textureDict, string _textureName, int _rpBonus, int _colorOverlay, string _titleLabel)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostAward == null) fn__endTextCommandThefeedPostAward = (delegate* unmanaged[Cdecl]<nint, nint, int, int, nint, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostAward");
				var ptr_textureDict = MemoryUtils.StringToHGlobalUtf8(_textureDict);
				var ptr_textureName = MemoryUtils.StringToHGlobalUtf8(_textureName);
				var ptr_titleLabel = MemoryUtils.StringToHGlobalUtf8(_titleLabel);
				var result = fn__endTextCommandThefeedPostAward(ptr_textureDict, ptr_textureName, _rpBonus, _colorOverlay, ptr_titleLabel);
				Marshal.FreeHGlobal(ptr_textureDict);
				Marshal.FreeHGlobal(ptr_textureName);
				Marshal.FreeHGlobal(ptr_titleLabel);
				return result;
			}
		}

		public int EndTextCommandThefeedPostCrewtag(bool _p0, bool _p1, ref int _p2, int _p3, bool _isLeader, bool _unk0, int _clanDesc, int _R, int _G, int _B)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostCrewtag == null) fn__endTextCommandThefeedPostCrewtag = (delegate* unmanaged[Cdecl]<bool, bool, int*, int, bool, bool, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostCrewtag");
				var ref_p2 = _p2;
				var result = fn__endTextCommandThefeedPostCrewtag(_p0, _p1, &ref_p2, _p3, _isLeader, _unk0, _clanDesc, _R, _G, _B);
				_p2 = ref_p2;
				return result;
			}
		}

		public int EndTextCommandThefeedPostCrewtagWithGameName(bool _p0, bool _p1, ref int _p2, int _p3, bool _isLeader, bool _unk0, int _clanDesc, string _playerName, int _R, int _G, int _B)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostCrewtagWithGameName == null) fn__endTextCommandThefeedPostCrewtagWithGameName = (delegate* unmanaged[Cdecl]<bool, bool, int*, int, bool, bool, int, nint, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostCrewtagWithGameName");
				var ref_p2 = _p2;
				var ptr_playerName = MemoryUtils.StringToHGlobalUtf8(_playerName);
				var result = fn__endTextCommandThefeedPostCrewtagWithGameName(_p0, _p1, &ref_p2, _p3, _isLeader, _unk0, _clanDesc, ptr_playerName, _R, _G, _B);
				_p2 = ref_p2;
				Marshal.FreeHGlobal(ptr_playerName);
				return result;
			}
		}

		public int EndTextCommandThefeedPostUnlock(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostUnlock == null) fn__endTextCommandThefeedPostUnlock = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostUnlock");
				var result = fn__endTextCommandThefeedPostUnlock(_p0, _p1, _p2);
				return result;
			}
		}

		public int EndTextCommandThefeedPostUnlockTu(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostUnlockTu == null) fn__endTextCommandThefeedPostUnlockTu = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostUnlockTu");
				var result = fn__endTextCommandThefeedPostUnlockTu(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public int EndTextCommandThefeedPostUnlockTuWithColor(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostUnlockTuWithColor == null) fn__endTextCommandThefeedPostUnlockTuWithColor = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostUnlockTuWithColor");
				var result = fn__endTextCommandThefeedPostUnlockTuWithColor(_p0, _p1, _p2, _p3, _p4, _p5);
				return result;
			}
		}

		public int EndTextCommandThefeedPostMpticker(bool _blink, bool _p1)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostMpticker == null) fn__endTextCommandThefeedPostMpticker = (delegate* unmanaged[Cdecl]<bool, bool, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostMpticker");
				var result = fn__endTextCommandThefeedPostMpticker(_blink, _p1);
				return result;
			}
		}

		public int EndTextCommandThefeedPostCrewRankup(string _p0, string _p1, string _p2, bool _p3, bool _p4)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostCrewRankup == null) fn__endTextCommandThefeedPostCrewRankup = (delegate* unmanaged[Cdecl]<nint, nint, nint, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostCrewRankup");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var result = fn__endTextCommandThefeedPostCrewRankup(ptr_p0, ptr_p1, ptr_p2, _p3, _p4);
				Marshal.FreeHGlobal(ptr_p0);
				Marshal.FreeHGlobal(ptr_p1);
				Marshal.FreeHGlobal(ptr_p2);
				return result;
			}
		}

		public int EndTextCommandThefeedPostVersusTu(ref int _p0, ref int _p1, int _p2, ref int _p3, ref int _p4, int _p5, int _p6, int _p7)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostVersusTu == null) fn__endTextCommandThefeedPostVersusTu = (delegate* unmanaged[Cdecl]<int*, int*, int, int*, int*, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostVersusTu");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p3 = _p3;
				var ref_p4 = _p4;
				var result = fn__endTextCommandThefeedPostVersusTu(&ref_p0, &ref_p1, _p2, &ref_p3, &ref_p4, _p5, _p6, _p7);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p3 = ref_p3;
				_p4 = ref_p4;
				return result;
			}
		}

		public int EndTextCommandThefeedPostReplayIcon(int _type, int _image, string _text)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostReplayIcon == null) fn__endTextCommandThefeedPostReplayIcon = (delegate* unmanaged[Cdecl]<int, int, nint, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostReplayIcon");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				var result = fn__endTextCommandThefeedPostReplayIcon(_type, _image, ptr_text);
				Marshal.FreeHGlobal(ptr_text);
				return result;
			}
		}

		public int EndTextCommandThefeedPostReplayInput(int _type, string _button, string _text)
		{
			unsafe {
				if (fn__endTextCommandThefeedPostReplayInput == null) fn__endTextCommandThefeedPostReplayInput = (delegate* unmanaged[Cdecl]<int, nint, nint, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandThefeedPostReplayInput");
				var ptr_button = MemoryUtils.StringToHGlobalUtf8(_button);
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				var result = fn__endTextCommandThefeedPostReplayInput(_type, ptr_button, ptr_text);
				Marshal.FreeHGlobal(ptr_button);
				Marshal.FreeHGlobal(ptr_text);
				return result;
			}
		}

		public void BeginTextCommandPrint(string _GxtEntry)
		{
			unsafe {
				if (fn__beginTextCommandPrint == null) fn__beginTextCommandPrint = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandPrint");
				var ptr_GxtEntry = MemoryUtils.StringToHGlobalUtf8(_GxtEntry);
				fn__beginTextCommandPrint(ptr_GxtEntry);
				Marshal.FreeHGlobal(ptr_GxtEntry);
			}
		}

		public void EndTextCommandPrint(int _duration, bool _drawImmediately)
		{
			unsafe {
				if (fn__endTextCommandPrint == null) fn__endTextCommandPrint = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_endTextCommandPrint");
				fn__endTextCommandPrint(_duration, _drawImmediately);
			}
		}

		public void BeginTextCommandIsMessageDisplayed(string _text)
		{
			unsafe {
				if (fn__beginTextCommandIsMessageDisplayed == null) fn__beginTextCommandIsMessageDisplayed = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandIsMessageDisplayed");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				fn__beginTextCommandIsMessageDisplayed(ptr_text);
				Marshal.FreeHGlobal(ptr_text);
			}
		}

		public bool EndTextCommandIsMessageDisplayed()
		{
			unsafe {
				if (fn__endTextCommandIsMessageDisplayed == null) fn__endTextCommandIsMessageDisplayed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_endTextCommandIsMessageDisplayed");
				var result = fn__endTextCommandIsMessageDisplayed();
				return result;
			}
		}

		public void BeginTextCommandDisplayText(string _text)
		{
			unsafe {
				if (fn__beginTextCommandDisplayText == null) fn__beginTextCommandDisplayText = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandDisplayText");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				fn__beginTextCommandDisplayText(ptr_text);
				Marshal.FreeHGlobal(ptr_text);
			}
		}

		public void EndTextCommandDisplayText(float _x, float _y, int _p2)
		{
			unsafe {
				if (fn__endTextCommandDisplayText == null) fn__endTextCommandDisplayText = (delegate* unmanaged[Cdecl]<float, float, int, void>) NativeLibrary.GetExport(handle, "Native_endTextCommandDisplayText");
				fn__endTextCommandDisplayText(_x, _y, _p2);
			}
		}

		public void BeginTextCommandGetWidth(string _text)
		{
			unsafe {
				if (fn__beginTextCommandGetWidth == null) fn__beginTextCommandGetWidth = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandGetWidth");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				fn__beginTextCommandGetWidth(ptr_text);
				Marshal.FreeHGlobal(ptr_text);
			}
		}

		public float EndTextCommandGetWidth(bool _p0)
		{
			unsafe {
				if (fn__endTextCommandGetWidth == null) fn__endTextCommandGetWidth = (delegate* unmanaged[Cdecl]<bool, float>) NativeLibrary.GetExport(handle, "Native_endTextCommandGetWidth");
				var result = fn__endTextCommandGetWidth(_p0);
				return result;
			}
		}

		public void BeginTextCommandLineCount(string _entry)
		{
			unsafe {
				if (fn__beginTextCommandLineCount == null) fn__beginTextCommandLineCount = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandLineCount");
				var ptr_entry = MemoryUtils.StringToHGlobalUtf8(_entry);
				fn__beginTextCommandLineCount(ptr_entry);
				Marshal.FreeHGlobal(ptr_entry);
			}
		}

		public int EndTextCommandLineCount(float _x, float _y)
		{
			unsafe {
				if (fn__endTextCommandLineCount == null) fn__endTextCommandLineCount = (delegate* unmanaged[Cdecl]<float, float, int>) NativeLibrary.GetExport(handle, "Native_endTextCommandLineCount");
				var result = fn__endTextCommandLineCount(_x, _y);
				return result;
			}
		}

		public void BeginTextCommandDisplayHelp(string _inputType)
		{
			unsafe {
				if (fn__beginTextCommandDisplayHelp == null) fn__beginTextCommandDisplayHelp = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandDisplayHelp");
				var ptr_inputType = MemoryUtils.StringToHGlobalUtf8(_inputType);
				fn__beginTextCommandDisplayHelp(ptr_inputType);
				Marshal.FreeHGlobal(ptr_inputType);
			}
		}

		public void EndTextCommandDisplayHelp(int _p0, bool _loop, bool _beep, int _shape)
		{
			unsafe {
				if (fn__endTextCommandDisplayHelp == null) fn__endTextCommandDisplayHelp = (delegate* unmanaged[Cdecl]<int, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_endTextCommandDisplayHelp");
				fn__endTextCommandDisplayHelp(_p0, _loop, _beep, _shape);
			}
		}

		public void BeginTextCommandIsThisHelpMessageBeingDisplayed(string _labelName)
		{
			unsafe {
				if (fn__beginTextCommandIsThisHelpMessageBeingDisplayed == null) fn__beginTextCommandIsThisHelpMessageBeingDisplayed = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandIsThisHelpMessageBeingDisplayed");
				var ptr_labelName = MemoryUtils.StringToHGlobalUtf8(_labelName);
				fn__beginTextCommandIsThisHelpMessageBeingDisplayed(ptr_labelName);
				Marshal.FreeHGlobal(ptr_labelName);
			}
		}

		public bool EndTextCommandIsThisHelpMessageBeingDisplayed(int _p0)
		{
			unsafe {
				if (fn__endTextCommandIsThisHelpMessageBeingDisplayed == null) fn__endTextCommandIsThisHelpMessageBeingDisplayed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_endTextCommandIsThisHelpMessageBeingDisplayed");
				var result = fn__endTextCommandIsThisHelpMessageBeingDisplayed(_p0);
				return result;
			}
		}

		public void BeginTextCommandSetBlipName(string _textLabel)
		{
			unsafe {
				if (fn__beginTextCommandSetBlipName == null) fn__beginTextCommandSetBlipName = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandSetBlipName");
				var ptr_textLabel = MemoryUtils.StringToHGlobalUtf8(_textLabel);
				fn__beginTextCommandSetBlipName(ptr_textLabel);
				Marshal.FreeHGlobal(ptr_textLabel);
			}
		}

		public void EndTextCommandSetBlipName(int _blip)
		{
			unsafe {
				if (fn__endTextCommandSetBlipName == null) fn__endTextCommandSetBlipName = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_endTextCommandSetBlipName");
				fn__endTextCommandSetBlipName(_blip);
			}
		}

		public void BeginTextCommandObjective(string _p0)
		{
			unsafe {
				if (fn__beginTextCommandObjective == null) fn__beginTextCommandObjective = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandObjective");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__beginTextCommandObjective(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void EndTextCommandObjective(bool _p0)
		{
			unsafe {
				if (fn__endTextCommandObjective == null) fn__endTextCommandObjective = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_endTextCommandObjective");
				fn__endTextCommandObjective(_p0);
			}
		}

		public void BeginTextCommandClearPrint(string _text)
		{
			unsafe {
				if (fn__beginTextCommandClearPrint == null) fn__beginTextCommandClearPrint = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandClearPrint");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				fn__beginTextCommandClearPrint(ptr_text);
				Marshal.FreeHGlobal(ptr_text);
			}
		}

		public void EndTextCommandClearPrint()
		{
			unsafe {
				if (fn__endTextCommandClearPrint == null) fn__endTextCommandClearPrint = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_endTextCommandClearPrint");
				fn__endTextCommandClearPrint();
			}
		}

		public void BeginTextCommandOverrideButtonText(string _gxtEntry)
		{
			unsafe {
				if (fn__beginTextCommandOverrideButtonText == null) fn__beginTextCommandOverrideButtonText = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_beginTextCommandOverrideButtonText");
				var ptr_gxtEntry = MemoryUtils.StringToHGlobalUtf8(_gxtEntry);
				fn__beginTextCommandOverrideButtonText(ptr_gxtEntry);
				Marshal.FreeHGlobal(ptr_gxtEntry);
			}
		}

		public void EndTextCommandOverrideButtonText(int _p0)
		{
			unsafe {
				if (fn__endTextCommandOverrideButtonText == null) fn__endTextCommandOverrideButtonText = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_endTextCommandOverrideButtonText");
				fn__endTextCommandOverrideButtonText(_p0);
			}
		}

		public void AddTextComponentInteger(int _value)
		{
			unsafe {
				if (fn__addTextComponentInteger == null) fn__addTextComponentInteger = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentInteger");
				fn__addTextComponentInteger(_value);
			}
		}

		public void AddTextComponentFloat(float _value, int _decimalPlaces)
		{
			unsafe {
				if (fn__addTextComponentFloat == null) fn__addTextComponentFloat = (delegate* unmanaged[Cdecl]<float, int, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentFloat");
				fn__addTextComponentFloat(_value, _decimalPlaces);
			}
		}

		public void AddTextComponentSubstringTextLabel(string _labelName)
		{
			unsafe {
				if (fn__addTextComponentSubstringTextLabel == null) fn__addTextComponentSubstringTextLabel = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentSubstringTextLabel");
				var ptr_labelName = MemoryUtils.StringToHGlobalUtf8(_labelName);
				fn__addTextComponentSubstringTextLabel(ptr_labelName);
				Marshal.FreeHGlobal(ptr_labelName);
			}
		}

		public void AddTextComponentSubstringTextLabelHashKey(int _gxtEntryHash)
		{
			unsafe {
				if (fn__addTextComponentSubstringTextLabelHashKey == null) fn__addTextComponentSubstringTextLabelHashKey = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentSubstringTextLabelHashKey");
				fn__addTextComponentSubstringTextLabelHashKey(_gxtEntryHash);
			}
		}

		public void AddTextComponentSubstringBlipName(int _blip)
		{
			unsafe {
				if (fn__addTextComponentSubstringBlipName == null) fn__addTextComponentSubstringBlipName = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentSubstringBlipName");
				fn__addTextComponentSubstringBlipName(_blip);
			}
		}

		public void AddTextComponentSubstringPlayerName(string _text)
		{
			unsafe {
				if (fn__addTextComponentSubstringPlayerName == null) fn__addTextComponentSubstringPlayerName = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentSubstringPlayerName");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				fn__addTextComponentSubstringPlayerName(ptr_text);
				Marshal.FreeHGlobal(ptr_text);
			}
		}

		public void AddTextComponentSubstringTime(int _timestamp, int _flags)
		{
			unsafe {
				if (fn__addTextComponentSubstringTime == null) fn__addTextComponentSubstringTime = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentSubstringTime");
				fn__addTextComponentSubstringTime(_timestamp, _flags);
			}
		}

		public void AddTextComponentFormattedInteger(int _value, bool _commaSeparated)
		{
			unsafe {
				if (fn__addTextComponentFormattedInteger == null) fn__addTextComponentFormattedInteger = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentFormattedInteger");
				fn__addTextComponentFormattedInteger(_value, _commaSeparated);
			}
		}

		public void AddTextComponentSubstringPhoneNumber(string _p0, int _p1)
		{
			unsafe {
				if (fn__addTextComponentSubstringPhoneNumber == null) fn__addTextComponentSubstringPhoneNumber = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentSubstringPhoneNumber");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__addTextComponentSubstringPhoneNumber(ptr_p0, _p1);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void AddTextComponentSubstringWebsite(string _website)
		{
			unsafe {
				if (fn__addTextComponentSubstringWebsite == null) fn__addTextComponentSubstringWebsite = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentSubstringWebsite");
				var ptr_website = MemoryUtils.StringToHGlobalUtf8(_website);
				fn__addTextComponentSubstringWebsite(ptr_website);
				Marshal.FreeHGlobal(ptr_website);
			}
		}

		public void AddTextComponentSubstringKeyboardDisplay(string _string)
		{
			unsafe {
				if (fn__addTextComponentSubstringKeyboardDisplay == null) fn__addTextComponentSubstringKeyboardDisplay = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_addTextComponentSubstringKeyboardDisplay");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				fn__addTextComponentSubstringKeyboardDisplay(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
			}
		}

		public void SetColourOfNextTextComponent(int _hudColor)
		{
			unsafe {
				if (fn__setColourOfNextTextComponent == null) fn__setColourOfNextTextComponent = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setColourOfNextTextComponent");
				fn__setColourOfNextTextComponent(_hudColor);
			}
		}

		public string GetTextSubstring(string _text, int _position, int _length)
		{
			unsafe {
				if (fn__getTextSubstring == null) fn__getTextSubstring = (delegate* unmanaged[Cdecl]<nint, int, int, nint>) NativeLibrary.GetExport(handle, "Native_getTextSubstring");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				var result = fn__getTextSubstring(ptr_text, _position, _length);
				Marshal.FreeHGlobal(ptr_text);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetTextSubstringSafe(string _text, int _position, int _length, int _maxLength)
		{
			unsafe {
				if (fn__getTextSubstringSafe == null) fn__getTextSubstringSafe = (delegate* unmanaged[Cdecl]<nint, int, int, int, nint>) NativeLibrary.GetExport(handle, "Native_getTextSubstringSafe");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				var result = fn__getTextSubstringSafe(ptr_text, _position, _length, _maxLength);
				Marshal.FreeHGlobal(ptr_text);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetTextSubstringSlice(string _text, int _startPosition, int _endPosition)
		{
			unsafe {
				if (fn__getTextSubstringSlice == null) fn__getTextSubstringSlice = (delegate* unmanaged[Cdecl]<nint, int, int, nint>) NativeLibrary.GetExport(handle, "Native_getTextSubstringSlice");
				var ptr_text = MemoryUtils.StringToHGlobalUtf8(_text);
				var result = fn__getTextSubstringSlice(ptr_text, _startPosition, _endPosition);
				Marshal.FreeHGlobal(ptr_text);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetLabelText(string _labelName)
		{
			unsafe {
				if (fn__getLabelText == null) fn__getLabelText = (delegate* unmanaged[Cdecl]<nint, nint>) NativeLibrary.GetExport(handle, "Native_getLabelText");
				var ptr_labelName = MemoryUtils.StringToHGlobalUtf8(_labelName);
				var result = fn__getLabelText(ptr_labelName);
				Marshal.FreeHGlobal(ptr_labelName);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void ClearPrints()
		{
			unsafe {
				if (fn__clearPrints == null) fn__clearPrints = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearPrints");
				fn__clearPrints();
			}
		}

		public void ClearBrief()
		{
			unsafe {
				if (fn__clearBrief == null) fn__clearBrief = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearBrief");
				fn__clearBrief();
			}
		}

		public void ClearAllHelpMessages()
		{
			unsafe {
				if (fn__clearAllHelpMessages == null) fn__clearAllHelpMessages = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearAllHelpMessages");
				fn__clearAllHelpMessages();
			}
		}

		public void ClearThisPrint(string _p0)
		{
			unsafe {
				if (fn__clearThisPrint == null) fn__clearThisPrint = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_clearThisPrint");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__clearThisPrint(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void ClearSmallPrints()
		{
			unsafe {
				if (fn__clearSmallPrints == null) fn__clearSmallPrints = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearSmallPrints");
				fn__clearSmallPrints();
			}
		}

		public bool DoesTextBlockExist(string _gxt)
		{
			unsafe {
				if (fn__doesTextBlockExist == null) fn__doesTextBlockExist = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_doesTextBlockExist");
				var ptr_gxt = MemoryUtils.StringToHGlobalUtf8(_gxt);
				var result = fn__doesTextBlockExist(ptr_gxt);
				Marshal.FreeHGlobal(ptr_gxt);
				return result;
			}
		}

		public void RequestAdditionalText(string _gxt, int _slot)
		{
			unsafe {
				if (fn__requestAdditionalText == null) fn__requestAdditionalText = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_requestAdditionalText");
				var ptr_gxt = MemoryUtils.StringToHGlobalUtf8(_gxt);
				fn__requestAdditionalText(ptr_gxt, _slot);
				Marshal.FreeHGlobal(ptr_gxt);
			}
		}

		public void RequestAdditionalTextForDlc(string _gxt, int _slot)
		{
			unsafe {
				if (fn__requestAdditionalTextForDlc == null) fn__requestAdditionalTextForDlc = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_requestAdditionalTextForDlc");
				var ptr_gxt = MemoryUtils.StringToHGlobalUtf8(_gxt);
				fn__requestAdditionalTextForDlc(ptr_gxt, _slot);
				Marshal.FreeHGlobal(ptr_gxt);
			}
		}

		public bool HasAdditionalTextLoaded(int _slot)
		{
			unsafe {
				if (fn__hasAdditionalTextLoaded == null) fn__hasAdditionalTextLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasAdditionalTextLoaded");
				var result = fn__hasAdditionalTextLoaded(_slot);
				return result;
			}
		}

		public void ClearAdditionalText(int _p0, bool _p1)
		{
			unsafe {
				if (fn__clearAdditionalText == null) fn__clearAdditionalText = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_clearAdditionalText");
				fn__clearAdditionalText(_p0, _p1);
			}
		}

		public bool IsStreamingAdditionalText(int _p0)
		{
			unsafe {
				if (fn__isStreamingAdditionalText == null) fn__isStreamingAdditionalText = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isStreamingAdditionalText");
				var result = fn__isStreamingAdditionalText(_p0);
				return result;
			}
		}

		public bool HasThisAdditionalTextLoaded(string _gxt, int _slot)
		{
			unsafe {
				if (fn__hasThisAdditionalTextLoaded == null) fn__hasThisAdditionalTextLoaded = (delegate* unmanaged[Cdecl]<nint, int, bool>) NativeLibrary.GetExport(handle, "Native_hasThisAdditionalTextLoaded");
				var ptr_gxt = MemoryUtils.StringToHGlobalUtf8(_gxt);
				var result = fn__hasThisAdditionalTextLoaded(ptr_gxt, _slot);
				Marshal.FreeHGlobal(ptr_gxt);
				return result;
			}
		}

		public bool IsMessageBeingDisplayed()
		{
			unsafe {
				if (fn__isMessageBeingDisplayed == null) fn__isMessageBeingDisplayed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMessageBeingDisplayed");
				var result = fn__isMessageBeingDisplayed();
				return result;
			}
		}

		public bool DoesTextLabelExist(string _gxt)
		{
			unsafe {
				if (fn__doesTextLabelExist == null) fn__doesTextLabelExist = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_doesTextLabelExist");
				var ptr_gxt = MemoryUtils.StringToHGlobalUtf8(_gxt);
				var result = fn__doesTextLabelExist(ptr_gxt);
				Marshal.FreeHGlobal(ptr_gxt);
				return result;
			}
		}

		public string _0x98C3CF913D895111(string _string, int _length)
		{
			unsafe {
				if (fn__0x98C3CF913D895111 == null) fn__0x98C3CF913D895111 = (delegate* unmanaged[Cdecl]<nint, int, nint>) NativeLibrary.GetExport(handle, "Native__0x98C3CF913D895111");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				var result = fn__0x98C3CF913D895111(ptr_string, _length);
				Marshal.FreeHGlobal(ptr_string);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int GetLengthOfStringWithThisTextLabel(string _gxt)
		{
			unsafe {
				if (fn__getLengthOfStringWithThisTextLabel == null) fn__getLengthOfStringWithThisTextLabel = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_getLengthOfStringWithThisTextLabel");
				var ptr_gxt = MemoryUtils.StringToHGlobalUtf8(_gxt);
				var result = fn__getLengthOfStringWithThisTextLabel(ptr_gxt);
				Marshal.FreeHGlobal(ptr_gxt);
				return result;
			}
		}

		public int GetLengthOfLiteralString(string _string)
		{
			unsafe {
				if (fn__getLengthOfLiteralString == null) fn__getLengthOfLiteralString = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_getLengthOfLiteralString");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				var result = fn__getLengthOfLiteralString(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
				return result;
			}
		}

		public int GetLengthOfLiteralStringInBytes(string _string)
		{
			unsafe {
				if (fn__getLengthOfLiteralStringInBytes == null) fn__getLengthOfLiteralStringInBytes = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_getLengthOfLiteralStringInBytes");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				var result = fn__getLengthOfLiteralStringInBytes(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
				return result;
			}
		}

		public string GetStreetNameFromHashKey(int _hash)
		{
			unsafe {
				if (fn__getStreetNameFromHashKey == null) fn__getStreetNameFromHashKey = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getStreetNameFromHashKey");
				var result = fn__getStreetNameFromHashKey(_hash);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool IsHudPreferenceSwitchedOn()
		{
			unsafe {
				if (fn__isHudPreferenceSwitchedOn == null) fn__isHudPreferenceSwitchedOn = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isHudPreferenceSwitchedOn");
				var result = fn__isHudPreferenceSwitchedOn();
				return result;
			}
		}

		public bool IsRadarPreferenceSwitchedOn()
		{
			unsafe {
				if (fn__isRadarPreferenceSwitchedOn == null) fn__isRadarPreferenceSwitchedOn = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isRadarPreferenceSwitchedOn");
				var result = fn__isRadarPreferenceSwitchedOn();
				return result;
			}
		}

		public bool IsSubtitlePreferenceSwitchedOn()
		{
			unsafe {
				if (fn__isSubtitlePreferenceSwitchedOn == null) fn__isSubtitlePreferenceSwitchedOn = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isSubtitlePreferenceSwitchedOn");
				var result = fn__isSubtitlePreferenceSwitchedOn();
				return result;
			}
		}

		public void DisplayHud(bool _toggle)
		{
			unsafe {
				if (fn__displayHud == null) fn__displayHud = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_displayHud");
				fn__displayHud(_toggle);
			}
		}

		public void DisplayHudWhenDeadThisFrame()
		{
			unsafe {
				if (fn__displayHudWhenDeadThisFrame == null) fn__displayHudWhenDeadThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_displayHudWhenDeadThisFrame");
				fn__displayHudWhenDeadThisFrame();
			}
		}

		public void DisplayHudWhenPausedThisFrame()
		{
			unsafe {
				if (fn__displayHudWhenPausedThisFrame == null) fn__displayHudWhenPausedThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_displayHudWhenPausedThisFrame");
				fn__displayHudWhenPausedThisFrame();
			}
		}

		public void DisplayRadar(bool _toggle)
		{
			unsafe {
				if (fn__displayRadar == null) fn__displayRadar = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_displayRadar");
				fn__displayRadar(_toggle);
			}
		}

		public void _0xCD74233600C4EA6B(bool _toggle)
		{
			unsafe {
				if (fn__0xCD74233600C4EA6B == null) fn__0xCD74233600C4EA6B = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xCD74233600C4EA6B");
				fn__0xCD74233600C4EA6B(_toggle);
			}
		}

		public bool _0xC2D2AD9EAAE265B8()
		{
			unsafe {
				if (fn__0xC2D2AD9EAAE265B8 == null) fn__0xC2D2AD9EAAE265B8 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xC2D2AD9EAAE265B8");
				var result = fn__0xC2D2AD9EAAE265B8();
				return result;
			}
		}

		public bool IsHudHidden()
		{
			unsafe {
				if (fn__isHudHidden == null) fn__isHudHidden = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isHudHidden");
				var result = fn__isHudHidden();
				return result;
			}
		}

		public bool IsRadarHidden()
		{
			unsafe {
				if (fn__isRadarHidden == null) fn__isRadarHidden = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isRadarHidden");
				var result = fn__isRadarHidden();
				return result;
			}
		}

		public bool IsMinimapRendering()
		{
			unsafe {
				if (fn__isMinimapRendering == null) fn__isMinimapRendering = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMinimapRendering");
				var result = fn__isMinimapRendering();
				return result;
			}
		}

		public void _0x0C698D8F099174C7(int _p0)
		{
			unsafe {
				if (fn__0x0C698D8F099174C7 == null) fn__0x0C698D8F099174C7 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x0C698D8F099174C7");
				fn__0x0C698D8F099174C7(_p0);
			}
		}

		public void _0xE4C3B169876D33D7(int _p0)
		{
			unsafe {
				if (fn__0xE4C3B169876D33D7 == null) fn__0xE4C3B169876D33D7 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xE4C3B169876D33D7");
				fn__0xE4C3B169876D33D7(_p0);
			}
		}

		public void _0xEB81A3DADD503187()
		{
			unsafe {
				if (fn__0xEB81A3DADD503187 == null) fn__0xEB81A3DADD503187 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xEB81A3DADD503187");
				fn__0xEB81A3DADD503187();
			}
		}

		public void SetBlipRoute(int _blip, bool _enabled)
		{
			unsafe {
				if (fn__setBlipRoute == null) fn__setBlipRoute = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipRoute");
				fn__setBlipRoute(_blip, _enabled);
			}
		}

		public void ClearAllBlipRoutes()
		{
			unsafe {
				if (fn__clearAllBlipRoutes == null) fn__clearAllBlipRoutes = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearAllBlipRoutes");
				fn__clearAllBlipRoutes();
			}
		}

		public void SetBlipRouteColour(int _blip, int _colour)
		{
			unsafe {
				if (fn__setBlipRouteColour == null) fn__setBlipRouteColour = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipRouteColour");
				fn__setBlipRouteColour(_blip, _colour);
			}
		}

		public void _0x2790F4B17D098E26(bool _toggle)
		{
			unsafe {
				if (fn__0x2790F4B17D098E26 == null) fn__0x2790F4B17D098E26 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x2790F4B17D098E26");
				fn__0x2790F4B17D098E26(_toggle);
			}
		}

		public void _0x6CDD58146A436083(int _p0)
		{
			unsafe {
				if (fn__0x6CDD58146A436083 == null) fn__0x6CDD58146A436083 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x6CDD58146A436083");
				fn__0x6CDD58146A436083(_p0);
			}
		}

		public void _0xD1942374085C8469(int _p0)
		{
			unsafe {
				if (fn__0xD1942374085C8469 == null) fn__0xD1942374085C8469 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xD1942374085C8469");
				fn__0xD1942374085C8469(_p0);
			}
		}

		public void AddNextMessageToPreviousBriefs(bool _p0)
		{
			unsafe {
				if (fn__addNextMessageToPreviousBriefs == null) fn__addNextMessageToPreviousBriefs = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_addNextMessageToPreviousBriefs");
				fn__addNextMessageToPreviousBriefs(_p0);
			}
		}

		public void _0x57D760D55F54E071(int _p0)
		{
			unsafe {
				if (fn__0x57D760D55F54E071 == null) fn__0x57D760D55F54E071 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x57D760D55F54E071");
				fn__0x57D760D55F54E071(_p0);
			}
		}

		public void SetRadarZoomPrecise(float _zoom)
		{
			unsafe {
				if (fn__setRadarZoomPrecise == null) fn__setRadarZoomPrecise = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setRadarZoomPrecise");
				fn__setRadarZoomPrecise(_zoom);
			}
		}

		public void SetRadarZoom(int _zoomLevel)
		{
			unsafe {
				if (fn__setRadarZoom == null) fn__setRadarZoom = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setRadarZoom");
				fn__setRadarZoom(_zoomLevel);
			}
		}

		public void SetRadarZoomToBlip(int _blip, float _zoom)
		{
			unsafe {
				if (fn__setRadarZoomToBlip == null) fn__setRadarZoomToBlip = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setRadarZoomToBlip");
				fn__setRadarZoomToBlip(_blip, _zoom);
			}
		}

		public void SetRadarZoomToDistance(float _zoom)
		{
			unsafe {
				if (fn__setRadarZoomToDistance == null) fn__setRadarZoomToDistance = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setRadarZoomToDistance");
				fn__setRadarZoomToDistance(_zoom);
			}
		}

		public void _0xD2049635DEB9C375()
		{
			unsafe {
				if (fn__0xD2049635DEB9C375 == null) fn__0xD2049635DEB9C375 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xD2049635DEB9C375");
				fn__0xD2049635DEB9C375();
			}
		}

		public void GetHudColour(int _hudColorIndex, ref int _r, ref int _g, ref int _b, ref int _a)
		{
			unsafe {
				if (fn__getHudColour == null) fn__getHudColour = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getHudColour");
				var ref_r = _r;
				var ref_g = _g;
				var ref_b = _b;
				var ref_a = _a;
				fn__getHudColour(_hudColorIndex, &ref_r, &ref_g, &ref_b, &ref_a);
				_r = ref_r;
				_g = ref_g;
				_b = ref_b;
				_a = ref_a;
			}
		}

		public void SetScriptVariableHudColour(int _r, int _g, int _b, int _a)
		{
			unsafe {
				if (fn__setScriptVariableHudColour == null) fn__setScriptVariableHudColour = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setScriptVariableHudColour");
				fn__setScriptVariableHudColour(_r, _g, _b, _a);
			}
		}

		public void SetScriptVariable2HudColour(int _r, int _g, int _b, int _a)
		{
			unsafe {
				if (fn__setScriptVariable2HudColour == null) fn__setScriptVariable2HudColour = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setScriptVariable2HudColour");
				fn__setScriptVariable2HudColour(_r, _g, _b, _a);
			}
		}

		public void ReplaceHudColour(int _hudColorIndex, int _hudColorIndex2)
		{
			unsafe {
				if (fn__replaceHudColour == null) fn__replaceHudColour = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_replaceHudColour");
				fn__replaceHudColour(_hudColorIndex, _hudColorIndex2);
			}
		}

		public void ReplaceHudColourWithRgba(int _hudColorIndex, int _r, int _g, int _b, int _a)
		{
			unsafe {
				if (fn__replaceHudColourWithRgba == null) fn__replaceHudColourWithRgba = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_replaceHudColourWithRgba");
				fn__replaceHudColourWithRgba(_hudColorIndex, _r, _g, _b, _a);
			}
		}

		public void SetAbilityBarVisibilityInMultiplayer(bool _visible)
		{
			unsafe {
				if (fn__setAbilityBarVisibilityInMultiplayer == null) fn__setAbilityBarVisibilityInMultiplayer = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setAbilityBarVisibilityInMultiplayer");
				fn__setAbilityBarVisibilityInMultiplayer(_visible);
			}
		}

		public void SetAllowAbilityBarInMultiplayer(bool _toggle)
		{
			unsafe {
				if (fn__setAllowAbilityBarInMultiplayer == null) fn__setAllowAbilityBarInMultiplayer = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setAllowAbilityBarInMultiplayer");
				fn__setAllowAbilityBarInMultiplayer(_toggle);
			}
		}

		public void FlashAbilityBar(int _millisecondsToFlash)
		{
			unsafe {
				if (fn__flashAbilityBar == null) fn__flashAbilityBar = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_flashAbilityBar");
				fn__flashAbilityBar(_millisecondsToFlash);
			}
		}

		public void SetAbilityBarValue(float _p0, float _p1)
		{
			unsafe {
				if (fn__setAbilityBarValue == null) fn__setAbilityBarValue = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_setAbilityBarValue");
				fn__setAbilityBarValue(_p0, _p1);
			}
		}

		public void FlashWantedDisplay(bool _p0)
		{
			unsafe {
				if (fn__flashWantedDisplay == null) fn__flashWantedDisplay = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_flashWantedDisplay");
				fn__flashWantedDisplay(_p0);
			}
		}

		public void _0xBA8D65C1C65702E5(bool _toggle)
		{
			unsafe {
				if (fn__0xBA8D65C1C65702E5 == null) fn__0xBA8D65C1C65702E5 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xBA8D65C1C65702E5");
				fn__0xBA8D65C1C65702E5(_toggle);
			}
		}

		public float GetRenderedCharacterHeight(float _size, int _font)
		{
			unsafe {
				if (fn__getRenderedCharacterHeight == null) fn__getRenderedCharacterHeight = (delegate* unmanaged[Cdecl]<float, int, float>) NativeLibrary.GetExport(handle, "Native_getRenderedCharacterHeight");
				var result = fn__getRenderedCharacterHeight(_size, _font);
				return result;
			}
		}

		public void SetTextScale(float _scale, float _size)
		{
			unsafe {
				if (fn__setTextScale == null) fn__setTextScale = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_setTextScale");
				fn__setTextScale(_scale, _size);
			}
		}

		public void SetTextColour(int _red, int _green, int _blue, int _alpha)
		{
			unsafe {
				if (fn__setTextColour == null) fn__setTextColour = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setTextColour");
				fn__setTextColour(_red, _green, _blue, _alpha);
			}
		}

		public void SetTextCentre(bool _align)
		{
			unsafe {
				if (fn__setTextCentre == null) fn__setTextCentre = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setTextCentre");
				fn__setTextCentre(_align);
			}
		}

		public void SetTextRightJustify(bool _toggle)
		{
			unsafe {
				if (fn__setTextRightJustify == null) fn__setTextRightJustify = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setTextRightJustify");
				fn__setTextRightJustify(_toggle);
			}
		}

		public void SetTextJustification(int _justifyType)
		{
			unsafe {
				if (fn__setTextJustification == null) fn__setTextJustification = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setTextJustification");
				fn__setTextJustification(_justifyType);
			}
		}

		public void SetTextWrap(float _start, float _end)
		{
			unsafe {
				if (fn__setTextWrap == null) fn__setTextWrap = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_setTextWrap");
				fn__setTextWrap(_start, _end);
			}
		}

		public void SetTextLeading(int _p0)
		{
			unsafe {
				if (fn__setTextLeading == null) fn__setTextLeading = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setTextLeading");
				fn__setTextLeading(_p0);
			}
		}

		public void SetTextProportional(bool _p0)
		{
			unsafe {
				if (fn__setTextProportional == null) fn__setTextProportional = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setTextProportional");
				fn__setTextProportional(_p0);
			}
		}

		public void SetTextFont(int _fontType)
		{
			unsafe {
				if (fn__setTextFont == null) fn__setTextFont = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setTextFont");
				fn__setTextFont(_fontType);
			}
		}

		public void SetTextDropShadow()
		{
			unsafe {
				if (fn__setTextDropShadow == null) fn__setTextDropShadow = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setTextDropShadow");
				fn__setTextDropShadow();
			}
		}

		public void SetTextDropshadow(int _distance, int _r, int _g, int _b, int _a)
		{
			unsafe {
				if (fn__setTextDropshadow == null) fn__setTextDropshadow = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setTextDropshadow");
				fn__setTextDropshadow(_distance, _r, _g, _b, _a);
			}
		}

		public void SetTextOutline()
		{
			unsafe {
				if (fn__setTextOutline == null) fn__setTextOutline = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setTextOutline");
				fn__setTextOutline();
			}
		}

		public void SetTextEdge(int _p0, int _r, int _g, int _b, int _a)
		{
			unsafe {
				if (fn__setTextEdge == null) fn__setTextEdge = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setTextEdge");
				fn__setTextEdge(_p0, _r, _g, _b, _a);
			}
		}

		public void SetTextRenderId(int _renderId)
		{
			unsafe {
				if (fn__setTextRenderId == null) fn__setTextRenderId = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setTextRenderId");
				fn__setTextRenderId(_renderId);
			}
		}

		public int GetDefaultScriptRendertargetRenderId()
		{
			unsafe {
				if (fn__getDefaultScriptRendertargetRenderId == null) fn__getDefaultScriptRendertargetRenderId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getDefaultScriptRendertargetRenderId");
				var result = fn__getDefaultScriptRendertargetRenderId();
				return result;
			}
		}

		public bool RegisterNamedRendertarget(string _name, bool _p1)
		{
			unsafe {
				if (fn__registerNamedRendertarget == null) fn__registerNamedRendertarget = (delegate* unmanaged[Cdecl]<nint, bool, bool>) NativeLibrary.GetExport(handle, "Native_registerNamedRendertarget");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__registerNamedRendertarget(ptr_name, _p1);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public bool IsNamedRendertargetRegistered(string _name)
		{
			unsafe {
				if (fn__isNamedRendertargetRegistered == null) fn__isNamedRendertargetRegistered = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isNamedRendertargetRegistered");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__isNamedRendertargetRegistered(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public bool ReleaseNamedRendertarget(string _name)
		{
			unsafe {
				if (fn__releaseNamedRendertarget == null) fn__releaseNamedRendertarget = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_releaseNamedRendertarget");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__releaseNamedRendertarget(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public void LinkNamedRendertarget(int _modelHash)
		{
			unsafe {
				if (fn__linkNamedRendertarget == null) fn__linkNamedRendertarget = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_linkNamedRendertarget");
				fn__linkNamedRendertarget(_modelHash);
			}
		}

		public int GetNamedRendertargetRenderId(string _name)
		{
			unsafe {
				if (fn__getNamedRendertargetRenderId == null) fn__getNamedRendertargetRenderId = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_getNamedRendertargetRenderId");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__getNamedRendertargetRenderId(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public bool IsNamedRendertargetLinked(int _modelHash)
		{
			unsafe {
				if (fn__isNamedRendertargetLinked == null) fn__isNamedRendertargetLinked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isNamedRendertargetLinked");
				var result = fn__isNamedRendertargetLinked(_modelHash);
				return result;
			}
		}

		public void ClearHelp(bool _toggle)
		{
			unsafe {
				if (fn__clearHelp == null) fn__clearHelp = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_clearHelp");
				fn__clearHelp(_toggle);
			}
		}

		public bool IsHelpMessageOnScreen()
		{
			unsafe {
				if (fn__isHelpMessageOnScreen == null) fn__isHelpMessageOnScreen = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isHelpMessageOnScreen");
				var result = fn__isHelpMessageOnScreen();
				return result;
			}
		}

		public bool _0x214CD562A939246A()
		{
			unsafe {
				if (fn__0x214CD562A939246A == null) fn__0x214CD562A939246A = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x214CD562A939246A");
				var result = fn__0x214CD562A939246A();
				return result;
			}
		}

		public bool IsHelpMessageBeingDisplayed()
		{
			unsafe {
				if (fn__isHelpMessageBeingDisplayed == null) fn__isHelpMessageBeingDisplayed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isHelpMessageBeingDisplayed");
				var result = fn__isHelpMessageBeingDisplayed();
				return result;
			}
		}

		public bool IsHelpMessageFadingOut()
		{
			unsafe {
				if (fn__isHelpMessageFadingOut == null) fn__isHelpMessageFadingOut = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isHelpMessageFadingOut");
				var result = fn__isHelpMessageFadingOut();
				return result;
			}
		}

		public void SetHelpMessageTextStyle(int _style, int _hudColor, int _alpha, int _p3, int _p4)
		{
			unsafe {
				if (fn__setHelpMessageTextStyle == null) fn__setHelpMessageTextStyle = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setHelpMessageTextStyle");
				fn__setHelpMessageTextStyle(_style, _hudColor, _alpha, _p3, _p4);
			}
		}

		public bool GetStandardBlipEnumId()
		{
			unsafe {
				if (fn__getStandardBlipEnumId == null) fn__getStandardBlipEnumId = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getStandardBlipEnumId");
				var result = fn__getStandardBlipEnumId();
				return result;
			}
		}

		public int GetWaypointBlipEnumId()
		{
			unsafe {
				if (fn__getWaypointBlipEnumId == null) fn__getWaypointBlipEnumId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getWaypointBlipEnumId");
				var result = fn__getWaypointBlipEnumId();
				return result;
			}
		}

		public int GetNumberOfActiveBlips()
		{
			unsafe {
				if (fn__getNumberOfActiveBlips == null) fn__getNumberOfActiveBlips = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumberOfActiveBlips");
				var result = fn__getNumberOfActiveBlips();
				return result;
			}
		}

		public int GetNextBlipInfoId(int _blipSprite)
		{
			unsafe {
				if (fn__getNextBlipInfoId == null) fn__getNextBlipInfoId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNextBlipInfoId");
				var result = fn__getNextBlipInfoId(_blipSprite);
				return result;
			}
		}

		public int GetFirstBlipInfoId(int _blipSprite)
		{
			unsafe {
				if (fn__getFirstBlipInfoId == null) fn__getFirstBlipInfoId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getFirstBlipInfoId");
				var result = fn__getFirstBlipInfoId(_blipSprite);
				return result;
			}
		}

		public int GetClosestBlipOfType(int _blipSprite)
		{
			unsafe {
				if (fn__getClosestBlipOfType == null) fn__getClosestBlipOfType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getClosestBlipOfType");
				var result = fn__getClosestBlipOfType(_blipSprite);
				return result;
			}
		}

		public Vector3 GetBlipInfoIdCoord(int _blip)
		{
			unsafe {
				if (fn__getBlipInfoIdCoord == null) fn__getBlipInfoIdCoord = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getBlipInfoIdCoord");
				var result = fn__getBlipInfoIdCoord(_blip);
				return result;
			}
		}

		public int GetBlipInfoIdDisplay(int _blip)
		{
			unsafe {
				if (fn__getBlipInfoIdDisplay == null) fn__getBlipInfoIdDisplay = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipInfoIdDisplay");
				var result = fn__getBlipInfoIdDisplay(_blip);
				return result;
			}
		}

		public int GetBlipInfoIdType(int _blip)
		{
			unsafe {
				if (fn__getBlipInfoIdType == null) fn__getBlipInfoIdType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipInfoIdType");
				var result = fn__getBlipInfoIdType(_blip);
				return result;
			}
		}

		public int GetBlipInfoIdEntityIndex(int _blip)
		{
			unsafe {
				if (fn__getBlipInfoIdEntityIndex == null) fn__getBlipInfoIdEntityIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipInfoIdEntityIndex");
				var result = fn__getBlipInfoIdEntityIndex(_blip);
				return result;
			}
		}

		public int GetBlipInfoIdPickupIndex(int _blip)
		{
			unsafe {
				if (fn__getBlipInfoIdPickupIndex == null) fn__getBlipInfoIdPickupIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipInfoIdPickupIndex");
				var result = fn__getBlipInfoIdPickupIndex(_blip);
				return result;
			}
		}

		public int GetBlipFromEntity(int _entity)
		{
			unsafe {
				if (fn__getBlipFromEntity == null) fn__getBlipFromEntity = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipFromEntity");
				var result = fn__getBlipFromEntity(_entity);
				return result;
			}
		}

		public int AddBlipForRadius(float _posX, float _posY, float _posZ, float _radius)
		{
			unsafe {
				if (fn__addBlipForRadius == null) fn__addBlipForRadius = (delegate* unmanaged[Cdecl]<float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_addBlipForRadius");
				var result = fn__addBlipForRadius(_posX, _posY, _posZ, _radius);
				return result;
			}
		}

		public int AddBlipForArea(float _x, float _y, float _z, float _width, float _height)
		{
			unsafe {
				if (fn__addBlipForArea == null) fn__addBlipForArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_addBlipForArea");
				var result = fn__addBlipForArea(_x, _y, _z, _width, _height);
				return result;
			}
		}

		public int AddBlipForEntity(int _entity)
		{
			unsafe {
				if (fn__addBlipForEntity == null) fn__addBlipForEntity = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_addBlipForEntity");
				var result = fn__addBlipForEntity(_entity);
				return result;
			}
		}

		public int AddBlipForPickup(int _pickup)
		{
			unsafe {
				if (fn__addBlipForPickup == null) fn__addBlipForPickup = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_addBlipForPickup");
				var result = fn__addBlipForPickup(_pickup);
				return result;
			}
		}

		public int AddBlipForCoord(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__addBlipForCoord == null) fn__addBlipForCoord = (delegate* unmanaged[Cdecl]<float, float, float, int>) NativeLibrary.GetExport(handle, "Native_addBlipForCoord");
				var result = fn__addBlipForCoord(_x, _y, _z);
				return result;
			}
		}

		public void TriggerSonarBlip(float _posX, float _posY, float _posZ, float _radius, int _p4)
		{
			unsafe {
				if (fn__triggerSonarBlip == null) fn__triggerSonarBlip = (delegate* unmanaged[Cdecl]<float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_triggerSonarBlip");
				fn__triggerSonarBlip(_posX, _posY, _posZ, _radius, _p4);
			}
		}

		public void AllowSonarBlips(bool _toggle)
		{
			unsafe {
				if (fn__allowSonarBlips == null) fn__allowSonarBlips = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_allowSonarBlips");
				fn__allowSonarBlips(_toggle);
			}
		}

		public void SetBlipCoords(int _blip, float _posX, float _posY, float _posZ)
		{
			unsafe {
				if (fn__setBlipCoords == null) fn__setBlipCoords = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setBlipCoords");
				fn__setBlipCoords(_blip, _posX, _posY, _posZ);
			}
		}

		public Vector3 GetBlipCoords(int _blip)
		{
			unsafe {
				if (fn__getBlipCoords == null) fn__getBlipCoords = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getBlipCoords");
				var result = fn__getBlipCoords(_blip);
				return result;
			}
		}

		public void SetBlipSprite(int _blip, int _spriteId)
		{
			unsafe {
				if (fn__setBlipSprite == null) fn__setBlipSprite = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipSprite");
				fn__setBlipSprite(_blip, _spriteId);
			}
		}

		public int GetBlipSprite(int _blip)
		{
			unsafe {
				if (fn__getBlipSprite == null) fn__getBlipSprite = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipSprite");
				var result = fn__getBlipSprite(_blip);
				return result;
			}
		}

		public void _0x9FCB3CBFB3EAD69A(int _p0, float _p1)
		{
			unsafe {
				if (fn__0x9FCB3CBFB3EAD69A == null) fn__0x9FCB3CBFB3EAD69A = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x9FCB3CBFB3EAD69A");
				fn__0x9FCB3CBFB3EAD69A(_p0, _p1);
			}
		}

		public void _0xB7B873520C84C118()
		{
			unsafe {
				if (fn__0xB7B873520C84C118 == null) fn__0xB7B873520C84C118 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xB7B873520C84C118");
				fn__0xB7B873520C84C118();
			}
		}

		public void SetBlipNameFromTextFile(int _blip, string _gxtEntry)
		{
			unsafe {
				if (fn__setBlipNameFromTextFile == null) fn__setBlipNameFromTextFile = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setBlipNameFromTextFile");
				var ptr_gxtEntry = MemoryUtils.StringToHGlobalUtf8(_gxtEntry);
				fn__setBlipNameFromTextFile(_blip, ptr_gxtEntry);
				Marshal.FreeHGlobal(ptr_gxtEntry);
			}
		}

		public void SetBlipNameToPlayerName(int _blip, int _player)
		{
			unsafe {
				if (fn__setBlipNameToPlayerName == null) fn__setBlipNameToPlayerName = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipNameToPlayerName");
				fn__setBlipNameToPlayerName(_blip, _player);
			}
		}

		public void SetBlipAlpha(int _blip, int _alpha)
		{
			unsafe {
				if (fn__setBlipAlpha == null) fn__setBlipAlpha = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipAlpha");
				fn__setBlipAlpha(_blip, _alpha);
			}
		}

		public int GetBlipAlpha(int _blip)
		{
			unsafe {
				if (fn__getBlipAlpha == null) fn__getBlipAlpha = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipAlpha");
				var result = fn__getBlipAlpha(_blip);
				return result;
			}
		}

		public void SetBlipFade(int _blip, int _opacity, int _duration)
		{
			unsafe {
				if (fn__setBlipFade == null) fn__setBlipFade = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipFade");
				fn__setBlipFade(_blip, _opacity, _duration);
			}
		}

		public int _0x2C173AE2BDB9385E(int _blip)
		{
			unsafe {
				if (fn__0x2C173AE2BDB9385E == null) fn__0x2C173AE2BDB9385E = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x2C173AE2BDB9385E");
				var result = fn__0x2C173AE2BDB9385E(_blip);
				return result;
			}
		}

		public void SetBlipRotation(int _blip, int _rotation)
		{
			unsafe {
				if (fn__setBlipRotation == null) fn__setBlipRotation = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipRotation");
				fn__setBlipRotation(_blip, _rotation);
			}
		}

		public void SetBlipSquaredRotation(int _blip, float _heading)
		{
			unsafe {
				if (fn__setBlipSquaredRotation == null) fn__setBlipSquaredRotation = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setBlipSquaredRotation");
				fn__setBlipSquaredRotation(_blip, _heading);
			}
		}

		public int GetBlipRotation(int _blip)
		{
			unsafe {
				if (fn__getBlipRotation == null) fn__getBlipRotation = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipRotation");
				var result = fn__getBlipRotation(_blip);
				return result;
			}
		}

		public void SetBlipFlashTimer(int _blip, int _duration)
		{
			unsafe {
				if (fn__setBlipFlashTimer == null) fn__setBlipFlashTimer = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipFlashTimer");
				fn__setBlipFlashTimer(_blip, _duration);
			}
		}

		public void SetBlipFlashInterval(int _blip, int _p1)
		{
			unsafe {
				if (fn__setBlipFlashInterval == null) fn__setBlipFlashInterval = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipFlashInterval");
				fn__setBlipFlashInterval(_blip, _p1);
			}
		}

		public void SetBlipColour(int _blip, int _color)
		{
			unsafe {
				if (fn__setBlipColour == null) fn__setBlipColour = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipColour");
				fn__setBlipColour(_blip, _color);
			}
		}

		public void SetBlipSecondaryColour(int _blip, int _r, int _g, int _b)
		{
			unsafe {
				if (fn__setBlipSecondaryColour == null) fn__setBlipSecondaryColour = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipSecondaryColour");
				fn__setBlipSecondaryColour(_blip, _r, _g, _b);
			}
		}

		public int GetBlipColour(int _blip)
		{
			unsafe {
				if (fn__getBlipColour == null) fn__getBlipColour = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipColour");
				var result = fn__getBlipColour(_blip);
				return result;
			}
		}

		public int GetBlipHudColour(int _blip)
		{
			unsafe {
				if (fn__getBlipHudColour == null) fn__getBlipHudColour = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getBlipHudColour");
				var result = fn__getBlipHudColour(_blip);
				return result;
			}
		}

		public bool IsBlipShortRange(int _blip)
		{
			unsafe {
				if (fn__isBlipShortRange == null) fn__isBlipShortRange = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isBlipShortRange");
				var result = fn__isBlipShortRange(_blip);
				return result;
			}
		}

		public bool IsBlipOnMinimap(int _blip)
		{
			unsafe {
				if (fn__isBlipOnMinimap == null) fn__isBlipOnMinimap = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isBlipOnMinimap");
				var result = fn__isBlipOnMinimap(_blip);
				return result;
			}
		}

		public bool DoesBlipHaveGpsRoute(int _blip)
		{
			unsafe {
				if (fn__doesBlipHaveGpsRoute == null) fn__doesBlipHaveGpsRoute = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesBlipHaveGpsRoute");
				var result = fn__doesBlipHaveGpsRoute(_blip);
				return result;
			}
		}

		public void SetBlipHiddenOnLegend(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipHiddenOnLegend == null) fn__setBlipHiddenOnLegend = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipHiddenOnLegend");
				fn__setBlipHiddenOnLegend(_blip, _toggle);
			}
		}

		public void SetBlipHighDetail(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipHighDetail == null) fn__setBlipHighDetail = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipHighDetail");
				fn__setBlipHighDetail(_blip, _toggle);
			}
		}

		public void SetBlipAsMissionCreatorBlip(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipAsMissionCreatorBlip == null) fn__setBlipAsMissionCreatorBlip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipAsMissionCreatorBlip");
				fn__setBlipAsMissionCreatorBlip(_blip, _toggle);
			}
		}

		public bool IsMissionCreatorBlip(int _blip)
		{
			unsafe {
				if (fn__isMissionCreatorBlip == null) fn__isMissionCreatorBlip = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMissionCreatorBlip");
				var result = fn__isMissionCreatorBlip(_blip);
				return result;
			}
		}

		public int GetNewSelectedMissionCreatorBlip()
		{
			unsafe {
				if (fn__getNewSelectedMissionCreatorBlip == null) fn__getNewSelectedMissionCreatorBlip = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNewSelectedMissionCreatorBlip");
				var result = fn__getNewSelectedMissionCreatorBlip();
				return result;
			}
		}

		public bool IsHoveringOverMissionCreatorBlip()
		{
			unsafe {
				if (fn__isHoveringOverMissionCreatorBlip == null) fn__isHoveringOverMissionCreatorBlip = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isHoveringOverMissionCreatorBlip");
				var result = fn__isHoveringOverMissionCreatorBlip();
				return result;
			}
		}

		public void ShowStartMissionInstructionalButton(bool _p0)
		{
			unsafe {
				if (fn__showStartMissionInstructionalButton == null) fn__showStartMissionInstructionalButton = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_showStartMissionInstructionalButton");
				fn__showStartMissionInstructionalButton(_p0);
			}
		}

		public void _0x2916A928514C9827()
		{
			unsafe {
				if (fn__0x2916A928514C9827 == null) fn__0x2916A928514C9827 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x2916A928514C9827");
				fn__0x2916A928514C9827();
			}
		}

		public void _0xB552929B85FC27EC(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xB552929B85FC27EC == null) fn__0xB552929B85FC27EC = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xB552929B85FC27EC");
				fn__0xB552929B85FC27EC(_p0, _p1);
			}
		}

		public void SetBlipFlashes(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipFlashes == null) fn__setBlipFlashes = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipFlashes");
				fn__setBlipFlashes(_blip, _toggle);
			}
		}

		public void SetBlipFlashesAlternate(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipFlashesAlternate == null) fn__setBlipFlashesAlternate = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipFlashesAlternate");
				fn__setBlipFlashesAlternate(_blip, _toggle);
			}
		}

		public bool IsBlipFlashing(int _blip)
		{
			unsafe {
				if (fn__isBlipFlashing == null) fn__isBlipFlashing = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isBlipFlashing");
				var result = fn__isBlipFlashing(_blip);
				return result;
			}
		}

		public void SetBlipAsShortRange(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipAsShortRange == null) fn__setBlipAsShortRange = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipAsShortRange");
				fn__setBlipAsShortRange(_blip, _toggle);
			}
		}

		public void SetBlipScale(int _blip, float _scale)
		{
			unsafe {
				if (fn__setBlipScale == null) fn__setBlipScale = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setBlipScale");
				fn__setBlipScale(_blip, _scale);
			}
		}

		public void SetBlipScaleTransformation(int _blip, float _xScale, float _yScale)
		{
			unsafe {
				if (fn__setBlipScaleTransformation == null) fn__setBlipScaleTransformation = (delegate* unmanaged[Cdecl]<int, float, float, void>) NativeLibrary.GetExport(handle, "Native_setBlipScaleTransformation");
				fn__setBlipScaleTransformation(_blip, _xScale, _yScale);
			}
		}

		public void SetBlipPriority(int _blip, int _priority)
		{
			unsafe {
				if (fn__setBlipPriority == null) fn__setBlipPriority = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipPriority");
				fn__setBlipPriority(_blip, _priority);
			}
		}

		public void SetBlipDisplay(int _blip, int _displayId)
		{
			unsafe {
				if (fn__setBlipDisplay == null) fn__setBlipDisplay = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipDisplay");
				fn__setBlipDisplay(_blip, _displayId);
			}
		}

		public void SetBlipCategory(int _blip, int _index)
		{
			unsafe {
				if (fn__setBlipCategory == null) fn__setBlipCategory = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipCategory");
				fn__setBlipCategory(_blip, _index);
			}
		}

		public void RemoveBlip(ref int _blip)
		{
			unsafe {
				if (fn__removeBlip == null) fn__removeBlip = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_removeBlip");
				var ref_blip = _blip;
				fn__removeBlip(&ref_blip);
				_blip = ref_blip;
			}
		}

		public void SetBlipAsFriendly(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipAsFriendly == null) fn__setBlipAsFriendly = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipAsFriendly");
				fn__setBlipAsFriendly(_blip, _toggle);
			}
		}

		public void PulseBlip(int _blip)
		{
			unsafe {
				if (fn__pulseBlip == null) fn__pulseBlip = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_pulseBlip");
				fn__pulseBlip(_blip);
			}
		}

		public void ShowNumberOnBlip(int _blip, int _number)
		{
			unsafe {
				if (fn__showNumberOnBlip == null) fn__showNumberOnBlip = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_showNumberOnBlip");
				fn__showNumberOnBlip(_blip, _number);
			}
		}

		public void HideNumberOnBlip(int _blip)
		{
			unsafe {
				if (fn__hideNumberOnBlip == null) fn__hideNumberOnBlip = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_hideNumberOnBlip");
				fn__hideNumberOnBlip(_blip);
			}
		}

		public void ShowHeightOnBlip(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__showHeightOnBlip == null) fn__showHeightOnBlip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_showHeightOnBlip");
				fn__showHeightOnBlip(_blip, _toggle);
			}
		}

		public void ShowTickOnBlip(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__showTickOnBlip == null) fn__showTickOnBlip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_showTickOnBlip");
				fn__showTickOnBlip(_blip, _toggle);
			}
		}

		public void ShowHeadingIndicatorOnBlip(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__showHeadingIndicatorOnBlip == null) fn__showHeadingIndicatorOnBlip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_showHeadingIndicatorOnBlip");
				fn__showHeadingIndicatorOnBlip(_blip, _toggle);
			}
		}

		public void ShowOutlineIndicatorOnBlip(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__showOutlineIndicatorOnBlip == null) fn__showOutlineIndicatorOnBlip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_showOutlineIndicatorOnBlip");
				fn__showOutlineIndicatorOnBlip(_blip, _toggle);
			}
		}

		public void ShowFriendIndicatorOnBlip(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__showFriendIndicatorOnBlip == null) fn__showFriendIndicatorOnBlip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_showFriendIndicatorOnBlip");
				fn__showFriendIndicatorOnBlip(_blip, _toggle);
			}
		}

		public void ShowCrewIndicatorOnBlip(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__showCrewIndicatorOnBlip == null) fn__showCrewIndicatorOnBlip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_showCrewIndicatorOnBlip");
				fn__showCrewIndicatorOnBlip(_blip, _toggle);
			}
		}

		public void SetBlipDisplayIndicatorOnBlip(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipDisplayIndicatorOnBlip == null) fn__setBlipDisplayIndicatorOnBlip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipDisplayIndicatorOnBlip");
				fn__setBlipDisplayIndicatorOnBlip(_blip, _toggle);
			}
		}

		public void _0x4B5B620C9B59ED34(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x4B5B620C9B59ED34 == null) fn__0x4B5B620C9B59ED34 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x4B5B620C9B59ED34");
				fn__0x4B5B620C9B59ED34(_p0, _p1);
			}
		}

		public void _0x2C9F302398E13141(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x2C9F302398E13141 == null) fn__0x2C9F302398E13141 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2C9F302398E13141");
				fn__0x2C9F302398E13141(_p0, _p1);
			}
		}

		public void SetBlipAsMinimalOnEdge(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipAsMinimalOnEdge == null) fn__setBlipAsMinimalOnEdge = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipAsMinimalOnEdge");
				fn__setBlipAsMinimalOnEdge(_blip, _toggle);
			}
		}

		public void SetRadiusBlipEdge(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setRadiusBlipEdge == null) fn__setRadiusBlipEdge = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setRadiusBlipEdge");
				fn__setRadiusBlipEdge(_blip, _toggle);
			}
		}

		public bool DoesBlipExist(int _blip)
		{
			unsafe {
				if (fn__doesBlipExist == null) fn__doesBlipExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesBlipExist");
				var result = fn__doesBlipExist(_blip);
				return result;
			}
		}

		public void SetWaypointOff()
		{
			unsafe {
				if (fn__setWaypointOff == null) fn__setWaypointOff = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setWaypointOff");
				fn__setWaypointOff();
			}
		}

		public void DeleteWaypoint()
		{
			unsafe {
				if (fn__deleteWaypoint == null) fn__deleteWaypoint = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_deleteWaypoint");
				fn__deleteWaypoint();
			}
		}

		public void RefreshWaypoint()
		{
			unsafe {
				if (fn__refreshWaypoint == null) fn__refreshWaypoint = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_refreshWaypoint");
				fn__refreshWaypoint();
			}
		}

		public bool IsWaypointActive()
		{
			unsafe {
				if (fn__isWaypointActive == null) fn__isWaypointActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isWaypointActive");
				var result = fn__isWaypointActive();
				return result;
			}
		}

		public void SetNewWaypoint(float _x, float _y)
		{
			unsafe {
				if (fn__setNewWaypoint == null) fn__setNewWaypoint = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_setNewWaypoint");
				fn__setNewWaypoint(_x, _y);
			}
		}

		public void SetBlipBright(int _blip, bool _toggle)
		{
			unsafe {
				if (fn__setBlipBright == null) fn__setBlipBright = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlipBright");
				fn__setBlipBright(_blip, _toggle);
			}
		}

		public void SetBlipShowCone(int _blip, bool _toggle, int _p2)
		{
			unsafe {
				if (fn__setBlipShowCone == null) fn__setBlipShowCone = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setBlipShowCone");
				fn__setBlipShowCone(_blip, _toggle, _p2);
			}
		}

		public void _0xC594B315EDF2D4AF(int _ped)
		{
			unsafe {
				if (fn__0xC594B315EDF2D4AF == null) fn__0xC594B315EDF2D4AF = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC594B315EDF2D4AF");
				fn__0xC594B315EDF2D4AF(_ped);
			}
		}

		public void _0xF83D0FEBE75E62C9(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8)
		{
			unsafe {
				if (fn__0xF83D0FEBE75E62C9 == null) fn__0xF83D0FEBE75E62C9 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xF83D0FEBE75E62C9");
				fn__0xF83D0FEBE75E62C9(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
			}
		}

		public void _0x35A3CD97B2C0A6D2(int _blip)
		{
			unsafe {
				if (fn__0x35A3CD97B2C0A6D2 == null) fn__0x35A3CD97B2C0A6D2 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x35A3CD97B2C0A6D2");
				fn__0x35A3CD97B2C0A6D2(_blip);
			}
		}

		public void _0x8410C5E0CD847B9D()
		{
			unsafe {
				if (fn__0x8410C5E0CD847B9D == null) fn__0x8410C5E0CD847B9D = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x8410C5E0CD847B9D");
				fn__0x8410C5E0CD847B9D();
			}
		}

		public int SetMinimapComponent(int _componentId, bool _toggle, int _overrideColor)
		{
			unsafe {
				if (fn__setMinimapComponent == null) fn__setMinimapComponent = (delegate* unmanaged[Cdecl]<int, bool, int, int>) NativeLibrary.GetExport(handle, "Native_setMinimapComponent");
				var result = fn__setMinimapComponent(_componentId, _toggle, _overrideColor);
				return result;
			}
		}

		public void SetMinimapSonarEnabled(bool _toggle)
		{
			unsafe {
				if (fn__setMinimapSonarEnabled == null) fn__setMinimapSonarEnabled = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMinimapSonarEnabled");
				fn__setMinimapSonarEnabled(_toggle);
			}
		}

		public void ShowSigninUi()
		{
			unsafe {
				if (fn__showSigninUi == null) fn__showSigninUi = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_showSigninUi");
				fn__showSigninUi();
			}
		}

		public int GetMainPlayerBlipId()
		{
			unsafe {
				if (fn__getMainPlayerBlipId == null) fn__getMainPlayerBlipId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMainPlayerBlipId");
				var result = fn__getMainPlayerBlipId();
				return result;
			}
		}

		public void _0x41350B4FC28E3941(bool _p0)
		{
			unsafe {
				if (fn__0x41350B4FC28E3941 == null) fn__0x41350B4FC28E3941 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x41350B4FC28E3941");
				fn__0x41350B4FC28E3941(_p0);
			}
		}

		public void HideLoadingOnFadeThisFrame()
		{
			unsafe {
				if (fn__hideLoadingOnFadeThisFrame == null) fn__hideLoadingOnFadeThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_hideLoadingOnFadeThisFrame");
				fn__hideLoadingOnFadeThisFrame();
			}
		}

		public void SetRadarAsInteriorThisFrame(int _interior, float _x, float _y, int _z, int _zoom)
		{
			unsafe {
				if (fn__setRadarAsInteriorThisFrame == null) fn__setRadarAsInteriorThisFrame = (delegate* unmanaged[Cdecl]<int, float, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_setRadarAsInteriorThisFrame");
				fn__setRadarAsInteriorThisFrame(_interior, _x, _y, _z, _zoom);
			}
		}

		public void SetInteriorZoomLevelIncreased(bool _toggle)
		{
			unsafe {
				if (fn__setInteriorZoomLevelIncreased == null) fn__setInteriorZoomLevelIncreased = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setInteriorZoomLevelIncreased");
				fn__setInteriorZoomLevelIncreased(_toggle);
			}
		}

		public void SetInteriorZoomLevelDecreased(bool _toggle)
		{
			unsafe {
				if (fn__setInteriorZoomLevelDecreased == null) fn__setInteriorZoomLevelDecreased = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setInteriorZoomLevelDecreased");
				fn__setInteriorZoomLevelDecreased(_toggle);
			}
		}

		public void SetRadarAsExteriorThisFrame()
		{
			unsafe {
				if (fn__setRadarAsExteriorThisFrame == null) fn__setRadarAsExteriorThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setRadarAsExteriorThisFrame");
				fn__setRadarAsExteriorThisFrame();
			}
		}

		public void SetPlayerBlipPositionThisFrame(float _x, float _y)
		{
			unsafe {
				if (fn__setPlayerBlipPositionThisFrame == null) fn__setPlayerBlipPositionThisFrame = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerBlipPositionThisFrame");
				fn__setPlayerBlipPositionThisFrame(_x, _y);
			}
		}

		public void _0xA17784FCA9548D15(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xA17784FCA9548D15 == null) fn__0xA17784FCA9548D15 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xA17784FCA9548D15");
				fn__0xA17784FCA9548D15(_p0, _p1, _p2);
			}
		}

		public bool IsMinimapInInterior()
		{
			unsafe {
				if (fn__isMinimapInInterior == null) fn__isMinimapInInterior = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMinimapInInterior");
				var result = fn__isMinimapInInterior();
				return result;
			}
		}

		public void HideMinimapExteriorMapThisFrame()
		{
			unsafe {
				if (fn__hideMinimapExteriorMapThisFrame == null) fn__hideMinimapExteriorMapThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_hideMinimapExteriorMapThisFrame");
				fn__hideMinimapExteriorMapThisFrame();
			}
		}

		public void HideMinimapInteriorMapThisFrame()
		{
			unsafe {
				if (fn__hideMinimapInteriorMapThisFrame == null) fn__hideMinimapInteriorMapThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_hideMinimapInteriorMapThisFrame");
				fn__hideMinimapInteriorMapThisFrame();
			}
		}

		public void SetToggleMinimapHeistIsland(bool _toggle)
		{
			unsafe {
				if (fn__setToggleMinimapHeistIsland == null) fn__setToggleMinimapHeistIsland = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setToggleMinimapHeistIsland");
				fn__setToggleMinimapHeistIsland(_toggle);
			}
		}

		public void DontTiltMinimapThisFrame()
		{
			unsafe {
				if (fn__dontTiltMinimapThisFrame == null) fn__dontTiltMinimapThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_dontTiltMinimapThisFrame");
				fn__dontTiltMinimapThisFrame();
			}
		}

		public void _0x55F5A5F07134DE60()
		{
			unsafe {
				if (fn__0x55F5A5F07134DE60 == null) fn__0x55F5A5F07134DE60 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x55F5A5F07134DE60");
				fn__0x55F5A5F07134DE60();
			}
		}

		public void SetWidescreenFormat(int _p0)
		{
			unsafe {
				if (fn__setWidescreenFormat == null) fn__setWidescreenFormat = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setWidescreenFormat");
				fn__setWidescreenFormat(_p0);
			}
		}

		public void DisplayAreaName(bool _toggle)
		{
			unsafe {
				if (fn__displayAreaName == null) fn__displayAreaName = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_displayAreaName");
				fn__displayAreaName(_toggle);
			}
		}

		public void DisplayCash(bool _toggle)
		{
			unsafe {
				if (fn__displayCash == null) fn__displayCash = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_displayCash");
				fn__displayCash(_toggle);
			}
		}

		public void _0x170F541E1CADD1DE(bool _p0)
		{
			unsafe {
				if (fn__0x170F541E1CADD1DE == null) fn__0x170F541E1CADD1DE = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x170F541E1CADD1DE");
				fn__0x170F541E1CADD1DE(_p0);
			}
		}

		public void SetPlayerCashChange(int _cash, int _bank)
		{
			unsafe {
				if (fn__setPlayerCashChange == null) fn__setPlayerCashChange = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerCashChange");
				fn__setPlayerCashChange(_cash, _bank);
			}
		}

		public void DisplayAmmoThisFrame(bool _display)
		{
			unsafe {
				if (fn__displayAmmoThisFrame == null) fn__displayAmmoThisFrame = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_displayAmmoThisFrame");
				fn__displayAmmoThisFrame(_display);
			}
		}

		public void DisplaySniperScopeThisFrame()
		{
			unsafe {
				if (fn__displaySniperScopeThisFrame == null) fn__displaySniperScopeThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_displaySniperScopeThisFrame");
				fn__displaySniperScopeThisFrame();
			}
		}

		public void HideHudAndRadarThisFrame()
		{
			unsafe {
				if (fn__hideHudAndRadarThisFrame == null) fn__hideHudAndRadarThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_hideHudAndRadarThisFrame");
				fn__hideHudAndRadarThisFrame();
			}
		}

		public void _0xE67C6DFD386EA5E7(bool _p0)
		{
			unsafe {
				if (fn__0xE67C6DFD386EA5E7 == null) fn__0xE67C6DFD386EA5E7 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xE67C6DFD386EA5E7");
				fn__0xE67C6DFD386EA5E7(_p0);
			}
		}

		public void SetMultiplayerWalletCash()
		{
			unsafe {
				if (fn__setMultiplayerWalletCash == null) fn__setMultiplayerWalletCash = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setMultiplayerWalletCash");
				fn__setMultiplayerWalletCash();
			}
		}

		public void RemoveMultiplayerWalletCash()
		{
			unsafe {
				if (fn__removeMultiplayerWalletCash == null) fn__removeMultiplayerWalletCash = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeMultiplayerWalletCash");
				fn__removeMultiplayerWalletCash();
			}
		}

		public void SetMultiplayerBankCash()
		{
			unsafe {
				if (fn__setMultiplayerBankCash == null) fn__setMultiplayerBankCash = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setMultiplayerBankCash");
				fn__setMultiplayerBankCash();
			}
		}

		public void RemoveMultiplayerBankCash()
		{
			unsafe {
				if (fn__removeMultiplayerBankCash == null) fn__removeMultiplayerBankCash = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeMultiplayerBankCash");
				fn__removeMultiplayerBankCash();
			}
		}

		public void SetMultiplayerHudCash(int _p0, int _p1)
		{
			unsafe {
				if (fn__setMultiplayerHudCash == null) fn__setMultiplayerHudCash = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setMultiplayerHudCash");
				fn__setMultiplayerHudCash(_p0, _p1);
			}
		}

		public void RemoveMultiplayerHudCash()
		{
			unsafe {
				if (fn__removeMultiplayerHudCash == null) fn__removeMultiplayerHudCash = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeMultiplayerHudCash");
				fn__removeMultiplayerHudCash();
			}
		}

		public void HideHelpTextThisFrame()
		{
			unsafe {
				if (fn__hideHelpTextThisFrame == null) fn__hideHelpTextThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_hideHelpTextThisFrame");
				fn__hideHelpTextThisFrame();
			}
		}

		public bool _0x801879A9B4F4B2FB()
		{
			unsafe {
				if (fn__0x801879A9B4F4B2FB == null) fn__0x801879A9B4F4B2FB = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x801879A9B4F4B2FB");
				var result = fn__0x801879A9B4F4B2FB();
				return result;
			}
		}

		public void DisplayHelpTextThisFrame(string _message, bool _p1)
		{
			unsafe {
				if (fn__displayHelpTextThisFrame == null) fn__displayHelpTextThisFrame = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_displayHelpTextThisFrame");
				var ptr_message = MemoryUtils.StringToHGlobalUtf8(_message);
				fn__displayHelpTextThisFrame(ptr_message, _p1);
				Marshal.FreeHGlobal(ptr_message);
			}
		}

		public void HudForceWeaponWheel(bool _show)
		{
			unsafe {
				if (fn__hudForceWeaponWheel == null) fn__hudForceWeaponWheel = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_hudForceWeaponWheel");
				fn__hudForceWeaponWheel(_show);
			}
		}

		public void HudDisplayLoadingScreenTips()
		{
			unsafe {
				if (fn__hudDisplayLoadingScreenTips == null) fn__hudDisplayLoadingScreenTips = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_hudDisplayLoadingScreenTips");
				fn__hudDisplayLoadingScreenTips();
			}
		}

		public void BlockWeaponWheelThisFrame()
		{
			unsafe {
				if (fn__blockWeaponWheelThisFrame == null) fn__blockWeaponWheelThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_blockWeaponWheelThisFrame");
				fn__blockWeaponWheelThisFrame();
			}
		}

		public int HudWeaponWheelGetSelectedHash()
		{
			unsafe {
				if (fn__hudWeaponWheelGetSelectedHash == null) fn__hudWeaponWheelGetSelectedHash = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_hudWeaponWheelGetSelectedHash");
				var result = fn__hudWeaponWheelGetSelectedHash();
				return result;
			}
		}

		public void HudSetWeaponWheelTopSlot(int _weaponHash)
		{
			unsafe {
				if (fn__hudSetWeaponWheelTopSlot == null) fn__hudSetWeaponWheelTopSlot = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_hudSetWeaponWheelTopSlot");
				fn__hudSetWeaponWheelTopSlot(_weaponHash);
			}
		}

		public int HudWeaponWheelGetSlotHash(int _weaponTypeIndex)
		{
			unsafe {
				if (fn__hudWeaponWheelGetSlotHash == null) fn__hudWeaponWheelGetSlotHash = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_hudWeaponWheelGetSlotHash");
				var result = fn__hudWeaponWheelGetSlotHash(_weaponTypeIndex);
				return result;
			}
		}

		public void HudWeaponWheelIgnoreControlInput(bool _toggle)
		{
			unsafe {
				if (fn__hudWeaponWheelIgnoreControlInput == null) fn__hudWeaponWheelIgnoreControlInput = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_hudWeaponWheelIgnoreControlInput");
				fn__hudWeaponWheelIgnoreControlInput(_toggle);
			}
		}

		public void SetGpsFlags(int _p0, float _p1)
		{
			unsafe {
				if (fn__setGpsFlags == null) fn__setGpsFlags = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setGpsFlags");
				fn__setGpsFlags(_p0, _p1);
			}
		}

		public void ClearGpsFlags()
		{
			unsafe {
				if (fn__clearGpsFlags == null) fn__clearGpsFlags = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearGpsFlags");
				fn__clearGpsFlags();
			}
		}

		public void SetRaceTrackRender(bool _toggle)
		{
			unsafe {
				if (fn__setRaceTrackRender == null) fn__setRaceTrackRender = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setRaceTrackRender");
				fn__setRaceTrackRender(_toggle);
			}
		}

		public void ClearGpsRaceTrack()
		{
			unsafe {
				if (fn__clearGpsRaceTrack == null) fn__clearGpsRaceTrack = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearGpsRaceTrack");
				fn__clearGpsRaceTrack();
			}
		}

		public void StartGpsCustomRoute(int _hudColor, bool _displayOnFoot, bool _followPlayer)
		{
			unsafe {
				if (fn__startGpsCustomRoute == null) fn__startGpsCustomRoute = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_startGpsCustomRoute");
				fn__startGpsCustomRoute(_hudColor, _displayOnFoot, _followPlayer);
			}
		}

		public void AddPointToGpsCustomRoute(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__addPointToGpsCustomRoute == null) fn__addPointToGpsCustomRoute = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_addPointToGpsCustomRoute");
				fn__addPointToGpsCustomRoute(_x, _y, _z);
			}
		}

		public void SetGpsCustomRouteRender(bool _toggle, int _radarThickness, int _mapThickness)
		{
			unsafe {
				if (fn__setGpsCustomRouteRender == null) fn__setGpsCustomRouteRender = (delegate* unmanaged[Cdecl]<bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_setGpsCustomRouteRender");
				fn__setGpsCustomRouteRender(_toggle, _radarThickness, _mapThickness);
			}
		}

		public void ClearGpsCustomRoute()
		{
			unsafe {
				if (fn__clearGpsCustomRoute == null) fn__clearGpsCustomRoute = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearGpsCustomRoute");
				fn__clearGpsCustomRoute();
			}
		}

		public void StartGpsMultiRoute(int _hudColor, bool _routeFromPlayer, bool _displayOnFoot)
		{
			unsafe {
				if (fn__startGpsMultiRoute == null) fn__startGpsMultiRoute = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_startGpsMultiRoute");
				fn__startGpsMultiRoute(_hudColor, _routeFromPlayer, _displayOnFoot);
			}
		}

		public void AddPointToGpsMultiRoute(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__addPointToGpsMultiRoute == null) fn__addPointToGpsMultiRoute = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_addPointToGpsMultiRoute");
				fn__addPointToGpsMultiRoute(_x, _y, _z);
			}
		}

		public void SetGpsMultiRouteRender(bool _toggle)
		{
			unsafe {
				if (fn__setGpsMultiRouteRender == null) fn__setGpsMultiRouteRender = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setGpsMultiRouteRender");
				fn__setGpsMultiRouteRender(_toggle);
			}
		}

		public void ClearGpsMultiRoute()
		{
			unsafe {
				if (fn__clearGpsMultiRoute == null) fn__clearGpsMultiRoute = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearGpsMultiRoute");
				fn__clearGpsMultiRoute();
			}
		}

		public void ClearGpsPlayerWaypoint()
		{
			unsafe {
				if (fn__clearGpsPlayerWaypoint == null) fn__clearGpsPlayerWaypoint = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearGpsPlayerWaypoint");
				fn__clearGpsPlayerWaypoint();
			}
		}

		public void SetGpsFlashes(bool _toggle)
		{
			unsafe {
				if (fn__setGpsFlashes == null) fn__setGpsFlashes = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setGpsFlashes");
				fn__setGpsFlashes(_toggle);
			}
		}

		public void SetMainPlayerBlipColour(int _color)
		{
			unsafe {
				if (fn__setMainPlayerBlipColour == null) fn__setMainPlayerBlipColour = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setMainPlayerBlipColour");
				fn__setMainPlayerBlipColour(_color);
			}
		}

		public void FlashMinimapDisplay()
		{
			unsafe {
				if (fn__flashMinimapDisplay == null) fn__flashMinimapDisplay = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_flashMinimapDisplay");
				fn__flashMinimapDisplay();
			}
		}

		public void FlashMinimapDisplayWithColor(int _hudColorIndex)
		{
			unsafe {
				if (fn__flashMinimapDisplayWithColor == null) fn__flashMinimapDisplayWithColor = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_flashMinimapDisplayWithColor");
				fn__flashMinimapDisplayWithColor(_hudColorIndex);
			}
		}

		public void ToggleStealthRadar(bool _toggle)
		{
			unsafe {
				if (fn__toggleStealthRadar == null) fn__toggleStealthRadar = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_toggleStealthRadar");
				fn__toggleStealthRadar(_toggle);
			}
		}

		public void SetMinimapInSpectatorMode(bool _toggle, int _ped)
		{
			unsafe {
				if (fn__setMinimapInSpectatorMode == null) fn__setMinimapInSpectatorMode = (delegate* unmanaged[Cdecl]<bool, int, void>) NativeLibrary.GetExport(handle, "Native_setMinimapInSpectatorMode");
				fn__setMinimapInSpectatorMode(_toggle, _ped);
			}
		}

		public void SetMissionName(bool _p0, string _name)
		{
			unsafe {
				if (fn__setMissionName == null) fn__setMissionName = (delegate* unmanaged[Cdecl]<bool, nint, void>) NativeLibrary.GetExport(handle, "Native_setMissionName");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setMissionName(_p0, ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void SetMissionName2(bool _p0, string _name)
		{
			unsafe {
				if (fn__setMissionName2 == null) fn__setMissionName2 = (delegate* unmanaged[Cdecl]<bool, nint, void>) NativeLibrary.GetExport(handle, "Native_setMissionName2");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setMissionName2(_p0, ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void _0x817B86108EB94E51(bool _p0, ref int _p1, ref int _p2, ref int _p3, ref int _p4, ref int _p5, ref int _p6, ref int _p7, ref int _p8)
		{
			unsafe {
				if (fn__0x817B86108EB94E51 == null) fn__0x817B86108EB94E51 = (delegate* unmanaged[Cdecl]<bool, int*, int*, int*, int*, int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native__0x817B86108EB94E51");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				var ref_p4 = _p4;
				var ref_p5 = _p5;
				var ref_p6 = _p6;
				var ref_p7 = _p7;
				var ref_p8 = _p8;
				fn__0x817B86108EB94E51(_p0, &ref_p1, &ref_p2, &ref_p3, &ref_p4, &ref_p5, &ref_p6, &ref_p7, &ref_p8);
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
				_p4 = ref_p4;
				_p5 = ref_p5;
				_p6 = ref_p6;
				_p7 = ref_p7;
				_p8 = ref_p8;
			}
		}

		public void SetMinimapBlockWaypoint(bool _toggle)
		{
			unsafe {
				if (fn__setMinimapBlockWaypoint == null) fn__setMinimapBlockWaypoint = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMinimapBlockWaypoint");
				fn__setMinimapBlockWaypoint(_toggle);
			}
		}

		public void SetMinimapInPrologue(bool _toggle)
		{
			unsafe {
				if (fn__setMinimapInPrologue == null) fn__setMinimapInPrologue = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMinimapInPrologue");
				fn__setMinimapInPrologue(_toggle);
			}
		}

		public void SetMinimapHideFow(bool _toggle)
		{
			unsafe {
				if (fn__setMinimapHideFow == null) fn__setMinimapHideFow = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMinimapHideFow");
				fn__setMinimapHideFow(_toggle);
			}
		}

		public float GetMinimapFowDiscoveryRatio()
		{
			unsafe {
				if (fn__getMinimapFowDiscoveryRatio == null) fn__getMinimapFowDiscoveryRatio = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getMinimapFowDiscoveryRatio");
				var result = fn__getMinimapFowDiscoveryRatio();
				return result;
			}
		}

		public bool GetMinimapFowCoordinateIsRevealed(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__getMinimapFowCoordinateIsRevealed == null) fn__getMinimapFowCoordinateIsRevealed = (delegate* unmanaged[Cdecl]<float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_getMinimapFowCoordinateIsRevealed");
				var result = fn__getMinimapFowCoordinateIsRevealed(_x, _y, _z);
				return result;
			}
		}

		public void _0x62E849B7EB28E770(bool _p0)
		{
			unsafe {
				if (fn__0x62E849B7EB28E770 == null) fn__0x62E849B7EB28E770 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x62E849B7EB28E770");
				fn__0x62E849B7EB28E770(_p0);
			}
		}

		public void SetMinimapFowRevealCoordinate(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setMinimapFowRevealCoordinate == null) fn__setMinimapFowRevealCoordinate = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setMinimapFowRevealCoordinate");
				fn__setMinimapFowRevealCoordinate(_x, _y, _z);
			}
		}

		public void SetMinimapGolfCourse(int _hole)
		{
			unsafe {
				if (fn__setMinimapGolfCourse == null) fn__setMinimapGolfCourse = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setMinimapGolfCourse");
				fn__setMinimapGolfCourse(_hole);
			}
		}

		public void SetMinimapGolfCourseOff()
		{
			unsafe {
				if (fn__setMinimapGolfCourseOff == null) fn__setMinimapGolfCourseOff = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setMinimapGolfCourseOff");
				fn__setMinimapGolfCourseOff();
			}
		}

		public void LockMinimapAngle(int _angle)
		{
			unsafe {
				if (fn__lockMinimapAngle == null) fn__lockMinimapAngle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_lockMinimapAngle");
				fn__lockMinimapAngle(_angle);
			}
		}

		public void UnlockMinimapAngle()
		{
			unsafe {
				if (fn__unlockMinimapAngle == null) fn__unlockMinimapAngle = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_unlockMinimapAngle");
				fn__unlockMinimapAngle();
			}
		}

		public void LockMinimapPosition(float _x, float _y)
		{
			unsafe {
				if (fn__lockMinimapPosition == null) fn__lockMinimapPosition = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_lockMinimapPosition");
				fn__lockMinimapPosition(_x, _y);
			}
		}

		public void UnlockMinimapPosition()
		{
			unsafe {
				if (fn__unlockMinimapPosition == null) fn__unlockMinimapPosition = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_unlockMinimapPosition");
				fn__unlockMinimapPosition();
			}
		}

		public void SetMinimapAltitudeIndicatorLevel(float _altitude, bool _p1, int _p2)
		{
			unsafe {
				if (fn__setMinimapAltitudeIndicatorLevel == null) fn__setMinimapAltitudeIndicatorLevel = (delegate* unmanaged[Cdecl]<float, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setMinimapAltitudeIndicatorLevel");
				fn__setMinimapAltitudeIndicatorLevel(_altitude, _p1, _p2);
			}
		}

		public void SetHealthHudDisplayValues(int _health, int _capacity, bool _wasAdded)
		{
			unsafe {
				if (fn__setHealthHudDisplayValues == null) fn__setHealthHudDisplayValues = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setHealthHudDisplayValues");
				fn__setHealthHudDisplayValues(_health, _capacity, _wasAdded);
			}
		}

		public void SetMaxHealthHudDisplay(int _maximumValue)
		{
			unsafe {
				if (fn__setMaxHealthHudDisplay == null) fn__setMaxHealthHudDisplay = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setMaxHealthHudDisplay");
				fn__setMaxHealthHudDisplay(_maximumValue);
			}
		}

		public void SetMaxArmourHudDisplay(int _maximumValue)
		{
			unsafe {
				if (fn__setMaxArmourHudDisplay == null) fn__setMaxArmourHudDisplay = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setMaxArmourHudDisplay");
				fn__setMaxArmourHudDisplay(_maximumValue);
			}
		}

		public void SetBigmapActive(bool _toggleBigMap, bool _showFullMap)
		{
			unsafe {
				if (fn__setBigmapActive == null) fn__setBigmapActive = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setBigmapActive");
				fn__setBigmapActive(_toggleBigMap, _showFullMap);
			}
		}

		public bool IsHudComponentActive(int _id)
		{
			unsafe {
				if (fn__isHudComponentActive == null) fn__isHudComponentActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isHudComponentActive");
				var result = fn__isHudComponentActive(_id);
				return result;
			}
		}

		public bool IsScriptedHudComponentActive(int _id)
		{
			unsafe {
				if (fn__isScriptedHudComponentActive == null) fn__isScriptedHudComponentActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isScriptedHudComponentActive");
				var result = fn__isScriptedHudComponentActive(_id);
				return result;
			}
		}

		public void HideScriptedHudComponentThisFrame(int _id)
		{
			unsafe {
				if (fn__hideScriptedHudComponentThisFrame == null) fn__hideScriptedHudComponentThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_hideScriptedHudComponentThisFrame");
				fn__hideScriptedHudComponentThisFrame(_id);
			}
		}

		public void ShowScriptedHudComponentThisFrame(int _id)
		{
			unsafe {
				if (fn__showScriptedHudComponentThisFrame == null) fn__showScriptedHudComponentThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_showScriptedHudComponentThisFrame");
				fn__showScriptedHudComponentThisFrame(_id);
			}
		}

		public bool IsScriptedHudComponentHiddenThisFrame(int _id)
		{
			unsafe {
				if (fn__isScriptedHudComponentHiddenThisFrame == null) fn__isScriptedHudComponentHiddenThisFrame = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isScriptedHudComponentHiddenThisFrame");
				var result = fn__isScriptedHudComponentHiddenThisFrame(_id);
				return result;
			}
		}

		public void HideHudComponentThisFrame(int _id)
		{
			unsafe {
				if (fn__hideHudComponentThisFrame == null) fn__hideHudComponentThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_hideHudComponentThisFrame");
				fn__hideHudComponentThisFrame(_id);
			}
		}

		public void ShowHudComponentThisFrame(int _id)
		{
			unsafe {
				if (fn__showHudComponentThisFrame == null) fn__showHudComponentThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_showHudComponentThisFrame");
				fn__showHudComponentThisFrame(_id);
			}
		}

		public void HideAreaAndVehicleNameThisFrame()
		{
			unsafe {
				if (fn__hideAreaAndVehicleNameThisFrame == null) fn__hideAreaAndVehicleNameThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_hideAreaAndVehicleNameThisFrame");
				fn__hideAreaAndVehicleNameThisFrame();
			}
		}

		public void ResetReticuleValues()
		{
			unsafe {
				if (fn__resetReticuleValues == null) fn__resetReticuleValues = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetReticuleValues");
				fn__resetReticuleValues();
			}
		}

		public void ResetHudComponentValues(int _id)
		{
			unsafe {
				if (fn__resetHudComponentValues == null) fn__resetHudComponentValues = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetHudComponentValues");
				fn__resetHudComponentValues(_id);
			}
		}

		public void SetHudComponentPosition(int _id, float _x, float _y)
		{
			unsafe {
				if (fn__setHudComponentPosition == null) fn__setHudComponentPosition = (delegate* unmanaged[Cdecl]<int, float, float, void>) NativeLibrary.GetExport(handle, "Native_setHudComponentPosition");
				fn__setHudComponentPosition(_id, _x, _y);
			}
		}

		public Vector3 GetHudComponentPosition(int _id)
		{
			unsafe {
				if (fn__getHudComponentPosition == null) fn__getHudComponentPosition = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getHudComponentPosition");
				var result = fn__getHudComponentPosition(_id);
				return result;
			}
		}

		public void ClearReminderMessage()
		{
			unsafe {
				if (fn__clearReminderMessage == null) fn__clearReminderMessage = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearReminderMessage");
				fn__clearReminderMessage();
			}
		}

		public bool GetScreenCoordFromWorldCoord2(float _worldX, float _worldY, float _worldZ, ref float _screenX, ref float _screenY)
		{
			unsafe {
				if (fn__getScreenCoordFromWorldCoord2 == null) fn__getScreenCoordFromWorldCoord2 = (delegate* unmanaged[Cdecl]<float, float, float, float*, float*, bool>) NativeLibrary.GetExport(handle, "Native_getScreenCoordFromWorldCoord2");
				var ref_screenX = _screenX;
				var ref_screenY = _screenY;
				var result = fn__getScreenCoordFromWorldCoord2(_worldX, _worldY, _worldZ, &ref_screenX, &ref_screenY);
				_screenX = ref_screenX;
				_screenY = ref_screenY;
				return result;
			}
		}

		public void OpenReportugcMenu()
		{
			unsafe {
				if (fn__openReportugcMenu == null) fn__openReportugcMenu = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_openReportugcMenu");
				fn__openReportugcMenu();
			}
		}

		public void ForceCloseReportugcMenu()
		{
			unsafe {
				if (fn__forceCloseReportugcMenu == null) fn__forceCloseReportugcMenu = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_forceCloseReportugcMenu");
				fn__forceCloseReportugcMenu();
			}
		}

		public bool IsReportugcMenuOpen()
		{
			unsafe {
				if (fn__isReportugcMenuOpen == null) fn__isReportugcMenuOpen = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isReportugcMenuOpen");
				var result = fn__isReportugcMenuOpen();
				return result;
			}
		}

		public bool IsFloatingHelpTextOnScreen(int _hudIndex)
		{
			unsafe {
				if (fn__isFloatingHelpTextOnScreen == null) fn__isFloatingHelpTextOnScreen = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isFloatingHelpTextOnScreen");
				var result = fn__isFloatingHelpTextOnScreen(_hudIndex);
				return result;
			}
		}

		public void SetFloatingHelpTextScreenPosition(int _hudIndex, float _x, float _y)
		{
			unsafe {
				if (fn__setFloatingHelpTextScreenPosition == null) fn__setFloatingHelpTextScreenPosition = (delegate* unmanaged[Cdecl]<int, float, float, void>) NativeLibrary.GetExport(handle, "Native_setFloatingHelpTextScreenPosition");
				fn__setFloatingHelpTextScreenPosition(_hudIndex, _x, _y);
			}
		}

		public void SetFloatingHelpTextWorldPosition(int _hudIndex, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setFloatingHelpTextWorldPosition == null) fn__setFloatingHelpTextWorldPosition = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setFloatingHelpTextWorldPosition");
				fn__setFloatingHelpTextWorldPosition(_hudIndex, _x, _y, _z);
			}
		}

		public void SetFloatingHelpTextToEntity(int _hudIndex, int _entity, float _offsetX, float _offsetY)
		{
			unsafe {
				if (fn__setFloatingHelpTextToEntity == null) fn__setFloatingHelpTextToEntity = (delegate* unmanaged[Cdecl]<int, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_setFloatingHelpTextToEntity");
				fn__setFloatingHelpTextToEntity(_hudIndex, _entity, _offsetX, _offsetY);
			}
		}

		public void SetFloatingHelpTextStyle(int _hudIndex, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__setFloatingHelpTextStyle == null) fn__setFloatingHelpTextStyle = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setFloatingHelpTextStyle");
				fn__setFloatingHelpTextStyle(_hudIndex, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void ClearFloatingHelp(int _hudIndex, bool _p1)
		{
			unsafe {
				if (fn__clearFloatingHelp == null) fn__clearFloatingHelp = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_clearFloatingHelp");
				fn__clearFloatingHelp(_hudIndex, _p1);
			}
		}

		public void CreateMpGamerTagWithCrewColor(int _player, string _username, bool _pointedClanTag, bool _isRockstarClan, string _clanTag, int _clanFlag, int _r, int _g, int _b)
		{
			unsafe {
				if (fn__createMpGamerTagWithCrewColor == null) fn__createMpGamerTagWithCrewColor = (delegate* unmanaged[Cdecl]<int, nint, bool, bool, nint, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_createMpGamerTagWithCrewColor");
				var ptr_username = MemoryUtils.StringToHGlobalUtf8(_username);
				var ptr_clanTag = MemoryUtils.StringToHGlobalUtf8(_clanTag);
				fn__createMpGamerTagWithCrewColor(_player, ptr_username, _pointedClanTag, _isRockstarClan, ptr_clanTag, _clanFlag, _r, _g, _b);
				Marshal.FreeHGlobal(ptr_username);
				Marshal.FreeHGlobal(ptr_clanTag);
			}
		}

		public bool IsMpGamerTagMovieActive()
		{
			unsafe {
				if (fn__isMpGamerTagMovieActive == null) fn__isMpGamerTagMovieActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMpGamerTagMovieActive");
				var result = fn__isMpGamerTagMovieActive();
				return result;
			}
		}

		public int CreateFakeMpGamerTag(int _ped, string _username, bool _pointedClanTag, bool _isRockstarClan, string _clanTag, int _clanFlag)
		{
			unsafe {
				if (fn__createFakeMpGamerTag == null) fn__createFakeMpGamerTag = (delegate* unmanaged[Cdecl]<int, nint, bool, bool, nint, int, int>) NativeLibrary.GetExport(handle, "Native_createFakeMpGamerTag");
				var ptr_username = MemoryUtils.StringToHGlobalUtf8(_username);
				var ptr_clanTag = MemoryUtils.StringToHGlobalUtf8(_clanTag);
				var result = fn__createFakeMpGamerTag(_ped, ptr_username, _pointedClanTag, _isRockstarClan, ptr_clanTag, _clanFlag);
				Marshal.FreeHGlobal(ptr_username);
				Marshal.FreeHGlobal(ptr_clanTag);
				return result;
			}
		}

		public void RemoveMpGamerTag(int _gamerTagId)
		{
			unsafe {
				if (fn__removeMpGamerTag == null) fn__removeMpGamerTag = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeMpGamerTag");
				fn__removeMpGamerTag(_gamerTagId);
			}
		}

		public bool IsMpGamerTagActive(int _gamerTagId)
		{
			unsafe {
				if (fn__isMpGamerTagActive == null) fn__isMpGamerTagActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMpGamerTagActive");
				var result = fn__isMpGamerTagActive(_gamerTagId);
				return result;
			}
		}

		public bool IsMpGamerTagFree(int _gamerTagId)
		{
			unsafe {
				if (fn__isMpGamerTagFree == null) fn__isMpGamerTagFree = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMpGamerTagFree");
				var result = fn__isMpGamerTagFree(_gamerTagId);
				return result;
			}
		}

		public void SetMpGamerTagVisibility(int _gamerTagId, int _component, bool _toggle, int _p3)
		{
			unsafe {
				if (fn__setMpGamerTagVisibility == null) fn__setMpGamerTagVisibility = (delegate* unmanaged[Cdecl]<int, int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagVisibility");
				fn__setMpGamerTagVisibility(_gamerTagId, _component, _toggle, _p3);
			}
		}

		public void SetMpGamerTagEnabled(int _gamerTagId, bool _toggle)
		{
			unsafe {
				if (fn__setMpGamerTagEnabled == null) fn__setMpGamerTagEnabled = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagEnabled");
				fn__setMpGamerTagEnabled(_gamerTagId, _toggle);
			}
		}

		public void SetMpGamerTagIcons(int _gamerTagId, bool _toggle)
		{
			unsafe {
				if (fn__setMpGamerTagIcons == null) fn__setMpGamerTagIcons = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagIcons");
				fn__setMpGamerTagIcons(_gamerTagId, _toggle);
			}
		}

		public void SetMpGamerHealthBarDisplay(int _gamerTagId, bool _toggle)
		{
			unsafe {
				if (fn__setMpGamerHealthBarDisplay == null) fn__setMpGamerHealthBarDisplay = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerHealthBarDisplay");
				fn__setMpGamerHealthBarDisplay(_gamerTagId, _toggle);
			}
		}

		public void SetMpGamerHealthBarMax(int _gamerTagId, int _value, int _maximumValue)
		{
			unsafe {
				if (fn__setMpGamerHealthBarMax == null) fn__setMpGamerHealthBarMax = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerHealthBarMax");
				fn__setMpGamerHealthBarMax(_gamerTagId, _value, _maximumValue);
			}
		}

		public void SetMpGamerTagColour(int _gamerTagId, int _component, int _hudColorIndex)
		{
			unsafe {
				if (fn__setMpGamerTagColour == null) fn__setMpGamerTagColour = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagColour");
				fn__setMpGamerTagColour(_gamerTagId, _component, _hudColorIndex);
			}
		}

		public void SetMpGamerTagHealthBarColour(int _gamerTagId, int _hudColorIndex)
		{
			unsafe {
				if (fn__setMpGamerTagHealthBarColour == null) fn__setMpGamerTagHealthBarColour = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagHealthBarColour");
				fn__setMpGamerTagHealthBarColour(_gamerTagId, _hudColorIndex);
			}
		}

		public void SetMpGamerTagAlpha(int _gamerTagId, int _component, int _alpha)
		{
			unsafe {
				if (fn__setMpGamerTagAlpha == null) fn__setMpGamerTagAlpha = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagAlpha");
				fn__setMpGamerTagAlpha(_gamerTagId, _component, _alpha);
			}
		}

		public void SetMpGamerTagWantedLevel(int _gamerTagId, int _wantedlvl)
		{
			unsafe {
				if (fn__setMpGamerTagWantedLevel == null) fn__setMpGamerTagWantedLevel = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagWantedLevel");
				fn__setMpGamerTagWantedLevel(_gamerTagId, _wantedlvl);
			}
		}

		public void SetMpGamerTagUnk(int _gamerTagId, int _p1)
		{
			unsafe {
				if (fn__setMpGamerTagUnk == null) fn__setMpGamerTagUnk = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagUnk");
				fn__setMpGamerTagUnk(_gamerTagId, _p1);
			}
		}

		public void SetMpGamerTagName(int _gamerTagId, string _string)
		{
			unsafe {
				if (fn__setMpGamerTagName == null) fn__setMpGamerTagName = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagName");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				fn__setMpGamerTagName(_gamerTagId, ptr_string);
				Marshal.FreeHGlobal(ptr_string);
			}
		}

		public bool IsValidMpGamerTagMovie(int _gamerTagId)
		{
			unsafe {
				if (fn__isValidMpGamerTagMovie == null) fn__isValidMpGamerTagMovie = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isValidMpGamerTagMovie");
				var result = fn__isValidMpGamerTagMovie(_gamerTagId);
				return result;
			}
		}

		public void SetMpGamerTagBigText(int _gamerTagId, string _string)
		{
			unsafe {
				if (fn__setMpGamerTagBigText == null) fn__setMpGamerTagBigText = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setMpGamerTagBigText");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				fn__setMpGamerTagBigText(_gamerTagId, ptr_string);
				Marshal.FreeHGlobal(ptr_string);
			}
		}

		public int GetCurrentWebpageId()
		{
			unsafe {
				if (fn__getCurrentWebpageId == null) fn__getCurrentWebpageId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCurrentWebpageId");
				var result = fn__getCurrentWebpageId();
				return result;
			}
		}

		public int GetCurrentWebsiteId()
		{
			unsafe {
				if (fn__getCurrentWebsiteId == null) fn__getCurrentWebsiteId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCurrentWebsiteId");
				var result = fn__getCurrentWebsiteId();
				return result;
			}
		}

		public int GetGlobalActionscriptFlag(int _flagIndex)
		{
			unsafe {
				if (fn__getGlobalActionscriptFlag == null) fn__getGlobalActionscriptFlag = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getGlobalActionscriptFlag");
				var result = fn__getGlobalActionscriptFlag(_flagIndex);
				return result;
			}
		}

		public void ResetGlobalActionscriptFlag(int _flagIndex)
		{
			unsafe {
				if (fn__resetGlobalActionscriptFlag == null) fn__resetGlobalActionscriptFlag = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetGlobalActionscriptFlag");
				fn__resetGlobalActionscriptFlag(_flagIndex);
			}
		}

		public bool IsWarningMessageActive2()
		{
			unsafe {
				if (fn__isWarningMessageActive2 == null) fn__isWarningMessageActive2 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isWarningMessageActive2");
				var result = fn__isWarningMessageActive2();
				return result;
			}
		}

		public void SetWarningMessage(string _titleMsg, int _flags, string _promptMsg, bool _p3, int _p4, string _p5, string _p6, bool _showBackground, int _p8)
		{
			unsafe {
				if (fn__setWarningMessage == null) fn__setWarningMessage = (delegate* unmanaged[Cdecl]<nint, int, nint, bool, int, nint, nint, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setWarningMessage");
				var ptr_titleMsg = MemoryUtils.StringToHGlobalUtf8(_titleMsg);
				var ptr_promptMsg = MemoryUtils.StringToHGlobalUtf8(_promptMsg);
				var ptr_p5 = MemoryUtils.StringToHGlobalUtf8(_p5);
				var ptr_p6 = MemoryUtils.StringToHGlobalUtf8(_p6);
				fn__setWarningMessage(ptr_titleMsg, _flags, ptr_promptMsg, _p3, _p4, ptr_p5, ptr_p6, _showBackground, _p8);
				Marshal.FreeHGlobal(ptr_titleMsg);
				Marshal.FreeHGlobal(ptr_promptMsg);
				Marshal.FreeHGlobal(ptr_p5);
				Marshal.FreeHGlobal(ptr_p6);
			}
		}

		public void SetWarningMessageWithHeader(string _entryHeader, string _entryLine1, int _instructionalKey, string _entryLine2, bool _p4, int _p5, ref int _showBackground, ref int _p7, bool _p8, int _p9)
		{
			unsafe {
				if (fn__setWarningMessageWithHeader == null) fn__setWarningMessageWithHeader = (delegate* unmanaged[Cdecl]<nint, nint, int, nint, bool, int, int*, int*, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setWarningMessageWithHeader");
				var ptr_entryHeader = MemoryUtils.StringToHGlobalUtf8(_entryHeader);
				var ptr_entryLine1 = MemoryUtils.StringToHGlobalUtf8(_entryLine1);
				var ptr_entryLine2 = MemoryUtils.StringToHGlobalUtf8(_entryLine2);
				var ref_showBackground = _showBackground;
				var ref_p7 = _p7;
				fn__setWarningMessageWithHeader(ptr_entryHeader, ptr_entryLine1, _instructionalKey, ptr_entryLine2, _p4, _p5, &ref_showBackground, &ref_p7, _p8, _p9);
				Marshal.FreeHGlobal(ptr_entryHeader);
				Marshal.FreeHGlobal(ptr_entryLine1);
				Marshal.FreeHGlobal(ptr_entryLine2);
				_showBackground = ref_showBackground;
				_p7 = ref_p7;
			}
		}

		public void SetWarningMessageWithHeaderAndSubstringFlags(string _entryHeader, string _entryLine1, int _instructionalKey, string _entryLine2, bool _p4, int _p5, int _additionalIntInfo, string _additionalTextInfoLine1, string _additionalTextInfoLine2, bool _showBackground, int _errorCode)
		{
			unsafe {
				if (fn__setWarningMessageWithHeaderAndSubstringFlags == null) fn__setWarningMessageWithHeaderAndSubstringFlags = (delegate* unmanaged[Cdecl]<nint, nint, int, nint, bool, int, int, nint, nint, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setWarningMessageWithHeaderAndSubstringFlags");
				var ptr_entryHeader = MemoryUtils.StringToHGlobalUtf8(_entryHeader);
				var ptr_entryLine1 = MemoryUtils.StringToHGlobalUtf8(_entryLine1);
				var ptr_entryLine2 = MemoryUtils.StringToHGlobalUtf8(_entryLine2);
				var ptr_additionalTextInfoLine1 = MemoryUtils.StringToHGlobalUtf8(_additionalTextInfoLine1);
				var ptr_additionalTextInfoLine2 = MemoryUtils.StringToHGlobalUtf8(_additionalTextInfoLine2);
				fn__setWarningMessageWithHeaderAndSubstringFlags(ptr_entryHeader, ptr_entryLine1, _instructionalKey, ptr_entryLine2, _p4, _p5, _additionalIntInfo, ptr_additionalTextInfoLine1, ptr_additionalTextInfoLine2, _showBackground, _errorCode);
				Marshal.FreeHGlobal(ptr_entryHeader);
				Marshal.FreeHGlobal(ptr_entryLine1);
				Marshal.FreeHGlobal(ptr_entryLine2);
				Marshal.FreeHGlobal(ptr_additionalTextInfoLine1);
				Marshal.FreeHGlobal(ptr_additionalTextInfoLine2);
			}
		}

		public void SetWarningMessageWithHeaderUnk(string _entryHeader, string _entryLine1, int _flags, string _entryLine2, bool _p4, int _p5, ref int _p6, ref int _p7, bool _showBg, int _p9, int _p10)
		{
			unsafe {
				if (fn__setWarningMessageWithHeaderUnk == null) fn__setWarningMessageWithHeaderUnk = (delegate* unmanaged[Cdecl]<nint, nint, int, nint, bool, int, int*, int*, bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_setWarningMessageWithHeaderUnk");
				var ptr_entryHeader = MemoryUtils.StringToHGlobalUtf8(_entryHeader);
				var ptr_entryLine1 = MemoryUtils.StringToHGlobalUtf8(_entryLine1);
				var ptr_entryLine2 = MemoryUtils.StringToHGlobalUtf8(_entryLine2);
				var ref_p6 = _p6;
				var ref_p7 = _p7;
				fn__setWarningMessageWithHeaderUnk(ptr_entryHeader, ptr_entryLine1, _flags, ptr_entryLine2, _p4, _p5, &ref_p6, &ref_p7, _showBg, _p9, _p10);
				Marshal.FreeHGlobal(ptr_entryHeader);
				Marshal.FreeHGlobal(ptr_entryLine1);
				Marshal.FreeHGlobal(ptr_entryLine2);
				_p6 = ref_p6;
				_p7 = ref_p7;
			}
		}

		public void SetWarningMessageWithAlert(string _labelTitle, string _labelMessage, int _p2, int _p3, string _labelMessage2, bool _p5, int _p6, int _p7, string _p8, string _p9, bool _background, int _errorCode)
		{
			unsafe {
				if (fn__setWarningMessageWithAlert == null) fn__setWarningMessageWithAlert = (delegate* unmanaged[Cdecl]<nint, nint, int, int, nint, bool, int, int, nint, nint, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setWarningMessageWithAlert");
				var ptr_labelTitle = MemoryUtils.StringToHGlobalUtf8(_labelTitle);
				var ptr_labelMessage = MemoryUtils.StringToHGlobalUtf8(_labelMessage);
				var ptr_labelMessage2 = MemoryUtils.StringToHGlobalUtf8(_labelMessage2);
				var ptr_p8 = MemoryUtils.StringToHGlobalUtf8(_p8);
				var ptr_p9 = MemoryUtils.StringToHGlobalUtf8(_p9);
				fn__setWarningMessageWithAlert(ptr_labelTitle, ptr_labelMessage, _p2, _p3, ptr_labelMessage2, _p5, _p6, _p7, ptr_p8, ptr_p9, _background, _errorCode);
				Marshal.FreeHGlobal(ptr_labelTitle);
				Marshal.FreeHGlobal(ptr_labelMessage);
				Marshal.FreeHGlobal(ptr_labelMessage2);
				Marshal.FreeHGlobal(ptr_p8);
				Marshal.FreeHGlobal(ptr_p9);
			}
		}

		public int GetWarningMessageTitleHash()
		{
			unsafe {
				if (fn__getWarningMessageTitleHash == null) fn__getWarningMessageTitleHash = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getWarningMessageTitleHash");
				var result = fn__getWarningMessageTitleHash();
				return result;
			}
		}

		public bool SetWarningMessageListRow(int _index, string _name, int _cash, int _rp, int _lvl, int _colour)
		{
			unsafe {
				if (fn__setWarningMessageListRow == null) fn__setWarningMessageListRow = (delegate* unmanaged[Cdecl]<int, nint, int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_setWarningMessageListRow");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__setWarningMessageListRow(_index, ptr_name, _cash, _rp, _lvl, _colour);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public bool _0xDAF87174BE7454FF(int _p0)
		{
			unsafe {
				if (fn__0xDAF87174BE7454FF == null) fn__0xDAF87174BE7454FF = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xDAF87174BE7454FF");
				var result = fn__0xDAF87174BE7454FF(_p0);
				return result;
			}
		}

		public void RemoveWarningMessageListItems()
		{
			unsafe {
				if (fn__removeWarningMessageListItems == null) fn__removeWarningMessageListItems = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeWarningMessageListItems");
				fn__removeWarningMessageListItems();
			}
		}

		public bool IsWarningMessageActive()
		{
			unsafe {
				if (fn__isWarningMessageActive == null) fn__isWarningMessageActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isWarningMessageActive");
				var result = fn__isWarningMessageActive();
				return result;
			}
		}

		public void ClearDynamicPauseMenuErrorMessage()
		{
			unsafe {
				if (fn__clearDynamicPauseMenuErrorMessage == null) fn__clearDynamicPauseMenuErrorMessage = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearDynamicPauseMenuErrorMessage");
				fn__clearDynamicPauseMenuErrorMessage();
			}
		}

		public void RaceGalleryFullscreen(bool _toggle)
		{
			unsafe {
				if (fn__raceGalleryFullscreen == null) fn__raceGalleryFullscreen = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_raceGalleryFullscreen");
				fn__raceGalleryFullscreen(_toggle);
			}
		}

		public void RaceGalleryNextBlipSprite(int _spriteId)
		{
			unsafe {
				if (fn__raceGalleryNextBlipSprite == null) fn__raceGalleryNextBlipSprite = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_raceGalleryNextBlipSprite");
				fn__raceGalleryNextBlipSprite(_spriteId);
			}
		}

		public int RaceGalleryAddBlip(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__raceGalleryAddBlip == null) fn__raceGalleryAddBlip = (delegate* unmanaged[Cdecl]<float, float, float, int>) NativeLibrary.GetExport(handle, "Native_raceGalleryAddBlip");
				var result = fn__raceGalleryAddBlip(_x, _y, _z);
				return result;
			}
		}

		public void ClearRaceGalleryBlips()
		{
			unsafe {
				if (fn__clearRaceGalleryBlips == null) fn__clearRaceGalleryBlips = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearRaceGalleryBlips");
				fn__clearRaceGalleryBlips();
			}
		}

		public int ForceSonarBlipsThisFrame()
		{
			unsafe {
				if (fn__forceSonarBlipsThisFrame == null) fn__forceSonarBlipsThisFrame = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_forceSonarBlipsThisFrame");
				var result = fn__forceSonarBlipsThisFrame();
				return result;
			}
		}

		public int GetNorthRadarBlip()
		{
			unsafe {
				if (fn__getNorthRadarBlip == null) fn__getNorthRadarBlip = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNorthRadarBlip");
				var result = fn__getNorthRadarBlip();
				return result;
			}
		}

		public void DisplayPlayerNameTagsOnBlips(bool _toggle)
		{
			unsafe {
				if (fn__displayPlayerNameTagsOnBlips == null) fn__displayPlayerNameTagsOnBlips = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_displayPlayerNameTagsOnBlips");
				fn__displayPlayerNameTagsOnBlips(_toggle);
			}
		}

		public void _0x211C4EF450086857()
		{
			unsafe {
				if (fn__0x211C4EF450086857 == null) fn__0x211C4EF450086857 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x211C4EF450086857");
				fn__0x211C4EF450086857();
			}
		}

		public void _0xBF4F34A85CA2970C()
		{
			unsafe {
				if (fn__0xBF4F34A85CA2970C == null) fn__0xBF4F34A85CA2970C = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xBF4F34A85CA2970C");
				fn__0xBF4F34A85CA2970C();
			}
		}

		public void ActivateFrontendMenu(int _menuhash, bool _togglePause, int _component)
		{
			unsafe {
				if (fn__activateFrontendMenu == null) fn__activateFrontendMenu = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_activateFrontendMenu");
				fn__activateFrontendMenu(_menuhash, _togglePause, _component);
			}
		}

		public void RestartFrontendMenu(int _menuHash, int _p1)
		{
			unsafe {
				if (fn__restartFrontendMenu == null) fn__restartFrontendMenu = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_restartFrontendMenu");
				fn__restartFrontendMenu(_menuHash, _p1);
			}
		}

		public int GetCurrentFrontendMenuVersion()
		{
			unsafe {
				if (fn__getCurrentFrontendMenuVersion == null) fn__getCurrentFrontendMenuVersion = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCurrentFrontendMenuVersion");
				var result = fn__getCurrentFrontendMenuVersion();
				return result;
			}
		}

		public void SetPauseMenuActive(bool _toggle)
		{
			unsafe {
				if (fn__setPauseMenuActive == null) fn__setPauseMenuActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setPauseMenuActive");
				fn__setPauseMenuActive(_toggle);
			}
		}

		public void DisableFrontendThisFrame()
		{
			unsafe {
				if (fn__disableFrontendThisFrame == null) fn__disableFrontendThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_disableFrontendThisFrame");
				fn__disableFrontendThisFrame();
			}
		}

		public void SuppressFrontendRenderingThisFrame()
		{
			unsafe {
				if (fn__suppressFrontendRenderingThisFrame == null) fn__suppressFrontendRenderingThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_suppressFrontendRenderingThisFrame");
				fn__suppressFrontendRenderingThisFrame();
			}
		}

		public void AllowPauseMenuWhenDeadThisFrame()
		{
			unsafe {
				if (fn__allowPauseMenuWhenDeadThisFrame == null) fn__allowPauseMenuWhenDeadThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_allowPauseMenuWhenDeadThisFrame");
				fn__allowPauseMenuWhenDeadThisFrame();
			}
		}

		public void SetFrontendActive(bool _active)
		{
			unsafe {
				if (fn__setFrontendActive == null) fn__setFrontendActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setFrontendActive");
				fn__setFrontendActive(_active);
			}
		}

		public bool IsPauseMenuActive()
		{
			unsafe {
				if (fn__isPauseMenuActive == null) fn__isPauseMenuActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPauseMenuActive");
				var result = fn__isPauseMenuActive();
				return result;
			}
		}

		public bool _0x2F057596F2BD0061()
		{
			unsafe {
				if (fn__0x2F057596F2BD0061 == null) fn__0x2F057596F2BD0061 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x2F057596F2BD0061");
				var result = fn__0x2F057596F2BD0061();
				return result;
			}
		}

		public int GetPauseMenuState()
		{
			unsafe {
				if (fn__getPauseMenuState == null) fn__getPauseMenuState = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPauseMenuState");
				var result = fn__getPauseMenuState();
				return result;
			}
		}

		public Vector3 _0x5BFF36D6ED83E0AE()
		{
			unsafe {
				if (fn__0x5BFF36D6ED83E0AE == null) fn__0x5BFF36D6ED83E0AE = (delegate* unmanaged[Cdecl]<Vector3>) NativeLibrary.GetExport(handle, "Native__0x5BFF36D6ED83E0AE");
				var result = fn__0x5BFF36D6ED83E0AE();
				return result;
			}
		}

		public bool IsPauseMenuRestarting()
		{
			unsafe {
				if (fn__isPauseMenuRestarting == null) fn__isPauseMenuRestarting = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPauseMenuRestarting");
				var result = fn__isPauseMenuRestarting();
				return result;
			}
		}

		public void LogDebugInfo(string _p0)
		{
			unsafe {
				if (fn__logDebugInfo == null) fn__logDebugInfo = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_logDebugInfo");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__logDebugInfo(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void _0x77F16B447824DA6C(int _p0)
		{
			unsafe {
				if (fn__0x77F16B447824DA6C == null) fn__0x77F16B447824DA6C = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x77F16B447824DA6C");
				fn__0x77F16B447824DA6C(_p0);
			}
		}

		public void _0xCDCA26E80FAECB8F()
		{
			unsafe {
				if (fn__0xCDCA26E80FAECB8F == null) fn__0xCDCA26E80FAECB8F = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xCDCA26E80FAECB8F");
				fn__0xCDCA26E80FAECB8F();
			}
		}

		public void _0x2DE6C5E2E996F178(int _p0)
		{
			unsafe {
				if (fn__0x2DE6C5E2E996F178 == null) fn__0x2DE6C5E2E996F178 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x2DE6C5E2E996F178");
				fn__0x2DE6C5E2E996F178(_p0);
			}
		}

		public void PauseMenuActivateContext(int _contextHash)
		{
			unsafe {
				if (fn__pauseMenuActivateContext == null) fn__pauseMenuActivateContext = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_pauseMenuActivateContext");
				fn__pauseMenuActivateContext(_contextHash);
			}
		}

		public void PauseMenuDeactivateContext(int _contextHash)
		{
			unsafe {
				if (fn__pauseMenuDeactivateContext == null) fn__pauseMenuDeactivateContext = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_pauseMenuDeactivateContext");
				fn__pauseMenuDeactivateContext(_contextHash);
			}
		}

		public bool PauseMenuIsContextActive(int _contextHash)
		{
			unsafe {
				if (fn__pauseMenuIsContextActive == null) fn__pauseMenuIsContextActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_pauseMenuIsContextActive");
				var result = fn__pauseMenuIsContextActive(_contextHash);
				return result;
			}
		}

		public bool PauseMenuIsContextMenuActive()
		{
			unsafe {
				if (fn__pauseMenuIsContextMenuActive == null) fn__pauseMenuIsContextMenuActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_pauseMenuIsContextMenuActive");
				var result = fn__pauseMenuIsContextMenuActive();
				return result;
			}
		}

		public int _0xDE03620F8703A9DF()
		{
			unsafe {
				if (fn__0xDE03620F8703A9DF == null) fn__0xDE03620F8703A9DF = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xDE03620F8703A9DF");
				var result = fn__0xDE03620F8703A9DF();
				return result;
			}
		}

		public int _0x359AF31A4B52F5ED()
		{
			unsafe {
				if (fn__0x359AF31A4B52F5ED == null) fn__0x359AF31A4B52F5ED = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x359AF31A4B52F5ED");
				var result = fn__0x359AF31A4B52F5ED();
				return result;
			}
		}

		public int _0x13C4B962653A5280()
		{
			unsafe {
				if (fn__0x13C4B962653A5280 == null) fn__0x13C4B962653A5280 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x13C4B962653A5280");
				var result = fn__0x13C4B962653A5280();
				return result;
			}
		}

		public bool _0xC8E1071177A23BE5(ref int _p0, ref int _p1, ref int _p2)
		{
			unsafe {
				if (fn__0xC8E1071177A23BE5 == null) fn__0xC8E1071177A23BE5 = (delegate* unmanaged[Cdecl]<int*, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0xC8E1071177A23BE5");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var result = fn__0xC8E1071177A23BE5(&ref_p0, &ref_p1, &ref_p2);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p2 = ref_p2;
				return result;
			}
		}

		public void _0x4895BDEA16E7C080(int _p0)
		{
			unsafe {
				if (fn__0x4895BDEA16E7C080 == null) fn__0x4895BDEA16E7C080 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x4895BDEA16E7C080");
				fn__0x4895BDEA16E7C080(_p0);
			}
		}

		public void PauseMenuSetBusySpinner(bool _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__pauseMenuSetBusySpinner == null) fn__pauseMenuSetBusySpinner = (delegate* unmanaged[Cdecl]<bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_pauseMenuSetBusySpinner");
				fn__pauseMenuSetBusySpinner(_p0, _p1, _p2);
			}
		}

		public void _0xF06EBB91A81E09E3(bool _p0)
		{
			unsafe {
				if (fn__0xF06EBB91A81E09E3 == null) fn__0xF06EBB91A81E09E3 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xF06EBB91A81E09E3");
				fn__0xF06EBB91A81E09E3(_p0);
			}
		}

		public bool IsFrontendReadyForControl()
		{
			unsafe {
				if (fn__isFrontendReadyForControl == null) fn__isFrontendReadyForControl = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isFrontendReadyForControl");
				var result = fn__isFrontendReadyForControl();
				return result;
			}
		}

		public void TakeControlOfFrontend()
		{
			unsafe {
				if (fn__takeControlOfFrontend == null) fn__takeControlOfFrontend = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_takeControlOfFrontend");
				fn__takeControlOfFrontend();
			}
		}

		public void ReleaseControlOfFrontend()
		{
			unsafe {
				if (fn__releaseControlOfFrontend == null) fn__releaseControlOfFrontend = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_releaseControlOfFrontend");
				fn__releaseControlOfFrontend();
			}
		}

		public bool _0x66E7CB63C97B7D20()
		{
			unsafe {
				if (fn__0x66E7CB63C97B7D20 == null) fn__0x66E7CB63C97B7D20 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x66E7CB63C97B7D20");
				var result = fn__0x66E7CB63C97B7D20();
				return result;
			}
		}

		public int _0x593FEAE1F73392D4()
		{
			unsafe {
				if (fn__0x593FEAE1F73392D4 == null) fn__0x593FEAE1F73392D4 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x593FEAE1F73392D4");
				var result = fn__0x593FEAE1F73392D4();
				return result;
			}
		}

		public bool IsNavigatingMenuContent()
		{
			unsafe {
				if (fn__isNavigatingMenuContent == null) fn__isNavigatingMenuContent = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isNavigatingMenuContent");
				var result = fn__isNavigatingMenuContent();
				return result;
			}
		}

		public bool _0xF284AC67940C6812()
		{
			unsafe {
				if (fn__0xF284AC67940C6812 == null) fn__0xF284AC67940C6812 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xF284AC67940C6812");
				var result = fn__0xF284AC67940C6812();
				return result;
			}
		}

		public bool _0x2E22FEFA0100275E()
		{
			unsafe {
				if (fn__0x2E22FEFA0100275E == null) fn__0x2E22FEFA0100275E = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x2E22FEFA0100275E");
				var result = fn__0x2E22FEFA0100275E();
				return result;
			}
		}

		public void _0x0CF54F20DE43879C(int _p0)
		{
			unsafe {
				if (fn__0x0CF54F20DE43879C == null) fn__0x0CF54F20DE43879C = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x0CF54F20DE43879C");
				fn__0x0CF54F20DE43879C(_p0);
			}
		}

		public void GetPauseMenuSelection(ref int _lastItemMenuId, ref int _selectedItemUniqueId)
		{
			unsafe {
				if (fn__getPauseMenuSelection == null) fn__getPauseMenuSelection = (delegate* unmanaged[Cdecl]<int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getPauseMenuSelection");
				var ref_lastItemMenuId = _lastItemMenuId;
				var ref_selectedItemUniqueId = _selectedItemUniqueId;
				fn__getPauseMenuSelection(&ref_lastItemMenuId, &ref_selectedItemUniqueId);
				_lastItemMenuId = ref_lastItemMenuId;
				_selectedItemUniqueId = ref_selectedItemUniqueId;
			}
		}

		public void GetPauseMenuSelectionData(ref int _lastItemMenuId, ref int _selectedItemMenuId, ref int _selectedItemUniqueId)
		{
			unsafe {
				if (fn__getPauseMenuSelectionData == null) fn__getPauseMenuSelectionData = (delegate* unmanaged[Cdecl]<int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getPauseMenuSelectionData");
				var ref_lastItemMenuId = _lastItemMenuId;
				var ref_selectedItemMenuId = _selectedItemMenuId;
				var ref_selectedItemUniqueId = _selectedItemUniqueId;
				fn__getPauseMenuSelectionData(&ref_lastItemMenuId, &ref_selectedItemMenuId, &ref_selectedItemUniqueId);
				_lastItemMenuId = ref_lastItemMenuId;
				_selectedItemMenuId = ref_selectedItemMenuId;
				_selectedItemUniqueId = ref_selectedItemUniqueId;
			}
		}

		public bool _0xA238192F33110615(ref int _p0, ref int _p1, ref int _p2)
		{
			unsafe {
				if (fn__0xA238192F33110615 == null) fn__0xA238192F33110615 = (delegate* unmanaged[Cdecl]<int*, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0xA238192F33110615");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var result = fn__0xA238192F33110615(&ref_p0, &ref_p1, &ref_p2);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p2 = ref_p2;
				return result;
			}
		}

		public bool GetMenuPedIntStat(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__getMenuPedIntStat == null) fn__getMenuPedIntStat = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getMenuPedIntStat");
				var ref_p1 = _p1;
				var result = fn__getMenuPedIntStat(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool _0xCA6B2F7CE32AB653(int _p0, ref int _p1, int _p2)
		{
			unsafe {
				if (fn__0xCA6B2F7CE32AB653 == null) fn__0xCA6B2F7CE32AB653 = (delegate* unmanaged[Cdecl]<int, int*, int, bool>) NativeLibrary.GetExport(handle, "Native__0xCA6B2F7CE32AB653");
				var ref_p1 = _p1;
				var result = fn__0xCA6B2F7CE32AB653(_p0, &ref_p1, _p2);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool GetMenuPedMaskedIntStat(int _p0, ref int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__getMenuPedMaskedIntStat == null) fn__getMenuPedMaskedIntStat = (delegate* unmanaged[Cdecl]<int, int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_getMenuPedMaskedIntStat");
				var ref_p1 = _p1;
				var result = fn__getMenuPedMaskedIntStat(_p0, &ref_p1, _p2, _p3);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool _0x24A49BEAF468DC90(int _p0, ref int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0x24A49BEAF468DC90 == null) fn__0x24A49BEAF468DC90 = (delegate* unmanaged[Cdecl]<int, int*, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native__0x24A49BEAF468DC90");
				var ref_p1 = _p1;
				var result = fn__0x24A49BEAF468DC90(_p0, &ref_p1, _p2, _p3, _p4);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool GetMenuPedFloatStat(int _p0, ref float _p1)
		{
			unsafe {
				if (fn__getMenuPedFloatStat == null) fn__getMenuPedFloatStat = (delegate* unmanaged[Cdecl]<int, float*, bool>) NativeLibrary.GetExport(handle, "Native_getMenuPedFloatStat");
				var ref_p1 = _p1;
				var result = fn__getMenuPedFloatStat(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool _0x8F08017F9D7C47BD(int _p0, ref int _p1, int _p2)
		{
			unsafe {
				if (fn__0x8F08017F9D7C47BD == null) fn__0x8F08017F9D7C47BD = (delegate* unmanaged[Cdecl]<int, int*, int, bool>) NativeLibrary.GetExport(handle, "Native__0x8F08017F9D7C47BD");
				var ref_p1 = _p1;
				var result = fn__0x8F08017F9D7C47BD(_p0, &ref_p1, _p2);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool GetMenuPedBoolStat(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__getMenuPedBoolStat == null) fn__getMenuPedBoolStat = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getMenuPedBoolStat");
				var ref_p1 = _p1;
				var result = fn__getMenuPedBoolStat(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public void ClearPedInPauseMenu()
		{
			unsafe {
				if (fn__clearPedInPauseMenu == null) fn__clearPedInPauseMenu = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearPedInPauseMenu");
				fn__clearPedInPauseMenu();
			}
		}

		public void GivePedToPauseMenu(int _ped, int _p1)
		{
			unsafe {
				if (fn__givePedToPauseMenu == null) fn__givePedToPauseMenu = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_givePedToPauseMenu");
				fn__givePedToPauseMenu(_ped, _p1);
			}
		}

		public void SetPauseMenuPedLighting(bool _state)
		{
			unsafe {
				if (fn__setPauseMenuPedLighting == null) fn__setPauseMenuPedLighting = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setPauseMenuPedLighting");
				fn__setPauseMenuPedLighting(_state);
			}
		}

		public void SetPauseMenuPedSleepState(bool _state)
		{
			unsafe {
				if (fn__setPauseMenuPedSleepState == null) fn__setPauseMenuPedSleepState = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setPauseMenuPedSleepState");
				fn__setPauseMenuPedSleepState(_state);
			}
		}

		public void OpenOnlinePoliciesMenu()
		{
			unsafe {
				if (fn__openOnlinePoliciesMenu == null) fn__openOnlinePoliciesMenu = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_openOnlinePoliciesMenu");
				fn__openOnlinePoliciesMenu();
			}
		}

		public bool _0xF13FE2A80C05C561()
		{
			unsafe {
				if (fn__0xF13FE2A80C05C561 == null) fn__0xF13FE2A80C05C561 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xF13FE2A80C05C561");
				var result = fn__0xF13FE2A80C05C561();
				return result;
			}
		}

		public bool IsOnlinePoliciesMenuActive()
		{
			unsafe {
				if (fn__isOnlinePoliciesMenuActive == null) fn__isOnlinePoliciesMenuActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isOnlinePoliciesMenuActive");
				var result = fn__isOnlinePoliciesMenuActive();
				return result;
			}
		}

		public void OpenSocialClubMenu()
		{
			unsafe {
				if (fn__openSocialClubMenu == null) fn__openSocialClubMenu = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_openSocialClubMenu");
				fn__openSocialClubMenu();
			}
		}

		public void CloseSocialClubMenu()
		{
			unsafe {
				if (fn__closeSocialClubMenu == null) fn__closeSocialClubMenu = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_closeSocialClubMenu");
				fn__closeSocialClubMenu();
			}
		}

		public void SetSocialClubTour(string _name)
		{
			unsafe {
				if (fn__setSocialClubTour == null) fn__setSocialClubTour = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setSocialClubTour");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setSocialClubTour(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public bool IsSocialClubActive()
		{
			unsafe {
				if (fn__isSocialClubActive == null) fn__isSocialClubActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isSocialClubActive");
				var result = fn__isSocialClubActive();
				return result;
			}
		}

		public void _0x1185A8087587322C(bool _p0)
		{
			unsafe {
				if (fn__0x1185A8087587322C == null) fn__0x1185A8087587322C = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x1185A8087587322C");
				fn__0x1185A8087587322C(_p0);
			}
		}

		public void ForceCloseTextInputBox()
		{
			unsafe {
				if (fn__forceCloseTextInputBox == null) fn__forceCloseTextInputBox = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_forceCloseTextInputBox");
				fn__forceCloseTextInputBox();
			}
		}

		public void _0x577599CCED639CA2(int _p0)
		{
			unsafe {
				if (fn__0x577599CCED639CA2 == null) fn__0x577599CCED639CA2 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x577599CCED639CA2");
				fn__0x577599CCED639CA2(_p0);
			}
		}

		public void OverrideMultiplayerChatPrefix(int _gxtEntryHash)
		{
			unsafe {
				if (fn__overrideMultiplayerChatPrefix == null) fn__overrideMultiplayerChatPrefix = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_overrideMultiplayerChatPrefix");
				fn__overrideMultiplayerChatPrefix(_gxtEntryHash);
			}
		}

		public bool IsMultiplayerChatActive()
		{
			unsafe {
				if (fn__isMultiplayerChatActive == null) fn__isMultiplayerChatActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMultiplayerChatActive");
				var result = fn__isMultiplayerChatActive();
				return result;
			}
		}

		public void CloseMultiplayerChat()
		{
			unsafe {
				if (fn__closeMultiplayerChat == null) fn__closeMultiplayerChat = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_closeMultiplayerChat");
				fn__closeMultiplayerChat();
			}
		}

		public void _0x7C226D5346D4D10A(int _p0)
		{
			unsafe {
				if (fn__0x7C226D5346D4D10A == null) fn__0x7C226D5346D4D10A = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x7C226D5346D4D10A");
				fn__0x7C226D5346D4D10A(_p0);
			}
		}

		public void OverrideMultiplayerChatColour(int _p0, int _hudColor)
		{
			unsafe {
				if (fn__overrideMultiplayerChatColour == null) fn__overrideMultiplayerChatColour = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_overrideMultiplayerChatColour");
				fn__overrideMultiplayerChatColour(_p0, _hudColor);
			}
		}

		public void SetTextChatUnk(bool _p0)
		{
			unsafe {
				if (fn__setTextChatUnk == null) fn__setTextChatUnk = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setTextChatUnk");
				fn__setTextChatUnk(_p0);
			}
		}

		public void FlagPlayerContextInTournament(bool _toggle)
		{
			unsafe {
				if (fn__flagPlayerContextInTournament == null) fn__flagPlayerContextInTournament = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_flagPlayerContextInTournament");
				fn__flagPlayerContextInTournament(_toggle);
			}
		}

		public void SetPedHasAiBlip(int _ped, bool _hasCone)
		{
			unsafe {
				if (fn__setPedHasAiBlip == null) fn__setPedHasAiBlip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedHasAiBlip");
				fn__setPedHasAiBlip(_ped, _hasCone);
			}
		}

		public void SetPedHasAiBlipWithColor(int _ped, bool _hasCone, int _color)
		{
			unsafe {
				if (fn__setPedHasAiBlipWithColor == null) fn__setPedHasAiBlipWithColor = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setPedHasAiBlipWithColor");
				fn__setPedHasAiBlipWithColor(_ped, _hasCone, _color);
			}
		}

		public bool DoesPedHaveAiBlip(int _ped)
		{
			unsafe {
				if (fn__doesPedHaveAiBlip == null) fn__doesPedHaveAiBlip = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesPedHaveAiBlip");
				var result = fn__doesPedHaveAiBlip(_ped);
				return result;
			}
		}

		public void SetPedAiBlipGangId(int _ped, int _gangId)
		{
			unsafe {
				if (fn__setPedAiBlipGangId == null) fn__setPedAiBlipGangId = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedAiBlipGangId");
				fn__setPedAiBlipGangId(_ped, _gangId);
			}
		}

		public void SetPedAiBlipHasCone(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedAiBlipHasCone == null) fn__setPedAiBlipHasCone = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAiBlipHasCone");
				fn__setPedAiBlipHasCone(_ped, _toggle);
			}
		}

		public void SetPedAiBlipForcedOn(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedAiBlipForcedOn == null) fn__setPedAiBlipForcedOn = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAiBlipForcedOn");
				fn__setPedAiBlipForcedOn(_ped, _toggle);
			}
		}

		public void SetPedAiBlipNoticeRange(int _ped, float _range)
		{
			unsafe {
				if (fn__setPedAiBlipNoticeRange == null) fn__setPedAiBlipNoticeRange = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedAiBlipNoticeRange");
				fn__setPedAiBlipNoticeRange(_ped, _range);
			}
		}

		public void SetPedAiBlipSprite(int _ped, int _spriteId)
		{
			unsafe {
				if (fn__setPedAiBlipSprite == null) fn__setPedAiBlipSprite = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedAiBlipSprite");
				fn__setPedAiBlipSprite(_ped, _spriteId);
			}
		}

		public int GetAiBlip2(int _ped)
		{
			unsafe {
				if (fn__getAiBlip2 == null) fn__getAiBlip2 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getAiBlip2");
				var result = fn__getAiBlip2(_ped);
				return result;
			}
		}

		public int GetAiBlip(int _ped)
		{
			unsafe {
				if (fn__getAiBlip == null) fn__getAiBlip = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getAiBlip");
				var result = fn__getAiBlip(_ped);
				return result;
			}
		}

		public bool HasDirectorModeBeenTriggered()
		{
			unsafe {
				if (fn__hasDirectorModeBeenTriggered == null) fn__hasDirectorModeBeenTriggered = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasDirectorModeBeenTriggered");
				var result = fn__hasDirectorModeBeenTriggered();
				return result;
			}
		}

		public void SetDirectorModeClearTriggeredFlag()
		{
			unsafe {
				if (fn__setDirectorModeClearTriggeredFlag == null) fn__setDirectorModeClearTriggeredFlag = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setDirectorModeClearTriggeredFlag");
				fn__setDirectorModeClearTriggeredFlag();
			}
		}

		public void SetPlayerIsInDirectorMode(bool _toggle)
		{
			unsafe {
				if (fn__setPlayerIsInDirectorMode == null) fn__setPlayerIsInDirectorMode = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerIsInDirectorMode");
				fn__setPlayerIsInDirectorMode(_toggle);
			}
		}

		public void _0x04655F9D075D0AE5(bool _toggle)
		{
			unsafe {
				if (fn__0x04655F9D075D0AE5 == null) fn__0x04655F9D075D0AE5 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x04655F9D075D0AE5");
				fn__0x04655F9D075D0AE5(_toggle);
			}
		}

		public void _0x243296A510B562B6()
		{
			unsafe {
				if (fn__0x243296A510B562B6 == null) fn__0x243296A510B562B6 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x243296A510B562B6");
				fn__0x243296A510B562B6();
			}
		}

		public float GetInteriorHeading(int _interior)
		{
			unsafe {
				if (fn__getInteriorHeading == null) fn__getInteriorHeading = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getInteriorHeading");
				var result = fn__getInteriorHeading(_interior);
				return result;
			}
		}

		public void GetInteriorInfo(int _interior, ref Vector3 _position, ref int _nameHash)
		{
			unsafe {
				if (fn__getInteriorInfo == null) fn__getInteriorInfo = (delegate* unmanaged[Cdecl]<int, Vector3*, int*, void>) NativeLibrary.GetExport(handle, "Native_getInteriorInfo");
				var ref_position = _position;
				var ref_nameHash = _nameHash;
				fn__getInteriorInfo(_interior, &ref_position, &ref_nameHash);
				_position = ref_position;
				_nameHash = ref_nameHash;
			}
		}

		public int GetInteriorGroupId(int _interior)
		{
			unsafe {
				if (fn__getInteriorGroupId == null) fn__getInteriorGroupId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getInteriorGroupId");
				var result = fn__getInteriorGroupId(_interior);
				return result;
			}
		}

		public Vector3 GetOffsetFromInteriorInWorldCoords(int _interior, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__getOffsetFromInteriorInWorldCoords == null) fn__getOffsetFromInteriorInWorldCoords = (delegate* unmanaged[Cdecl]<int, float, float, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getOffsetFromInteriorInWorldCoords");
				var result = fn__getOffsetFromInteriorInWorldCoords(_interior, _x, _y, _z);
				return result;
			}
		}

		public bool IsInteriorScene()
		{
			unsafe {
				if (fn__isInteriorScene == null) fn__isInteriorScene = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isInteriorScene");
				var result = fn__isInteriorScene();
				return result;
			}
		}

		public bool IsValidInterior(int _interior)
		{
			unsafe {
				if (fn__isValidInterior == null) fn__isValidInterior = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isValidInterior");
				var result = fn__isValidInterior(_interior);
				return result;
			}
		}

		public void ClearRoomForEntity(int _entity)
		{
			unsafe {
				if (fn__clearRoomForEntity == null) fn__clearRoomForEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearRoomForEntity");
				fn__clearRoomForEntity(_entity);
			}
		}

		public void ForceRoomForEntity(int _entity, int _interior, int _roomHashKey)
		{
			unsafe {
				if (fn__forceRoomForEntity == null) fn__forceRoomForEntity = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_forceRoomForEntity");
				fn__forceRoomForEntity(_entity, _interior, _roomHashKey);
			}
		}

		public int GetRoomKeyFromEntity(int _entity)
		{
			unsafe {
				if (fn__getRoomKeyFromEntity == null) fn__getRoomKeyFromEntity = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getRoomKeyFromEntity");
				var result = fn__getRoomKeyFromEntity(_entity);
				return result;
			}
		}

		public int GetKeyForEntityInRoom(int _entity)
		{
			unsafe {
				if (fn__getKeyForEntityInRoom == null) fn__getKeyForEntityInRoom = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getKeyForEntityInRoom");
				var result = fn__getKeyForEntityInRoom(_entity);
				return result;
			}
		}

		public int GetInteriorFromEntity(int _entity)
		{
			unsafe {
				if (fn__getInteriorFromEntity == null) fn__getInteriorFromEntity = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getInteriorFromEntity");
				var result = fn__getInteriorFromEntity(_entity);
				return result;
			}
		}

		public void _0x82EBB79E258FA2B7(int _entity, int _interior)
		{
			unsafe {
				if (fn__0x82EBB79E258FA2B7 == null) fn__0x82EBB79E258FA2B7 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x82EBB79E258FA2B7");
				fn__0x82EBB79E258FA2B7(_entity, _interior);
			}
		}

		public void ClearInteriorForEntity(int _entity)
		{
			unsafe {
				if (fn__clearInteriorForEntity == null) fn__clearInteriorForEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearInteriorForEntity");
				fn__clearInteriorForEntity(_entity);
			}
		}

		public void _0x38C1CB1CB119A016(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x38C1CB1CB119A016 == null) fn__0x38C1CB1CB119A016 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x38C1CB1CB119A016");
				fn__0x38C1CB1CB119A016(_p0, _p1);
			}
		}

		public void ForceRoomForGameViewport(int _interiorID, int _roomHashKey)
		{
			unsafe {
				if (fn__forceRoomForGameViewport == null) fn__forceRoomForGameViewport = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_forceRoomForGameViewport");
				fn__forceRoomForGameViewport(_interiorID, _roomHashKey);
			}
		}

		public void _0xAF348AFCB575A441(string _roomName)
		{
			unsafe {
				if (fn__0xAF348AFCB575A441 == null) fn__0xAF348AFCB575A441 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0xAF348AFCB575A441");
				var ptr_roomName = MemoryUtils.StringToHGlobalUtf8(_roomName);
				fn__0xAF348AFCB575A441(ptr_roomName);
				Marshal.FreeHGlobal(ptr_roomName);
			}
		}

		public void _0x405DC2AEF6AF95B9(int _roomHashKey)
		{
			unsafe {
				if (fn__0x405DC2AEF6AF95B9 == null) fn__0x405DC2AEF6AF95B9 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x405DC2AEF6AF95B9");
				fn__0x405DC2AEF6AF95B9(_roomHashKey);
			}
		}

		public int GetRoomKeyForGameViewport()
		{
			unsafe {
				if (fn__getRoomKeyForGameViewport == null) fn__getRoomKeyForGameViewport = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getRoomKeyForGameViewport");
				var result = fn__getRoomKeyForGameViewport();
				return result;
			}
		}

		public void ClearRoomForGameViewport()
		{
			unsafe {
				if (fn__clearRoomForGameViewport == null) fn__clearRoomForGameViewport = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearRoomForGameViewport");
				fn__clearRoomForGameViewport();
			}
		}

		public int GetInteriorFromGameplayCam()
		{
			unsafe {
				if (fn__getInteriorFromGameplayCam == null) fn__getInteriorFromGameplayCam = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getInteriorFromGameplayCam");
				var result = fn__getInteriorFromGameplayCam();
				return result;
			}
		}

		public int GetInteriorAtCoords(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__getInteriorAtCoords == null) fn__getInteriorAtCoords = (delegate* unmanaged[Cdecl]<float, float, float, int>) NativeLibrary.GetExport(handle, "Native_getInteriorAtCoords");
				var result = fn__getInteriorAtCoords(_x, _y, _z);
				return result;
			}
		}

		public void AddPickupToInteriorRoomByName(int _pickup, string _roomName)
		{
			unsafe {
				if (fn__addPickupToInteriorRoomByName == null) fn__addPickupToInteriorRoomByName = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_addPickupToInteriorRoomByName");
				var ptr_roomName = MemoryUtils.StringToHGlobalUtf8(_roomName);
				fn__addPickupToInteriorRoomByName(_pickup, ptr_roomName);
				Marshal.FreeHGlobal(ptr_roomName);
			}
		}

		public void PinInteriorInMemory(int _interior)
		{
			unsafe {
				if (fn__pinInteriorInMemory == null) fn__pinInteriorInMemory = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_pinInteriorInMemory");
				fn__pinInteriorInMemory(_interior);
			}
		}

		public void UnpinInterior(int _interior)
		{
			unsafe {
				if (fn__unpinInterior == null) fn__unpinInterior = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_unpinInterior");
				fn__unpinInterior(_interior);
			}
		}

		public bool IsInteriorReady(int _interior)
		{
			unsafe {
				if (fn__isInteriorReady == null) fn__isInteriorReady = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isInteriorReady");
				var result = fn__isInteriorReady(_interior);
				return result;
			}
		}

		public int _0x4C2330E61D3DEB56(int _interior)
		{
			unsafe {
				if (fn__0x4C2330E61D3DEB56 == null) fn__0x4C2330E61D3DEB56 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x4C2330E61D3DEB56");
				var result = fn__0x4C2330E61D3DEB56(_interior);
				return result;
			}
		}

		public int GetInteriorAtCoordsWithType(float _x, float _y, float _z, string _interiorType)
		{
			unsafe {
				if (fn__getInteriorAtCoordsWithType == null) fn__getInteriorAtCoordsWithType = (delegate* unmanaged[Cdecl]<float, float, float, nint, int>) NativeLibrary.GetExport(handle, "Native_getInteriorAtCoordsWithType");
				var ptr_interiorType = MemoryUtils.StringToHGlobalUtf8(_interiorType);
				var result = fn__getInteriorAtCoordsWithType(_x, _y, _z, ptr_interiorType);
				Marshal.FreeHGlobal(ptr_interiorType);
				return result;
			}
		}

		public int GetInteriorAtCoordsWithTypehash(float _x, float _y, float _z, int _typeHash)
		{
			unsafe {
				if (fn__getInteriorAtCoordsWithTypehash == null) fn__getInteriorAtCoordsWithTypehash = (delegate* unmanaged[Cdecl]<float, float, float, int, int>) NativeLibrary.GetExport(handle, "Native_getInteriorAtCoordsWithTypehash");
				var result = fn__getInteriorAtCoordsWithTypehash(_x, _y, _z, _typeHash);
				return result;
			}
		}

		public void _0x483ACA1176CA93F1()
		{
			unsafe {
				if (fn__0x483ACA1176CA93F1 == null) fn__0x483ACA1176CA93F1 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x483ACA1176CA93F1");
				fn__0x483ACA1176CA93F1();
			}
		}

		public bool IsCollisionMarkedOutside(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__isCollisionMarkedOutside == null) fn__isCollisionMarkedOutside = (delegate* unmanaged[Cdecl]<float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isCollisionMarkedOutside");
				var result = fn__isCollisionMarkedOutside(_x, _y, _z);
				return result;
			}
		}

		public int GetInteriorFromCollision(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__getInteriorFromCollision == null) fn__getInteriorFromCollision = (delegate* unmanaged[Cdecl]<float, float, float, int>) NativeLibrary.GetExport(handle, "Native_getInteriorFromCollision");
				var result = fn__getInteriorFromCollision(_x, _y, _z);
				return result;
			}
		}

		public void _0x7ECDF98587E92DEC(int _p0)
		{
			unsafe {
				if (fn__0x7ECDF98587E92DEC == null) fn__0x7ECDF98587E92DEC = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x7ECDF98587E92DEC");
				fn__0x7ECDF98587E92DEC(_p0);
			}
		}

		public void ActivateInteriorEntitySet(int _interior, string _entitySetName)
		{
			unsafe {
				if (fn__activateInteriorEntitySet == null) fn__activateInteriorEntitySet = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_activateInteriorEntitySet");
				var ptr_entitySetName = MemoryUtils.StringToHGlobalUtf8(_entitySetName);
				fn__activateInteriorEntitySet(_interior, ptr_entitySetName);
				Marshal.FreeHGlobal(ptr_entitySetName);
			}
		}

		public void DeactivateInteriorEntitySet(int _interior, string _entitySetName)
		{
			unsafe {
				if (fn__deactivateInteriorEntitySet == null) fn__deactivateInteriorEntitySet = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_deactivateInteriorEntitySet");
				var ptr_entitySetName = MemoryUtils.StringToHGlobalUtf8(_entitySetName);
				fn__deactivateInteriorEntitySet(_interior, ptr_entitySetName);
				Marshal.FreeHGlobal(ptr_entitySetName);
			}
		}

		public bool IsInteriorEntitySetActive(int _interior, string _entitySetName)
		{
			unsafe {
				if (fn__isInteriorEntitySetActive == null) fn__isInteriorEntitySetActive = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_isInteriorEntitySetActive");
				var ptr_entitySetName = MemoryUtils.StringToHGlobalUtf8(_entitySetName);
				var result = fn__isInteriorEntitySetActive(_interior, ptr_entitySetName);
				Marshal.FreeHGlobal(ptr_entitySetName);
				return result;
			}
		}

		public void SetInteriorEntitySetColor(int _interior, string _entitySetName, int _color)
		{
			unsafe {
				if (fn__setInteriorEntitySetColor == null) fn__setInteriorEntitySetColor = (delegate* unmanaged[Cdecl]<int, nint, int, void>) NativeLibrary.GetExport(handle, "Native_setInteriorEntitySetColor");
				var ptr_entitySetName = MemoryUtils.StringToHGlobalUtf8(_entitySetName);
				fn__setInteriorEntitySetColor(_interior, ptr_entitySetName, _color);
				Marshal.FreeHGlobal(ptr_entitySetName);
			}
		}

		public void RefreshInterior(int _interior)
		{
			unsafe {
				if (fn__refreshInterior == null) fn__refreshInterior = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_refreshInterior");
				fn__refreshInterior(_interior);
			}
		}

		public void EnableExteriorCullModelThisFrame(int _mapObjectHash)
		{
			unsafe {
				if (fn__enableExteriorCullModelThisFrame == null) fn__enableExteriorCullModelThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_enableExteriorCullModelThisFrame");
				fn__enableExteriorCullModelThisFrame(_mapObjectHash);
			}
		}

		public void EnableScriptCullModelThisFrame(int _mapObjectHash)
		{
			unsafe {
				if (fn__enableScriptCullModelThisFrame == null) fn__enableScriptCullModelThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_enableScriptCullModelThisFrame");
				fn__enableScriptCullModelThisFrame(_mapObjectHash);
			}
		}

		public void DisableInterior(int _interior, bool _toggle)
		{
			unsafe {
				if (fn__disableInterior == null) fn__disableInterior = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_disableInterior");
				fn__disableInterior(_interior, _toggle);
			}
		}

		public bool IsInteriorDisabled(int _interior)
		{
			unsafe {
				if (fn__isInteriorDisabled == null) fn__isInteriorDisabled = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isInteriorDisabled");
				var result = fn__isInteriorDisabled(_interior);
				return result;
			}
		}

		public void CapInterior(int _interior, bool _toggle)
		{
			unsafe {
				if (fn__capInterior == null) fn__capInterior = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_capInterior");
				fn__capInterior(_interior, _toggle);
			}
		}

		public bool IsInteriorCapped(int _interior)
		{
			unsafe {
				if (fn__isInteriorCapped == null) fn__isInteriorCapped = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isInteriorCapped");
				var result = fn__isInteriorCapped(_interior);
				return result;
			}
		}

		public void _0x9E6542F0CE8E70A3(bool _toggle)
		{
			unsafe {
				if (fn__0x9E6542F0CE8E70A3 == null) fn__0x9E6542F0CE8E70A3 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x9E6542F0CE8E70A3");
				fn__0x9E6542F0CE8E70A3(_toggle);
			}
		}

		public void _0x7241CCB7D020DB69(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__0x7241CCB7D020DB69 == null) fn__0x7241CCB7D020DB69 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x7241CCB7D020DB69");
				fn__0x7241CCB7D020DB69(_entity, _toggle);
			}
		}

		public int CreateItemset(bool _p0)
		{
			unsafe {
				if (fn__createItemset == null) fn__createItemset = (delegate* unmanaged[Cdecl]<bool, int>) NativeLibrary.GetExport(handle, "Native_createItemset");
				var result = fn__createItemset(_p0);
				return result;
			}
		}

		public void DestroyItemset(int _p0)
		{
			unsafe {
				if (fn__destroyItemset == null) fn__destroyItemset = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_destroyItemset");
				fn__destroyItemset(_p0);
			}
		}

		public bool IsItemsetValid(int _p0)
		{
			unsafe {
				if (fn__isItemsetValid == null) fn__isItemsetValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isItemsetValid");
				var result = fn__isItemsetValid(_p0);
				return result;
			}
		}

		public bool AddToItemset(int _p0, int _p1)
		{
			unsafe {
				if (fn__addToItemset == null) fn__addToItemset = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_addToItemset");
				var result = fn__addToItemset(_p0, _p1);
				return result;
			}
		}

		public void RemoveFromItemset(int _p0, int _p1)
		{
			unsafe {
				if (fn__removeFromItemset == null) fn__removeFromItemset = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_removeFromItemset");
				fn__removeFromItemset(_p0, _p1);
			}
		}

		public int GetItemsetSize(int _x)
		{
			unsafe {
				if (fn__getItemsetSize == null) fn__getItemsetSize = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getItemsetSize");
				var result = fn__getItemsetSize(_x);
				return result;
			}
		}

		public int GetIndexedItemInItemset(int _p0, int _p1)
		{
			unsafe {
				if (fn__getIndexedItemInItemset == null) fn__getIndexedItemInItemset = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getIndexedItemInItemset");
				var result = fn__getIndexedItemInItemset(_p0, _p1);
				return result;
			}
		}

		public bool IsInItemset(int _p0, int _p1)
		{
			unsafe {
				if (fn__isInItemset == null) fn__isInItemset = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isInItemset");
				var result = fn__isInItemset(_p0, _p1);
				return result;
			}
		}

		public void CleanItemset(int _p0)
		{
			unsafe {
				if (fn__cleanItemset == null) fn__cleanItemset = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_cleanItemset");
				fn__cleanItemset(_p0);
			}
		}

		public int _0xF2CA003F167E21D2()
		{
			unsafe {
				if (fn__0xF2CA003F167E21D2 == null) fn__0xF2CA003F167E21D2 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xF2CA003F167E21D2");
				var result = fn__0xF2CA003F167E21D2();
				return result;
			}
		}

		public bool LoadingscreenGetLoadFreemode()
		{
			unsafe {
				if (fn__loadingscreenGetLoadFreemode == null) fn__loadingscreenGetLoadFreemode = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_loadingscreenGetLoadFreemode");
				var result = fn__loadingscreenGetLoadFreemode();
				return result;
			}
		}

		public void LoadingscreenSetLoadFreemode(bool _toggle)
		{
			unsafe {
				if (fn__loadingscreenSetLoadFreemode == null) fn__loadingscreenSetLoadFreemode = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_loadingscreenSetLoadFreemode");
				fn__loadingscreenSetLoadFreemode(_toggle);
			}
		}

		public bool LoadingscreenGetLoadFreemodeWithEventName()
		{
			unsafe {
				if (fn__loadingscreenGetLoadFreemodeWithEventName == null) fn__loadingscreenGetLoadFreemodeWithEventName = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_loadingscreenGetLoadFreemodeWithEventName");
				var result = fn__loadingscreenGetLoadFreemodeWithEventName();
				return result;
			}
		}

		public void LoadingscreenSetLoadFreemodeWithEventName(bool _toggle)
		{
			unsafe {
				if (fn__loadingscreenSetLoadFreemodeWithEventName == null) fn__loadingscreenSetLoadFreemodeWithEventName = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_loadingscreenSetLoadFreemodeWithEventName");
				fn__loadingscreenSetLoadFreemodeWithEventName(_toggle);
			}
		}

		public bool LoadingscreenIsLoadingFreemode()
		{
			unsafe {
				if (fn__loadingscreenIsLoadingFreemode == null) fn__loadingscreenIsLoadingFreemode = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_loadingscreenIsLoadingFreemode");
				var result = fn__loadingscreenIsLoadingFreemode();
				return result;
			}
		}

		public void LoadingscreenSetIsLoadingFreemode(bool _toggle)
		{
			unsafe {
				if (fn__loadingscreenSetIsLoadingFreemode == null) fn__loadingscreenSetIsLoadingFreemode = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_loadingscreenSetIsLoadingFreemode");
				fn__loadingscreenSetIsLoadingFreemode(_toggle);
			}
		}

		public void _0xFA1E0E893D915215(bool _toggle)
		{
			unsafe {
				if (fn__0xFA1E0E893D915215 == null) fn__0xFA1E0E893D915215 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xFA1E0E893D915215");
				fn__0xFA1E0E893D915215(_toggle);
			}
		}

		public int LocalizationGetSystemLanguage()
		{
			unsafe {
				if (fn__localizationGetSystemLanguage == null) fn__localizationGetSystemLanguage = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_localizationGetSystemLanguage");
				var result = fn__localizationGetSystemLanguage();
				return result;
			}
		}

		public int GetCurrentLanguage()
		{
			unsafe {
				if (fn__getCurrentLanguage == null) fn__getCurrentLanguage = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCurrentLanguage");
				var result = fn__getCurrentLanguage();
				return result;
			}
		}

		public int LocalizationGetSystemDateFormat()
		{
			unsafe {
				if (fn__localizationGetSystemDateFormat == null) fn__localizationGetSystemDateFormat = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_localizationGetSystemDateFormat");
				var result = fn__localizationGetSystemDateFormat();
				return result;
			}
		}

		public int GetAllocatedStackSize()
		{
			unsafe {
				if (fn__getAllocatedStackSize == null) fn__getAllocatedStackSize = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getAllocatedStackSize");
				var result = fn__getAllocatedStackSize();
				return result;
			}
		}

		public int GetNumberOfFreeStacksOfThisSize(int _stackSize)
		{
			unsafe {
				if (fn__getNumberOfFreeStacksOfThisSize == null) fn__getNumberOfFreeStacksOfThisSize = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfFreeStacksOfThisSize");
				var result = fn__getNumberOfFreeStacksOfThisSize(_stackSize);
				return result;
			}
		}

		public void SetRandomSeed(int _seed)
		{
			unsafe {
				if (fn__setRandomSeed == null) fn__setRandomSeed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setRandomSeed");
				fn__setRandomSeed(_seed);
			}
		}

		public void SetTimeScale(float _timeScale)
		{
			unsafe {
				if (fn__setTimeScale == null) fn__setTimeScale = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setTimeScale");
				fn__setTimeScale(_timeScale);
			}
		}

		public void SetMissionFlag(bool _toggle)
		{
			unsafe {
				if (fn__setMissionFlag == null) fn__setMissionFlag = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMissionFlag");
				fn__setMissionFlag(_toggle);
			}
		}

		public bool GetMissionFlag()
		{
			unsafe {
				if (fn__getMissionFlag == null) fn__getMissionFlag = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getMissionFlag");
				var result = fn__getMissionFlag();
				return result;
			}
		}

		public void SetRandomEventFlag(bool _toggle)
		{
			unsafe {
				if (fn__setRandomEventFlag == null) fn__setRandomEventFlag = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setRandomEventFlag");
				fn__setRandomEventFlag(_toggle);
			}
		}

		public bool GetRandomEventFlag()
		{
			unsafe {
				if (fn__getRandomEventFlag == null) fn__getRandomEventFlag = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getRandomEventFlag");
				var result = fn__getRandomEventFlag();
				return result;
			}
		}

		public string GetGlobalCharBuffer()
		{
			unsafe {
				if (fn__getGlobalCharBuffer == null) fn__getGlobalCharBuffer = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_getGlobalCharBuffer");
				var result = fn__getGlobalCharBuffer();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void _0x4DCDF92BF64236CD(string _p0, string _p1)
		{
			unsafe {
				if (fn__0x4DCDF92BF64236CD == null) fn__0x4DCDF92BF64236CD = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native__0x4DCDF92BF64236CD");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__0x4DCDF92BF64236CD(ptr_p0, ptr_p1);
				Marshal.FreeHGlobal(ptr_p0);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void _0x31125FD509D9043F(string _p0)
		{
			unsafe {
				if (fn__0x31125FD509D9043F == null) fn__0x31125FD509D9043F = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0x31125FD509D9043F");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0x31125FD509D9043F(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void _0xEBD3205A207939ED(string _p0)
		{
			unsafe {
				if (fn__0xEBD3205A207939ED == null) fn__0xEBD3205A207939ED = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0xEBD3205A207939ED");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0xEBD3205A207939ED(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void _0x97E7E2C04245115B(int _p0)
		{
			unsafe {
				if (fn__0x97E7E2C04245115B == null) fn__0x97E7E2C04245115B = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x97E7E2C04245115B");
				fn__0x97E7E2C04245115B(_p0);
			}
		}

		public void _0x916CA67D26FD1E37(string _p0)
		{
			unsafe {
				if (fn__0x916CA67D26FD1E37 == null) fn__0x916CA67D26FD1E37 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0x916CA67D26FD1E37");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0x916CA67D26FD1E37(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void _0xEB078CA2B5E82ADD(string _p0, string _p1)
		{
			unsafe {
				if (fn__0xEB078CA2B5E82ADD == null) fn__0xEB078CA2B5E82ADD = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native__0xEB078CA2B5E82ADD");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__0xEB078CA2B5E82ADD(ptr_p0, ptr_p1);
				Marshal.FreeHGlobal(ptr_p0);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void _0x703CC7F60CBB2B57(string _p0)
		{
			unsafe {
				if (fn__0x703CC7F60CBB2B57 == null) fn__0x703CC7F60CBB2B57 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0x703CC7F60CBB2B57");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0x703CC7F60CBB2B57(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void _0x8951EB9C6906D3C8()
		{
			unsafe {
				if (fn__0x8951EB9C6906D3C8 == null) fn__0x8951EB9C6906D3C8 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x8951EB9C6906D3C8");
				fn__0x8951EB9C6906D3C8();
			}
		}

		public void _0xBA4B8D83BDC75551(string _p0)
		{
			unsafe {
				if (fn__0xBA4B8D83BDC75551 == null) fn__0xBA4B8D83BDC75551 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0xBA4B8D83BDC75551");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0xBA4B8D83BDC75551(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public bool HasResumedFromSuspend()
		{
			unsafe {
				if (fn__hasResumedFromSuspend == null) fn__hasResumedFromSuspend = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasResumedFromSuspend");
				var result = fn__hasResumedFromSuspend();
				return result;
			}
		}

		public void _0x65D2EBB47E1CEC21(bool _toggle)
		{
			unsafe {
				if (fn__0x65D2EBB47E1CEC21 == null) fn__0x65D2EBB47E1CEC21 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x65D2EBB47E1CEC21");
				fn__0x65D2EBB47E1CEC21(_toggle);
			}
		}

		public void _0x6F2135B6129620C1(bool _toggle)
		{
			unsafe {
				if (fn__0x6F2135B6129620C1 == null) fn__0x6F2135B6129620C1 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x6F2135B6129620C1");
				fn__0x6F2135B6129620C1(_toggle);
			}
		}

		public void _0x8D74E26F54B4E5C3(string _p0)
		{
			unsafe {
				if (fn__0x8D74E26F54B4E5C3 == null) fn__0x8D74E26F54B4E5C3 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0x8D74E26F54B4E5C3");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0x8D74E26F54B4E5C3(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public bool GetBaseElementMetadata(ref int _p0, ref int _p1, int _p2, bool _p3)
		{
			unsafe {
				if (fn__getBaseElementMetadata == null) fn__getBaseElementMetadata = (delegate* unmanaged[Cdecl]<int*, int*, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_getBaseElementMetadata");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__getBaseElementMetadata(&ref_p0, &ref_p1, _p2, _p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public int GetPrevWeatherTypeHashName()
		{
			unsafe {
				if (fn__getPrevWeatherTypeHashName == null) fn__getPrevWeatherTypeHashName = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPrevWeatherTypeHashName");
				var result = fn__getPrevWeatherTypeHashName();
				return result;
			}
		}

		public int GetNextWeatherTypeHashName()
		{
			unsafe {
				if (fn__getNextWeatherTypeHashName == null) fn__getNextWeatherTypeHashName = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNextWeatherTypeHashName");
				var result = fn__getNextWeatherTypeHashName();
				return result;
			}
		}

		public bool IsPrevWeatherType(string _weatherType)
		{
			unsafe {
				if (fn__isPrevWeatherType == null) fn__isPrevWeatherType = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isPrevWeatherType");
				var ptr_weatherType = MemoryUtils.StringToHGlobalUtf8(_weatherType);
				var result = fn__isPrevWeatherType(ptr_weatherType);
				Marshal.FreeHGlobal(ptr_weatherType);
				return result;
			}
		}

		public bool IsNextWeatherType(string _weatherType)
		{
			unsafe {
				if (fn__isNextWeatherType == null) fn__isNextWeatherType = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isNextWeatherType");
				var ptr_weatherType = MemoryUtils.StringToHGlobalUtf8(_weatherType);
				var result = fn__isNextWeatherType(ptr_weatherType);
				Marshal.FreeHGlobal(ptr_weatherType);
				return result;
			}
		}

		public void SetWeatherTypePersist(string _weatherType)
		{
			unsafe {
				if (fn__setWeatherTypePersist == null) fn__setWeatherTypePersist = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setWeatherTypePersist");
				var ptr_weatherType = MemoryUtils.StringToHGlobalUtf8(_weatherType);
				fn__setWeatherTypePersist(ptr_weatherType);
				Marshal.FreeHGlobal(ptr_weatherType);
			}
		}

		public void SetWeatherTypeNowPersist(string _weatherType)
		{
			unsafe {
				if (fn__setWeatherTypeNowPersist == null) fn__setWeatherTypeNowPersist = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setWeatherTypeNowPersist");
				var ptr_weatherType = MemoryUtils.StringToHGlobalUtf8(_weatherType);
				fn__setWeatherTypeNowPersist(ptr_weatherType);
				Marshal.FreeHGlobal(ptr_weatherType);
			}
		}

		public void SetWeatherTypeNow(string _weatherType)
		{
			unsafe {
				if (fn__setWeatherTypeNow == null) fn__setWeatherTypeNow = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setWeatherTypeNow");
				var ptr_weatherType = MemoryUtils.StringToHGlobalUtf8(_weatherType);
				fn__setWeatherTypeNow(ptr_weatherType);
				Marshal.FreeHGlobal(ptr_weatherType);
			}
		}

		public void SetWeatherTypeOvertimePersist(string _weatherType, float _time)
		{
			unsafe {
				if (fn__setWeatherTypeOvertimePersist == null) fn__setWeatherTypeOvertimePersist = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_setWeatherTypeOvertimePersist");
				var ptr_weatherType = MemoryUtils.StringToHGlobalUtf8(_weatherType);
				fn__setWeatherTypeOvertimePersist(ptr_weatherType, _time);
				Marshal.FreeHGlobal(ptr_weatherType);
			}
		}

		public void SetRandomWeatherType()
		{
			unsafe {
				if (fn__setRandomWeatherType == null) fn__setRandomWeatherType = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setRandomWeatherType");
				fn__setRandomWeatherType();
			}
		}

		public void ClearWeatherTypePersist()
		{
			unsafe {
				if (fn__clearWeatherTypePersist == null) fn__clearWeatherTypePersist = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearWeatherTypePersist");
				fn__clearWeatherTypePersist();
			}
		}

		public void _0x0CF97F497FE7D048(float _p0)
		{
			unsafe {
				if (fn__0x0CF97F497FE7D048 == null) fn__0x0CF97F497FE7D048 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x0CF97F497FE7D048");
				fn__0x0CF97F497FE7D048(_p0);
			}
		}

		public void GetWeatherTypeTransition(ref int _weatherType1, ref int _weatherType2, ref float _percentWeather2)
		{
			unsafe {
				if (fn__getWeatherTypeTransition == null) fn__getWeatherTypeTransition = (delegate* unmanaged[Cdecl]<int*, int*, float*, void>) NativeLibrary.GetExport(handle, "Native_getWeatherTypeTransition");
				var ref_weatherType1 = _weatherType1;
				var ref_weatherType2 = _weatherType2;
				var ref_percentWeather2 = _percentWeather2;
				fn__getWeatherTypeTransition(&ref_weatherType1, &ref_weatherType2, &ref_percentWeather2);
				_weatherType1 = ref_weatherType1;
				_weatherType2 = ref_weatherType2;
				_percentWeather2 = ref_percentWeather2;
			}
		}

		public void SetWeatherTypeTransition(int _weatherType1, int _weatherType2, float _percentWeather2)
		{
			unsafe {
				if (fn__setWeatherTypeTransition == null) fn__setWeatherTypeTransition = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setWeatherTypeTransition");
				fn__setWeatherTypeTransition(_weatherType1, _weatherType2, _percentWeather2);
			}
		}

		public void SetOverrideWeather(string _weatherType)
		{
			unsafe {
				if (fn__setOverrideWeather == null) fn__setOverrideWeather = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setOverrideWeather");
				var ptr_weatherType = MemoryUtils.StringToHGlobalUtf8(_weatherType);
				fn__setOverrideWeather(ptr_weatherType);
				Marshal.FreeHGlobal(ptr_weatherType);
			}
		}

		public void _0x1178E104409FE58C(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x1178E104409FE58C == null) fn__0x1178E104409FE58C = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1178E104409FE58C");
				fn__0x1178E104409FE58C(_p0, _p1);
			}
		}

		public void ClearOverrideWeather()
		{
			unsafe {
				if (fn__clearOverrideWeather == null) fn__clearOverrideWeather = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearOverrideWeather");
				fn__clearOverrideWeather();
			}
		}

		public void WaterOverrideSetShorewaveamplitude(float _amplitude)
		{
			unsafe {
				if (fn__waterOverrideSetShorewaveamplitude == null) fn__waterOverrideSetShorewaveamplitude = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetShorewaveamplitude");
				fn__waterOverrideSetShorewaveamplitude(_amplitude);
			}
		}

		public void WaterOverrideSetShorewaveminamplitude(float _minAmplitude)
		{
			unsafe {
				if (fn__waterOverrideSetShorewaveminamplitude == null) fn__waterOverrideSetShorewaveminamplitude = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetShorewaveminamplitude");
				fn__waterOverrideSetShorewaveminamplitude(_minAmplitude);
			}
		}

		public void WaterOverrideSetShorewavemaxamplitude(float _maxAmplitude)
		{
			unsafe {
				if (fn__waterOverrideSetShorewavemaxamplitude == null) fn__waterOverrideSetShorewavemaxamplitude = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetShorewavemaxamplitude");
				fn__waterOverrideSetShorewavemaxamplitude(_maxAmplitude);
			}
		}

		public void WaterOverrideSetOceannoiseminamplitude(float _minAmplitude)
		{
			unsafe {
				if (fn__waterOverrideSetOceannoiseminamplitude == null) fn__waterOverrideSetOceannoiseminamplitude = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetOceannoiseminamplitude");
				fn__waterOverrideSetOceannoiseminamplitude(_minAmplitude);
			}
		}

		public void WaterOverrideSetOceanwaveamplitude(float _amplitude)
		{
			unsafe {
				if (fn__waterOverrideSetOceanwaveamplitude == null) fn__waterOverrideSetOceanwaveamplitude = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetOceanwaveamplitude");
				fn__waterOverrideSetOceanwaveamplitude(_amplitude);
			}
		}

		public void WaterOverrideSetOceanwaveminamplitude(float _minAmplitude)
		{
			unsafe {
				if (fn__waterOverrideSetOceanwaveminamplitude == null) fn__waterOverrideSetOceanwaveminamplitude = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetOceanwaveminamplitude");
				fn__waterOverrideSetOceanwaveminamplitude(_minAmplitude);
			}
		}

		public void WaterOverrideSetOceanwavemaxamplitude(float _maxAmplitude)
		{
			unsafe {
				if (fn__waterOverrideSetOceanwavemaxamplitude == null) fn__waterOverrideSetOceanwavemaxamplitude = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetOceanwavemaxamplitude");
				fn__waterOverrideSetOceanwavemaxamplitude(_maxAmplitude);
			}
		}

		public void WaterOverrideSetRipplebumpiness(float _bumpiness)
		{
			unsafe {
				if (fn__waterOverrideSetRipplebumpiness == null) fn__waterOverrideSetRipplebumpiness = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetRipplebumpiness");
				fn__waterOverrideSetRipplebumpiness(_bumpiness);
			}
		}

		public void WaterOverrideSetRippleminbumpiness(float _minBumpiness)
		{
			unsafe {
				if (fn__waterOverrideSetRippleminbumpiness == null) fn__waterOverrideSetRippleminbumpiness = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetRippleminbumpiness");
				fn__waterOverrideSetRippleminbumpiness(_minBumpiness);
			}
		}

		public void WaterOverrideSetRipplemaxbumpiness(float _maxBumpiness)
		{
			unsafe {
				if (fn__waterOverrideSetRipplemaxbumpiness == null) fn__waterOverrideSetRipplemaxbumpiness = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetRipplemaxbumpiness");
				fn__waterOverrideSetRipplemaxbumpiness(_maxBumpiness);
			}
		}

		public void WaterOverrideSetRippledisturb(float _disturb)
		{
			unsafe {
				if (fn__waterOverrideSetRippledisturb == null) fn__waterOverrideSetRippledisturb = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetRippledisturb");
				fn__waterOverrideSetRippledisturb(_disturb);
			}
		}

		public void WaterOverrideSetStrength(float _strength)
		{
			unsafe {
				if (fn__waterOverrideSetStrength == null) fn__waterOverrideSetStrength = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideSetStrength");
				fn__waterOverrideSetStrength(_strength);
			}
		}

		public void WaterOverrideFadeIn(float _p0)
		{
			unsafe {
				if (fn__waterOverrideFadeIn == null) fn__waterOverrideFadeIn = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideFadeIn");
				fn__waterOverrideFadeIn(_p0);
			}
		}

		public void WaterOverrideFadeOut(float _p0)
		{
			unsafe {
				if (fn__waterOverrideFadeOut == null) fn__waterOverrideFadeOut = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_waterOverrideFadeOut");
				fn__waterOverrideFadeOut(_p0);
			}
		}

		public void SetWind(float _speed)
		{
			unsafe {
				if (fn__setWind == null) fn__setWind = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setWind");
				fn__setWind(_speed);
			}
		}

		public void SetWindSpeed(float _speed)
		{
			unsafe {
				if (fn__setWindSpeed == null) fn__setWindSpeed = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setWindSpeed");
				fn__setWindSpeed(_speed);
			}
		}

		public float GetWindSpeed()
		{
			unsafe {
				if (fn__getWindSpeed == null) fn__getWindSpeed = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getWindSpeed");
				var result = fn__getWindSpeed();
				return result;
			}
		}

		public void SetWindDirection(float _direction)
		{
			unsafe {
				if (fn__setWindDirection == null) fn__setWindDirection = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setWindDirection");
				fn__setWindDirection(_direction);
			}
		}

		public Vector3 GetWindDirection()
		{
			unsafe {
				if (fn__getWindDirection == null) fn__getWindDirection = (delegate* unmanaged[Cdecl]<Vector3>) NativeLibrary.GetExport(handle, "Native_getWindDirection");
				var result = fn__getWindDirection();
				return result;
			}
		}

		public void SetRainLevel(float _intensity)
		{
			unsafe {
				if (fn__setRainLevel == null) fn__setRainLevel = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setRainLevel");
				fn__setRainLevel(_intensity);
			}
		}

		public float GetRainLevel()
		{
			unsafe {
				if (fn__getRainLevel == null) fn__getRainLevel = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getRainLevel");
				var result = fn__getRainLevel();
				return result;
			}
		}

		public void SetSnowLevel(float _level)
		{
			unsafe {
				if (fn__setSnowLevel == null) fn__setSnowLevel = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setSnowLevel");
				fn__setSnowLevel(_level);
			}
		}

		public float GetSnowLevel()
		{
			unsafe {
				if (fn__getSnowLevel == null) fn__getSnowLevel = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getSnowLevel");
				var result = fn__getSnowLevel();
				return result;
			}
		}

		public void ForceLightningFlash()
		{
			unsafe {
				if (fn__forceLightningFlash == null) fn__forceLightningFlash = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_forceLightningFlash");
				fn__forceLightningFlash();
			}
		}

		public void _0x02DEAAC8F8EA7FE7(string _p0)
		{
			unsafe {
				if (fn__0x02DEAAC8F8EA7FE7 == null) fn__0x02DEAAC8F8EA7FE7 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0x02DEAAC8F8EA7FE7");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0x02DEAAC8F8EA7FE7(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public void PreloadCloudHat(string _name)
		{
			unsafe {
				if (fn__preloadCloudHat == null) fn__preloadCloudHat = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_preloadCloudHat");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__preloadCloudHat(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void LoadCloudHat(string _name, float _transitionTime)
		{
			unsafe {
				if (fn__loadCloudHat == null) fn__loadCloudHat = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_loadCloudHat");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__loadCloudHat(ptr_name, _transitionTime);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void UnloadCloudHat(string _name, float _p1)
		{
			unsafe {
				if (fn__unloadCloudHat == null) fn__unloadCloudHat = (delegate* unmanaged[Cdecl]<nint, float, void>) NativeLibrary.GetExport(handle, "Native_unloadCloudHat");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__unloadCloudHat(ptr_name, _p1);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void ClearCloudHat()
		{
			unsafe {
				if (fn__clearCloudHat == null) fn__clearCloudHat = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearCloudHat");
				fn__clearCloudHat();
			}
		}

		public void SetCloudHatOpacity(float _opacity)
		{
			unsafe {
				if (fn__setCloudHatOpacity == null) fn__setCloudHatOpacity = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setCloudHatOpacity");
				fn__setCloudHatOpacity(_opacity);
			}
		}

		public float GetCloudHatOpacity()
		{
			unsafe {
				if (fn__getCloudHatOpacity == null) fn__getCloudHatOpacity = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getCloudHatOpacity");
				var result = fn__getCloudHatOpacity();
				return result;
			}
		}

		public int GetGameTimer()
		{
			unsafe {
				if (fn__getGameTimer == null) fn__getGameTimer = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getGameTimer");
				var result = fn__getGameTimer();
				return result;
			}
		}

		public float GetFrameTime()
		{
			unsafe {
				if (fn__getFrameTime == null) fn__getFrameTime = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getFrameTime");
				var result = fn__getFrameTime();
				return result;
			}
		}

		public float GetBenchmarkTime()
		{
			unsafe {
				if (fn__getBenchmarkTime == null) fn__getBenchmarkTime = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getBenchmarkTime");
				var result = fn__getBenchmarkTime();
				return result;
			}
		}

		public int GetFrameCount()
		{
			unsafe {
				if (fn__getFrameCount == null) fn__getFrameCount = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getFrameCount");
				var result = fn__getFrameCount();
				return result;
			}
		}

		public float GetRandomFloatInRange(float _startRange, float _endRange)
		{
			unsafe {
				if (fn__getRandomFloatInRange == null) fn__getRandomFloatInRange = (delegate* unmanaged[Cdecl]<float, float, float>) NativeLibrary.GetExport(handle, "Native_getRandomFloatInRange");
				var result = fn__getRandomFloatInRange(_startRange, _endRange);
				return result;
			}
		}

		public int GetRandomIntInRange(int _startRange, int _endRange)
		{
			unsafe {
				if (fn__getRandomIntInRange == null) fn__getRandomIntInRange = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getRandomIntInRange");
				var result = fn__getRandomIntInRange(_startRange, _endRange);
				return result;
			}
		}

		public int GetRandomIntInRange2(int _startRange, int _endRange)
		{
			unsafe {
				if (fn__getRandomIntInRange2 == null) fn__getRandomIntInRange2 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getRandomIntInRange2");
				var result = fn__getRandomIntInRange2(_startRange, _endRange);
				return result;
			}
		}

		public bool GetGroundZFor3dCoord(float _x, float _y, float _z, ref float _groundZ, bool _ignoreWater, bool _p5)
		{
			unsafe {
				if (fn__getGroundZFor3dCoord == null) fn__getGroundZFor3dCoord = (delegate* unmanaged[Cdecl]<float, float, float, float*, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_getGroundZFor3dCoord");
				var ref_groundZ = _groundZ;
				var result = fn__getGroundZFor3dCoord(_x, _y, _z, &ref_groundZ, _ignoreWater, _p5);
				_groundZ = ref_groundZ;
				return result;
			}
		}

		public bool GetGroundZAndNormalFor3dCoord(float _x, float _y, float _z, ref float _groundZ, ref Vector3 _normal)
		{
			unsafe {
				if (fn__getGroundZAndNormalFor3dCoord == null) fn__getGroundZAndNormalFor3dCoord = (delegate* unmanaged[Cdecl]<float, float, float, float*, Vector3*, bool>) NativeLibrary.GetExport(handle, "Native_getGroundZAndNormalFor3dCoord");
				var ref_groundZ = _groundZ;
				var ref_normal = _normal;
				var result = fn__getGroundZAndNormalFor3dCoord(_x, _y, _z, &ref_groundZ, &ref_normal);
				_groundZ = ref_groundZ;
				_normal = ref_normal;
				return result;
			}
		}

		public bool GetGroundZFor3dCoord2(float _x, float _y, float _z, ref float _groundZ, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__getGroundZFor3dCoord2 == null) fn__getGroundZFor3dCoord2 = (delegate* unmanaged[Cdecl]<float, float, float, float*, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_getGroundZFor3dCoord2");
				var ref_groundZ = _groundZ;
				var result = fn__getGroundZFor3dCoord2(_x, _y, _z, &ref_groundZ, _p4, _p5);
				_groundZ = ref_groundZ;
				return result;
			}
		}

		public float Asin(float _p0)
		{
			unsafe {
				if (fn__asin == null) fn__asin = (delegate* unmanaged[Cdecl]<float, float>) NativeLibrary.GetExport(handle, "Native_asin");
				var result = fn__asin(_p0);
				return result;
			}
		}

		public float Acos(float _p0)
		{
			unsafe {
				if (fn__acos == null) fn__acos = (delegate* unmanaged[Cdecl]<float, float>) NativeLibrary.GetExport(handle, "Native_acos");
				var result = fn__acos(_p0);
				return result;
			}
		}

		public float Tan(float _p0)
		{
			unsafe {
				if (fn__tan == null) fn__tan = (delegate* unmanaged[Cdecl]<float, float>) NativeLibrary.GetExport(handle, "Native_tan");
				var result = fn__tan(_p0);
				return result;
			}
		}

		public float Atan(float _p0)
		{
			unsafe {
				if (fn__atan == null) fn__atan = (delegate* unmanaged[Cdecl]<float, float>) NativeLibrary.GetExport(handle, "Native_atan");
				var result = fn__atan(_p0);
				return result;
			}
		}

		public float Atan2(float _p0, float _p1)
		{
			unsafe {
				if (fn__atan2 == null) fn__atan2 = (delegate* unmanaged[Cdecl]<float, float, float>) NativeLibrary.GetExport(handle, "Native_atan2");
				var result = fn__atan2(_p0, _p1);
				return result;
			}
		}

		public float GetDistanceBetweenCoords(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _useZ)
		{
			unsafe {
				if (fn__getDistanceBetweenCoords == null) fn__getDistanceBetweenCoords = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, float>) NativeLibrary.GetExport(handle, "Native_getDistanceBetweenCoords");
				var result = fn__getDistanceBetweenCoords(_x1, _y1, _z1, _x2, _y2, _z2, _useZ);
				return result;
			}
		}

		public float GetAngleBetween2dVectors(float _x1, float _y1, float _x2, float _y2)
		{
			unsafe {
				if (fn__getAngleBetween2dVectors == null) fn__getAngleBetween2dVectors = (delegate* unmanaged[Cdecl]<float, float, float, float, float>) NativeLibrary.GetExport(handle, "Native_getAngleBetween2dVectors");
				var result = fn__getAngleBetween2dVectors(_x1, _y1, _x2, _y2);
				return result;
			}
		}

		public float GetHeadingFromVector2d(float _dx, float _dy)
		{
			unsafe {
				if (fn__getHeadingFromVector2d == null) fn__getHeadingFromVector2d = (delegate* unmanaged[Cdecl]<float, float, float>) NativeLibrary.GetExport(handle, "Native_getHeadingFromVector2d");
				var result = fn__getHeadingFromVector2d(_dx, _dy);
				return result;
			}
		}

		public float _0x7F8F6405F4777AF6(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, float _p8, bool _p9)
		{
			unsafe {
				if (fn__0x7F8F6405F4777AF6 == null) fn__0x7F8F6405F4777AF6 = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, bool, float>) NativeLibrary.GetExport(handle, "Native__0x7F8F6405F4777AF6");
				var result = fn__0x7F8F6405F4777AF6(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
				return result;
			}
		}

		public Vector3 _0x21C235BC64831E5A(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, float _p8, bool _p9)
		{
			unsafe {
				if (fn__0x21C235BC64831E5A == null) fn__0x21C235BC64831E5A = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, bool, Vector3>) NativeLibrary.GetExport(handle, "Native__0x21C235BC64831E5A");
				var result = fn__0x21C235BC64831E5A(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
				return result;
			}
		}

		public bool _0xF56DFB7B61BE7276(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, float _p8, float _p9, float _p10, float _p11, ref float _p12)
		{
			unsafe {
				if (fn__0xF56DFB7B61BE7276 == null) fn__0xF56DFB7B61BE7276 = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, float*, bool>) NativeLibrary.GetExport(handle, "Native__0xF56DFB7B61BE7276");
				var ref_p12 = _p12;
				var result = fn__0xF56DFB7B61BE7276(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, &ref_p12);
				_p12 = ref_p12;
				return result;
			}
		}

		public int _0xA0AD167E4B39D9A2(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9, int _p10, int _p11, int _p12, int _p13)
		{
			unsafe {
				if (fn__0xA0AD167E4B39D9A2 == null) fn__0xA0AD167E4B39D9A2 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0xA0AD167E4B39D9A2");
				var result = fn__0xA0AD167E4B39D9A2(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12, _p13);
				return result;
			}
		}

		public void SetBit(ref int _address, int _offset)
		{
			unsafe {
				if (fn__setBit == null) fn__setBit = (delegate* unmanaged[Cdecl]<int*, int, void>) NativeLibrary.GetExport(handle, "Native_setBit");
				var ref_address = _address;
				fn__setBit(&ref_address, _offset);
				_address = ref_address;
			}
		}

		public void ClearBit(ref int _address, int _offset)
		{
			unsafe {
				if (fn__clearBit == null) fn__clearBit = (delegate* unmanaged[Cdecl]<int*, int, void>) NativeLibrary.GetExport(handle, "Native_clearBit");
				var ref_address = _address;
				fn__clearBit(&ref_address, _offset);
				_address = ref_address;
			}
		}

		public int GetHashKey(string _string)
		{
			unsafe {
				if (fn__getHashKey == null) fn__getHashKey = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_getHashKey");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				var result = fn__getHashKey(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
				return result;
			}
		}

		public void SlerpNearQuaternion(float _t, float _x, float _y, float _z, float _w, float _x1, float _y1, float _z1, float _w1, ref float _outX, ref float _outY, ref float _outZ, ref float _outW)
		{
			unsafe {
				if (fn__slerpNearQuaternion == null) fn__slerpNearQuaternion = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float*, float*, float*, float*, void>) NativeLibrary.GetExport(handle, "Native_slerpNearQuaternion");
				var ref_outX = _outX;
				var ref_outY = _outY;
				var ref_outZ = _outZ;
				var ref_outW = _outW;
				fn__slerpNearQuaternion(_t, _x, _y, _z, _w, _x1, _y1, _z1, _w1, &ref_outX, &ref_outY, &ref_outZ, &ref_outW);
				_outX = ref_outX;
				_outY = ref_outY;
				_outZ = ref_outZ;
				_outW = ref_outW;
			}
		}

		public bool IsAreaOccupied(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, bool _p6, bool _p7, bool _p8, bool _p9, bool _p10, int _p11, bool _p12)
		{
			unsafe {
				if (fn__isAreaOccupied == null) fn__isAreaOccupied = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool, bool, bool, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isAreaOccupied");
				var result = fn__isAreaOccupied(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12);
				return result;
			}
		}

		public int _0x39455BF4F4F55186(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9, int _p10, int _p11, int _p12)
		{
			unsafe {
				if (fn__0x39455BF4F4F55186 == null) fn__0x39455BF4F4F55186 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x39455BF4F4F55186");
				var result = fn__0x39455BF4F4F55186(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12);
				return result;
			}
		}

		public bool IsPositionOccupied(float _x, float _y, float _z, float _range, bool _p4, bool _checkVehicles, bool _checkPeds, bool _p7, bool _p8, int _ignoreEntity, bool _p10)
		{
			unsafe {
				if (fn__isPositionOccupied == null) fn__isPositionOccupied = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, bool, bool, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isPositionOccupied");
				var result = fn__isPositionOccupied(_x, _y, _z, _range, _p4, _checkVehicles, _checkPeds, _p7, _p8, _ignoreEntity, _p10);
				return result;
			}
		}

		public bool IsPointObscuredByAMissionEntity(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, int _p6)
		{
			unsafe {
				if (fn__isPointObscuredByAMissionEntity == null) fn__isPointObscuredByAMissionEntity = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool>) NativeLibrary.GetExport(handle, "Native_isPointObscuredByAMissionEntity");
				var result = fn__isPointObscuredByAMissionEntity(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
				return result;
			}
		}

		public void ClearArea(float _X, float _Y, float _Z, float _radius, bool _p4, bool _ignoreCopCars, bool _ignoreObjects, bool _p7)
		{
			unsafe {
				if (fn__clearArea == null) fn__clearArea = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_clearArea");
				fn__clearArea(_X, _Y, _Z, _radius, _p4, _ignoreCopCars, _ignoreObjects, _p7);
			}
		}

		public void ClearAreaLeaveVehicleHealth(float _x, float _y, float _z, float _radius, bool _p4, bool _p5, bool _p6, bool _p7)
		{
			unsafe {
				if (fn__clearAreaLeaveVehicleHealth == null) fn__clearAreaLeaveVehicleHealth = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_clearAreaLeaveVehicleHealth");
				fn__clearAreaLeaveVehicleHealth(_x, _y, _z, _radius, _p4, _p5, _p6, _p7);
			}
		}

		public void ClearAreaOfVehicles(float _x, float _y, float _z, float _radius, bool _p4, bool _p5, bool _p6, bool _p7, bool _p8, bool _p9)
		{
			unsafe {
				if (fn__clearAreaOfVehicles == null) fn__clearAreaOfVehicles = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_clearAreaOfVehicles");
				fn__clearAreaOfVehicles(_x, _y, _z, _radius, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void ClearAngledAreaOfVehicles(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width, bool _p7, bool _p8, bool _p9, bool _p10, bool _p11, int _p12)
		{
			unsafe {
				if (fn__clearAngledAreaOfVehicles == null) fn__clearAngledAreaOfVehicles = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, bool, bool, bool, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_clearAngledAreaOfVehicles");
				fn__clearAngledAreaOfVehicles(_x1, _y1, _z1, _x2, _y2, _z2, _width, _p7, _p8, _p9, _p10, _p11, _p12);
			}
		}

		public void ClearAreaOfObjects(float _x, float _y, float _z, float _radius, int _flags)
		{
			unsafe {
				if (fn__clearAreaOfObjects == null) fn__clearAreaOfObjects = (delegate* unmanaged[Cdecl]<float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_clearAreaOfObjects");
				fn__clearAreaOfObjects(_x, _y, _z, _radius, _flags);
			}
		}

		public void ClearAreaOfPeds(float _x, float _y, float _z, float _radius, int _flags)
		{
			unsafe {
				if (fn__clearAreaOfPeds == null) fn__clearAreaOfPeds = (delegate* unmanaged[Cdecl]<float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_clearAreaOfPeds");
				fn__clearAreaOfPeds(_x, _y, _z, _radius, _flags);
			}
		}

		public void ClearAreaOfCops(float _x, float _y, float _z, float _radius, int _flags)
		{
			unsafe {
				if (fn__clearAreaOfCops == null) fn__clearAreaOfCops = (delegate* unmanaged[Cdecl]<float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_clearAreaOfCops");
				fn__clearAreaOfCops(_x, _y, _z, _radius, _flags);
			}
		}

		public void ClearAreaOfProjectiles(float _x, float _y, float _z, float _radius, int _flags)
		{
			unsafe {
				if (fn__clearAreaOfProjectiles == null) fn__clearAreaOfProjectiles = (delegate* unmanaged[Cdecl]<float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_clearAreaOfProjectiles");
				fn__clearAreaOfProjectiles(_x, _y, _z, _radius, _flags);
			}
		}

		public void _0x7EC6F9A478A6A512()
		{
			unsafe {
				if (fn__0x7EC6F9A478A6A512 == null) fn__0x7EC6F9A478A6A512 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x7EC6F9A478A6A512");
				fn__0x7EC6F9A478A6A512();
			}
		}

		public void SetSaveMenuActive(bool _ignoreVehicle)
		{
			unsafe {
				if (fn__setSaveMenuActive == null) fn__setSaveMenuActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setSaveMenuActive");
				fn__setSaveMenuActive(_ignoreVehicle);
			}
		}

		public int _0x397BAA01068BAA96()
		{
			unsafe {
				if (fn__0x397BAA01068BAA96 == null) fn__0x397BAA01068BAA96 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x397BAA01068BAA96");
				var result = fn__0x397BAA01068BAA96();
				return result;
			}
		}

		public void SetCreditsActive(bool _toggle)
		{
			unsafe {
				if (fn__setCreditsActive == null) fn__setCreditsActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setCreditsActive");
				fn__setCreditsActive(_toggle);
			}
		}

		public void _0xB51B9AB9EF81868C(bool _toggle)
		{
			unsafe {
				if (fn__0xB51B9AB9EF81868C == null) fn__0xB51B9AB9EF81868C = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xB51B9AB9EF81868C");
				fn__0xB51B9AB9EF81868C(_toggle);
			}
		}

		public bool HaveCreditsReachedEnd()
		{
			unsafe {
				if (fn__haveCreditsReachedEnd == null) fn__haveCreditsReachedEnd = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_haveCreditsReachedEnd");
				var result = fn__haveCreditsReachedEnd();
				return result;
			}
		}

		public void TerminateAllScriptsWithThisName(string _scriptName)
		{
			unsafe {
				if (fn__terminateAllScriptsWithThisName == null) fn__terminateAllScriptsWithThisName = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_terminateAllScriptsWithThisName");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				fn__terminateAllScriptsWithThisName(ptr_scriptName);
				Marshal.FreeHGlobal(ptr_scriptName);
			}
		}

		public void NetworkSetScriptIsSafeForNetworkGame()
		{
			unsafe {
				if (fn__networkSetScriptIsSafeForNetworkGame == null) fn__networkSetScriptIsSafeForNetworkGame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkSetScriptIsSafeForNetworkGame");
				fn__networkSetScriptIsSafeForNetworkGame();
			}
		}

		public int AddHospitalRestart(float _x, float _y, float _z, float _p3, int _p4)
		{
			unsafe {
				if (fn__addHospitalRestart == null) fn__addHospitalRestart = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int>) NativeLibrary.GetExport(handle, "Native_addHospitalRestart");
				var result = fn__addHospitalRestart(_x, _y, _z, _p3, _p4);
				return result;
			}
		}

		public void DisableHospitalRestart(int _hospitalIndex, bool _toggle)
		{
			unsafe {
				if (fn__disableHospitalRestart == null) fn__disableHospitalRestart = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_disableHospitalRestart");
				fn__disableHospitalRestart(_hospitalIndex, _toggle);
			}
		}

		public int AddPoliceRestart(float _p0, float _p1, float _p2, float _p3, int _p4)
		{
			unsafe {
				if (fn__addPoliceRestart == null) fn__addPoliceRestart = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int>) NativeLibrary.GetExport(handle, "Native_addPoliceRestart");
				var result = fn__addPoliceRestart(_p0, _p1, _p2, _p3, _p4);
				return result;
			}
		}

		public void DisablePoliceRestart(int _policeIndex, bool _toggle)
		{
			unsafe {
				if (fn__disablePoliceRestart == null) fn__disablePoliceRestart = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_disablePoliceRestart");
				fn__disablePoliceRestart(_policeIndex, _toggle);
			}
		}

		public void SetRestartCustomPosition(float _x, float _y, float _z, float _heading)
		{
			unsafe {
				if (fn__setRestartCustomPosition == null) fn__setRestartCustomPosition = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setRestartCustomPosition");
				fn__setRestartCustomPosition(_x, _y, _z, _heading);
			}
		}

		public void ClearRestartCustomPosition()
		{
			unsafe {
				if (fn__clearRestartCustomPosition == null) fn__clearRestartCustomPosition = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearRestartCustomPosition");
				fn__clearRestartCustomPosition();
			}
		}

		public void PauseDeathArrestRestart(bool _toggle)
		{
			unsafe {
				if (fn__pauseDeathArrestRestart == null) fn__pauseDeathArrestRestart = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_pauseDeathArrestRestart");
				fn__pauseDeathArrestRestart(_toggle);
			}
		}

		public void IgnoreNextRestart(bool _toggle)
		{
			unsafe {
				if (fn__ignoreNextRestart == null) fn__ignoreNextRestart = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_ignoreNextRestart");
				fn__ignoreNextRestart(_toggle);
			}
		}

		public void SetFadeOutAfterDeath(bool _toggle)
		{
			unsafe {
				if (fn__setFadeOutAfterDeath == null) fn__setFadeOutAfterDeath = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setFadeOutAfterDeath");
				fn__setFadeOutAfterDeath(_toggle);
			}
		}

		public void SetFadeOutAfterArrest(bool _toggle)
		{
			unsafe {
				if (fn__setFadeOutAfterArrest == null) fn__setFadeOutAfterArrest = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setFadeOutAfterArrest");
				fn__setFadeOutAfterArrest(_toggle);
			}
		}

		public void SetFadeInAfterDeathArrest(bool _toggle)
		{
			unsafe {
				if (fn__setFadeInAfterDeathArrest == null) fn__setFadeInAfterDeathArrest = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setFadeInAfterDeathArrest");
				fn__setFadeInAfterDeathArrest(_toggle);
			}
		}

		public void SetFadeInAfterLoad(bool _toggle)
		{
			unsafe {
				if (fn__setFadeInAfterLoad == null) fn__setFadeInAfterLoad = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setFadeInAfterLoad");
				fn__setFadeInAfterLoad(_toggle);
			}
		}

		public int RegisterSaveHouse(float _p0, float _p1, float _p2, float _p3, ref int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__registerSaveHouse == null) fn__registerSaveHouse = (delegate* unmanaged[Cdecl]<float, float, float, float, int*, int, int, int>) NativeLibrary.GetExport(handle, "Native_registerSaveHouse");
				var ref_p4 = _p4;
				var result = fn__registerSaveHouse(_p0, _p1, _p2, _p3, &ref_p4, _p5, _p6);
				_p4 = ref_p4;
				return result;
			}
		}

		public void SetSaveHouse(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setSaveHouse == null) fn__setSaveHouse = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setSaveHouse");
				fn__setSaveHouse(_p0, _p1, _p2);
			}
		}

		public bool OverrideSaveHouse(bool _p0, float _p1, float _p2, float _p3, float _p4, bool _p5, float _p6, float _p7)
		{
			unsafe {
				if (fn__overrideSaveHouse == null) fn__overrideSaveHouse = (delegate* unmanaged[Cdecl]<bool, float, float, float, float, bool, float, float, bool>) NativeLibrary.GetExport(handle, "Native_overrideSaveHouse");
				var result = fn__overrideSaveHouse(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
				return result;
			}
		}

		public bool _0xA4A0065E39C9F25C(ref Vector3 _p0, ref float _p1, ref bool _fadeInAfterLoad, ref bool _p3)
		{
			unsafe {
				if (fn__0xA4A0065E39C9F25C == null) fn__0xA4A0065E39C9F25C = (delegate* unmanaged[Cdecl]<Vector3*, float*, bool*, bool*, bool>) NativeLibrary.GetExport(handle, "Native__0xA4A0065E39C9F25C");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_fadeInAfterLoad = _fadeInAfterLoad;
				var ref_p3 = _p3;
				var result = fn__0xA4A0065E39C9F25C(&ref_p0, &ref_p1, &ref_fadeInAfterLoad, &ref_p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_fadeInAfterLoad = ref_fadeInAfterLoad;
				_p3 = ref_p3;
				return result;
			}
		}

		public void DoAutoSave()
		{
			unsafe {
				if (fn__doAutoSave == null) fn__doAutoSave = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_doAutoSave");
				fn__doAutoSave();
			}
		}

		public bool GetIsAutoSaveOff()
		{
			unsafe {
				if (fn__getIsAutoSaveOff == null) fn__getIsAutoSaveOff = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getIsAutoSaveOff");
				var result = fn__getIsAutoSaveOff();
				return result;
			}
		}

		public bool IsAutoSaveInProgress()
		{
			unsafe {
				if (fn__isAutoSaveInProgress == null) fn__isAutoSaveInProgress = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isAutoSaveInProgress");
				var result = fn__isAutoSaveInProgress();
				return result;
			}
		}

		public bool HasCodeRequestedAutosave()
		{
			unsafe {
				if (fn__hasCodeRequestedAutosave == null) fn__hasCodeRequestedAutosave = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasCodeRequestedAutosave");
				var result = fn__hasCodeRequestedAutosave();
				return result;
			}
		}

		public void ClearCodeRequestedAutosave()
		{
			unsafe {
				if (fn__clearCodeRequestedAutosave == null) fn__clearCodeRequestedAutosave = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearCodeRequestedAutosave");
				fn__clearCodeRequestedAutosave();
			}
		}

		public void BeginReplayStats(int _p0, int _p1)
		{
			unsafe {
				if (fn__beginReplayStats == null) fn__beginReplayStats = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_beginReplayStats");
				fn__beginReplayStats(_p0, _p1);
			}
		}

		public void AddReplayStatValue(int _value)
		{
			unsafe {
				if (fn__addReplayStatValue == null) fn__addReplayStatValue = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_addReplayStatValue");
				fn__addReplayStatValue(_value);
			}
		}

		public void EndReplayStats()
		{
			unsafe {
				if (fn__endReplayStats == null) fn__endReplayStats = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_endReplayStats");
				fn__endReplayStats();
			}
		}

		public int HaveReplayStatsBeenStored()
		{
			unsafe {
				if (fn__haveReplayStatsBeenStored == null) fn__haveReplayStatsBeenStored = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_haveReplayStatsBeenStored");
				var result = fn__haveReplayStatsBeenStored();
				return result;
			}
		}

		public int GetReplayStatMissionId()
		{
			unsafe {
				if (fn__getReplayStatMissionId == null) fn__getReplayStatMissionId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getReplayStatMissionId");
				var result = fn__getReplayStatMissionId();
				return result;
			}
		}

		public int GetReplayStatMissionType()
		{
			unsafe {
				if (fn__getReplayStatMissionType == null) fn__getReplayStatMissionType = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getReplayStatMissionType");
				var result = fn__getReplayStatMissionType();
				return result;
			}
		}

		public int GetReplayStatCount()
		{
			unsafe {
				if (fn__getReplayStatCount == null) fn__getReplayStatCount = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getReplayStatCount");
				var result = fn__getReplayStatCount();
				return result;
			}
		}

		public int GetReplayStatAtIndex(int _index)
		{
			unsafe {
				if (fn__getReplayStatAtIndex == null) fn__getReplayStatAtIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getReplayStatAtIndex");
				var result = fn__getReplayStatAtIndex(_index);
				return result;
			}
		}

		public void ClearReplayStats()
		{
			unsafe {
				if (fn__clearReplayStats == null) fn__clearReplayStats = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearReplayStats");
				fn__clearReplayStats();
			}
		}

		public bool QueueMissionRepeatLoad()
		{
			unsafe {
				if (fn__queueMissionRepeatLoad == null) fn__queueMissionRepeatLoad = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_queueMissionRepeatLoad");
				var result = fn__queueMissionRepeatLoad();
				return result;
			}
		}

		public bool QueueMissionRepeatSave()
		{
			unsafe {
				if (fn__queueMissionRepeatSave == null) fn__queueMissionRepeatSave = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_queueMissionRepeatSave");
				var result = fn__queueMissionRepeatSave();
				return result;
			}
		}

		public int _0xEB2104E905C6F2E9()
		{
			unsafe {
				if (fn__0xEB2104E905C6F2E9 == null) fn__0xEB2104E905C6F2E9 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xEB2104E905C6F2E9");
				var result = fn__0xEB2104E905C6F2E9();
				return result;
			}
		}

		public int GetStatusOfMissionRepeatSave()
		{
			unsafe {
				if (fn__getStatusOfMissionRepeatSave == null) fn__getStatusOfMissionRepeatSave = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getStatusOfMissionRepeatSave");
				var result = fn__getStatusOfMissionRepeatSave();
				return result;
			}
		}

		public bool IsMemoryCardInUse()
		{
			unsafe {
				if (fn__isMemoryCardInUse == null) fn__isMemoryCardInUse = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMemoryCardInUse");
				var result = fn__isMemoryCardInUse();
				return result;
			}
		}

		public void ShootSingleBulletBetweenCoords(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _damage, bool _p7, int _weaponHash, int _ownerPed, bool _isAudible, bool _isInvisible, float _speed)
		{
			unsafe {
				if (fn__shootSingleBulletBetweenCoords == null) fn__shootSingleBulletBetweenCoords = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, int, int, bool, bool, float, void>) NativeLibrary.GetExport(handle, "Native_shootSingleBulletBetweenCoords");
				fn__shootSingleBulletBetweenCoords(_x1, _y1, _z1, _x2, _y2, _z2, _damage, _p7, _weaponHash, _ownerPed, _isAudible, _isInvisible, _speed);
			}
		}

		public void ShootSingleBulletBetweenCoordsIgnoreEntity(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _damage, bool _p7, int _weaponHash, int _ownerPed, bool _isAudible, bool _isInvisible, float _speed, int _entity, int _p14)
		{
			unsafe {
				if (fn__shootSingleBulletBetweenCoordsIgnoreEntity == null) fn__shootSingleBulletBetweenCoordsIgnoreEntity = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, int, int, bool, bool, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_shootSingleBulletBetweenCoordsIgnoreEntity");
				fn__shootSingleBulletBetweenCoordsIgnoreEntity(_x1, _y1, _z1, _x2, _y2, _z2, _damage, _p7, _weaponHash, _ownerPed, _isAudible, _isInvisible, _speed, _entity, _p14);
			}
		}

		public void ShootSingleBulletBetweenCoordsIgnoreEntityNew(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _damage, bool _p7, int _weaponHash, int _ownerPed, bool _isAudible, bool _isInvisible, float _speed, int _entity, bool _p14, bool _p15, bool _p16, bool _p17, int _p18, int _p19, int _p20)
		{
			unsafe {
				if (fn__shootSingleBulletBetweenCoordsIgnoreEntityNew == null) fn__shootSingleBulletBetweenCoordsIgnoreEntityNew = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, int, int, bool, bool, float, int, bool, bool, bool, bool, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_shootSingleBulletBetweenCoordsIgnoreEntityNew");
				fn__shootSingleBulletBetweenCoordsIgnoreEntityNew(_x1, _y1, _z1, _x2, _y2, _z2, _damage, _p7, _weaponHash, _ownerPed, _isAudible, _isInvisible, _speed, _entity, _p14, _p15, _p16, _p17, _p18, _p19, _p20);
			}
		}

		public void GetModelDimensions(int _modelHash, ref Vector3 _minimum, ref Vector3 _maximum)
		{
			unsafe {
				if (fn__getModelDimensions == null) fn__getModelDimensions = (delegate* unmanaged[Cdecl]<int, Vector3*, Vector3*, void>) NativeLibrary.GetExport(handle, "Native_getModelDimensions");
				var ref_minimum = _minimum;
				var ref_maximum = _maximum;
				fn__getModelDimensions(_modelHash, &ref_minimum, &ref_maximum);
				_minimum = ref_minimum;
				_maximum = ref_maximum;
			}
		}

		public void SetFakeWantedLevel(int _fakeWantedLevel)
		{
			unsafe {
				if (fn__setFakeWantedLevel == null) fn__setFakeWantedLevel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setFakeWantedLevel");
				fn__setFakeWantedLevel(_fakeWantedLevel);
			}
		}

		public int GetFakeWantedLevel()
		{
			unsafe {
				if (fn__getFakeWantedLevel == null) fn__getFakeWantedLevel = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getFakeWantedLevel");
				var result = fn__getFakeWantedLevel();
				return result;
			}
		}

		public bool IsBitSet(int _address, int _offset)
		{
			unsafe {
				if (fn__isBitSet == null) fn__isBitSet = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isBitSet");
				var result = fn__isBitSet(_address, _offset);
				return result;
			}
		}

		public void UsingMissionCreator(bool _toggle)
		{
			unsafe {
				if (fn__usingMissionCreator == null) fn__usingMissionCreator = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_usingMissionCreator");
				fn__usingMissionCreator(_toggle);
			}
		}

		public void AllowMissionCreatorWarp(bool _toggle)
		{
			unsafe {
				if (fn__allowMissionCreatorWarp == null) fn__allowMissionCreatorWarp = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_allowMissionCreatorWarp");
				fn__allowMissionCreatorWarp(_toggle);
			}
		}

		public void SetMinigameInProgress(bool _toggle)
		{
			unsafe {
				if (fn__setMinigameInProgress == null) fn__setMinigameInProgress = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMinigameInProgress");
				fn__setMinigameInProgress(_toggle);
			}
		}

		public bool IsMinigameInProgress()
		{
			unsafe {
				if (fn__isMinigameInProgress == null) fn__isMinigameInProgress = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isMinigameInProgress");
				var result = fn__isMinigameInProgress();
				return result;
			}
		}

		public bool IsThisAMinigameScript()
		{
			unsafe {
				if (fn__isThisAMinigameScript == null) fn__isThisAMinigameScript = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isThisAMinigameScript");
				var result = fn__isThisAMinigameScript();
				return result;
			}
		}

		public bool IsSniperInverted()
		{
			unsafe {
				if (fn__isSniperInverted == null) fn__isSniperInverted = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isSniperInverted");
				var result = fn__isSniperInverted();
				return result;
			}
		}

		public bool ShouldUseMetricMeasurements()
		{
			unsafe {
				if (fn__shouldUseMetricMeasurements == null) fn__shouldUseMetricMeasurements = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_shouldUseMetricMeasurements");
				var result = fn__shouldUseMetricMeasurements();
				return result;
			}
		}

		public int GetProfileSetting(int _profileSetting)
		{
			unsafe {
				if (fn__getProfileSetting == null) fn__getProfileSetting = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getProfileSetting");
				var result = fn__getProfileSetting(_profileSetting);
				return result;
			}
		}

		public bool AreStringsEqual(string _string1, string _string2)
		{
			unsafe {
				if (fn__areStringsEqual == null) fn__areStringsEqual = (delegate* unmanaged[Cdecl]<nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_areStringsEqual");
				var ptr_string1 = MemoryUtils.StringToHGlobalUtf8(_string1);
				var ptr_string2 = MemoryUtils.StringToHGlobalUtf8(_string2);
				var result = fn__areStringsEqual(ptr_string1, ptr_string2);
				Marshal.FreeHGlobal(ptr_string1);
				Marshal.FreeHGlobal(ptr_string2);
				return result;
			}
		}

		public int CompareStrings(string _str1, string _str2, bool _matchCase, int _maxLength)
		{
			unsafe {
				if (fn__compareStrings == null) fn__compareStrings = (delegate* unmanaged[Cdecl]<nint, nint, bool, int, int>) NativeLibrary.GetExport(handle, "Native_compareStrings");
				var ptr_str1 = MemoryUtils.StringToHGlobalUtf8(_str1);
				var ptr_str2 = MemoryUtils.StringToHGlobalUtf8(_str2);
				var result = fn__compareStrings(ptr_str1, ptr_str2, _matchCase, _maxLength);
				Marshal.FreeHGlobal(ptr_str1);
				Marshal.FreeHGlobal(ptr_str2);
				return result;
			}
		}

		public int Absi(int _value)
		{
			unsafe {
				if (fn__absi == null) fn__absi = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_absi");
				var result = fn__absi(_value);
				return result;
			}
		}

		public float Absf(float _value)
		{
			unsafe {
				if (fn__absf == null) fn__absf = (delegate* unmanaged[Cdecl]<float, float>) NativeLibrary.GetExport(handle, "Native_absf");
				var result = fn__absf(_value);
				return result;
			}
		}

		public bool IsSniperBulletInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__isSniperBulletInArea == null) fn__isSniperBulletInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isSniperBulletInArea");
				var result = fn__isSniperBulletInArea(_x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public bool IsProjectileInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _ownedByPlayer)
		{
			unsafe {
				if (fn__isProjectileInArea == null) fn__isProjectileInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_isProjectileInArea");
				var result = fn__isProjectileInArea(_x1, _y1, _z1, _x2, _y2, _z2, _ownedByPlayer);
				return result;
			}
		}

		public bool IsProjectileTypeInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _type, bool _ownedByPlayer)
		{
			unsafe {
				if (fn__isProjectileTypeInArea == null) fn__isProjectileTypeInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isProjectileTypeInArea");
				var result = fn__isProjectileTypeInArea(_x1, _y1, _z1, _x2, _y2, _z2, _type, _ownedByPlayer);
				return result;
			}
		}

		public bool IsProjectileTypeInAngledArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width, int _p7, bool _ownedByPlayer)
		{
			unsafe {
				if (fn__isProjectileTypeInAngledArea == null) fn__isProjectileTypeInAngledArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isProjectileTypeInAngledArea");
				var result = fn__isProjectileTypeInAngledArea(_x1, _y1, _z1, _x2, _y2, _z2, _width, _p7, _ownedByPlayer);
				return result;
			}
		}

		public bool IsProjectileTypeWithinDistance(float _x, float _y, float _z, int _projectileHash, float _radius, bool _ownedByPlayer)
		{
			unsafe {
				if (fn__isProjectileTypeWithinDistance == null) fn__isProjectileTypeWithinDistance = (delegate* unmanaged[Cdecl]<float, float, float, int, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_isProjectileTypeWithinDistance");
				var result = fn__isProjectileTypeWithinDistance(_x, _y, _z, _projectileHash, _radius, _ownedByPlayer);
				return result;
			}
		}

		public bool GetCoordsOfProjectileTypeInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _projectileHash, ref Vector3 _projectilePos, bool _ownedByPlayer)
		{
			unsafe {
				if (fn__getCoordsOfProjectileTypeInArea == null) fn__getCoordsOfProjectileTypeInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, Vector3*, bool, bool>) NativeLibrary.GetExport(handle, "Native_getCoordsOfProjectileTypeInArea");
				var ref_projectilePos = _projectilePos;
				var result = fn__getCoordsOfProjectileTypeInArea(_x1, _y1, _z1, _x2, _y2, _z2, _projectileHash, &ref_projectilePos, _ownedByPlayer);
				_projectilePos = ref_projectilePos;
				return result;
			}
		}

		public bool GetCoordsOfProjectileTypeWithinDistance(int _ped, int _weaponHash, float _distance, ref Vector3 _outCoords, bool _p4)
		{
			unsafe {
				if (fn__getCoordsOfProjectileTypeWithinDistance == null) fn__getCoordsOfProjectileTypeWithinDistance = (delegate* unmanaged[Cdecl]<int, int, float, Vector3*, bool, bool>) NativeLibrary.GetExport(handle, "Native_getCoordsOfProjectileTypeWithinDistance");
				var ref_outCoords = _outCoords;
				var result = fn__getCoordsOfProjectileTypeWithinDistance(_ped, _weaponHash, _distance, &ref_outCoords, _p4);
				_outCoords = ref_outCoords;
				return result;
			}
		}

		public bool GetProjectileNearPed(int _ped, int _weaponHash, float _distance, ref Vector3 _outCoords, ref int _outProjectile, bool _p5)
		{
			unsafe {
				if (fn__getProjectileNearPed == null) fn__getProjectileNearPed = (delegate* unmanaged[Cdecl]<int, int, float, Vector3*, int*, bool, bool>) NativeLibrary.GetExport(handle, "Native_getProjectileNearPed");
				var ref_outCoords = _outCoords;
				var ref_outProjectile = _outProjectile;
				var result = fn__getProjectileNearPed(_ped, _weaponHash, _distance, &ref_outCoords, &ref_outProjectile, _p5);
				_outCoords = ref_outCoords;
				_outProjectile = ref_outProjectile;
				return result;
			}
		}

		public bool IsBulletInAngledArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width, bool _ownedByPlayer)
		{
			unsafe {
				if (fn__isBulletInAngledArea == null) fn__isBulletInAngledArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_isBulletInAngledArea");
				var result = fn__isBulletInAngledArea(_x1, _y1, _z1, _x2, _y2, _z2, _width, _ownedByPlayer);
				return result;
			}
		}

		public bool IsBulletInArea(float _x, float _y, float _z, float _radius, bool _ownedByPlayer)
		{
			unsafe {
				if (fn__isBulletInArea == null) fn__isBulletInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_isBulletInArea");
				var result = fn__isBulletInArea(_x, _y, _z, _radius, _ownedByPlayer);
				return result;
			}
		}

		public bool IsBulletInBox(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _ownedByPlayer)
		{
			unsafe {
				if (fn__isBulletInBox == null) fn__isBulletInBox = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_isBulletInBox");
				var result = fn__isBulletInBox(_x1, _y1, _z1, _x2, _y2, _z2, _ownedByPlayer);
				return result;
			}
		}

		public bool HasBulletImpactedInArea(float _x, float _y, float _z, float _p3, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__hasBulletImpactedInArea == null) fn__hasBulletImpactedInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_hasBulletImpactedInArea");
				var result = fn__hasBulletImpactedInArea(_x, _y, _z, _p3, _p4, _p5);
				return result;
			}
		}

		public bool HasBulletImpactedInBox(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, bool _p6, bool _p7)
		{
			unsafe {
				if (fn__hasBulletImpactedInBox == null) fn__hasBulletImpactedInBox = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_hasBulletImpactedInBox");
				var result = fn__hasBulletImpactedInBox(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
				return result;
			}
		}

		public bool IsOrbisVersion()
		{
			unsafe {
				if (fn__isOrbisVersion == null) fn__isOrbisVersion = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isOrbisVersion");
				var result = fn__isOrbisVersion();
				return result;
			}
		}

		public bool IsDurangoVersion()
		{
			unsafe {
				if (fn__isDurangoVersion == null) fn__isDurangoVersion = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isDurangoVersion");
				var result = fn__isDurangoVersion();
				return result;
			}
		}

		public bool IsXbox360Version()
		{
			unsafe {
				if (fn__isXbox360Version == null) fn__isXbox360Version = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isXbox360Version");
				var result = fn__isXbox360Version();
				return result;
			}
		}

		public bool IsPs3Version()
		{
			unsafe {
				if (fn__isPs3Version == null) fn__isPs3Version = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPs3Version");
				var result = fn__isPs3Version();
				return result;
			}
		}

		public bool IsPcVersion()
		{
			unsafe {
				if (fn__isPcVersion == null) fn__isPcVersion = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPcVersion");
				var result = fn__isPcVersion();
				return result;
			}
		}

		public bool IsAussieVersion()
		{
			unsafe {
				if (fn__isAussieVersion == null) fn__isAussieVersion = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isAussieVersion");
				var result = fn__isAussieVersion();
				return result;
			}
		}

		public bool IsStringNull(string _string)
		{
			unsafe {
				if (fn__isStringNull == null) fn__isStringNull = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isStringNull");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				var result = fn__isStringNull(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
				return result;
			}
		}

		public bool IsStringNullOrEmpty(string _string)
		{
			unsafe {
				if (fn__isStringNullOrEmpty == null) fn__isStringNullOrEmpty = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isStringNullOrEmpty");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				var result = fn__isStringNullOrEmpty(ptr_string);
				Marshal.FreeHGlobal(ptr_string);
				return result;
			}
		}

		public bool StringToInt(string _string, ref int _outInteger)
		{
			unsafe {
				if (fn__stringToInt == null) fn__stringToInt = (delegate* unmanaged[Cdecl]<nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_stringToInt");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				var ref_outInteger = _outInteger;
				var result = fn__stringToInt(ptr_string, &ref_outInteger);
				Marshal.FreeHGlobal(ptr_string);
				_outInteger = ref_outInteger;
				return result;
			}
		}

		public void SetBitsInRange(ref int _unkVar, int _rangeStart, int _rangeEnd, int _p3)
		{
			unsafe {
				if (fn__setBitsInRange == null) fn__setBitsInRange = (delegate* unmanaged[Cdecl]<int*, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setBitsInRange");
				var ref_unkVar = _unkVar;
				fn__setBitsInRange(&ref_unkVar, _rangeStart, _rangeEnd, _p3);
				_unkVar = ref_unkVar;
			}
		}

		public int GetBitsInRange(int _unkVar, int _rangeStart, int _rangeEnd)
		{
			unsafe {
				if (fn__getBitsInRange == null) fn__getBitsInRange = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getBitsInRange");
				var result = fn__getBitsInRange(_unkVar, _rangeStart, _rangeEnd);
				return result;
			}
		}

		public int AddStuntJump(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _x3, float _y3, float _z3, float _x4, float _y4, float _z4, float _camX, float _camY, float _camZ, int _p15, int _p16, int _p17)
		{
			unsafe {
				if (fn__addStuntJump == null) fn__addStuntJump = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_addStuntJump");
				var result = fn__addStuntJump(_x1, _y1, _z1, _x2, _y2, _z2, _x3, _y3, _z3, _x4, _y4, _z4, _camX, _camY, _camZ, _p15, _p16, _p17);
				return result;
			}
		}

		public int AddStuntJumpAngled(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _radius1, float _x3, float _y3, float _z3, float _x4, float _y4, float _z4, float _radius2, float _camX, float _camY, float _camZ, int _p17, int _p18, int _p19)
		{
			unsafe {
				if (fn__addStuntJumpAngled == null) fn__addStuntJumpAngled = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_addStuntJumpAngled");
				var result = fn__addStuntJumpAngled(_x1, _y1, _z1, _x2, _y2, _z2, _radius1, _x3, _y3, _z3, _x4, _y4, _z4, _radius2, _camX, _camY, _camZ, _p17, _p18, _p19);
				return result;
			}
		}

		public void _0xFB80AB299D2EE1BD(bool _toggle)
		{
			unsafe {
				if (fn__0xFB80AB299D2EE1BD == null) fn__0xFB80AB299D2EE1BD = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xFB80AB299D2EE1BD");
				fn__0xFB80AB299D2EE1BD(_toggle);
			}
		}

		public void DeleteStuntJump(int _p0)
		{
			unsafe {
				if (fn__deleteStuntJump == null) fn__deleteStuntJump = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_deleteStuntJump");
				fn__deleteStuntJump(_p0);
			}
		}

		public void EnableStuntJumpSet(int _p0)
		{
			unsafe {
				if (fn__enableStuntJumpSet == null) fn__enableStuntJumpSet = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_enableStuntJumpSet");
				fn__enableStuntJumpSet(_p0);
			}
		}

		public void DisableStuntJumpSet(int _p0)
		{
			unsafe {
				if (fn__disableStuntJumpSet == null) fn__disableStuntJumpSet = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableStuntJumpSet");
				fn__disableStuntJumpSet(_p0);
			}
		}

		public void SetStuntJumpsCanTrigger(bool _toggle)
		{
			unsafe {
				if (fn__setStuntJumpsCanTrigger == null) fn__setStuntJumpsCanTrigger = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setStuntJumpsCanTrigger");
				fn__setStuntJumpsCanTrigger(_toggle);
			}
		}

		public bool IsStuntJumpInProgress()
		{
			unsafe {
				if (fn__isStuntJumpInProgress == null) fn__isStuntJumpInProgress = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isStuntJumpInProgress");
				var result = fn__isStuntJumpInProgress();
				return result;
			}
		}

		public bool IsStuntJumpMessageShowing()
		{
			unsafe {
				if (fn__isStuntJumpMessageShowing == null) fn__isStuntJumpMessageShowing = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isStuntJumpMessageShowing");
				var result = fn__isStuntJumpMessageShowing();
				return result;
			}
		}

		public int GetNumSuccessfulStuntJumps()
		{
			unsafe {
				if (fn__getNumSuccessfulStuntJumps == null) fn__getNumSuccessfulStuntJumps = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumSuccessfulStuntJumps");
				var result = fn__getNumSuccessfulStuntJumps();
				return result;
			}
		}

		public int GetTotalSuccessfulStuntJumps()
		{
			unsafe {
				if (fn__getTotalSuccessfulStuntJumps == null) fn__getTotalSuccessfulStuntJumps = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getTotalSuccessfulStuntJumps");
				var result = fn__getTotalSuccessfulStuntJumps();
				return result;
			}
		}

		public void CancelStuntJump()
		{
			unsafe {
				if (fn__cancelStuntJump == null) fn__cancelStuntJump = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_cancelStuntJump");
				fn__cancelStuntJump();
			}
		}

		public void SetGamePaused(bool _toggle)
		{
			unsafe {
				if (fn__setGamePaused == null) fn__setGamePaused = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setGamePaused");
				fn__setGamePaused(_toggle);
			}
		}

		public void SetThisScriptCanBePaused(bool _toggle)
		{
			unsafe {
				if (fn__setThisScriptCanBePaused == null) fn__setThisScriptCanBePaused = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setThisScriptCanBePaused");
				fn__setThisScriptCanBePaused(_toggle);
			}
		}

		public void SetThisScriptCanRemoveBlipsCreatedByAnyScript(bool _toggle)
		{
			unsafe {
				if (fn__setThisScriptCanRemoveBlipsCreatedByAnyScript == null) fn__setThisScriptCanRemoveBlipsCreatedByAnyScript = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setThisScriptCanRemoveBlipsCreatedByAnyScript");
				fn__setThisScriptCanRemoveBlipsCreatedByAnyScript(_toggle);
			}
		}

		public bool HasButtonCombinationJustBeenEntered(int _hash, int _amount)
		{
			unsafe {
				if (fn__hasButtonCombinationJustBeenEntered == null) fn__hasButtonCombinationJustBeenEntered = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasButtonCombinationJustBeenEntered");
				var result = fn__hasButtonCombinationJustBeenEntered(_hash, _amount);
				return result;
			}
		}

		public bool HasCheatStringJustBeenEntered(int _hash)
		{
			unsafe {
				if (fn__hasCheatStringJustBeenEntered == null) fn__hasCheatStringJustBeenEntered = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasCheatStringJustBeenEntered");
				var result = fn__hasCheatStringJustBeenEntered(_hash);
				return result;
			}
		}

		public void _0xFA3FFB0EEBC288A3(bool _p0)
		{
			unsafe {
				if (fn__0xFA3FFB0EEBC288A3 == null) fn__0xFA3FFB0EEBC288A3 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xFA3FFB0EEBC288A3");
				fn__0xFA3FFB0EEBC288A3(_p0);
			}
		}

		public void SetInstancePriorityMode(int _p0)
		{
			unsafe {
				if (fn__setInstancePriorityMode == null) fn__setInstancePriorityMode = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setInstancePriorityMode");
				fn__setInstancePriorityMode(_p0);
			}
		}

		public void SetInstancePriorityHint(int _flag)
		{
			unsafe {
				if (fn__setInstancePriorityHint == null) fn__setInstancePriorityHint = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setInstancePriorityHint");
				fn__setInstancePriorityHint(_flag);
			}
		}

		public bool IsFrontendFading()
		{
			unsafe {
				if (fn__isFrontendFading == null) fn__isFrontendFading = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isFrontendFading");
				var result = fn__isFrontendFading();
				return result;
			}
		}

		public void PopulateNow()
		{
			unsafe {
				if (fn__populateNow == null) fn__populateNow = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_populateNow");
				fn__populateNow();
			}
		}

		public int GetIndexOfCurrentLevel()
		{
			unsafe {
				if (fn__getIndexOfCurrentLevel == null) fn__getIndexOfCurrentLevel = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getIndexOfCurrentLevel");
				var result = fn__getIndexOfCurrentLevel();
				return result;
			}
		}

		public void SetGravityLevel(int _level)
		{
			unsafe {
				if (fn__setGravityLevel == null) fn__setGravityLevel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setGravityLevel");
				fn__setGravityLevel(_level);
			}
		}

		public void StartSaveData(ref int _p0, int _p1, bool _p2)
		{
			unsafe {
				if (fn__startSaveData == null) fn__startSaveData = (delegate* unmanaged[Cdecl]<int*, int, bool, void>) NativeLibrary.GetExport(handle, "Native_startSaveData");
				var ref_p0 = _p0;
				fn__startSaveData(&ref_p0, _p1, _p2);
				_p0 = ref_p0;
			}
		}

		public void StopSaveData()
		{
			unsafe {
				if (fn__stopSaveData == null) fn__stopSaveData = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopSaveData");
				fn__stopSaveData();
			}
		}

		public int GetSizeOfSaveData(bool _p0)
		{
			unsafe {
				if (fn__getSizeOfSaveData == null) fn__getSizeOfSaveData = (delegate* unmanaged[Cdecl]<bool, int>) NativeLibrary.GetExport(handle, "Native_getSizeOfSaveData");
				var result = fn__getSizeOfSaveData(_p0);
				return result;
			}
		}

		public void RegisterIntToSave(ref int _p0, string _name)
		{
			unsafe {
				if (fn__registerIntToSave == null) fn__registerIntToSave = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native_registerIntToSave");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__registerIntToSave(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void RegisterInt64ToSave(ref int _p0, string _name)
		{
			unsafe {
				if (fn__registerInt64ToSave == null) fn__registerInt64ToSave = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native_registerInt64ToSave");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__registerInt64ToSave(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void RegisterEnumToSave(ref int _p0, string _name)
		{
			unsafe {
				if (fn__registerEnumToSave == null) fn__registerEnumToSave = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native_registerEnumToSave");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__registerEnumToSave(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void RegisterFloatToSave(ref int _p0, string _name)
		{
			unsafe {
				if (fn__registerFloatToSave == null) fn__registerFloatToSave = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native_registerFloatToSave");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__registerFloatToSave(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void RegisterBoolToSave(ref int _p0, string _name)
		{
			unsafe {
				if (fn__registerBoolToSave == null) fn__registerBoolToSave = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native_registerBoolToSave");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__registerBoolToSave(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void RegisterTextLabelToSave(ref int _p0, string _name)
		{
			unsafe {
				if (fn__registerTextLabelToSave == null) fn__registerTextLabelToSave = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native_registerTextLabelToSave");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__registerTextLabelToSave(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void RegisterTextLabelToSave2(ref int _p0, string _name)
		{
			unsafe {
				if (fn__registerTextLabelToSave2 == null) fn__registerTextLabelToSave2 = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native_registerTextLabelToSave2");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__registerTextLabelToSave2(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void _0x48F069265A0E4BEC(ref int _p0, string _name)
		{
			unsafe {
				if (fn__0x48F069265A0E4BEC == null) fn__0x48F069265A0E4BEC = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native__0x48F069265A0E4BEC");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__0x48F069265A0E4BEC(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void _0x8269816F6CFD40F8(ref int _p0, string _name)
		{
			unsafe {
				if (fn__0x8269816F6CFD40F8 == null) fn__0x8269816F6CFD40F8 = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native__0x8269816F6CFD40F8");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__0x8269816F6CFD40F8(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void _0xFAA457EF263E8763(ref int _p0, string _name)
		{
			unsafe {
				if (fn__0xFAA457EF263E8763 == null) fn__0xFAA457EF263E8763 = (delegate* unmanaged[Cdecl]<int*, nint, void>) NativeLibrary.GetExport(handle, "Native__0xFAA457EF263E8763");
				var ref_p0 = _p0;
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__0xFAA457EF263E8763(&ref_p0, ptr_name);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void StartSaveStructWithSize(ref int _p0, int _size, string _structName)
		{
			unsafe {
				if (fn__startSaveStructWithSize == null) fn__startSaveStructWithSize = (delegate* unmanaged[Cdecl]<int*, int, nint, void>) NativeLibrary.GetExport(handle, "Native_startSaveStructWithSize");
				var ref_p0 = _p0;
				var ptr_structName = MemoryUtils.StringToHGlobalUtf8(_structName);
				fn__startSaveStructWithSize(&ref_p0, _size, ptr_structName);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_structName);
			}
		}

		public void StopSaveStruct()
		{
			unsafe {
				if (fn__stopSaveStruct == null) fn__stopSaveStruct = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopSaveStruct");
				fn__stopSaveStruct();
			}
		}

		public void StartSaveArrayWithSize(ref int _p0, int _size, string _arrayName)
		{
			unsafe {
				if (fn__startSaveArrayWithSize == null) fn__startSaveArrayWithSize = (delegate* unmanaged[Cdecl]<int*, int, nint, void>) NativeLibrary.GetExport(handle, "Native_startSaveArrayWithSize");
				var ref_p0 = _p0;
				var ptr_arrayName = MemoryUtils.StringToHGlobalUtf8(_arrayName);
				fn__startSaveArrayWithSize(&ref_p0, _size, ptr_arrayName);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_arrayName);
			}
		}

		public void StopSaveArray()
		{
			unsafe {
				if (fn__stopSaveArray == null) fn__stopSaveArray = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopSaveArray");
				fn__stopSaveArray();
			}
		}

		public void CopyMemory(ref int _dst, ref int _src, int _size)
		{
			unsafe {
				if (fn__copyMemory == null) fn__copyMemory = (delegate* unmanaged[Cdecl]<int*, int*, int, void>) NativeLibrary.GetExport(handle, "Native_copyMemory");
				var ref_dst = _dst;
				var ref_src = _src;
				fn__copyMemory(&ref_dst, &ref_src, _size);
				_dst = ref_dst;
				_src = ref_src;
			}
		}

		public void EnableDispatchService(int _dispatchService, bool _toggle)
		{
			unsafe {
				if (fn__enableDispatchService == null) fn__enableDispatchService = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_enableDispatchService");
				fn__enableDispatchService(_dispatchService, _toggle);
			}
		}

		public void BlockDispatchServiceResourceCreation(int _dispatchService, bool _toggle)
		{
			unsafe {
				if (fn__blockDispatchServiceResourceCreation == null) fn__blockDispatchServiceResourceCreation = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_blockDispatchServiceResourceCreation");
				fn__blockDispatchServiceResourceCreation(_dispatchService, _toggle);
			}
		}

		public int GetNumDispatchedUnitsForPlayer(int _dispatchService)
		{
			unsafe {
				if (fn__getNumDispatchedUnitsForPlayer == null) fn__getNumDispatchedUnitsForPlayer = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumDispatchedUnitsForPlayer");
				var result = fn__getNumDispatchedUnitsForPlayer(_dispatchService);
				return result;
			}
		}

		public bool CreateIncident(int _dispatchService, float _x, float _y, float _z, int _numUnits, float _radius, ref int _outIncidentID, int _p7, int _p8)
		{
			unsafe {
				if (fn__createIncident == null) fn__createIncident = (delegate* unmanaged[Cdecl]<int, float, float, float, int, float, int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_createIncident");
				var ref_outIncidentID = _outIncidentID;
				var result = fn__createIncident(_dispatchService, _x, _y, _z, _numUnits, _radius, &ref_outIncidentID, _p7, _p8);
				_outIncidentID = ref_outIncidentID;
				return result;
			}
		}

		public bool CreateIncidentWithEntity(int _dispatchService, int _ped, int _numUnits, float _radius, ref int _outIncidentID, int _p5, int _p6)
		{
			unsafe {
				if (fn__createIncidentWithEntity == null) fn__createIncidentWithEntity = (delegate* unmanaged[Cdecl]<int, int, int, float, int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_createIncidentWithEntity");
				var ref_outIncidentID = _outIncidentID;
				var result = fn__createIncidentWithEntity(_dispatchService, _ped, _numUnits, _radius, &ref_outIncidentID, _p5, _p6);
				_outIncidentID = ref_outIncidentID;
				return result;
			}
		}

		public void DeleteIncident(int _incidentId)
		{
			unsafe {
				if (fn__deleteIncident == null) fn__deleteIncident = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_deleteIncident");
				fn__deleteIncident(_incidentId);
			}
		}

		public bool IsIncidentValid(int _incidentId)
		{
			unsafe {
				if (fn__isIncidentValid == null) fn__isIncidentValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isIncidentValid");
				var result = fn__isIncidentValid(_incidentId);
				return result;
			}
		}

		public void SetIncidentRequestedUnits(int _incidentId, int _dispatchService, int _numUnits)
		{
			unsafe {
				if (fn__setIncidentRequestedUnits == null) fn__setIncidentRequestedUnits = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setIncidentRequestedUnits");
				fn__setIncidentRequestedUnits(_incidentId, _dispatchService, _numUnits);
			}
		}

		public void SetIncidentUnk(int _incidentId, float _p1)
		{
			unsafe {
				if (fn__setIncidentUnk == null) fn__setIncidentUnk = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setIncidentUnk");
				fn__setIncidentUnk(_incidentId, _p1);
			}
		}

		public bool FindSpawnPointInDirection(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _distance, ref Vector3 _spawnPoint)
		{
			unsafe {
				if (fn__findSpawnPointInDirection == null) fn__findSpawnPointInDirection = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, Vector3*, bool>) NativeLibrary.GetExport(handle, "Native_findSpawnPointInDirection");
				var ref_spawnPoint = _spawnPoint;
				var result = fn__findSpawnPointInDirection(_x1, _y1, _z1, _x2, _y2, _z2, _distance, &ref_spawnPoint);
				_spawnPoint = ref_spawnPoint;
				return result;
			}
		}

		public int AddPopMultiplierArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _p6, float _p7, bool _p8, bool _p9)
		{
			unsafe {
				if (fn__addPopMultiplierArea == null) fn__addPopMultiplierArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_addPopMultiplierArea");
				var result = fn__addPopMultiplierArea(_x1, _y1, _z1, _x2, _y2, _z2, _p6, _p7, _p8, _p9);
				return result;
			}
		}

		public bool DoesPopMultiplierAreaExist(int _id)
		{
			unsafe {
				if (fn__doesPopMultiplierAreaExist == null) fn__doesPopMultiplierAreaExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesPopMultiplierAreaExist");
				var result = fn__doesPopMultiplierAreaExist(_id);
				return result;
			}
		}

		public void RemovePopMultiplierArea(int _id, bool _p1)
		{
			unsafe {
				if (fn__removePopMultiplierArea == null) fn__removePopMultiplierArea = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removePopMultiplierArea");
				fn__removePopMultiplierArea(_id, _p1);
			}
		}

		public bool IsPopMultiplierAreaUnk(int _id)
		{
			unsafe {
				if (fn__isPopMultiplierAreaUnk == null) fn__isPopMultiplierAreaUnk = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPopMultiplierAreaUnk");
				var result = fn__isPopMultiplierAreaUnk(_id);
				return result;
			}
		}

		public int AddPopMultiplierSphere(float _x, float _y, float _z, float _radius, float _pedMultiplier, float _vehicleMultiplier, bool _p6, bool _p7)
		{
			unsafe {
				if (fn__addPopMultiplierSphere == null) fn__addPopMultiplierSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_addPopMultiplierSphere");
				var result = fn__addPopMultiplierSphere(_x, _y, _z, _radius, _pedMultiplier, _vehicleMultiplier, _p6, _p7);
				return result;
			}
		}

		public bool DoesPopMultiplierSphereExist(int _id)
		{
			unsafe {
				if (fn__doesPopMultiplierSphereExist == null) fn__doesPopMultiplierSphereExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesPopMultiplierSphereExist");
				var result = fn__doesPopMultiplierSphereExist(_id);
				return result;
			}
		}

		public void RemovePopMultiplierSphere(int _id, bool _p1)
		{
			unsafe {
				if (fn__removePopMultiplierSphere == null) fn__removePopMultiplierSphere = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removePopMultiplierSphere");
				fn__removePopMultiplierSphere(_id, _p1);
			}
		}

		public void EnableTennisMode(int _ped, bool _toggle, bool _p2)
		{
			unsafe {
				if (fn__enableTennisMode == null) fn__enableTennisMode = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_enableTennisMode");
				fn__enableTennisMode(_ped, _toggle, _p2);
			}
		}

		public bool IsTennisMode(int _ped)
		{
			unsafe {
				if (fn__isTennisMode == null) fn__isTennisMode = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isTennisMode");
				var result = fn__isTennisMode(_ped);
				return result;
			}
		}

		public void PlayTennisSwingAnim(int _ped, string _animDict, string _animName, float _p3, float _p4, bool _p5)
		{
			unsafe {
				if (fn__playTennisSwingAnim == null) fn__playTennisSwingAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_playTennisSwingAnim");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				fn__playTennisSwingAnim(_ped, ptr_animDict, ptr_animName, _p3, _p4, _p5);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
			}
		}

		public bool GetTennisSwingAnimComplete(int _ped)
		{
			unsafe {
				if (fn__getTennisSwingAnimComplete == null) fn__getTennisSwingAnimComplete = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getTennisSwingAnimComplete");
				var result = fn__getTennisSwingAnimComplete(_ped);
				return result;
			}
		}

		public bool _0x19BFED045C647C49(int _ped)
		{
			unsafe {
				if (fn__0x19BFED045C647C49 == null) fn__0x19BFED045C647C49 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x19BFED045C647C49");
				var result = fn__0x19BFED045C647C49(_ped);
				return result;
			}
		}

		public bool _0xE95B0C7D5BA3B96B(int _ped)
		{
			unsafe {
				if (fn__0xE95B0C7D5BA3B96B == null) fn__0xE95B0C7D5BA3B96B = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xE95B0C7D5BA3B96B");
				var result = fn__0xE95B0C7D5BA3B96B(_ped);
				return result;
			}
		}

		public void PlayTennisDiveAnim(int _ped, int _p1, float _p2, float _p3, float _p4, bool _p5)
		{
			unsafe {
				if (fn__playTennisDiveAnim == null) fn__playTennisDiveAnim = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_playTennisDiveAnim");
				fn__playTennisDiveAnim(_ped, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void _0x54F157E0336A3822(int _ped, string _p1, float _p2)
		{
			unsafe {
				if (fn__0x54F157E0336A3822 == null) fn__0x54F157E0336A3822 = (delegate* unmanaged[Cdecl]<int, nint, float, void>) NativeLibrary.GetExport(handle, "Native__0x54F157E0336A3822");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__0x54F157E0336A3822(_ped, ptr_p1, _p2);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void ResetDispatchSpawnLocation()
		{
			unsafe {
				if (fn__resetDispatchSpawnLocation == null) fn__resetDispatchSpawnLocation = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetDispatchSpawnLocation");
				fn__resetDispatchSpawnLocation();
			}
		}

		public void SetDispatchSpawnLocation(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setDispatchSpawnLocation == null) fn__setDispatchSpawnLocation = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setDispatchSpawnLocation");
				fn__setDispatchSpawnLocation(_x, _y, _z);
			}
		}

		public void ResetDispatchIdealSpawnDistance()
		{
			unsafe {
				if (fn__resetDispatchIdealSpawnDistance == null) fn__resetDispatchIdealSpawnDistance = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetDispatchIdealSpawnDistance");
				fn__resetDispatchIdealSpawnDistance();
			}
		}

		public void SetDispatchIdealSpawnDistance(float _p0)
		{
			unsafe {
				if (fn__setDispatchIdealSpawnDistance == null) fn__setDispatchIdealSpawnDistance = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setDispatchIdealSpawnDistance");
				fn__setDispatchIdealSpawnDistance(_p0);
			}
		}

		public void ResetDispatchTimeBetweenSpawnAttempts(int _p0)
		{
			unsafe {
				if (fn__resetDispatchTimeBetweenSpawnAttempts == null) fn__resetDispatchTimeBetweenSpawnAttempts = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetDispatchTimeBetweenSpawnAttempts");
				fn__resetDispatchTimeBetweenSpawnAttempts(_p0);
			}
		}

		public void SetDispatchTimeBetweenSpawnAttempts(int _p0, float _p1)
		{
			unsafe {
				if (fn__setDispatchTimeBetweenSpawnAttempts == null) fn__setDispatchTimeBetweenSpawnAttempts = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setDispatchTimeBetweenSpawnAttempts");
				fn__setDispatchTimeBetweenSpawnAttempts(_p0, _p1);
			}
		}

		public void SetDispatchTimeBetweenSpawnAttemptsMultiplier(int _p0, float _p1)
		{
			unsafe {
				if (fn__setDispatchTimeBetweenSpawnAttemptsMultiplier == null) fn__setDispatchTimeBetweenSpawnAttemptsMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setDispatchTimeBetweenSpawnAttemptsMultiplier");
				fn__setDispatchTimeBetweenSpawnAttemptsMultiplier(_p0, _p1);
			}
		}

		public int AddDispatchSpawnBlockingAngledArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width)
		{
			unsafe {
				if (fn__addDispatchSpawnBlockingAngledArea == null) fn__addDispatchSpawnBlockingAngledArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_addDispatchSpawnBlockingAngledArea");
				var result = fn__addDispatchSpawnBlockingAngledArea(_x1, _y1, _z1, _x2, _y2, _z2, _width);
				return result;
			}
		}

		public int AddDispatchSpawnBlockingArea(float _x1, float _y1, float _x2, float _y2)
		{
			unsafe {
				if (fn__addDispatchSpawnBlockingArea == null) fn__addDispatchSpawnBlockingArea = (delegate* unmanaged[Cdecl]<float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_addDispatchSpawnBlockingArea");
				var result = fn__addDispatchSpawnBlockingArea(_x1, _y1, _x2, _y2);
				return result;
			}
		}

		public void RemoveDispatchSpawnBlockingArea(int _p0)
		{
			unsafe {
				if (fn__removeDispatchSpawnBlockingArea == null) fn__removeDispatchSpawnBlockingArea = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeDispatchSpawnBlockingArea");
				fn__removeDispatchSpawnBlockingArea(_p0);
			}
		}

		public void ResetDispatchSpawnBlockingAreas()
		{
			unsafe {
				if (fn__resetDispatchSpawnBlockingAreas == null) fn__resetDispatchSpawnBlockingAreas = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetDispatchSpawnBlockingAreas");
				fn__resetDispatchSpawnBlockingAreas();
			}
		}

		public void _0xD9F692D349249528()
		{
			unsafe {
				if (fn__0xD9F692D349249528 == null) fn__0xD9F692D349249528 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xD9F692D349249528");
				fn__0xD9F692D349249528();
			}
		}

		public void _0xE532EC1A63231B4F(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xE532EC1A63231B4F == null) fn__0xE532EC1A63231B4F = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xE532EC1A63231B4F");
				fn__0xE532EC1A63231B4F(_p0, _p1);
			}
		}

		public void AddTacticalAnalysisPoint(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__addTacticalAnalysisPoint == null) fn__addTacticalAnalysisPoint = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_addTacticalAnalysisPoint");
				fn__addTacticalAnalysisPoint(_x, _y, _z);
			}
		}

		public void ClearTacticalAnalysisPoints()
		{
			unsafe {
				if (fn__clearTacticalAnalysisPoints == null) fn__clearTacticalAnalysisPoints = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearTacticalAnalysisPoints");
				fn__clearTacticalAnalysisPoints();
			}
		}

		public void SetRiotModeEnabled(bool _toggle)
		{
			unsafe {
				if (fn__setRiotModeEnabled == null) fn__setRiotModeEnabled = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setRiotModeEnabled");
				fn__setRiotModeEnabled(_toggle);
			}
		}

		public void DisplayOnscreenKeyboardWithLongerInitialString(int _p0, string _windowTitle, ref int _p2, string _defaultText, string _defaultConcat1, string _defaultConcat2, string _defaultConcat3, string _defaultConcat4, string _defaultConcat5, string _defaultConcat6, string _defaultConcat7, int _maxInputLength)
		{
			unsafe {
				if (fn__displayOnscreenKeyboardWithLongerInitialString == null) fn__displayOnscreenKeyboardWithLongerInitialString = (delegate* unmanaged[Cdecl]<int, nint, int*, nint, nint, nint, nint, nint, nint, nint, nint, int, void>) NativeLibrary.GetExport(handle, "Native_displayOnscreenKeyboardWithLongerInitialString");
				var ptr_windowTitle = MemoryUtils.StringToHGlobalUtf8(_windowTitle);
				var ref_p2 = _p2;
				var ptr_defaultText = MemoryUtils.StringToHGlobalUtf8(_defaultText);
				var ptr_defaultConcat1 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat1);
				var ptr_defaultConcat2 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat2);
				var ptr_defaultConcat3 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat3);
				var ptr_defaultConcat4 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat4);
				var ptr_defaultConcat5 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat5);
				var ptr_defaultConcat6 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat6);
				var ptr_defaultConcat7 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat7);
				fn__displayOnscreenKeyboardWithLongerInitialString(_p0, ptr_windowTitle, &ref_p2, ptr_defaultText, ptr_defaultConcat1, ptr_defaultConcat2, ptr_defaultConcat3, ptr_defaultConcat4, ptr_defaultConcat5, ptr_defaultConcat6, ptr_defaultConcat7, _maxInputLength);
				Marshal.FreeHGlobal(ptr_windowTitle);
				_p2 = ref_p2;
				Marshal.FreeHGlobal(ptr_defaultText);
				Marshal.FreeHGlobal(ptr_defaultConcat1);
				Marshal.FreeHGlobal(ptr_defaultConcat2);
				Marshal.FreeHGlobal(ptr_defaultConcat3);
				Marshal.FreeHGlobal(ptr_defaultConcat4);
				Marshal.FreeHGlobal(ptr_defaultConcat5);
				Marshal.FreeHGlobal(ptr_defaultConcat6);
				Marshal.FreeHGlobal(ptr_defaultConcat7);
			}
		}

		public void DisplayOnscreenKeyboard(int _p0, string _windowTitle, string _p2, string _defaultText, string _defaultConcat1, string _defaultConcat2, string _defaultConcat3, int _maxInputLength)
		{
			unsafe {
				if (fn__displayOnscreenKeyboard == null) fn__displayOnscreenKeyboard = (delegate* unmanaged[Cdecl]<int, nint, nint, nint, nint, nint, nint, int, void>) NativeLibrary.GetExport(handle, "Native_displayOnscreenKeyboard");
				var ptr_windowTitle = MemoryUtils.StringToHGlobalUtf8(_windowTitle);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var ptr_defaultText = MemoryUtils.StringToHGlobalUtf8(_defaultText);
				var ptr_defaultConcat1 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat1);
				var ptr_defaultConcat2 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat2);
				var ptr_defaultConcat3 = MemoryUtils.StringToHGlobalUtf8(_defaultConcat3);
				fn__displayOnscreenKeyboard(_p0, ptr_windowTitle, ptr_p2, ptr_defaultText, ptr_defaultConcat1, ptr_defaultConcat2, ptr_defaultConcat3, _maxInputLength);
				Marshal.FreeHGlobal(ptr_windowTitle);
				Marshal.FreeHGlobal(ptr_p2);
				Marshal.FreeHGlobal(ptr_defaultText);
				Marshal.FreeHGlobal(ptr_defaultConcat1);
				Marshal.FreeHGlobal(ptr_defaultConcat2);
				Marshal.FreeHGlobal(ptr_defaultConcat3);
			}
		}

		public int UpdateOnscreenKeyboard()
		{
			unsafe {
				if (fn__updateOnscreenKeyboard == null) fn__updateOnscreenKeyboard = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_updateOnscreenKeyboard");
				var result = fn__updateOnscreenKeyboard();
				return result;
			}
		}

		public string GetOnscreenKeyboardResult()
		{
			unsafe {
				if (fn__getOnscreenKeyboardResult == null) fn__getOnscreenKeyboardResult = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_getOnscreenKeyboardResult");
				var result = fn__getOnscreenKeyboardResult();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void CancelOnscreenKeyboard()
		{
			unsafe {
				if (fn__cancelOnscreenKeyboard == null) fn__cancelOnscreenKeyboard = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_cancelOnscreenKeyboard");
				fn__cancelOnscreenKeyboard();
			}
		}

		public void NextOnscreenKeyboardResultWillDisplayUsingTheseFonts(int _p0)
		{
			unsafe {
				if (fn__nextOnscreenKeyboardResultWillDisplayUsingTheseFonts == null) fn__nextOnscreenKeyboardResultWillDisplayUsingTheseFonts = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_nextOnscreenKeyboardResultWillDisplayUsingTheseFonts");
				fn__nextOnscreenKeyboardResultWillDisplayUsingTheseFonts(_p0);
			}
		}

		public void RemoveStealthKill(int _hash, bool _p1)
		{
			unsafe {
				if (fn__removeStealthKill == null) fn__removeStealthKill = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removeStealthKill");
				fn__removeStealthKill(_hash, _p1);
			}
		}

		public void _0x1EAE0A6E978894A2(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0x1EAE0A6E978894A2 == null) fn__0x1EAE0A6E978894A2 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x1EAE0A6E978894A2");
				fn__0x1EAE0A6E978894A2(_p0, _p1);
			}
		}

		public void SetExplosiveAmmoThisFrame(int _player)
		{
			unsafe {
				if (fn__setExplosiveAmmoThisFrame == null) fn__setExplosiveAmmoThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setExplosiveAmmoThisFrame");
				fn__setExplosiveAmmoThisFrame(_player);
			}
		}

		public void SetFireAmmoThisFrame(int _player)
		{
			unsafe {
				if (fn__setFireAmmoThisFrame == null) fn__setFireAmmoThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setFireAmmoThisFrame");
				fn__setFireAmmoThisFrame(_player);
			}
		}

		public void SetExplosiveMeleeThisFrame(int _player)
		{
			unsafe {
				if (fn__setExplosiveMeleeThisFrame == null) fn__setExplosiveMeleeThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setExplosiveMeleeThisFrame");
				fn__setExplosiveMeleeThisFrame(_player);
			}
		}

		public void SetSuperJumpThisFrame(int _player)
		{
			unsafe {
				if (fn__setSuperJumpThisFrame == null) fn__setSuperJumpThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setSuperJumpThisFrame");
				fn__setSuperJumpThisFrame(_player);
			}
		}

		public void SetBeastModeActive(int _player)
		{
			unsafe {
				if (fn__setBeastModeActive == null) fn__setBeastModeActive = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setBeastModeActive");
				fn__setBeastModeActive(_player);
			}
		}

		public void SetForcePlayerToJump(int _player)
		{
			unsafe {
				if (fn__setForcePlayerToJump == null) fn__setForcePlayerToJump = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setForcePlayerToJump");
				fn__setForcePlayerToJump(_player);
			}
		}

		public bool _0x6FDDF453C0C756EC()
		{
			unsafe {
				if (fn__0x6FDDF453C0C756EC == null) fn__0x6FDDF453C0C756EC = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x6FDDF453C0C756EC");
				var result = fn__0x6FDDF453C0C756EC();
				return result;
			}
		}

		public void _0xFB00CA71DA386228()
		{
			unsafe {
				if (fn__0xFB00CA71DA386228 == null) fn__0xFB00CA71DA386228 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xFB00CA71DA386228");
				fn__0xFB00CA71DA386228();
			}
		}

		public bool AreProfileSettingsValid()
		{
			unsafe {
				if (fn__areProfileSettingsValid == null) fn__areProfileSettingsValid = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_areProfileSettingsValid");
				var result = fn__areProfileSettingsValid();
				return result;
			}
		}

		public void _0xE3D969D2785FFB5E()
		{
			unsafe {
				if (fn__0xE3D969D2785FFB5E == null) fn__0xE3D969D2785FFB5E = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xE3D969D2785FFB5E");
				fn__0xE3D969D2785FFB5E();
			}
		}

		public void ForceGameStatePlaying()
		{
			unsafe {
				if (fn__forceGameStatePlaying == null) fn__forceGameStatePlaying = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_forceGameStatePlaying");
				fn__forceGameStatePlaying();
			}
		}

		public void ScriptRaceInit(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__scriptRaceInit == null) fn__scriptRaceInit = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_scriptRaceInit");
				fn__scriptRaceInit(_p0, _p1, _p2, _p3);
			}
		}

		public void ScriptRaceShutdown()
		{
			unsafe {
				if (fn__scriptRaceShutdown == null) fn__scriptRaceShutdown = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_scriptRaceShutdown");
				fn__scriptRaceShutdown();
			}
		}

		public void _0x1BB299305C3E8C13(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x1BB299305C3E8C13 == null) fn__0x1BB299305C3E8C13 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1BB299305C3E8C13");
				fn__0x1BB299305C3E8C13(_p0, _p1, _p2, _p3);
			}
		}

		public bool ScriptRaceGetPlayerSplitTime(int _player, ref int _p1, ref int _p2)
		{
			unsafe {
				if (fn__scriptRaceGetPlayerSplitTime == null) fn__scriptRaceGetPlayerSplitTime = (delegate* unmanaged[Cdecl]<int, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_scriptRaceGetPlayerSplitTime");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var result = fn__scriptRaceGetPlayerSplitTime(_player, &ref_p1, &ref_p2);
				_p1 = ref_p1;
				_p2 = ref_p2;
				return result;
			}
		}

		public void StartBenchmarkRecording()
		{
			unsafe {
				if (fn__startBenchmarkRecording == null) fn__startBenchmarkRecording = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_startBenchmarkRecording");
				fn__startBenchmarkRecording();
			}
		}

		public void StopBenchmarkRecording()
		{
			unsafe {
				if (fn__stopBenchmarkRecording == null) fn__stopBenchmarkRecording = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopBenchmarkRecording");
				fn__stopBenchmarkRecording();
			}
		}

		public void ResetBenchmarkRecording()
		{
			unsafe {
				if (fn__resetBenchmarkRecording == null) fn__resetBenchmarkRecording = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetBenchmarkRecording");
				fn__resetBenchmarkRecording();
			}
		}

		public void SaveBenchmarkRecording()
		{
			unsafe {
				if (fn__saveBenchmarkRecording == null) fn__saveBenchmarkRecording = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_saveBenchmarkRecording");
				fn__saveBenchmarkRecording();
			}
		}

		public bool UiIsSingleplayerPauseMenuActive()
		{
			unsafe {
				if (fn__uiIsSingleplayerPauseMenuActive == null) fn__uiIsSingleplayerPauseMenuActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_uiIsSingleplayerPauseMenuActive");
				var result = fn__uiIsSingleplayerPauseMenuActive();
				return result;
			}
		}

		public bool LandingMenuIsActive()
		{
			unsafe {
				if (fn__landingMenuIsActive == null) fn__landingMenuIsActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_landingMenuIsActive");
				var result = fn__landingMenuIsActive();
				return result;
			}
		}

		public bool IsCommandLineBenchmarkValueSet()
		{
			unsafe {
				if (fn__isCommandLineBenchmarkValueSet == null) fn__isCommandLineBenchmarkValueSet = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isCommandLineBenchmarkValueSet");
				var result = fn__isCommandLineBenchmarkValueSet();
				return result;
			}
		}

		public int GetBenchmarkIterationsFromCommandLine()
		{
			unsafe {
				if (fn__getBenchmarkIterationsFromCommandLine == null) fn__getBenchmarkIterationsFromCommandLine = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getBenchmarkIterationsFromCommandLine");
				var result = fn__getBenchmarkIterationsFromCommandLine();
				return result;
			}
		}

		public int GetBenchmarkPassFromCommandLine()
		{
			unsafe {
				if (fn__getBenchmarkPassFromCommandLine == null) fn__getBenchmarkPassFromCommandLine = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getBenchmarkPassFromCommandLine");
				var result = fn__getBenchmarkPassFromCommandLine();
				return result;
			}
		}

		public void RestartGame()
		{
			unsafe {
				if (fn__restartGame == null) fn__restartGame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_restartGame");
				fn__restartGame();
			}
		}

		public void ForceSocialClubUpdate()
		{
			unsafe {
				if (fn__forceSocialClubUpdate == null) fn__forceSocialClubUpdate = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_forceSocialClubUpdate");
				fn__forceSocialClubUpdate();
			}
		}

		public bool HasAsyncInstallFinished()
		{
			unsafe {
				if (fn__hasAsyncInstallFinished == null) fn__hasAsyncInstallFinished = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasAsyncInstallFinished");
				var result = fn__hasAsyncInstallFinished();
				return result;
			}
		}

		public void CleanupAsyncInstall()
		{
			unsafe {
				if (fn__cleanupAsyncInstall == null) fn__cleanupAsyncInstall = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_cleanupAsyncInstall");
				fn__cleanupAsyncInstall();
			}
		}

		public bool IsInPowerSavingMode()
		{
			unsafe {
				if (fn__isInPowerSavingMode == null) fn__isInPowerSavingMode = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isInPowerSavingMode");
				var result = fn__isInPowerSavingMode();
				return result;
			}
		}

		public int GetPowerSavingModeDuration()
		{
			unsafe {
				if (fn__getPowerSavingModeDuration == null) fn__getPowerSavingModeDuration = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPowerSavingModeDuration");
				var result = fn__getPowerSavingModeDuration();
				return result;
			}
		}

		public void SetPlayerIsInAnimalForm(bool _toggle)
		{
			unsafe {
				if (fn__setPlayerIsInAnimalForm == null) fn__setPlayerIsInAnimalForm = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerIsInAnimalForm");
				fn__setPlayerIsInAnimalForm(_toggle);
			}
		}

		public bool GetIsPlayerInAnimalForm()
		{
			unsafe {
				if (fn__getIsPlayerInAnimalForm == null) fn__getIsPlayerInAnimalForm = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getIsPlayerInAnimalForm");
				var result = fn__getIsPlayerInAnimalForm();
				return result;
			}
		}

		public void SetPlayerRockstarEditorDisabled(bool _toggle)
		{
			unsafe {
				if (fn__setPlayerRockstarEditorDisabled == null) fn__setPlayerRockstarEditorDisabled = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerRockstarEditorDisabled");
				fn__setPlayerRockstarEditorDisabled(_toggle);
			}
		}

		public void _0x23227DF0B2115469()
		{
			unsafe {
				if (fn__0x23227DF0B2115469 == null) fn__0x23227DF0B2115469 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x23227DF0B2115469");
				fn__0x23227DF0B2115469();
			}
		}

		public int _0xD10282B6E3751BA0()
		{
			unsafe {
				if (fn__0xD10282B6E3751BA0 == null) fn__0xD10282B6E3751BA0 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xD10282B6E3751BA0");
				var result = fn__0xD10282B6E3751BA0();
				return result;
			}
		}

		public void _0x693478ACBD7F18E7()
		{
			unsafe {
				if (fn__0x693478ACBD7F18E7 == null) fn__0x693478ACBD7F18E7 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x693478ACBD7F18E7");
				fn__0x693478ACBD7F18E7();
			}
		}

		public void CreateMobilePhone(int _phoneType)
		{
			unsafe {
				if (fn__createMobilePhone == null) fn__createMobilePhone = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_createMobilePhone");
				fn__createMobilePhone(_phoneType);
			}
		}

		public void DestroyMobilePhone()
		{
			unsafe {
				if (fn__destroyMobilePhone == null) fn__destroyMobilePhone = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_destroyMobilePhone");
				fn__destroyMobilePhone();
			}
		}

		public void SetMobilePhoneScale(float _scale)
		{
			unsafe {
				if (fn__setMobilePhoneScale == null) fn__setMobilePhoneScale = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setMobilePhoneScale");
				fn__setMobilePhoneScale(_scale);
			}
		}

		public void SetMobilePhoneRotation(float _rotX, float _rotY, float _rotZ, int _p3)
		{
			unsafe {
				if (fn__setMobilePhoneRotation == null) fn__setMobilePhoneRotation = (delegate* unmanaged[Cdecl]<float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setMobilePhoneRotation");
				fn__setMobilePhoneRotation(_rotX, _rotY, _rotZ, _p3);
			}
		}

		public void GetMobilePhoneRotation(ref Vector3 _rotation, int _p1)
		{
			unsafe {
				if (fn__getMobilePhoneRotation == null) fn__getMobilePhoneRotation = (delegate* unmanaged[Cdecl]<Vector3*, int, void>) NativeLibrary.GetExport(handle, "Native_getMobilePhoneRotation");
				var ref_rotation = _rotation;
				fn__getMobilePhoneRotation(&ref_rotation, _p1);
				_rotation = ref_rotation;
			}
		}

		public void SetMobilePhonePosition(float _posX, float _posY, float _posZ)
		{
			unsafe {
				if (fn__setMobilePhonePosition == null) fn__setMobilePhonePosition = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setMobilePhonePosition");
				fn__setMobilePhonePosition(_posX, _posY, _posZ);
			}
		}

		public void GetMobilePhonePosition(ref Vector3 _position)
		{
			unsafe {
				if (fn__getMobilePhonePosition == null) fn__getMobilePhonePosition = (delegate* unmanaged[Cdecl]<Vector3*, void>) NativeLibrary.GetExport(handle, "Native_getMobilePhonePosition");
				var ref_position = _position;
				fn__getMobilePhonePosition(&ref_position);
				_position = ref_position;
			}
		}

		public void ScriptIsMovingMobilePhoneOffscreen(bool _toggle)
		{
			unsafe {
				if (fn__scriptIsMovingMobilePhoneOffscreen == null) fn__scriptIsMovingMobilePhoneOffscreen = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_scriptIsMovingMobilePhoneOffscreen");
				fn__scriptIsMovingMobilePhoneOffscreen(_toggle);
			}
		}

		public bool CanPhoneBeSeenOnScreen()
		{
			unsafe {
				if (fn__canPhoneBeSeenOnScreen == null) fn__canPhoneBeSeenOnScreen = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_canPhoneBeSeenOnScreen");
				var result = fn__canPhoneBeSeenOnScreen();
				return result;
			}
		}

		public void SetMobilePhoneUnk(bool _toggle)
		{
			unsafe {
				if (fn__setMobilePhoneUnk == null) fn__setMobilePhoneUnk = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setMobilePhoneUnk");
				fn__setMobilePhoneUnk(_toggle);
			}
		}

		public void CellCamMoveFinger(int _direction)
		{
			unsafe {
				if (fn__cellCamMoveFinger == null) fn__cellCamMoveFinger = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_cellCamMoveFinger");
				fn__cellCamMoveFinger(_direction);
			}
		}

		public void CellCamSetLean(bool _toggle)
		{
			unsafe {
				if (fn__cellCamSetLean == null) fn__cellCamSetLean = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_cellCamSetLean");
				fn__cellCamSetLean(_toggle);
			}
		}

		public void CellCamActivate(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__cellCamActivate == null) fn__cellCamActivate = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_cellCamActivate");
				fn__cellCamActivate(_p0, _p1);
			}
		}

		public void CellCamDisableThisFrame(bool _toggle)
		{
			unsafe {
				if (fn__cellCamDisableThisFrame == null) fn__cellCamDisableThisFrame = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_cellCamDisableThisFrame");
				fn__cellCamDisableThisFrame(_toggle);
			}
		}

		public void _0xA2CCBE62CD4C91A4(ref int _toggle)
		{
			unsafe {
				if (fn__0xA2CCBE62CD4C91A4 == null) fn__0xA2CCBE62CD4C91A4 = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native__0xA2CCBE62CD4C91A4");
				var ref_toggle = _toggle;
				fn__0xA2CCBE62CD4C91A4(&ref_toggle);
				_toggle = ref_toggle;
			}
		}

		public void _0x1B0B4AEED5B9B41C(float _p0)
		{
			unsafe {
				if (fn__0x1B0B4AEED5B9B41C == null) fn__0x1B0B4AEED5B9B41C = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x1B0B4AEED5B9B41C");
				fn__0x1B0B4AEED5B9B41C(_p0);
			}
		}

		public void _0x53F4892D18EC90A4(float _p0)
		{
			unsafe {
				if (fn__0x53F4892D18EC90A4 == null) fn__0x53F4892D18EC90A4 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x53F4892D18EC90A4");
				fn__0x53F4892D18EC90A4(_p0);
			}
		}

		public void _0x3117D84EFA60F77B(float _p0)
		{
			unsafe {
				if (fn__0x3117D84EFA60F77B == null) fn__0x3117D84EFA60F77B = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x3117D84EFA60F77B");
				fn__0x3117D84EFA60F77B(_p0);
			}
		}

		public void _0x15E69E2802C24B8D(float _p0)
		{
			unsafe {
				if (fn__0x15E69E2802C24B8D == null) fn__0x15E69E2802C24B8D = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x15E69E2802C24B8D");
				fn__0x15E69E2802C24B8D(_p0);
			}
		}

		public void _0xAC2890471901861C(float _p0)
		{
			unsafe {
				if (fn__0xAC2890471901861C == null) fn__0xAC2890471901861C = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0xAC2890471901861C");
				fn__0xAC2890471901861C(_p0);
			}
		}

		public void _0xD6ADE981781FCA09(float _p0)
		{
			unsafe {
				if (fn__0xD6ADE981781FCA09 == null) fn__0xD6ADE981781FCA09 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0xD6ADE981781FCA09");
				fn__0xD6ADE981781FCA09(_p0);
			}
		}

		public void _0xF1E22DC13F5EEBAD(float _p0)
		{
			unsafe {
				if (fn__0xF1E22DC13F5EEBAD == null) fn__0xF1E22DC13F5EEBAD = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0xF1E22DC13F5EEBAD");
				fn__0xF1E22DC13F5EEBAD(_p0);
			}
		}

		public void _0x466DA42C89865553(float _p0)
		{
			unsafe {
				if (fn__0x466DA42C89865553 == null) fn__0x466DA42C89865553 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x466DA42C89865553");
				fn__0x466DA42C89865553(_p0);
			}
		}

		public bool CellCamIsCharVisibleNoFaceCheck(int _entity)
		{
			unsafe {
				if (fn__cellCamIsCharVisibleNoFaceCheck == null) fn__cellCamIsCharVisibleNoFaceCheck = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_cellCamIsCharVisibleNoFaceCheck");
				var result = fn__cellCamIsCharVisibleNoFaceCheck(_entity);
				return result;
			}
		}

		public void GetMobilePhoneRenderId(ref int _renderId)
		{
			unsafe {
				if (fn__getMobilePhoneRenderId == null) fn__getMobilePhoneRenderId = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_getMobilePhoneRenderId");
				var ref_renderId = _renderId;
				fn__getMobilePhoneRenderId(&ref_renderId);
				_renderId = ref_renderId;
			}
		}

		public void NetworkInitializeCash(int _wallet, int _bank)
		{
			unsafe {
				if (fn__networkInitializeCash == null) fn__networkInitializeCash = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkInitializeCash");
				fn__networkInitializeCash(_wallet, _bank);
			}
		}

		public void NetworkDeleteCharacter(int _characterSlot, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkDeleteCharacter == null) fn__networkDeleteCharacter = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkDeleteCharacter");
				fn__networkDeleteCharacter(_characterSlot, _p1, _p2);
			}
		}

		public void NetworkManualDeleteCharacter(int _characterSlot)
		{
			unsafe {
				if (fn__networkManualDeleteCharacter == null) fn__networkManualDeleteCharacter = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkManualDeleteCharacter");
				fn__networkManualDeleteCharacter(_characterSlot);
			}
		}

		public bool NetworkGetIsHighEarner()
		{
			unsafe {
				if (fn__networkGetIsHighEarner == null) fn__networkGetIsHighEarner = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkGetIsHighEarner");
				var result = fn__networkGetIsHighEarner();
				return result;
			}
		}

		public void NetworkClearCharacterWallet(int _characterSlot)
		{
			unsafe {
				if (fn__networkClearCharacterWallet == null) fn__networkClearCharacterWallet = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkClearCharacterWallet");
				fn__networkClearCharacterWallet(_characterSlot);
			}
		}

		public void NetworkGivePlayerJobshareCash(int _amount, ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkGivePlayerJobshareCash == null) fn__networkGivePlayerJobshareCash = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_networkGivePlayerJobshareCash");
				var ref_gamerHandle = _gamerHandle;
				fn__networkGivePlayerJobshareCash(_amount, &ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public void NetworkReceivePlayerJobshareCash(int _value, ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkReceivePlayerJobshareCash == null) fn__networkReceivePlayerJobshareCash = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_networkReceivePlayerJobshareCash");
				var ref_gamerHandle = _gamerHandle;
				fn__networkReceivePlayerJobshareCash(_value, &ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public bool NetworkCanShareJobCash()
		{
			unsafe {
				if (fn__networkCanShareJobCash == null) fn__networkCanShareJobCash = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkCanShareJobCash");
				var result = fn__networkCanShareJobCash();
				return result;
			}
		}

		public void NetworkRefundCash(int _index, string _context, string _reason, bool _unk)
		{
			unsafe {
				if (fn__networkRefundCash == null) fn__networkRefundCash = (delegate* unmanaged[Cdecl]<int, nint, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_networkRefundCash");
				var ptr_context = MemoryUtils.StringToHGlobalUtf8(_context);
				var ptr_reason = MemoryUtils.StringToHGlobalUtf8(_reason);
				fn__networkRefundCash(_index, ptr_context, ptr_reason, _unk);
				Marshal.FreeHGlobal(ptr_context);
				Marshal.FreeHGlobal(ptr_reason);
			}
		}

		public void NetworkDeductCash(int _amount, string _p1, string _p2, bool _p3, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__networkDeductCash == null) fn__networkDeductCash = (delegate* unmanaged[Cdecl]<int, nint, nint, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkDeductCash");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				fn__networkDeductCash(_amount, ptr_p1, ptr_p2, _p3, _p4, _p5);
				Marshal.FreeHGlobal(ptr_p1);
				Marshal.FreeHGlobal(ptr_p2);
			}
		}

		public bool NetworkMoneyCanBet(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkMoneyCanBet == null) fn__networkMoneyCanBet = (delegate* unmanaged[Cdecl]<int, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkMoneyCanBet");
				var result = fn__networkMoneyCanBet(_amount, _p1, _p2);
				return result;
			}
		}

		public bool NetworkCanBet(int _amount)
		{
			unsafe {
				if (fn__networkCanBet == null) fn__networkCanBet = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkCanBet");
				var result = fn__networkCanBet(_amount);
				return result;
			}
		}

		public bool NetworkCasinoCanUseGamblingType(int _hash)
		{
			unsafe {
				if (fn__networkCasinoCanUseGamblingType == null) fn__networkCasinoCanUseGamblingType = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkCasinoCanUseGamblingType");
				var result = fn__networkCasinoCanUseGamblingType(_hash);
				return result;
			}
		}

		public bool NetworkCasinoCanPurchaseChipsWithPvc()
		{
			unsafe {
				if (fn__networkCasinoCanPurchaseChipsWithPvc == null) fn__networkCasinoCanPurchaseChipsWithPvc = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkCasinoCanPurchaseChipsWithPvc");
				var result = fn__networkCasinoCanPurchaseChipsWithPvc();
				return result;
			}
		}

		public bool NetworkCasinoCanGamble(int _p0)
		{
			unsafe {
				if (fn__networkCasinoCanGamble == null) fn__networkCasinoCanGamble = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkCasinoCanGamble");
				var result = fn__networkCasinoCanGamble(_p0);
				return result;
			}
		}

		public bool NetworkCasinoCanPurchaseChipsWithPvc2()
		{
			unsafe {
				if (fn__networkCasinoCanPurchaseChipsWithPvc2 == null) fn__networkCasinoCanPurchaseChipsWithPvc2 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkCasinoCanPurchaseChipsWithPvc2");
				var result = fn__networkCasinoCanPurchaseChipsWithPvc2();
				return result;
			}
		}

		public bool NetworkCasinoPurchaseChips(int _p0, int _p1)
		{
			unsafe {
				if (fn__networkCasinoPurchaseChips == null) fn__networkCasinoPurchaseChips = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkCasinoPurchaseChips");
				var result = fn__networkCasinoPurchaseChips(_p0, _p1);
				return result;
			}
		}

		public bool NetworkCasinoSellChips(int _p0, int _p1)
		{
			unsafe {
				if (fn__networkCasinoSellChips == null) fn__networkCasinoSellChips = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkCasinoSellChips");
				var result = fn__networkCasinoSellChips(_p0, _p1);
				return result;
			}
		}

		public void _0xCD0F5B5D932AE473()
		{
			unsafe {
				if (fn__0xCD0F5B5D932AE473 == null) fn__0xCD0F5B5D932AE473 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xCD0F5B5D932AE473");
				fn__0xCD0F5B5D932AE473();
			}
		}

		public bool CanPayGoon(int _p0, int _p1, int _amount, ref int _p3)
		{
			unsafe {
				if (fn__canPayGoon == null) fn__canPayGoon = (delegate* unmanaged[Cdecl]<int, int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_canPayGoon");
				var ref_p3 = _p3;
				var result = fn__canPayGoon(_p0, _p1, _amount, &ref_p3);
				_p3 = ref_p3;
				return result;
			}
		}

		public void NetworkEarnFromCashingOut(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromCashingOut == null) fn__networkEarnFromCashingOut = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCashingOut");
				fn__networkEarnFromCashingOut(_amount);
			}
		}

		public void NetworkEarnFromPickup(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromPickup == null) fn__networkEarnFromPickup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromPickup");
				fn__networkEarnFromPickup(_amount);
			}
		}

		public void NetworkEarnFromGangPickup(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromGangPickup == null) fn__networkEarnFromGangPickup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromGangPickup");
				fn__networkEarnFromGangPickup(_amount);
			}
		}

		public void NetworkEarnFromAssassinateTargetKilled(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromAssassinateTargetKilled == null) fn__networkEarnFromAssassinateTargetKilled = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromAssassinateTargetKilled");
				fn__networkEarnFromAssassinateTargetKilled(_amount);
			}
		}

		public void NetworkEarnFromArmourTruck(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromArmourTruck == null) fn__networkEarnFromArmourTruck = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromArmourTruck");
				fn__networkEarnFromArmourTruck(_amount);
			}
		}

		public void NetworkEarnFromCrateDrop(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromCrateDrop == null) fn__networkEarnFromCrateDrop = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCrateDrop");
				fn__networkEarnFromCrateDrop(_amount);
			}
		}

		public void NetworkEarnFromBetting(int _amount, string _p1)
		{
			unsafe {
				if (fn__networkEarnFromBetting == null) fn__networkEarnFromBetting = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromBetting");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__networkEarnFromBetting(_amount, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void NetworkEarnFromJob(int _amount, string _p1)
		{
			unsafe {
				if (fn__networkEarnFromJob == null) fn__networkEarnFromJob = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromJob");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__networkEarnFromJob(_amount, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void NetworkEarnFromJobX2(int _amount, string _p1)
		{
			unsafe {
				if (fn__networkEarnFromJobX2 == null) fn__networkEarnFromJobX2 = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromJobX2");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__networkEarnFromJobX2(_amount, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void NetworkEarnFromPremiumJob(int _amount, string _p1)
		{
			unsafe {
				if (fn__networkEarnFromPremiumJob == null) fn__networkEarnFromPremiumJob = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromPremiumJob");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__networkEarnFromPremiumJob(_amount, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void NetworkEarnFromBendJob(int _amount, string _heistHash)
		{
			unsafe {
				if (fn__networkEarnFromBendJob == null) fn__networkEarnFromBendJob = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromBendJob");
				var ptr_heistHash = MemoryUtils.StringToHGlobalUtf8(_heistHash);
				fn__networkEarnFromBendJob(_amount, ptr_heistHash);
				Marshal.FreeHGlobal(ptr_heistHash);
			}
		}

		public void NetworkEarnFromChallengeWin(int _p0, ref int _p1, bool _p2)
		{
			unsafe {
				if (fn__networkEarnFromChallengeWin == null) fn__networkEarnFromChallengeWin = (delegate* unmanaged[Cdecl]<int, int*, bool, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromChallengeWin");
				var ref_p1 = _p1;
				fn__networkEarnFromChallengeWin(_p0, &ref_p1, _p2);
				_p1 = ref_p1;
			}
		}

		public void NetworkEarnFromBounty(int _amount, ref int _gamerHandle, ref int _p2, int _p3)
		{
			unsafe {
				if (fn__networkEarnFromBounty == null) fn__networkEarnFromBounty = (delegate* unmanaged[Cdecl]<int, int*, int*, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromBounty");
				var ref_gamerHandle = _gamerHandle;
				var ref_p2 = _p2;
				fn__networkEarnFromBounty(_amount, &ref_gamerHandle, &ref_p2, _p3);
				_gamerHandle = ref_gamerHandle;
				_p2 = ref_p2;
			}
		}

		public void NetworkEarnFromImportExport(int _amount, int _modelHash)
		{
			unsafe {
				if (fn__networkEarnFromImportExport == null) fn__networkEarnFromImportExport = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromImportExport");
				fn__networkEarnFromImportExport(_amount, _modelHash);
			}
		}

		public void NetworkEarnFromHoldups(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromHoldups == null) fn__networkEarnFromHoldups = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromHoldups");
				fn__networkEarnFromHoldups(_amount);
			}
		}

		public void NetworkEarnFromProperty(int _amount, int _propertyName)
		{
			unsafe {
				if (fn__networkEarnFromProperty == null) fn__networkEarnFromProperty = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromProperty");
				fn__networkEarnFromProperty(_amount, _propertyName);
			}
		}

		public void NetworkEarnFromAiTargetKill(int _p0, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromAiTargetKill == null) fn__networkEarnFromAiTargetKill = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromAiTargetKill");
				fn__networkEarnFromAiTargetKill(_p0, _p1);
			}
		}

		public void NetworkEarnFromNotBadsport(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromNotBadsport == null) fn__networkEarnFromNotBadsport = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromNotBadsport");
				fn__networkEarnFromNotBadsport(_amount);
			}
		}

		public void NetworkEarnFromRockstar(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromRockstar == null) fn__networkEarnFromRockstar = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromRockstar");
				fn__networkEarnFromRockstar(_amount);
			}
		}

		public void NetworkEarnFromVehicle(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7)
		{
			unsafe {
				if (fn__networkEarnFromVehicle == null) fn__networkEarnFromVehicle = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromVehicle");
				fn__networkEarnFromVehicle(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
			}
		}

		public void NetworkEarnFromPersonalVehicle(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8)
		{
			unsafe {
				if (fn__networkEarnFromPersonalVehicle == null) fn__networkEarnFromPersonalVehicle = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromPersonalVehicle");
				fn__networkEarnFromPersonalVehicle(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
			}
		}

		public void NetworkEarnFromDailyObjectives(int _p0, string _p1, int _p2)
		{
			unsafe {
				if (fn__networkEarnFromDailyObjectives == null) fn__networkEarnFromDailyObjectives = (delegate* unmanaged[Cdecl]<int, nint, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromDailyObjectives");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__networkEarnFromDailyObjectives(_p0, ptr_p1, _p2);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void NetworkEarnFromAmbientJob(int _p0, string _p1, ref int _p2)
		{
			unsafe {
				if (fn__networkEarnFromAmbientJob == null) fn__networkEarnFromAmbientJob = (delegate* unmanaged[Cdecl]<int, nint, int*, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromAmbientJob");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ref_p2 = _p2;
				fn__networkEarnFromAmbientJob(_p0, ptr_p1, &ref_p2);
				Marshal.FreeHGlobal(ptr_p1);
				_p2 = ref_p2;
			}
		}

		public void NetworkEarnFromJobBonus(int _p0, ref int _p1, ref int _p2)
		{
			unsafe {
				if (fn__networkEarnFromJobBonus == null) fn__networkEarnFromJobBonus = (delegate* unmanaged[Cdecl]<int, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromJobBonus");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				fn__networkEarnFromJobBonus(_p0, &ref_p1, &ref_p2);
				_p1 = ref_p1;
				_p2 = ref_p2;
			}
		}

		public void NetworkEarnJobBonusHeistAward(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkEarnJobBonusHeistAward == null) fn__networkEarnJobBonusHeistAward = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnJobBonusHeistAward");
				fn__networkEarnJobBonusHeistAward(_p0, _p1, _p2);
			}
		}

		public void NetworkEarnJobBonusFirstTimeBonus(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkEarnJobBonusFirstTimeBonus == null) fn__networkEarnJobBonusFirstTimeBonus = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnJobBonusFirstTimeBonus");
				fn__networkEarnJobBonusFirstTimeBonus(_p0, _p1, _p2);
			}
		}

		public void NetworkEarnGoon(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkEarnGoon == null) fn__networkEarnGoon = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnGoon");
				fn__networkEarnGoon(_p0, _p1, _p2);
			}
		}

		public void NetworkEarnBoss(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkEarnBoss == null) fn__networkEarnBoss = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnBoss");
				fn__networkEarnBoss(_p0, _p1, _p2);
			}
		}

		public void NetworkEarnBossAgency(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkEarnBossAgency == null) fn__networkEarnBossAgency = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnBossAgency");
				fn__networkEarnBossAgency(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnFromWarehouse(int _amount, int _id)
		{
			unsafe {
				if (fn__networkEarnFromWarehouse == null) fn__networkEarnFromWarehouse = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromWarehouse");
				fn__networkEarnFromWarehouse(_amount, _id);
			}
		}

		public void NetworkEarnFromContraband(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromContraband == null) fn__networkEarnFromContraband = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromContraband");
				fn__networkEarnFromContraband(_amount, _p1);
			}
		}

		public void NetworkEarnFromDestroyingContraband(int _p0)
		{
			unsafe {
				if (fn__networkEarnFromDestroyingContraband == null) fn__networkEarnFromDestroyingContraband = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromDestroyingContraband");
				fn__networkEarnFromDestroyingContraband(_p0);
			}
		}

		public void _0x6B7E4FB50D5F3D65(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0x6B7E4FB50D5F3D65 == null) fn__0x6B7E4FB50D5F3D65 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x6B7E4FB50D5F3D65");
				fn__0x6B7E4FB50D5F3D65(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void _0x31BA138F6304FB9F(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x31BA138F6304FB9F == null) fn__0x31BA138F6304FB9F = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x31BA138F6304FB9F");
				fn__0x31BA138F6304FB9F(_p0, _p1);
			}
		}

		public void _0x55A1E095DB052FA5(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x55A1E095DB052FA5 == null) fn__0x55A1E095DB052FA5 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x55A1E095DB052FA5");
				fn__0x55A1E095DB052FA5(_p0, _p1);
			}
		}

		public void NetworkEarnFromBusinessProduct(int _amount, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkEarnFromBusinessProduct == null) fn__networkEarnFromBusinessProduct = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromBusinessProduct");
				fn__networkEarnFromBusinessProduct(_amount, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnFromVehicleExport(int _amount, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkEarnFromVehicleExport == null) fn__networkEarnFromVehicleExport = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromVehicleExport");
				fn__networkEarnFromVehicleExport(_amount, _p1, _p2);
			}
		}

		public void NetworkEarnFromSmuggling(int _amount, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkEarnFromSmuggling == null) fn__networkEarnFromSmuggling = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromSmuggling");
				fn__networkEarnFromSmuggling(_amount, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnBountyHunterReward(int _p0)
		{
			unsafe {
				if (fn__networkEarnBountyHunterReward == null) fn__networkEarnBountyHunterReward = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnBountyHunterReward");
				fn__networkEarnBountyHunterReward(_p0);
			}
		}

		public void NetworkEarnFromBusinessBattle(int _p0)
		{
			unsafe {
				if (fn__networkEarnFromBusinessBattle == null) fn__networkEarnFromBusinessBattle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromBusinessBattle");
				fn__networkEarnFromBusinessBattle(_p0);
			}
		}

		public void NetworkEarnFromClubManagementParticipation(int _p0)
		{
			unsafe {
				if (fn__networkEarnFromClubManagementParticipation == null) fn__networkEarnFromClubManagementParticipation = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromClubManagementParticipation");
				fn__networkEarnFromClubManagementParticipation(_p0);
			}
		}

		public void NetworkEarnFromFmbbPhonecallMission(int _p0)
		{
			unsafe {
				if (fn__networkEarnFromFmbbPhonecallMission == null) fn__networkEarnFromFmbbPhonecallMission = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromFmbbPhonecallMission");
				fn__networkEarnFromFmbbPhonecallMission(_p0);
			}
		}

		public void NetworkEarnFromBusinessHubSell(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkEarnFromBusinessHubSell == null) fn__networkEarnFromBusinessHubSell = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromBusinessHubSell");
				fn__networkEarnFromBusinessHubSell(_p0, _p1, _p2);
			}
		}

		public void NetworkEarnFromFmbbBossWork(int _p0)
		{
			unsafe {
				if (fn__networkEarnFromFmbbBossWork == null) fn__networkEarnFromFmbbBossWork = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromFmbbBossWork");
				fn__networkEarnFromFmbbBossWork(_p0);
			}
		}

		public void NetworkEarnFmbbWageBonus(int _p0)
		{
			unsafe {
				if (fn__networkEarnFmbbWageBonus == null) fn__networkEarnFmbbWageBonus = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFmbbWageBonus");
				fn__networkEarnFmbbWageBonus(_p0);
			}
		}

		public bool NetworkCanSpendMoney(int _p0, bool _p1, bool _p2, bool _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__networkCanSpendMoney == null) fn__networkCanSpendMoney = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkCanSpendMoney");
				var result = fn__networkCanSpendMoney(_p0, _p1, _p2, _p3, _p4, _p5);
				return result;
			}
		}

		public bool NetworkCanSpendMoney2(int _p0, bool _p1, bool _p2, bool _p3, ref int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__networkCanSpendMoney2 == null) fn__networkCanSpendMoney2 = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkCanSpendMoney2");
				var ref_p4 = _p4;
				var result = fn__networkCanSpendMoney2(_p0, _p1, _p2, _p3, &ref_p4, _p5, _p6);
				_p4 = ref_p4;
				return result;
			}
		}

		public void NetworkBuyItem(int _amount, int _item, int _p2, int _p3, bool _p4, string _item_name, int _p6, int _p7, int _p8, bool _p9)
		{
			unsafe {
				if (fn__networkBuyItem == null) fn__networkBuyItem = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, nint, int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuyItem");
				var ptr_item_name = MemoryUtils.StringToHGlobalUtf8(_item_name);
				fn__networkBuyItem(_amount, _item, _p2, _p3, _p4, ptr_item_name, _p6, _p7, _p8, _p9);
				Marshal.FreeHGlobal(ptr_item_name);
			}
		}

		public void NetworkSpentTaxi(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentTaxi == null) fn__networkSpentTaxi = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentTaxi");
				fn__networkSpentTaxi(_amount, _p1, _p2);
			}
		}

		public void NetworkPayEmployeeWage(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkPayEmployeeWage == null) fn__networkPayEmployeeWage = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkPayEmployeeWage");
				fn__networkPayEmployeeWage(_p0, _p1, _p2);
			}
		}

		public void NetworkPayUtilityBill(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkPayUtilityBill == null) fn__networkPayUtilityBill = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkPayUtilityBill");
				fn__networkPayUtilityBill(_amount, _p1, _p2);
			}
		}

		public void NetworkPayMatchEntryFee(int _amount, string _matchId, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkPayMatchEntryFee == null) fn__networkPayMatchEntryFee = (delegate* unmanaged[Cdecl]<int, nint, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkPayMatchEntryFee");
				var ptr_matchId = MemoryUtils.StringToHGlobalUtf8(_matchId);
				fn__networkPayMatchEntryFee(_amount, ptr_matchId, _p2, _p3);
				Marshal.FreeHGlobal(ptr_matchId);
			}
		}

		public void NetworkSpentBetting(int _amount, int _p1, string _matchId, bool _p3, bool _p4)
		{
			unsafe {
				if (fn__networkSpentBetting == null) fn__networkSpentBetting = (delegate* unmanaged[Cdecl]<int, int, nint, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBetting");
				var ptr_matchId = MemoryUtils.StringToHGlobalUtf8(_matchId);
				fn__networkSpentBetting(_amount, _p1, ptr_matchId, _p3, _p4);
				Marshal.FreeHGlobal(ptr_matchId);
			}
		}

		public void NetworkSpentWager(int _p0, int _p1, int _amount)
		{
			unsafe {
				if (fn__networkSpentWager == null) fn__networkSpentWager = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentWager");
				fn__networkSpentWager(_p0, _p1, _amount);
			}
		}

		public void NetworkSpentInStripclub(int _p0, bool _p1, int _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentInStripclub == null) fn__networkSpentInStripclub = (delegate* unmanaged[Cdecl]<int, bool, int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentInStripclub");
				fn__networkSpentInStripclub(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkBuyHealthcare(int _cost, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkBuyHealthcare == null) fn__networkBuyHealthcare = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuyHealthcare");
				fn__networkBuyHealthcare(_cost, _p1, _p2);
			}
		}

		public void NetworkBuyAirstrike(int _cost, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkBuyAirstrike == null) fn__networkBuyAirstrike = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuyAirstrike");
				fn__networkBuyAirstrike(_cost, _p1, _p2);
			}
		}

		public void NetworkBuyBackupGang(int _p0, int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkBuyBackupGang == null) fn__networkBuyBackupGang = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuyBackupGang");
				fn__networkBuyBackupGang(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkBuyHeliStrike(int _cost, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkBuyHeliStrike == null) fn__networkBuyHeliStrike = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuyHeliStrike");
				fn__networkBuyHeliStrike(_cost, _p1, _p2);
			}
		}

		public void NetworkSpentAmmoDrop(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentAmmoDrop == null) fn__networkSpentAmmoDrop = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentAmmoDrop");
				fn__networkSpentAmmoDrop(_p0, _p1, _p2);
			}
		}

		public void NetworkBuyBounty(int _amount, int _victim, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkBuyBounty == null) fn__networkBuyBounty = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuyBounty");
				fn__networkBuyBounty(_amount, _victim, _p2, _p3);
			}
		}

		public void NetworkBuyProperty(int _cost, int _propertyName, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkBuyProperty == null) fn__networkBuyProperty = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuyProperty");
				fn__networkBuyProperty(_cost, _propertyName, _p2, _p3);
			}
		}

		public void NetworkBuySmokes(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkBuySmokes == null) fn__networkBuySmokes = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuySmokes");
				fn__networkBuySmokes(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentHeliPickup(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentHeliPickup == null) fn__networkSpentHeliPickup = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentHeliPickup");
				fn__networkSpentHeliPickup(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentBoatPickup(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBoatPickup == null) fn__networkSpentBoatPickup = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBoatPickup");
				fn__networkSpentBoatPickup(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentBullShark(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBullShark == null) fn__networkSpentBullShark = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBullShark");
				fn__networkSpentBullShark(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentCashDrop(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentCashDrop == null) fn__networkSpentCashDrop = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCashDrop");
				fn__networkSpentCashDrop(_amount, _p1, _p2);
			}
		}

		public void NetworkSpentHireMugger(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentHireMugger == null) fn__networkSpentHireMugger = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentHireMugger");
				fn__networkSpentHireMugger(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentRobbedByMugger(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentRobbedByMugger == null) fn__networkSpentRobbedByMugger = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentRobbedByMugger");
				fn__networkSpentRobbedByMugger(_amount, _p1, _p2);
			}
		}

		public void NetworkSpentHireMercenary(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentHireMercenary == null) fn__networkSpentHireMercenary = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentHireMercenary");
				fn__networkSpentHireMercenary(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentBuyWantedlevel(int _p0, ref int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentBuyWantedlevel == null) fn__networkSpentBuyWantedlevel = (delegate* unmanaged[Cdecl]<int, int*, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyWantedlevel");
				var ref_p1 = _p1;
				fn__networkSpentBuyWantedlevel(_p0, &ref_p1, _p2, _p3);
				_p1 = ref_p1;
			}
		}

		public void NetworkSpentBuyOfftheradar(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBuyOfftheradar == null) fn__networkSpentBuyOfftheradar = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyOfftheradar");
				fn__networkSpentBuyOfftheradar(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentBuyRevealPlayers(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBuyRevealPlayers == null) fn__networkSpentBuyRevealPlayers = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyRevealPlayers");
				fn__networkSpentBuyRevealPlayers(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentCarwash(int _p0, int _p1, int _p2, bool _p3, bool _p4)
		{
			unsafe {
				if (fn__networkSpentCarwash == null) fn__networkSpentCarwash = (delegate* unmanaged[Cdecl]<int, int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCarwash");
				fn__networkSpentCarwash(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkSpentCinema(int _p0, int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentCinema == null) fn__networkSpentCinema = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCinema");
				fn__networkSpentCinema(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentTelescope(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentTelescope == null) fn__networkSpentTelescope = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentTelescope");
				fn__networkSpentTelescope(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentHoldups(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentHoldups == null) fn__networkSpentHoldups = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentHoldups");
				fn__networkSpentHoldups(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentBuyPassiveMode(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBuyPassiveMode == null) fn__networkSpentBuyPassiveMode = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyPassiveMode");
				fn__networkSpentBuyPassiveMode(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentBankInterest(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBankInterest == null) fn__networkSpentBankInterest = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBankInterest");
				fn__networkSpentBankInterest(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentProstitutes(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentProstitutes == null) fn__networkSpentProstitutes = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentProstitutes");
				fn__networkSpentProstitutes(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentArrestBail(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentArrestBail == null) fn__networkSpentArrestBail = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentArrestBail");
				fn__networkSpentArrestBail(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentPayVehicleInsurancePremium(int _amount, int _vehicleModel, ref int _gamerHandle, bool _notBankrupt, bool _hasTheMoney)
		{
			unsafe {
				if (fn__networkSpentPayVehicleInsurancePremium == null) fn__networkSpentPayVehicleInsurancePremium = (delegate* unmanaged[Cdecl]<int, int, int*, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentPayVehicleInsurancePremium");
				var ref_gamerHandle = _gamerHandle;
				fn__networkSpentPayVehicleInsurancePremium(_amount, _vehicleModel, &ref_gamerHandle, _notBankrupt, _hasTheMoney);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public void NetworkSpentCallPlayer(int _p0, ref int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentCallPlayer == null) fn__networkSpentCallPlayer = (delegate* unmanaged[Cdecl]<int, int*, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCallPlayer");
				var ref_p1 = _p1;
				fn__networkSpentCallPlayer(_p0, &ref_p1, _p2, _p3);
				_p1 = ref_p1;
			}
		}

		public void NetworkSpentBounty(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBounty == null) fn__networkSpentBounty = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBounty");
				fn__networkSpentBounty(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentFromRockstar(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentFromRockstar == null) fn__networkSpentFromRockstar = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentFromRockstar");
				fn__networkSpentFromRockstar(_p0, _p1, _p2);
			}
		}

		public int _0x9B5016A6433A68C5()
		{
			unsafe {
				if (fn__0x9B5016A6433A68C5 == null) fn__0x9B5016A6433A68C5 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x9B5016A6433A68C5");
				var result = fn__0x9B5016A6433A68C5();
				return result;
			}
		}

		public string ProcessCashGift(ref int _p0, ref int _p1, string _p2)
		{
			unsafe {
				if (fn__processCashGift == null) fn__processCashGift = (delegate* unmanaged[Cdecl]<int*, int*, nint, nint>) NativeLibrary.GetExport(handle, "Native_processCashGift");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var result = fn__processCashGift(&ref_p0, &ref_p1, ptr_p2);
				_p0 = ref_p0;
				_p1 = ref_p1;
				Marshal.FreeHGlobal(ptr_p2);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void NetworkSpentPlayerHealthcare(int _p0, int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentPlayerHealthcare == null) fn__networkSpentPlayerHealthcare = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentPlayerHealthcare");
				fn__networkSpentPlayerHealthcare(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentNoCops(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentNoCops == null) fn__networkSpentNoCops = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentNoCops");
				fn__networkSpentNoCops(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentRequestJob(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentRequestJob == null) fn__networkSpentRequestJob = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentRequestJob");
				fn__networkSpentRequestJob(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentRequestHeist(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentRequestHeist == null) fn__networkSpentRequestHeist = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentRequestHeist");
				fn__networkSpentRequestHeist(_p0, _p1, _p2);
			}
		}

		public void NetworkBuyFairgroundRide(int _amount, int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkBuyFairgroundRide == null) fn__networkBuyFairgroundRide = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuyFairgroundRide");
				fn__networkBuyFairgroundRide(_amount, _p1, _p2, _p3);
			}
		}

		public bool _0x7C4FCCD2E4DEB394()
		{
			unsafe {
				if (fn__0x7C4FCCD2E4DEB394 == null) fn__0x7C4FCCD2E4DEB394 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x7C4FCCD2E4DEB394");
				var result = fn__0x7C4FCCD2E4DEB394();
				return result;
			}
		}

		public void NetworkSpentJobSkip(int _amount, string _matchId, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentJobSkip == null) fn__networkSpentJobSkip = (delegate* unmanaged[Cdecl]<int, nint, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentJobSkip");
				var ptr_matchId = MemoryUtils.StringToHGlobalUtf8(_matchId);
				fn__networkSpentJobSkip(_amount, ptr_matchId, _p2, _p3);
				Marshal.FreeHGlobal(ptr_matchId);
			}
		}

		public bool NetworkSpentBoss(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBoss == null) fn__networkSpentBoss = (delegate* unmanaged[Cdecl]<int, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkSpentBoss");
				var result = fn__networkSpentBoss(_amount, _p1, _p2);
				return result;
			}
		}

		public void NetworkSpentPayGoon(int _p0, int _p1, int _amount)
		{
			unsafe {
				if (fn__networkSpentPayGoon == null) fn__networkSpentPayGoon = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentPayGoon");
				fn__networkSpentPayGoon(_p0, _p1, _amount);
			}
		}

		public void NetworkSpentPayBoss(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkSpentPayBoss == null) fn__networkSpentPayBoss = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentPayBoss");
				fn__networkSpentPayBoss(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentMoveYacht(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentMoveYacht == null) fn__networkSpentMoveYacht = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentMoveYacht");
				fn__networkSpentMoveYacht(_amount, _p1, _p2);
			}
		}

		public void NetworkSpentRenameOrganization(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkSpentRenameOrganization == null) fn__networkSpentRenameOrganization = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentRenameOrganization");
				fn__networkSpentRenameOrganization(_p0, _p1, _p2);
			}
		}

		public void NetworkBuyContraband(int _p0, int _p1, int _p2, bool _p3, bool _p4)
		{
			unsafe {
				if (fn__networkBuyContraband == null) fn__networkBuyContraband = (delegate* unmanaged[Cdecl]<int, int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkBuyContraband");
				fn__networkBuyContraband(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkSpentVipUtilityCharges(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkSpentVipUtilityCharges == null) fn__networkSpentVipUtilityCharges = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentVipUtilityCharges");
				fn__networkSpentVipUtilityCharges(_p0, _p1, _p2);
			}
		}

		public void _0x112209CE0290C03A(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x112209CE0290C03A == null) fn__0x112209CE0290C03A = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x112209CE0290C03A");
				fn__0x112209CE0290C03A(_p0, _p1, _p2, _p3);
			}
		}

		public void _0xED5FD7AF10F5E262(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xED5FD7AF10F5E262 == null) fn__0xED5FD7AF10F5E262 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xED5FD7AF10F5E262");
				fn__0xED5FD7AF10F5E262(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x0D30EB83668E63C5(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x0D30EB83668E63C5 == null) fn__0x0D30EB83668E63C5 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0D30EB83668E63C5");
				fn__0x0D30EB83668E63C5(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentPaServiceDancer(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentPaServiceDancer == null) fn__networkSpentPaServiceDancer = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentPaServiceDancer");
				fn__networkSpentPaServiceDancer(_p0, _p1, _p2, _p3);
			}
		}

		public void _0xE23ADC6FCB1F29AE(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xE23ADC6FCB1F29AE == null) fn__0xE23ADC6FCB1F29AE = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xE23ADC6FCB1F29AE");
				fn__0xE23ADC6FCB1F29AE(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentPaServiceHeliPickup(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentPaServiceHeliPickup == null) fn__networkSpentPaServiceHeliPickup = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentPaServiceHeliPickup");
				fn__networkSpentPaServiceHeliPickup(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x69EF772B192614C1(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x69EF772B192614C1 == null) fn__0x69EF772B192614C1 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x69EF772B192614C1");
				fn__0x69EF772B192614C1(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x8E243837643D9583(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x8E243837643D9583 == null) fn__0x8E243837643D9583 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x8E243837643D9583");
				fn__0x8E243837643D9583(_p0, _p1, _p2, _p3);
			}
		}

		public void _0xBD0EFB25CCA8F97A(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xBD0EFB25CCA8F97A == null) fn__0xBD0EFB25CCA8F97A = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xBD0EFB25CCA8F97A");
				fn__0xBD0EFB25CCA8F97A(_p0, _p1, _p2, _p3);
			}
		}

		public void _0xA95F667A755725DA(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xA95F667A755725DA == null) fn__0xA95F667A755725DA = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xA95F667A755725DA");
				fn__0xA95F667A755725DA(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentPurchaseWarehouse(int _amount, ref int _data, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentPurchaseWarehouse == null) fn__networkSpentPurchaseWarehouse = (delegate* unmanaged[Cdecl]<int, int*, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentPurchaseWarehouse");
				var ref_data = _data;
				fn__networkSpentPurchaseWarehouse(_amount, &ref_data, _p2, _p3);
				_data = ref_data;
			}
		}

		public void _0x4128464231E3CA0B(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x4128464231E3CA0B == null) fn__0x4128464231E3CA0B = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x4128464231E3CA0B");
				fn__0x4128464231E3CA0B(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x2FAB6614CE22E196(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x2FAB6614CE22E196 == null) fn__0x2FAB6614CE22E196 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2FAB6614CE22E196");
				fn__0x2FAB6614CE22E196(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentOrderWarehouseVehicle(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentOrderWarehouseVehicle == null) fn__networkSpentOrderWarehouseVehicle = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentOrderWarehouseVehicle");
				fn__networkSpentOrderWarehouseVehicle(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentOrderBodyguardVehicle(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentOrderBodyguardVehicle == null) fn__networkSpentOrderBodyguardVehicle = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentOrderBodyguardVehicle");
				fn__networkSpentOrderBodyguardVehicle(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentJukebox(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentJukebox == null) fn__networkSpentJukebox = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentJukebox");
				fn__networkSpentJukebox(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x998E18CEB44487FC(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x998E18CEB44487FC == null) fn__0x998E18CEB44487FC = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x998E18CEB44487FC");
				fn__0x998E18CEB44487FC(_p0, _p1, _p2, _p3);
			}
		}

		public void _0xFA07759E6FDDD7CF(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xFA07759E6FDDD7CF == null) fn__0xFA07759E6FDDD7CF = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xFA07759E6FDDD7CF");
				fn__0xFA07759E6FDDD7CF(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x6FD97159FE3C971A(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x6FD97159FE3C971A == null) fn__0x6FD97159FE3C971A = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x6FD97159FE3C971A");
				fn__0x6FD97159FE3C971A(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x675D19C6067CAE08(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x675D19C6067CAE08 == null) fn__0x675D19C6067CAE08 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x675D19C6067CAE08");
				fn__0x675D19C6067CAE08(_p0, _p1, _p2, _p3);
			}
		}

		public void _0xA51B086B0B2C0F7A(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xA51B086B0B2C0F7A == null) fn__0xA51B086B0B2C0F7A = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xA51B086B0B2C0F7A");
				fn__0xA51B086B0B2C0F7A(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentBaService(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__networkSpentBaService == null) fn__networkSpentBaService = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBaService");
				fn__networkSpentBaService(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkSpentBusiness(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentBusiness == null) fn__networkSpentBusiness = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBusiness");
				fn__networkSpentBusiness(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x5F456788B05FAEAC(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x5F456788B05FAEAC == null) fn__0x5F456788B05FAEAC = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x5F456788B05FAEAC");
				fn__0x5F456788B05FAEAC(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentVehicleExportMods(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__networkSpentVehicleExportMods == null) fn__networkSpentVehicleExportMods = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentVehicleExportMods");
				fn__networkSpentVehicleExportMods(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void _0xB4C2EC463672474E(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xB4C2EC463672474E == null) fn__0xB4C2EC463672474E = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xB4C2EC463672474E");
				fn__0xB4C2EC463672474E(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x2AFC2D19B50797F2(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x2AFC2D19B50797F2 == null) fn__0x2AFC2D19B50797F2 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2AFC2D19B50797F2");
				fn__0x2AFC2D19B50797F2(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentImportExportRepair(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkSpentImportExportRepair == null) fn__networkSpentImportExportRepair = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentImportExportRepair");
				fn__networkSpentImportExportRepair(_p0, _p1, _p2);
			}
		}

		public void NetworkSpentPurchaseHangar(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentPurchaseHangar == null) fn__networkSpentPurchaseHangar = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentPurchaseHangar");
				fn__networkSpentPurchaseHangar(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentUpgradeHangar(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentUpgradeHangar == null) fn__networkSpentUpgradeHangar = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentUpgradeHangar");
				fn__networkSpentUpgradeHangar(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentHangarUtilityCharges(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentHangarUtilityCharges == null) fn__networkSpentHangarUtilityCharges = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentHangarUtilityCharges");
				fn__networkSpentHangarUtilityCharges(_amount, _p1, _p2);
			}
		}

		public void NetworkSpentHangarStaffCharges(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentHangarStaffCharges == null) fn__networkSpentHangarStaffCharges = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentHangarStaffCharges");
				fn__networkSpentHangarStaffCharges(_amount, _p1, _p2);
			}
		}

		public void NetworkSpentBuyTruck(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentBuyTruck == null) fn__networkSpentBuyTruck = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyTruck");
				fn__networkSpentBuyTruck(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentUpgradeTruck(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentUpgradeTruck == null) fn__networkSpentUpgradeTruck = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentUpgradeTruck");
				fn__networkSpentUpgradeTruck(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentBuyBunker(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentBuyBunker == null) fn__networkSpentBuyBunker = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyBunker");
				fn__networkSpentBuyBunker(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentUpgradeBunker(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentUpgradeBunker == null) fn__networkSpentUpgradeBunker = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentUpgradeBunker");
				fn__networkSpentUpgradeBunker(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnFromSellBunker(int _amount, int _bunkerHash)
		{
			unsafe {
				if (fn__networkEarnFromSellBunker == null) fn__networkEarnFromSellBunker = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromSellBunker");
				fn__networkEarnFromSellBunker(_amount, _bunkerHash);
			}
		}

		public void NetworkSpentBallisticEquipment(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBallisticEquipment == null) fn__networkSpentBallisticEquipment = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBallisticEquipment");
				fn__networkSpentBallisticEquipment(_amount, _p1, _p2);
			}
		}

		public void NetworkEarnFromRdrBonus(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromRdrBonus == null) fn__networkEarnFromRdrBonus = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromRdrBonus");
				fn__networkEarnFromRdrBonus(_amount, _p1);
			}
		}

		public void NetworkEarnFromWagePayment(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromWagePayment == null) fn__networkEarnFromWagePayment = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromWagePayment");
				fn__networkEarnFromWagePayment(_amount);
			}
		}

		public void NetworkEarnFromWagePaymentBonus(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromWagePaymentBonus == null) fn__networkEarnFromWagePaymentBonus = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromWagePaymentBonus");
				fn__networkEarnFromWagePaymentBonus(_amount);
			}
		}

		public void NetworkSpentBuyBase(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentBuyBase == null) fn__networkSpentBuyBase = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyBase");
				fn__networkSpentBuyBase(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentUpgradeBase(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentUpgradeBase == null) fn__networkSpentUpgradeBase = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentUpgradeBase");
				fn__networkSpentUpgradeBase(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentBuyTiltrotor(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentBuyTiltrotor == null) fn__networkSpentBuyTiltrotor = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyTiltrotor");
				fn__networkSpentBuyTiltrotor(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentUpgradeTiltrotor(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentUpgradeTiltrotor == null) fn__networkSpentUpgradeTiltrotor = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentUpgradeTiltrotor");
				fn__networkSpentUpgradeTiltrotor(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentEmployAssassins(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentEmployAssassins == null) fn__networkSpentEmployAssassins = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentEmployAssassins");
				fn__networkSpentEmployAssassins(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentGangopsCannon(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentGangopsCannon == null) fn__networkSpentGangopsCannon = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentGangopsCannon");
				fn__networkSpentGangopsCannon(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentGangopsStartMission(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentGangopsStartMission == null) fn__networkSpentGangopsStartMission = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentGangopsStartMission");
				fn__networkSpentGangopsStartMission(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentCasinoHeistSkipMission(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentCasinoHeistSkipMission == null) fn__networkSpentCasinoHeistSkipMission = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCasinoHeistSkipMission");
				fn__networkSpentCasinoHeistSkipMission(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnFromSellBase(int _amount, int _baseNameHash)
		{
			unsafe {
				if (fn__networkEarnFromSellBase == null) fn__networkEarnFromSellBase = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromSellBase");
				fn__networkEarnFromSellBase(_amount, _baseNameHash);
			}
		}

		public void NetworkEarnFromTargetRefund(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromTargetRefund == null) fn__networkEarnFromTargetRefund = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromTargetRefund");
				fn__networkEarnFromTargetRefund(_amount, _p1);
			}
		}

		public void NetworkEarnFromGangopsWages(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromGangopsWages == null) fn__networkEarnFromGangopsWages = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromGangopsWages");
				fn__networkEarnFromGangopsWages(_amount, _p1);
			}
		}

		public void NetworkEarnFromGangopsWagesBonus(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromGangopsWagesBonus == null) fn__networkEarnFromGangopsWagesBonus = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromGangopsWagesBonus");
				fn__networkEarnFromGangopsWagesBonus(_amount, _p1);
			}
		}

		public void NetworkEarnFromDarChallenge(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromDarChallenge == null) fn__networkEarnFromDarChallenge = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromDarChallenge");
				fn__networkEarnFromDarChallenge(_amount, _p1);
			}
		}

		public void NetworkEarnFromDoomsdayFinaleBonus(int _amount, int _vehicleHash)
		{
			unsafe {
				if (fn__networkEarnFromDoomsdayFinaleBonus == null) fn__networkEarnFromDoomsdayFinaleBonus = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromDoomsdayFinaleBonus");
				fn__networkEarnFromDoomsdayFinaleBonus(_amount, _vehicleHash);
			}
		}

		public void NetworkEarnFromGangopsAwards(int _amount, string _unk, int _p2)
		{
			unsafe {
				if (fn__networkEarnFromGangopsAwards == null) fn__networkEarnFromGangopsAwards = (delegate* unmanaged[Cdecl]<int, nint, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromGangopsAwards");
				var ptr_unk = MemoryUtils.StringToHGlobalUtf8(_unk);
				fn__networkEarnFromGangopsAwards(_amount, ptr_unk, _p2);
				Marshal.FreeHGlobal(ptr_unk);
			}
		}

		public void NetworkEarnFromGangopsElite(int _amount, string _unk, int _actIndex)
		{
			unsafe {
				if (fn__networkEarnFromGangopsElite == null) fn__networkEarnFromGangopsElite = (delegate* unmanaged[Cdecl]<int, nint, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromGangopsElite");
				var ptr_unk = MemoryUtils.StringToHGlobalUtf8(_unk);
				fn__networkEarnFromGangopsElite(_amount, ptr_unk, _actIndex);
				Marshal.FreeHGlobal(ptr_unk);
			}
		}

		public void NetworkRivalDeliveryCompleted(int _earnedMoney)
		{
			unsafe {
				if (fn__networkRivalDeliveryCompleted == null) fn__networkRivalDeliveryCompleted = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkRivalDeliveryCompleted");
				fn__networkRivalDeliveryCompleted(_earnedMoney);
			}
		}

		public void NetworkSpentGangopsStartStrand(int _type, int _amount, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentGangopsStartStrand == null) fn__networkSpentGangopsStartStrand = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentGangopsStartStrand");
				fn__networkSpentGangopsStartStrand(_type, _amount, _p2, _p3);
			}
		}

		public void NetworkSpentGangopsTripSkip(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentGangopsTripSkip == null) fn__networkSpentGangopsTripSkip = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentGangopsTripSkip");
				fn__networkSpentGangopsTripSkip(_amount, _p1, _p2);
			}
		}

		public void NetworkEarnFromGangopsJobsPrepParticipation(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromGangopsJobsPrepParticipation == null) fn__networkEarnFromGangopsJobsPrepParticipation = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromGangopsJobsPrepParticipation");
				fn__networkEarnFromGangopsJobsPrepParticipation(_amount);
			}
		}

		public void NetworkEarnFromGangopsJobsSetup(int _amount, string _unk)
		{
			unsafe {
				if (fn__networkEarnFromGangopsJobsSetup == null) fn__networkEarnFromGangopsJobsSetup = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromGangopsJobsSetup");
				var ptr_unk = MemoryUtils.StringToHGlobalUtf8(_unk);
				fn__networkEarnFromGangopsJobsSetup(_amount, ptr_unk);
				Marshal.FreeHGlobal(ptr_unk);
			}
		}

		public void NetworkEarnFromGangopsJobsFinale(int _amount, string _unk)
		{
			unsafe {
				if (fn__networkEarnFromGangopsJobsFinale == null) fn__networkEarnFromGangopsJobsFinale = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromGangopsJobsFinale");
				var ptr_unk = MemoryUtils.StringToHGlobalUtf8(_unk);
				fn__networkEarnFromGangopsJobsFinale(_amount, ptr_unk);
				Marshal.FreeHGlobal(ptr_unk);
			}
		}

		public void _0x2A7CEC72C3443BCC(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x2A7CEC72C3443BCC == null) fn__0x2A7CEC72C3443BCC = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2A7CEC72C3443BCC");
				fn__0x2A7CEC72C3443BCC(_p0, _p1, _p2);
			}
		}

		public void _0xE0F82D68C7039158(int _p0)
		{
			unsafe {
				if (fn__0xE0F82D68C7039158 == null) fn__0xE0F82D68C7039158 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xE0F82D68C7039158");
				fn__0xE0F82D68C7039158(_p0);
			}
		}

		public void _0xB4DEAE67F35E2ACD(int _p0)
		{
			unsafe {
				if (fn__0xB4DEAE67F35E2ACD == null) fn__0xB4DEAE67F35E2ACD = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xB4DEAE67F35E2ACD");
				fn__0xB4DEAE67F35E2ACD(_p0);
			}
		}

		public void NetworkEarnFromBbEventBonus(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromBbEventBonus == null) fn__networkEarnFromBbEventBonus = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromBbEventBonus");
				fn__networkEarnFromBbEventBonus(_amount);
			}
		}

		public void _0x2A93C46AAB1EACC9(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x2A93C46AAB1EACC9 == null) fn__0x2A93C46AAB1EACC9 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2A93C46AAB1EACC9");
				fn__0x2A93C46AAB1EACC9(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x226C284C830D0CA8(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x226C284C830D0CA8 == null) fn__0x226C284C830D0CA8 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x226C284C830D0CA8");
				fn__0x226C284C830D0CA8(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnFromHackerTruckMission(int _p0, int _amount, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkEarnFromHackerTruckMission == null) fn__networkEarnFromHackerTruckMission = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromHackerTruckMission");
				fn__networkEarnFromHackerTruckMission(_p0, _amount, _p2, _p3);
			}
		}

		public void _0xED76D195E6E3BF7F(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xED76D195E6E3BF7F == null) fn__0xED76D195E6E3BF7F = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xED76D195E6E3BF7F");
				fn__0xED76D195E6E3BF7F(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x1DC9B749E7AE282B(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x1DC9B749E7AE282B == null) fn__0x1DC9B749E7AE282B = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1DC9B749E7AE282B");
				fn__0x1DC9B749E7AE282B(_p0, _p1, _p2, _p3);
			}
		}

		public void _0xC6E74CF8C884C880(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__0xC6E74CF8C884C880 == null) fn__0xC6E74CF8C884C880 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xC6E74CF8C884C880");
				fn__0xC6E74CF8C884C880(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void _0x65482BFD0923C8A1(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__0x65482BFD0923C8A1 == null) fn__0x65482BFD0923C8A1 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x65482BFD0923C8A1");
				fn__0x65482BFD0923C8A1(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void NetworkSpentRdrhatchetBonus(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentRdrhatchetBonus == null) fn__networkSpentRdrhatchetBonus = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentRdrhatchetBonus");
				fn__networkSpentRdrhatchetBonus(_amount, _p1, _p2);
			}
		}

		public void NetworkSpentNightclubEntryFee(int _player, int _amount, int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentNightclubEntryFee == null) fn__networkSpentNightclubEntryFee = (delegate* unmanaged[Cdecl]<int, int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentNightclubEntryFee");
				fn__networkSpentNightclubEntryFee(_player, _amount, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentNightclubBarDrink(int _amount, int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentNightclubBarDrink == null) fn__networkSpentNightclubBarDrink = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentNightclubBarDrink");
				fn__networkSpentNightclubBarDrink(_amount, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentBountyHunterMission(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentBountyHunterMission == null) fn__networkSpentBountyHunterMission = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBountyHunterMission");
				fn__networkSpentBountyHunterMission(_amount, _p1, _p2);
			}
		}

		public void NetworkSpentRehireDj(int _amount, int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentRehireDj == null) fn__networkSpentRehireDj = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentRehireDj");
				fn__networkSpentRehireDj(_amount, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentArenaJoinSpectator(int _amount, int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentArenaJoinSpectator == null) fn__networkSpentArenaJoinSpectator = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentArenaJoinSpectator");
				fn__networkSpentArenaJoinSpectator(_amount, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnFromArenaSkillLevelProgression(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromArenaSkillLevelProgression == null) fn__networkEarnFromArenaSkillLevelProgression = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromArenaSkillLevelProgression");
				fn__networkEarnFromArenaSkillLevelProgression(_amount, _p1);
			}
		}

		public void NetworkEarnFromArenaCareerProgression(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromArenaCareerProgression == null) fn__networkEarnFromArenaCareerProgression = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromArenaCareerProgression");
				fn__networkEarnFromArenaCareerProgression(_amount, _p1);
			}
		}

		public void NetworkSpentMakeItRain(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentMakeItRain == null) fn__networkSpentMakeItRain = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentMakeItRain");
				fn__networkSpentMakeItRain(_amount, _p1, _p2);
			}
		}

		public void NetworkSpentBuyArena(int _amount, bool _p1, bool _p2, string _p3)
		{
			unsafe {
				if (fn__networkSpentBuyArena == null) fn__networkSpentBuyArena = (delegate* unmanaged[Cdecl]<int, bool, bool, nint, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyArena");
				var ptr_p3 = MemoryUtils.StringToHGlobalUtf8(_p3);
				fn__networkSpentBuyArena(_amount, _p1, _p2, ptr_p3);
				Marshal.FreeHGlobal(ptr_p3);
			}
		}

		public void NetworkSpentUpgradeArena(int _amount, bool _p1, bool _p2, string _p3)
		{
			unsafe {
				if (fn__networkSpentUpgradeArena == null) fn__networkSpentUpgradeArena = (delegate* unmanaged[Cdecl]<int, bool, bool, nint, void>) NativeLibrary.GetExport(handle, "Native_networkSpentUpgradeArena");
				var ptr_p3 = MemoryUtils.StringToHGlobalUtf8(_p3);
				fn__networkSpentUpgradeArena(_amount, _p1, _p2, ptr_p3);
				Marshal.FreeHGlobal(ptr_p3);
			}
		}

		public void NetworkSpentArenaSpectatorBox(int _amount, int _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentArenaSpectatorBox == null) fn__networkSpentArenaSpectatorBox = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentArenaSpectatorBox");
				fn__networkSpentArenaSpectatorBox(_amount, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentSpinTheWheelPayment(int _amount, int _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentSpinTheWheelPayment == null) fn__networkSpentSpinTheWheelPayment = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentSpinTheWheelPayment");
				fn__networkSpentSpinTheWheelPayment(_amount, _p1, _p2);
			}
		}

		public void NetworkEarnFromSpinTheWheelCash(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromSpinTheWheelCash == null) fn__networkEarnFromSpinTheWheelCash = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromSpinTheWheelCash");
				fn__networkEarnFromSpinTheWheelCash(_amount);
			}
		}

		public void NetworkSpentArenaPremium(int _amount, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__networkSpentArenaPremium == null) fn__networkSpentArenaPremium = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentArenaPremium");
				fn__networkSpentArenaPremium(_amount, _p1, _p2);
			}
		}

		public void NetworkEarnFromArenaWar(int _amount, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkEarnFromArenaWar == null) fn__networkEarnFromArenaWar = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromArenaWar");
				fn__networkEarnFromArenaWar(_amount, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnFromAssassinateTargetKilled2(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromAssassinateTargetKilled2 == null) fn__networkEarnFromAssassinateTargetKilled2 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromAssassinateTargetKilled2");
				fn__networkEarnFromAssassinateTargetKilled2(_amount);
			}
		}

		public void NetworkEarnFromBbEventCargo(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromBbEventCargo == null) fn__networkEarnFromBbEventCargo = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromBbEventCargo");
				fn__networkEarnFromBbEventCargo(_amount);
			}
		}

		public void NetworkEarnFromRcTimeTrial(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromRcTimeTrial == null) fn__networkEarnFromRcTimeTrial = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromRcTimeTrial");
				fn__networkEarnFromRcTimeTrial(_amount);
			}
		}

		public void NetworkEarnFromDailyObjectiveEvent(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromDailyObjectiveEvent == null) fn__networkEarnFromDailyObjectiveEvent = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromDailyObjectiveEvent");
				fn__networkEarnFromDailyObjectiveEvent(_amount);
			}
		}

		public void NetworkSpentCasinoMembership(int _amount, bool _p1, bool _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentCasinoMembership == null) fn__networkSpentCasinoMembership = (delegate* unmanaged[Cdecl]<int, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCasinoMembership");
				fn__networkSpentCasinoMembership(_amount, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentBuyCasino(int _amount, bool _p1, bool _p2, ref int _data)
		{
			unsafe {
				if (fn__networkSpentBuyCasino == null) fn__networkSpentBuyCasino = (delegate* unmanaged[Cdecl]<int, bool, bool, int*, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyCasino");
				var ref_data = _data;
				fn__networkSpentBuyCasino(_amount, _p1, _p2, &ref_data);
				_data = ref_data;
			}
		}

		public void NetworkSpentUpgradeCasino(int _amount, bool _p1, bool _p2, ref int _data)
		{
			unsafe {
				if (fn__networkSpentUpgradeCasino == null) fn__networkSpentUpgradeCasino = (delegate* unmanaged[Cdecl]<int, bool, bool, int*, void>) NativeLibrary.GetExport(handle, "Native_networkSpentUpgradeCasino");
				var ref_data = _data;
				fn__networkSpentUpgradeCasino(_amount, _p1, _p2, &ref_data);
				_data = ref_data;
			}
		}

		public void NetworkSpentCasinoGeneric(int _amount, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__networkSpentCasinoGeneric == null) fn__networkSpentCasinoGeneric = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCasinoGeneric");
				fn__networkSpentCasinoGeneric(_amount, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkEarnFromTimeTrialWin(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromTimeTrialWin == null) fn__networkEarnFromTimeTrialWin = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromTimeTrialWin");
				fn__networkEarnFromTimeTrialWin(_amount);
			}
		}

		public void NetworkEarnFromCollectablesActionFigures(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromCollectablesActionFigures == null) fn__networkEarnFromCollectablesActionFigures = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCollectablesActionFigures");
				fn__networkEarnFromCollectablesActionFigures(_amount);
			}
		}

		public void NetworkEarnFromCompleteCollection(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromCompleteCollection == null) fn__networkEarnFromCompleteCollection = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCompleteCollection");
				fn__networkEarnFromCompleteCollection(_amount);
			}
		}

		public void NetworkEarnFromSellingVehicle(int _amount, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkEarnFromSellingVehicle == null) fn__networkEarnFromSellingVehicle = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromSellingVehicle");
				fn__networkEarnFromSellingVehicle(_amount, _p1, _p2);
			}
		}

		public void NetworkEarnFromCasinoMissionReward(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromCasinoMissionReward == null) fn__networkEarnFromCasinoMissionReward = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCasinoMissionReward");
				fn__networkEarnFromCasinoMissionReward(_amount);
			}
		}

		public void NetworkEarnFromCasinoStoryMissionReward(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromCasinoStoryMissionReward == null) fn__networkEarnFromCasinoStoryMissionReward = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCasinoStoryMissionReward");
				fn__networkEarnFromCasinoStoryMissionReward(_amount);
			}
		}

		public void NetworkEarnFromCasinoMissionParticipation(int _amount)
		{
			unsafe {
				if (fn__networkEarnFromCasinoMissionParticipation == null) fn__networkEarnFromCasinoMissionParticipation = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCasinoMissionParticipation");
				fn__networkEarnFromCasinoMissionParticipation(_amount);
			}
		}

		public void NetworkEarnFromCasinoAward(int _amount, int _hash)
		{
			unsafe {
				if (fn__networkEarnFromCasinoAward == null) fn__networkEarnFromCasinoAward = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCasinoAward");
				fn__networkEarnFromCasinoAward(_amount, _hash);
			}
		}

		public void _0x870289A558348378(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x870289A558348378 == null) fn__0x870289A558348378 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x870289A558348378");
				fn__0x870289A558348378(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x5574637681911FDA(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x5574637681911FDA == null) fn__0x5574637681911FDA = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x5574637681911FDA");
				fn__0x5574637681911FDA(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentCasinoHeist(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9, int _p10)
		{
			unsafe {
				if (fn__networkSpentCasinoHeist == null) fn__networkSpentCasinoHeist = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCasinoHeist");
				fn__networkSpentCasinoHeist(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10);
			}
		}

		public void _0xB5B58E24868CB09E(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0xB5B58E24868CB09E == null) fn__0xB5B58E24868CB09E = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xB5B58E24868CB09E");
				fn__0xB5B58E24868CB09E(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkSpentArcadeGame(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__networkSpentArcadeGame == null) fn__networkSpentArcadeGame = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentArcadeGame");
				fn__networkSpentArcadeGame(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkSpentArcadeGeneric(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__networkSpentArcadeGeneric == null) fn__networkSpentArcadeGeneric = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentArcadeGeneric");
				fn__networkSpentArcadeGeneric(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkEarnCasinoHeist(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__networkEarnCasinoHeist == null) fn__networkEarnCasinoHeist = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnCasinoHeist");
				fn__networkEarnCasinoHeist(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void _0x4C3B75694F7E0D9C(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x4C3B75694F7E0D9C == null) fn__0x4C3B75694F7E0D9C = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x4C3B75694F7E0D9C");
				fn__0x4C3B75694F7E0D9C(_p0, _p1, _p2);
			}
		}

		public void _0xD29334ED1A256DBF(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0xD29334ED1A256DBF == null) fn__0xD29334ED1A256DBF = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xD29334ED1A256DBF");
				fn__0xD29334ED1A256DBF(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void _0xA95CFB4E02390842(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xA95CFB4E02390842 == null) fn__0xA95CFB4E02390842 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xA95CFB4E02390842");
				fn__0xA95CFB4E02390842(_p0, _p1, _p2);
			}
		}

		public void _0x0DD362F14F18942A(int _amount, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x0DD362F14F18942A == null) fn__0x0DD362F14F18942A = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0DD362F14F18942A");
				fn__0x0DD362F14F18942A(_amount, _p1, _p2);
			}
		}

		public void NetworkEarnCasinoHeistBonus(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__networkEarnCasinoHeistBonus == null) fn__networkEarnCasinoHeistBonus = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnCasinoHeistBonus");
				fn__networkEarnCasinoHeistBonus(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkEarnFromCollectionItem(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromCollectionItem == null) fn__networkEarnFromCollectionItem = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCollectionItem");
				fn__networkEarnFromCollectionItem(_amount, _p1);
			}
		}

		public void NetworkEarnCollectableCompletedCollection(int _amount, int _p1)
		{
			unsafe {
				if (fn__networkEarnCollectableCompletedCollection == null) fn__networkEarnCollectableCompletedCollection = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnCollectableCompletedCollection");
				fn__networkEarnCollectableCompletedCollection(_amount, _p1);
			}
		}

		public void _0xDE68E30D89F97132(int _amount, int _p1)
		{
			unsafe {
				if (fn__0xDE68E30D89F97132 == null) fn__0xDE68E30D89F97132 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xDE68E30D89F97132");
				fn__0xDE68E30D89F97132(_amount, _p1);
			}
		}

		public void _0xE2E244AB823B4483(int _amount, int _p1)
		{
			unsafe {
				if (fn__0xE2E244AB823B4483 == null) fn__0xE2E244AB823B4483 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xE2E244AB823B4483");
				fn__0xE2E244AB823B4483(_amount, _p1);
			}
		}

		public void NetworkSpentBeachPartyGeneric(int _p0)
		{
			unsafe {
				if (fn__networkSpentBeachPartyGeneric == null) fn__networkSpentBeachPartyGeneric = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBeachPartyGeneric");
				fn__networkSpentBeachPartyGeneric(_p0);
			}
		}

		public void NetworkSpentSubmarine(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__networkSpentSubmarine == null) fn__networkSpentSubmarine = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentSubmarine");
				fn__networkSpentSubmarine(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void NetworkSpentCasinoClubGeneric(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8)
		{
			unsafe {
				if (fn__networkSpentCasinoClubGeneric == null) fn__networkSpentCasinoClubGeneric = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCasinoClubGeneric");
				fn__networkSpentCasinoClubGeneric(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
			}
		}

		public void _0x90CD7C6871FBF1B4(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x90CD7C6871FBF1B4 == null) fn__0x90CD7C6871FBF1B4 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x90CD7C6871FBF1B4");
				fn__0x90CD7C6871FBF1B4(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentUpgradeSub(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentUpgradeSub == null) fn__networkSpentUpgradeSub = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentUpgradeSub");
				fn__networkSpentUpgradeSub(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentIslandHeist(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentIslandHeist == null) fn__networkSpentIslandHeist = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentIslandHeist");
				fn__networkSpentIslandHeist(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnIslandHeist(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__networkEarnIslandHeist == null) fn__networkEarnIslandHeist = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnIslandHeist");
				fn__networkEarnIslandHeist(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void _0xA51338E0DCCD4065(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xA51338E0DCCD4065 == null) fn__0xA51338E0DCCD4065 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xA51338E0DCCD4065");
				fn__0xA51338E0DCCD4065(_p0, _p1, _p2);
			}
		}

		public void _0xE2BB399D90942091(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xE2BB399D90942091 == null) fn__0xE2BB399D90942091 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xE2BB399D90942091");
				fn__0xE2BB399D90942091(_p0, _p1);
			}
		}

		public void NetworkSpentCarclubMembership(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__networkSpentCarclubMembership == null) fn__networkSpentCarclubMembership = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCarclubMembership");
				fn__networkSpentCarclubMembership(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkSpentCarclub(int _p0, bool _p1, bool _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentCarclub == null) fn__networkSpentCarclub = (delegate* unmanaged[Cdecl]<int, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCarclub");
				fn__networkSpentCarclub(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentAutoshopModifications(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__networkSpentAutoshopModifications == null) fn__networkSpentAutoshopModifications = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentAutoshopModifications");
				fn__networkSpentAutoshopModifications(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkSpentCarclubTakeover(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentCarclubTakeover == null) fn__networkSpentCarclubTakeover = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentCarclubTakeover");
				fn__networkSpentCarclubTakeover(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentBuyAutoshop(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentBuyAutoshop == null) fn__networkSpentBuyAutoshop = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentBuyAutoshop");
				fn__networkSpentBuyAutoshop(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentUpgradeAutoshop(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentUpgradeAutoshop == null) fn__networkSpentUpgradeAutoshop = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentUpgradeAutoshop");
				fn__networkSpentUpgradeAutoshop(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkEarnFromAutoshopBusiness(int _p0, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromAutoshopBusiness == null) fn__networkEarnFromAutoshopBusiness = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromAutoshopBusiness");
				fn__networkEarnFromAutoshopBusiness(_p0, _p1);
			}
		}

		public void NetworkEarnFromAutoshopIncome(int _p0)
		{
			unsafe {
				if (fn__networkEarnFromAutoshopIncome == null) fn__networkEarnFromAutoshopIncome = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromAutoshopIncome");
				fn__networkEarnFromAutoshopIncome(_p0);
			}
		}

		public void NetworkEarnFromCarclubMembership(int _p0)
		{
			unsafe {
				if (fn__networkEarnFromCarclubMembership == null) fn__networkEarnFromCarclubMembership = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromCarclubMembership");
				fn__networkEarnFromCarclubMembership(_p0);
			}
		}

		public void NetworkEarnFromVehicleAutoshop(int _p0, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromVehicleAutoshop == null) fn__networkEarnFromVehicleAutoshop = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromVehicleAutoshop");
				fn__networkEarnFromVehicleAutoshop(_p0, _p1);
			}
		}

		public void NetworkEarnFromVehicleAutoshopBonus(int _p0)
		{
			unsafe {
				if (fn__networkEarnFromVehicleAutoshopBonus == null) fn__networkEarnFromVehicleAutoshopBonus = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromVehicleAutoshopBonus");
				fn__networkEarnFromVehicleAutoshopBonus(_p0);
			}
		}

		public void NetworkEarnFromTunerAward(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkEarnFromTunerAward == null) fn__networkEarnFromTunerAward = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromTunerAward");
				fn__networkEarnFromTunerAward(_p0, _p1, _p2);
			}
		}

		public void NetworkEarnFromTunerFinale(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__networkEarnFromTunerFinale == null) fn__networkEarnFromTunerFinale = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromTunerFinale");
				fn__networkEarnFromTunerFinale(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void NetworkEarnFromUpgradeAutoshopLocation(int _p0, int _p1)
		{
			unsafe {
				if (fn__networkEarnFromUpgradeAutoshopLocation == null) fn__networkEarnFromUpgradeAutoshopLocation = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkEarnFromUpgradeAutoshopLocation");
				fn__networkEarnFromUpgradeAutoshopLocation(_p0, _p1);
			}
		}

		public void NetworkSpentImAbility(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSpentImAbility == null) fn__networkSpentImAbility = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSpentImAbility");
				fn__networkSpentImAbility(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSpentFromBank(int _p0, int _p1, int _p2, bool _p3)
		{
			unsafe {
				if (fn__networkSpentFromBank == null) fn__networkSpentFromBank = (delegate* unmanaged[Cdecl]<int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSpentFromBank");
				fn__networkSpentFromBank(_p0, _p1, _p2, _p3);
			}
		}

		public int NetworkGetVcBankBalance()
		{
			unsafe {
				if (fn__networkGetVcBankBalance == null) fn__networkGetVcBankBalance = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetVcBankBalance");
				var result = fn__networkGetVcBankBalance();
				return result;
			}
		}

		public int NetworkGetVcWalletBalance(int _characterSlot)
		{
			unsafe {
				if (fn__networkGetVcWalletBalance == null) fn__networkGetVcWalletBalance = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetVcWalletBalance");
				var result = fn__networkGetVcWalletBalance(_characterSlot);
				return result;
			}
		}

		public int NetworkGetVcBalance()
		{
			unsafe {
				if (fn__networkGetVcBalance == null) fn__networkGetVcBalance = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetVcBalance");
				var result = fn__networkGetVcBalance();
				return result;
			}
		}

		public int NetworkGetEvcBalance()
		{
			unsafe {
				if (fn__networkGetEvcBalance == null) fn__networkGetEvcBalance = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetEvcBalance");
				var result = fn__networkGetEvcBalance();
				return result;
			}
		}

		public int NetworkGetPvcBalance()
		{
			unsafe {
				if (fn__networkGetPvcBalance == null) fn__networkGetPvcBalance = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetPvcBalance");
				var result = fn__networkGetPvcBalance();
				return result;
			}
		}

		public string NetworkGetStringWalletBalance(int _characterSlot)
		{
			unsafe {
				if (fn__networkGetStringWalletBalance == null) fn__networkGetStringWalletBalance = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_networkGetStringWalletBalance");
				var result = fn__networkGetStringWalletBalance(_characterSlot);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string NetworkGetStringBankBalance()
		{
			unsafe {
				if (fn__networkGetStringBankBalance == null) fn__networkGetStringBankBalance = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_networkGetStringBankBalance");
				var result = fn__networkGetStringBankBalance();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string NetworkGetStringBankWalletBalance()
		{
			unsafe {
				if (fn__networkGetStringBankWalletBalance == null) fn__networkGetStringBankWalletBalance = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_networkGetStringBankWalletBalance");
				var result = fn__networkGetStringBankWalletBalance();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool NetworkGetVcWalletBalanceIsNotLessThan(int _amount, int _characterSlot)
		{
			unsafe {
				if (fn__networkGetVcWalletBalanceIsNotLessThan == null) fn__networkGetVcWalletBalanceIsNotLessThan = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetVcWalletBalanceIsNotLessThan");
				var result = fn__networkGetVcWalletBalanceIsNotLessThan(_amount, _characterSlot);
				return result;
			}
		}

		public bool NetworkGetVcBankBalanceIsNotLessThan(int _amount)
		{
			unsafe {
				if (fn__networkGetVcBankBalanceIsNotLessThan == null) fn__networkGetVcBankBalanceIsNotLessThan = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetVcBankBalanceIsNotLessThan");
				var result = fn__networkGetVcBankBalanceIsNotLessThan(_amount);
				return result;
			}
		}

		public bool NetworkGetVcBankWalletBalanceIsNotLessThan(int _amount, int _characterSlot)
		{
			unsafe {
				if (fn__networkGetVcBankWalletBalanceIsNotLessThan == null) fn__networkGetVcBankWalletBalanceIsNotLessThan = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetVcBankWalletBalanceIsNotLessThan");
				var result = fn__networkGetVcBankWalletBalanceIsNotLessThan(_amount, _characterSlot);
				return result;
			}
		}

		public int NetworkGetPvcTransferBalance()
		{
			unsafe {
				if (fn__networkGetPvcTransferBalance == null) fn__networkGetPvcTransferBalance = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetPvcTransferBalance");
				var result = fn__networkGetPvcTransferBalance();
				return result;
			}
		}

		public bool _0x08E8EEADFD0DC4A0(int _amount)
		{
			unsafe {
				if (fn__0x08E8EEADFD0DC4A0 == null) fn__0x08E8EEADFD0DC4A0 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x08E8EEADFD0DC4A0");
				var result = fn__0x08E8EEADFD0DC4A0(_amount);
				return result;
			}
		}

		public bool NetworkCanReceivePlayerCash(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkCanReceivePlayerCash == null) fn__networkCanReceivePlayerCash = (delegate* unmanaged[Cdecl]<int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkCanReceivePlayerCash");
				var result = fn__networkCanReceivePlayerCash(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public int NetworkGetRemainingTransferBalance()
		{
			unsafe {
				if (fn__networkGetRemainingTransferBalance == null) fn__networkGetRemainingTransferBalance = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetRemainingTransferBalance");
				var result = fn__networkGetRemainingTransferBalance();
				return result;
			}
		}

		public int WithdrawVc(int _amount)
		{
			unsafe {
				if (fn__withdrawVc == null) fn__withdrawVc = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_withdrawVc");
				var result = fn__withdrawVc(_amount);
				return result;
			}
		}

		public bool DepositVc(int _amount)
		{
			unsafe {
				if (fn__depositVc == null) fn__depositVc = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_depositVc");
				var result = fn__depositVc(_amount);
				return result;
			}
		}

		public bool _0xE154B48B68EF72BC(int _p0)
		{
			unsafe {
				if (fn__0xE154B48B68EF72BC == null) fn__0xE154B48B68EF72BC = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xE154B48B68EF72BC");
				var result = fn__0xE154B48B68EF72BC(_p0);
				return result;
			}
		}

		public bool _0x6FCF8DDEA146C45B(int _p0)
		{
			unsafe {
				if (fn__0x6FCF8DDEA146C45B == null) fn__0x6FCF8DDEA146C45B = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x6FCF8DDEA146C45B");
				var result = fn__0x6FCF8DDEA146C45B(_p0);
				return result;
			}
		}

		public bool NetGameserverUseServerTransactions()
		{
			unsafe {
				if (fn__netGameserverUseServerTransactions == null) fn__netGameserverUseServerTransactions = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_netGameserverUseServerTransactions");
				var result = fn__netGameserverUseServerTransactions();
				return result;
			}
		}

		public bool NetGameserverCatalogItemExists(string _name)
		{
			unsafe {
				if (fn__netGameserverCatalogItemExists == null) fn__netGameserverCatalogItemExists = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverCatalogItemExists");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__netGameserverCatalogItemExists(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public bool NetGameserverCatalogItemExistsHash(int _hash)
		{
			unsafe {
				if (fn__netGameserverCatalogItemExistsHash == null) fn__netGameserverCatalogItemExistsHash = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverCatalogItemExistsHash");
				var result = fn__netGameserverCatalogItemExistsHash(_hash);
				return result;
			}
		}

		public int NetGameserverGetPrice(int _itemHash, int _categoryHash, bool _p2)
		{
			unsafe {
				if (fn__netGameserverGetPrice == null) fn__netGameserverGetPrice = (delegate* unmanaged[Cdecl]<int, int, bool, int>) NativeLibrary.GetExport(handle, "Native_netGameserverGetPrice");
				var result = fn__netGameserverGetPrice(_itemHash, _categoryHash, _p2);
				return result;
			}
		}

		public bool NetGameserverCatalogIsReady()
		{
			unsafe {
				if (fn__netGameserverCatalogIsReady == null) fn__netGameserverCatalogIsReady = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_netGameserverCatalogIsReady");
				var result = fn__netGameserverCatalogIsReady();
				return result;
			}
		}

		public bool NetGameserverIsCatalogValid()
		{
			unsafe {
				if (fn__netGameserverIsCatalogValid == null) fn__netGameserverIsCatalogValid = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_netGameserverIsCatalogValid");
				var result = fn__netGameserverIsCatalogValid();
				return result;
			}
		}

		public int _0x85F6C9ABA1DE2BCF()
		{
			unsafe {
				if (fn__0x85F6C9ABA1DE2BCF == null) fn__0x85F6C9ABA1DE2BCF = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x85F6C9ABA1DE2BCF");
				var result = fn__0x85F6C9ABA1DE2BCF();
				return result;
			}
		}

		public int _0x357B152EF96C30B6()
		{
			unsafe {
				if (fn__0x357B152EF96C30B6 == null) fn__0x357B152EF96C30B6 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x357B152EF96C30B6");
				var result = fn__0x357B152EF96C30B6();
				return result;
			}
		}

		public bool NetGameserverGetCatalogState(ref int _state)
		{
			unsafe {
				if (fn__netGameserverGetCatalogState == null) fn__netGameserverGetCatalogState = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverGetCatalogState");
				var ref_state = _state;
				var result = fn__netGameserverGetCatalogState(&ref_state);
				_state = ref_state;
				return result;
			}
		}

		public int _0xE3E5A7C64CA2C6ED()
		{
			unsafe {
				if (fn__0xE3E5A7C64CA2C6ED == null) fn__0xE3E5A7C64CA2C6ED = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xE3E5A7C64CA2C6ED");
				var result = fn__0xE3E5A7C64CA2C6ED();
				return result;
			}
		}

		public bool _0x0395CB47B022E62C(ref int _p0)
		{
			unsafe {
				if (fn__0x0395CB47B022E62C == null) fn__0x0395CB47B022E62C = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native__0x0395CB47B022E62C");
				var ref_p0 = _p0;
				var result = fn__0x0395CB47B022E62C(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetGameserverStartSession(int _charSlot)
		{
			unsafe {
				if (fn__netGameserverStartSession == null) fn__netGameserverStartSession = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverStartSession");
				var result = fn__netGameserverStartSession(_charSlot);
				return result;
			}
		}

		public bool _0x72EB7BA9B69BF6AB()
		{
			unsafe {
				if (fn__0x72EB7BA9B69BF6AB == null) fn__0x72EB7BA9B69BF6AB = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x72EB7BA9B69BF6AB");
				var result = fn__0x72EB7BA9B69BF6AB();
				return result;
			}
		}

		public bool _0x170910093218C8B9(ref int _p0)
		{
			unsafe {
				if (fn__0x170910093218C8B9 == null) fn__0x170910093218C8B9 = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native__0x170910093218C8B9");
				var ref_p0 = _p0;
				var result = fn__0x170910093218C8B9(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool _0xC13C38E47EA5DF31(ref int _p0)
		{
			unsafe {
				if (fn__0xC13C38E47EA5DF31 == null) fn__0xC13C38E47EA5DF31 = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native__0xC13C38E47EA5DF31");
				var ref_p0 = _p0;
				var result = fn__0xC13C38E47EA5DF31(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetGameserverIsSessionValid(int _charSlot)
		{
			unsafe {
				if (fn__netGameserverIsSessionValid == null) fn__netGameserverIsSessionValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverIsSessionValid");
				var result = fn__netGameserverIsSessionValid(_charSlot);
				return result;
			}
		}

		public int _0x74A0FD0688F1EE45(int _p0)
		{
			unsafe {
				if (fn__0x74A0FD0688F1EE45 == null) fn__0x74A0FD0688F1EE45 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x74A0FD0688F1EE45");
				var result = fn__0x74A0FD0688F1EE45(_p0);
				return result;
			}
		}

		public bool NetGameserverSessionApplyReceivedData(int _charSlot)
		{
			unsafe {
				if (fn__netGameserverSessionApplyReceivedData == null) fn__netGameserverSessionApplyReceivedData = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverSessionApplyReceivedData");
				var result = fn__netGameserverSessionApplyReceivedData(_charSlot);
				return result;
			}
		}

		public bool NetGameserverIsSessionRefreshPending()
		{
			unsafe {
				if (fn__netGameserverIsSessionRefreshPending == null) fn__netGameserverIsSessionRefreshPending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_netGameserverIsSessionRefreshPending");
				var result = fn__netGameserverIsSessionRefreshPending();
				return result;
			}
		}

		public bool NetGameserverGetBalance(bool _inventory, bool _playerbalance)
		{
			unsafe {
				if (fn__netGameserverGetBalance == null) fn__netGameserverGetBalance = (delegate* unmanaged[Cdecl]<bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverGetBalance");
				var result = fn__netGameserverGetBalance(_inventory, _playerbalance);
				return result;
			}
		}

		public bool _0x613F125BA3BD2EB9()
		{
			unsafe {
				if (fn__0x613F125BA3BD2EB9 == null) fn__0x613F125BA3BD2EB9 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x613F125BA3BD2EB9");
				var result = fn__0x613F125BA3BD2EB9();
				return result;
			}
		}

		public bool NetGameserverGetTransactionManagerData(ref int _p0, ref bool _p1)
		{
			unsafe {
				if (fn__netGameserverGetTransactionManagerData == null) fn__netGameserverGetTransactionManagerData = (delegate* unmanaged[Cdecl]<int*, bool*, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverGetTransactionManagerData");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__netGameserverGetTransactionManagerData(&ref_p0, &ref_p1);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public bool NetGameserverBasketStart(ref int _transactionId, int _categoryHash, int _actionHash, int _flags)
		{
			unsafe {
				if (fn__netGameserverBasketStart == null) fn__netGameserverBasketStart = (delegate* unmanaged[Cdecl]<int*, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverBasketStart");
				var ref_transactionId = _transactionId;
				var result = fn__netGameserverBasketStart(&ref_transactionId, _categoryHash, _actionHash, _flags);
				_transactionId = ref_transactionId;
				return result;
			}
		}

		public bool NetGameserverBasketDelete()
		{
			unsafe {
				if (fn__netGameserverBasketDelete == null) fn__netGameserverBasketDelete = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_netGameserverBasketDelete");
				var result = fn__netGameserverBasketDelete();
				return result;
			}
		}

		public bool NetGameserverBasketEnd()
		{
			unsafe {
				if (fn__netGameserverBasketEnd == null) fn__netGameserverBasketEnd = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_netGameserverBasketEnd");
				var result = fn__netGameserverBasketEnd();
				return result;
			}
		}

		public bool NetGameserverBasketAddItem(ref int _itemData, int _quantity)
		{
			unsafe {
				if (fn__netGameserverBasketAddItem == null) fn__netGameserverBasketAddItem = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverBasketAddItem");
				var ref_itemData = _itemData;
				var result = fn__netGameserverBasketAddItem(&ref_itemData, _quantity);
				_itemData = ref_itemData;
				return result;
			}
		}

		public bool NetGameserverBasketIsFull()
		{
			unsafe {
				if (fn__netGameserverBasketIsFull == null) fn__netGameserverBasketIsFull = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_netGameserverBasketIsFull");
				var result = fn__netGameserverBasketIsFull();
				return result;
			}
		}

		public bool NetGameserverBasketApplyServerData(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__netGameserverBasketApplyServerData == null) fn__netGameserverBasketApplyServerData = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverBasketApplyServerData");
				var ref_p1 = _p1;
				var result = fn__netGameserverBasketApplyServerData(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool NetGameserverCheckoutStart(int _transactionId)
		{
			unsafe {
				if (fn__netGameserverCheckoutStart == null) fn__netGameserverCheckoutStart = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverCheckoutStart");
				var result = fn__netGameserverCheckoutStart(_transactionId);
				return result;
			}
		}

		public bool NetGameserverBeginService(ref int _transactionId, int _categoryHash, int _itemHash, int _actionTypeHash, int _value, int _flags)
		{
			unsafe {
				if (fn__netGameserverBeginService == null) fn__netGameserverBeginService = (delegate* unmanaged[Cdecl]<int*, int, int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverBeginService");
				var ref_transactionId = _transactionId;
				var result = fn__netGameserverBeginService(&ref_transactionId, _categoryHash, _itemHash, _actionTypeHash, _value, _flags);
				_transactionId = ref_transactionId;
				return result;
			}
		}

		public bool NetGameserverEndService(int _transactionId)
		{
			unsafe {
				if (fn__netGameserverEndService == null) fn__netGameserverEndService = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverEndService");
				var result = fn__netGameserverEndService(_transactionId);
				return result;
			}
		}

		public bool NetGameserverDeleteCharacterSlot(int _slot, bool _transfer, int _reason)
		{
			unsafe {
				if (fn__netGameserverDeleteCharacterSlot == null) fn__netGameserverDeleteCharacterSlot = (delegate* unmanaged[Cdecl]<int, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverDeleteCharacterSlot");
				var result = fn__netGameserverDeleteCharacterSlot(_slot, _transfer, _reason);
				return result;
			}
		}

		public int NetGameserverDeleteCharacterSlotGetStatus()
		{
			unsafe {
				if (fn__netGameserverDeleteCharacterSlotGetStatus == null) fn__netGameserverDeleteCharacterSlotGetStatus = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_netGameserverDeleteCharacterSlotGetStatus");
				var result = fn__netGameserverDeleteCharacterSlotGetStatus();
				return result;
			}
		}

		public bool NetGameserverDeleteSetTelemetryNonceSeed()
		{
			unsafe {
				if (fn__netGameserverDeleteSetTelemetryNonceSeed == null) fn__netGameserverDeleteSetTelemetryNonceSeed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_netGameserverDeleteSetTelemetryNonceSeed");
				var result = fn__netGameserverDeleteSetTelemetryNonceSeed();
				return result;
			}
		}

		public bool NetGameserverTransferBankToWallet(int _charSlot, int _amount)
		{
			unsafe {
				if (fn__netGameserverTransferBankToWallet == null) fn__netGameserverTransferBankToWallet = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverTransferBankToWallet");
				var result = fn__netGameserverTransferBankToWallet(_charSlot, _amount);
				return result;
			}
		}

		public bool NetGameserverTransferWalletToBank(int _charSlot, int _amount)
		{
			unsafe {
				if (fn__netGameserverTransferWalletToBank == null) fn__netGameserverTransferWalletToBank = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverTransferWalletToBank");
				var result = fn__netGameserverTransferWalletToBank(_charSlot, _amount);
				return result;
			}
		}

		public int NetGameserverTransferCashGetStatus()
		{
			unsafe {
				if (fn__netGameserverTransferCashGetStatus == null) fn__netGameserverTransferCashGetStatus = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_netGameserverTransferCashGetStatus");
				var result = fn__netGameserverTransferCashGetStatus();
				return result;
			}
		}

		public int NetGameserverTransferCashGetStatus2()
		{
			unsafe {
				if (fn__netGameserverTransferCashGetStatus2 == null) fn__netGameserverTransferCashGetStatus2 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_netGameserverTransferCashGetStatus2");
				var result = fn__netGameserverTransferCashGetStatus2();
				return result;
			}
		}

		public bool NetGameserverTransferCashSetTelemetryNonceSeed()
		{
			unsafe {
				if (fn__netGameserverTransferCashSetTelemetryNonceSeed == null) fn__netGameserverTransferCashSetTelemetryNonceSeed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_netGameserverTransferCashSetTelemetryNonceSeed");
				var result = fn__netGameserverTransferCashSetTelemetryNonceSeed();
				return result;
			}
		}

		public bool NetGameserverSetTelemetryNonceSeed(int _p0)
		{
			unsafe {
				if (fn__netGameserverSetTelemetryNonceSeed == null) fn__netGameserverSetTelemetryNonceSeed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_netGameserverSetTelemetryNonceSeed");
				var result = fn__netGameserverSetTelemetryNonceSeed(_p0);
				return result;
			}
		}

		public string GetOnlineVersion()
		{
			unsafe {
				if (fn__getOnlineVersion == null) fn__getOnlineVersion = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_getOnlineVersion");
				var result = fn__getOnlineVersion();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool NetworkIsSignedIn()
		{
			unsafe {
				if (fn__networkIsSignedIn == null) fn__networkIsSignedIn = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsSignedIn");
				var result = fn__networkIsSignedIn();
				return result;
			}
		}

		public bool NetworkIsSignedOnline()
		{
			unsafe {
				if (fn__networkIsSignedOnline == null) fn__networkIsSignedOnline = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsSignedOnline");
				var result = fn__networkIsSignedOnline();
				return result;
			}
		}

		public bool _0xBD545D44CCE70597()
		{
			unsafe {
				if (fn__0xBD545D44CCE70597 == null) fn__0xBD545D44CCE70597 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xBD545D44CCE70597");
				var result = fn__0xBD545D44CCE70597();
				return result;
			}
		}

		public int _0xEBCAB9E5048434F4()
		{
			unsafe {
				if (fn__0xEBCAB9E5048434F4 == null) fn__0xEBCAB9E5048434F4 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xEBCAB9E5048434F4");
				var result = fn__0xEBCAB9E5048434F4();
				return result;
			}
		}

		public int _0x74FB3E29E6D10FA9()
		{
			unsafe {
				if (fn__0x74FB3E29E6D10FA9 == null) fn__0x74FB3E29E6D10FA9 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x74FB3E29E6D10FA9");
				var result = fn__0x74FB3E29E6D10FA9();
				return result;
			}
		}

		public int _0x7808619F31FF22DB()
		{
			unsafe {
				if (fn__0x7808619F31FF22DB == null) fn__0x7808619F31FF22DB = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x7808619F31FF22DB");
				var result = fn__0x7808619F31FF22DB();
				return result;
			}
		}

		public int _0xA0FA4EC6A05DA44E()
		{
			unsafe {
				if (fn__0xA0FA4EC6A05DA44E == null) fn__0xA0FA4EC6A05DA44E = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xA0FA4EC6A05DA44E");
				var result = fn__0xA0FA4EC6A05DA44E();
				return result;
			}
		}

		public bool NetworkHasValidRosCredentials()
		{
			unsafe {
				if (fn__networkHasValidRosCredentials == null) fn__networkHasValidRosCredentials = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHasValidRosCredentials");
				var result = fn__networkHasValidRosCredentials();
				return result;
			}
		}

		public bool _0x8D11E61A4ABF49CC()
		{
			unsafe {
				if (fn__0x8D11E61A4ABF49CC == null) fn__0x8D11E61A4ABF49CC = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x8D11E61A4ABF49CC");
				var result = fn__0x8D11E61A4ABF49CC();
				return result;
			}
		}

		public bool NetworkIsCloudAvailable()
		{
			unsafe {
				if (fn__networkIsCloudAvailable == null) fn__networkIsCloudAvailable = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsCloudAvailable");
				var result = fn__networkIsCloudAvailable();
				return result;
			}
		}

		public bool NetworkHasSocialClubAccount()
		{
			unsafe {
				if (fn__networkHasSocialClubAccount == null) fn__networkHasSocialClubAccount = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHasSocialClubAccount");
				var result = fn__networkHasSocialClubAccount();
				return result;
			}
		}

		public bool NetworkAreSocialClubPoliciesCurrent()
		{
			unsafe {
				if (fn__networkAreSocialClubPoliciesCurrent == null) fn__networkAreSocialClubPoliciesCurrent = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkAreSocialClubPoliciesCurrent");
				var result = fn__networkAreSocialClubPoliciesCurrent();
				return result;
			}
		}

		public bool NetworkIsHost()
		{
			unsafe {
				if (fn__networkIsHost == null) fn__networkIsHost = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsHost");
				var result = fn__networkIsHost();
				return result;
			}
		}

		public bool _0x4237E822315D8BA9()
		{
			unsafe {
				if (fn__0x4237E822315D8BA9 == null) fn__0x4237E822315D8BA9 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x4237E822315D8BA9");
				var result = fn__0x4237E822315D8BA9();
				return result;
			}
		}

		public bool NetworkHaveOnlinePrivileges()
		{
			unsafe {
				if (fn__networkHaveOnlinePrivileges == null) fn__networkHaveOnlinePrivileges = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHaveOnlinePrivileges");
				var result = fn__networkHaveOnlinePrivileges();
				return result;
			}
		}

		public bool NetworkHasAgeRestrictedProfile()
		{
			unsafe {
				if (fn__networkHasAgeRestrictedProfile == null) fn__networkHasAgeRestrictedProfile = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHasAgeRestrictedProfile");
				var result = fn__networkHasAgeRestrictedProfile();
				return result;
			}
		}

		public bool NetworkHaveUserContentPrivileges(int _p0)
		{
			unsafe {
				if (fn__networkHaveUserContentPrivileges == null) fn__networkHaveUserContentPrivileges = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkHaveUserContentPrivileges");
				var result = fn__networkHaveUserContentPrivileges(_p0);
				return result;
			}
		}

		public bool NetworkHaveCommunicationPrivileges(int _p0, int _player)
		{
			unsafe {
				if (fn__networkHaveCommunicationPrivileges == null) fn__networkHaveCommunicationPrivileges = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkHaveCommunicationPrivileges");
				var result = fn__networkHaveCommunicationPrivileges(_p0, _player);
				return result;
			}
		}

		public bool _0x78321BEA235FD8CD(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0x78321BEA235FD8CD == null) fn__0x78321BEA235FD8CD = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native__0x78321BEA235FD8CD");
				var result = fn__0x78321BEA235FD8CD(_p0, _p1);
				return result;
			}
		}

		public bool NetworkCheckUserContentPrivileges(int _p0, int _p1, bool _p2)
		{
			unsafe {
				if (fn__networkCheckUserContentPrivileges == null) fn__networkCheckUserContentPrivileges = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkCheckUserContentPrivileges");
				var result = fn__networkCheckUserContentPrivileges(_p0, _p1, _p2);
				return result;
			}
		}

		public bool NetworkCheckCommunicationPrivileges(int _p0, int _p1, bool _p2)
		{
			unsafe {
				if (fn__networkCheckCommunicationPrivileges == null) fn__networkCheckCommunicationPrivileges = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkCheckCommunicationPrivileges");
				var result = fn__networkCheckCommunicationPrivileges(_p0, _p1, _p2);
				return result;
			}
		}

		public int _0x07EAB372C8841D99(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x07EAB372C8841D99 == null) fn__0x07EAB372C8841D99 = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x07EAB372C8841D99");
				var result = fn__0x07EAB372C8841D99(_p0, _p1, _p2);
				return result;
			}
		}

		public int _0x906CA41A4B74ECA4()
		{
			unsafe {
				if (fn__0x906CA41A4B74ECA4 == null) fn__0x906CA41A4B74ECA4 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x906CA41A4B74ECA4");
				var result = fn__0x906CA41A4B74ECA4();
				return result;
			}
		}

		public int _0x023ACAB2DC9DC4A4()
		{
			unsafe {
				if (fn__0x023ACAB2DC9DC4A4 == null) fn__0x023ACAB2DC9DC4A4 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x023ACAB2DC9DC4A4");
				var result = fn__0x023ACAB2DC9DC4A4();
				return result;
			}
		}

		public bool NetworkHasSocialNetworkingSharingPriv()
		{
			unsafe {
				if (fn__networkHasSocialNetworkingSharingPriv == null) fn__networkHasSocialNetworkingSharingPriv = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHasSocialNetworkingSharingPriv");
				var result = fn__networkHasSocialNetworkingSharingPriv();
				return result;
			}
		}

		public int NetworkGetAgeGroup()
		{
			unsafe {
				if (fn__networkGetAgeGroup == null) fn__networkGetAgeGroup = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetAgeGroup");
				var result = fn__networkGetAgeGroup();
				return result;
			}
		}

		public int _0x0CF6CC51AA18F0F8(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x0CF6CC51AA18F0F8 == null) fn__0x0CF6CC51AA18F0F8 = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x0CF6CC51AA18F0F8");
				var result = fn__0x0CF6CC51AA18F0F8(_p0, _p1, _p2);
				return result;
			}
		}

		public bool _0x64E5C4CC82847B73()
		{
			unsafe {
				if (fn__0x64E5C4CC82847B73 == null) fn__0x64E5C4CC82847B73 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x64E5C4CC82847B73");
				var result = fn__0x64E5C4CC82847B73();
				return result;
			}
		}

		public void _0x1F7BC3539F9E0224()
		{
			unsafe {
				if (fn__0x1F7BC3539F9E0224 == null) fn__0x1F7BC3539F9E0224 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x1F7BC3539F9E0224");
				fn__0x1F7BC3539F9E0224();
			}
		}

		public bool NetworkHaveOnlinePrivilege2()
		{
			unsafe {
				if (fn__networkHaveOnlinePrivilege2 == null) fn__networkHaveOnlinePrivilege2 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHaveOnlinePrivilege2");
				var result = fn__networkHaveOnlinePrivilege2();
				return result;
			}
		}

		public int _0xA8ACB6459542A8C8()
		{
			unsafe {
				if (fn__0xA8ACB6459542A8C8 == null) fn__0xA8ACB6459542A8C8 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xA8ACB6459542A8C8");
				var result = fn__0xA8ACB6459542A8C8();
				return result;
			}
		}

		public void _0x83FE8D7229593017()
		{
			unsafe {
				if (fn__0x83FE8D7229593017 == null) fn__0x83FE8D7229593017 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x83FE8D7229593017");
				fn__0x83FE8D7229593017();
			}
		}

		public int _0x53C10C8BD774F2C9()
		{
			unsafe {
				if (fn__0x53C10C8BD774F2C9 == null) fn__0x53C10C8BD774F2C9 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x53C10C8BD774F2C9");
				var result = fn__0x53C10C8BD774F2C9();
				return result;
			}
		}

		public bool NetworkCanBail()
		{
			unsafe {
				if (fn__networkCanBail == null) fn__networkCanBail = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkCanBail");
				var result = fn__networkCanBail();
				return result;
			}
		}

		public void NetworkBail(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkBail == null) fn__networkBail = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkBail");
				fn__networkBail(_p0, _p1, _p2);
			}
		}

		public void _0x283B6062A2C01E9B()
		{
			unsafe {
				if (fn__0x283B6062A2C01E9B == null) fn__0x283B6062A2C01E9B = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x283B6062A2C01E9B");
				fn__0x283B6062A2C01E9B();
			}
		}

		public int _0x8B4FFC790CA131EF(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x8B4FFC790CA131EF == null) fn__0x8B4FFC790CA131EF = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x8B4FFC790CA131EF");
				var result = fn__0x8B4FFC790CA131EF(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public void NetworkTransitionTrack(int _hash, int _p1, int _p2, int _state, int _p4)
		{
			unsafe {
				if (fn__networkTransitionTrack == null) fn__networkTransitionTrack = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkTransitionTrack");
				fn__networkTransitionTrack(_hash, _p1, _p2, _state, _p4);
			}
		}

		public int _0x04918A41BC9B8157(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x04918A41BC9B8157 == null) fn__0x04918A41BC9B8157 = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x04918A41BC9B8157");
				var result = fn__0x04918A41BC9B8157(_p0, _p1, _p2);
				return result;
			}
		}

		public bool NetworkCanAccessMultiplayer(ref int _loadingState)
		{
			unsafe {
				if (fn__networkCanAccessMultiplayer == null) fn__networkCanAccessMultiplayer = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkCanAccessMultiplayer");
				var ref_loadingState = _loadingState;
				var result = fn__networkCanAccessMultiplayer(&ref_loadingState);
				_loadingState = ref_loadingState;
				return result;
			}
		}

		public bool NetworkIsMultiplayerDisabled()
		{
			unsafe {
				if (fn__networkIsMultiplayerDisabled == null) fn__networkIsMultiplayerDisabled = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsMultiplayerDisabled");
				var result = fn__networkIsMultiplayerDisabled();
				return result;
			}
		}

		public bool NetworkCanEnterMultiplayer()
		{
			unsafe {
				if (fn__networkCanEnterMultiplayer == null) fn__networkCanEnterMultiplayer = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkCanEnterMultiplayer");
				var result = fn__networkCanEnterMultiplayer();
				return result;
			}
		}

		public int NetworkSessionEnter(int _p0, int _p1, int _p2, int _maxPlayers, int _p4, int _p5)
		{
			unsafe {
				if (fn__networkSessionEnter == null) fn__networkSessionEnter = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_networkSessionEnter");
				var result = fn__networkSessionEnter(_p0, _p1, _p2, _maxPlayers, _p4, _p5);
				return result;
			}
		}

		public bool NetworkSessionFriendMatchmaking(int _p0, int _p1, int _maxPlayers, bool _p3)
		{
			unsafe {
				if (fn__networkSessionFriendMatchmaking == null) fn__networkSessionFriendMatchmaking = (delegate* unmanaged[Cdecl]<int, int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkSessionFriendMatchmaking");
				var result = fn__networkSessionFriendMatchmaking(_p0, _p1, _maxPlayers, _p3);
				return result;
			}
		}

		public bool NetworkSessionCrewMatchmaking(int _p0, int _p1, int _p2, int _maxPlayers, bool _p4)
		{
			unsafe {
				if (fn__networkSessionCrewMatchmaking == null) fn__networkSessionCrewMatchmaking = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkSessionCrewMatchmaking");
				var result = fn__networkSessionCrewMatchmaking(_p0, _p1, _p2, _maxPlayers, _p4);
				return result;
			}
		}

		public bool NetworkSessionActivityQuickmatch(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSessionActivityQuickmatch == null) fn__networkSessionActivityQuickmatch = (delegate* unmanaged[Cdecl]<int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkSessionActivityQuickmatch");
				var result = fn__networkSessionActivityQuickmatch(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public bool NetworkSessionHost(int _p0, int _maxPlayers, bool _p2)
		{
			unsafe {
				if (fn__networkSessionHost == null) fn__networkSessionHost = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkSessionHost");
				var result = fn__networkSessionHost(_p0, _maxPlayers, _p2);
				return result;
			}
		}

		public bool NetworkSessionHostClosed(int _p0, int _maxPlayers)
		{
			unsafe {
				if (fn__networkSessionHostClosed == null) fn__networkSessionHostClosed = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkSessionHostClosed");
				var result = fn__networkSessionHostClosed(_p0, _maxPlayers);
				return result;
			}
		}

		public bool NetworkSessionHostFriendsOnly(int _p0, int _maxPlayers)
		{
			unsafe {
				if (fn__networkSessionHostFriendsOnly == null) fn__networkSessionHostFriendsOnly = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkSessionHostFriendsOnly");
				var result = fn__networkSessionHostFriendsOnly(_p0, _maxPlayers);
				return result;
			}
		}

		public bool NetworkSessionIsClosedFriends()
		{
			unsafe {
				if (fn__networkSessionIsClosedFriends == null) fn__networkSessionIsClosedFriends = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkSessionIsClosedFriends");
				var result = fn__networkSessionIsClosedFriends();
				return result;
			}
		}

		public bool NetworkSessionIsClosedCrew()
		{
			unsafe {
				if (fn__networkSessionIsClosedCrew == null) fn__networkSessionIsClosedCrew = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkSessionIsClosedCrew");
				var result = fn__networkSessionIsClosedCrew();
				return result;
			}
		}

		public bool NetworkSessionIsSolo()
		{
			unsafe {
				if (fn__networkSessionIsSolo == null) fn__networkSessionIsSolo = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkSessionIsSolo");
				var result = fn__networkSessionIsSolo();
				return result;
			}
		}

		public bool NetworkSessionIsPrivate()
		{
			unsafe {
				if (fn__networkSessionIsPrivate == null) fn__networkSessionIsPrivate = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkSessionIsPrivate");
				var result = fn__networkSessionIsPrivate();
				return result;
			}
		}

		public bool NetworkSessionEnd(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__networkSessionEnd == null) fn__networkSessionEnd = (delegate* unmanaged[Cdecl]<bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkSessionEnd");
				var result = fn__networkSessionEnd(_p0, _p1);
				return result;
			}
		}

		public int _0xB9351A07A0D458B1(int _p0)
		{
			unsafe {
				if (fn__0xB9351A07A0D458B1 == null) fn__0xB9351A07A0D458B1 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xB9351A07A0D458B1");
				var result = fn__0xB9351A07A0D458B1(_p0);
				return result;
			}
		}

		public void NetworkSessionKickPlayer(int _player)
		{
			unsafe {
				if (fn__networkSessionKickPlayer == null) fn__networkSessionKickPlayer = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSessionKickPlayer");
				fn__networkSessionKickPlayer(_player);
			}
		}

		public bool NetworkSessionGetKickVote(int _player)
		{
			unsafe {
				if (fn__networkSessionGetKickVote == null) fn__networkSessionGetKickVote = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkSessionGetKickVote");
				var result = fn__networkSessionGetKickVote(_player);
				return result;
			}
		}

		public int _0x041C7F2A6C9894E6(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x041C7F2A6C9894E6 == null) fn__0x041C7F2A6C9894E6 = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x041C7F2A6C9894E6");
				var result = fn__0x041C7F2A6C9894E6(_p0, _p1, _p2);
				return result;
			}
		}

		public bool NetworkJoinPreviouslyFailedSession()
		{
			unsafe {
				if (fn__networkJoinPreviouslyFailedSession == null) fn__networkJoinPreviouslyFailedSession = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkJoinPreviouslyFailedSession");
				var result = fn__networkJoinPreviouslyFailedSession();
				return result;
			}
		}

		public bool NetworkJoinPreviouslyFailedTransition()
		{
			unsafe {
				if (fn__networkJoinPreviouslyFailedTransition == null) fn__networkJoinPreviouslyFailedTransition = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkJoinPreviouslyFailedTransition");
				var result = fn__networkJoinPreviouslyFailedTransition();
				return result;
			}
		}

		public void NetworkSessionSetMatchmakingGroup(int _matchmakingGroup)
		{
			unsafe {
				if (fn__networkSessionSetMatchmakingGroup == null) fn__networkSessionSetMatchmakingGroup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSessionSetMatchmakingGroup");
				fn__networkSessionSetMatchmakingGroup(_matchmakingGroup);
			}
		}

		public void NetworkSessionSetMatchmakingGroupMax(int _playerType, int _playerCount)
		{
			unsafe {
				if (fn__networkSessionSetMatchmakingGroupMax == null) fn__networkSessionSetMatchmakingGroupMax = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSessionSetMatchmakingGroupMax");
				fn__networkSessionSetMatchmakingGroupMax(_playerType, _playerCount);
			}
		}

		public int NetworkSessionGetMatchmakingGroupFree(int _p0)
		{
			unsafe {
				if (fn__networkSessionGetMatchmakingGroupFree == null) fn__networkSessionGetMatchmakingGroupFree = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkSessionGetMatchmakingGroupFree");
				var result = fn__networkSessionGetMatchmakingGroupFree(_p0);
				return result;
			}
		}

		public void NetworkSessionAddActiveMatchmakingGroup(int _groupId)
		{
			unsafe {
				if (fn__networkSessionAddActiveMatchmakingGroup == null) fn__networkSessionAddActiveMatchmakingGroup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSessionAddActiveMatchmakingGroup");
				fn__networkSessionAddActiveMatchmakingGroup(_groupId);
			}
		}

		public void _0xF49ABC20D8552257(int _p0)
		{
			unsafe {
				if (fn__0xF49ABC20D8552257 == null) fn__0xF49ABC20D8552257 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xF49ABC20D8552257");
				fn__0xF49ABC20D8552257(_p0);
			}
		}

		public void _0x4811BBAC21C5FCD5(int _p0)
		{
			unsafe {
				if (fn__0x4811BBAC21C5FCD5 == null) fn__0x4811BBAC21C5FCD5 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x4811BBAC21C5FCD5");
				fn__0x4811BBAC21C5FCD5(_p0);
			}
		}

		public void _0x5539C3EBF104A53A(bool _p0)
		{
			unsafe {
				if (fn__0x5539C3EBF104A53A == null) fn__0x5539C3EBF104A53A = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x5539C3EBF104A53A");
				fn__0x5539C3EBF104A53A(_p0);
			}
		}

		public void _0x702BC4D605522539(int _p0)
		{
			unsafe {
				if (fn__0x702BC4D605522539 == null) fn__0x702BC4D605522539 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x702BC4D605522539");
				fn__0x702BC4D605522539(_p0);
			}
		}

		public void NetworkSessionSetMatchmakingPropertyId(bool _p0)
		{
			unsafe {
				if (fn__networkSessionSetMatchmakingPropertyId == null) fn__networkSessionSetMatchmakingPropertyId = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSessionSetMatchmakingPropertyId");
				fn__networkSessionSetMatchmakingPropertyId(_p0);
			}
		}

		public void NetworkSessionSetMatchmakingMentalState(int _p0)
		{
			unsafe {
				if (fn__networkSessionSetMatchmakingMentalState == null) fn__networkSessionSetMatchmakingMentalState = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSessionSetMatchmakingMentalState");
				fn__networkSessionSetMatchmakingMentalState(_p0);
			}
		}

		public void _0x5ECD378EE64450AB(int _p0)
		{
			unsafe {
				if (fn__0x5ECD378EE64450AB == null) fn__0x5ECD378EE64450AB = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x5ECD378EE64450AB");
				fn__0x5ECD378EE64450AB(_p0);
			}
		}

		public void _0x59D421683D31835A(int _p0)
		{
			unsafe {
				if (fn__0x59D421683D31835A == null) fn__0x59D421683D31835A = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x59D421683D31835A");
				fn__0x59D421683D31835A(_p0);
			}
		}

		public void _0x1153FA02A659051C()
		{
			unsafe {
				if (fn__0x1153FA02A659051C == null) fn__0x1153FA02A659051C = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x1153FA02A659051C");
				fn__0x1153FA02A659051C();
			}
		}

		public void NetworkSessionValidateJoin(bool _p0)
		{
			unsafe {
				if (fn__networkSessionValidateJoin == null) fn__networkSessionValidateJoin = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSessionValidateJoin");
				fn__networkSessionValidateJoin(_p0);
			}
		}

		public void NetworkAddFollowers(ref int _p0, int _p1)
		{
			unsafe {
				if (fn__networkAddFollowers == null) fn__networkAddFollowers = (delegate* unmanaged[Cdecl]<int*, int, void>) NativeLibrary.GetExport(handle, "Native_networkAddFollowers");
				var ref_p0 = _p0;
				fn__networkAddFollowers(&ref_p0, _p1);
				_p0 = ref_p0;
			}
		}

		public void NetworkClearFollowers()
		{
			unsafe {
				if (fn__networkClearFollowers == null) fn__networkClearFollowers = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkClearFollowers");
				fn__networkClearFollowers();
			}
		}

		public void NetworkGetGlobalMultiplayerClock(ref int _hours, ref int _minutes, ref int _seconds)
		{
			unsafe {
				if (fn__networkGetGlobalMultiplayerClock == null) fn__networkGetGlobalMultiplayerClock = (delegate* unmanaged[Cdecl]<int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_networkGetGlobalMultiplayerClock");
				var ref_hours = _hours;
				var ref_minutes = _minutes;
				var ref_seconds = _seconds;
				fn__networkGetGlobalMultiplayerClock(&ref_hours, &ref_minutes, &ref_seconds);
				_hours = ref_hours;
				_minutes = ref_minutes;
				_seconds = ref_seconds;
			}
		}

		public void _0x600F8CB31C7AAB6E(int _p0)
		{
			unsafe {
				if (fn__0x600F8CB31C7AAB6E == null) fn__0x600F8CB31C7AAB6E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x600F8CB31C7AAB6E");
				fn__0x600F8CB31C7AAB6E(_p0);
			}
		}

		public int NetworkGetTargetingMode()
		{
			unsafe {
				if (fn__networkGetTargetingMode == null) fn__networkGetTargetingMode = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetTargetingMode");
				var result = fn__networkGetTargetingMode();
				return result;
			}
		}

		public bool NetworkFindGamersInCrew(int _p0)
		{
			unsafe {
				if (fn__networkFindGamersInCrew == null) fn__networkFindGamersInCrew = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkFindGamersInCrew");
				var result = fn__networkFindGamersInCrew(_p0);
				return result;
			}
		}

		public bool NetworkFindMatchedGamers(int _p0, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__networkFindMatchedGamers == null) fn__networkFindMatchedGamers = (delegate* unmanaged[Cdecl]<int, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_networkFindMatchedGamers");
				var result = fn__networkFindMatchedGamers(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public bool NetworkIsFindingGamers()
		{
			unsafe {
				if (fn__networkIsFindingGamers == null) fn__networkIsFindingGamers = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsFindingGamers");
				var result = fn__networkIsFindingGamers();
				return result;
			}
		}

		public bool NetworkDidFindGamersSucceed()
		{
			unsafe {
				if (fn__networkDidFindGamersSucceed == null) fn__networkDidFindGamersSucceed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkDidFindGamersSucceed");
				var result = fn__networkDidFindGamersSucceed();
				return result;
			}
		}

		public int NetworkGetNumFoundGamers()
		{
			unsafe {
				if (fn__networkGetNumFoundGamers == null) fn__networkGetNumFoundGamers = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetNumFoundGamers");
				var result = fn__networkGetNumFoundGamers();
				return result;
			}
		}

		public bool NetworkGetFoundGamer(ref int _p0, int _p1)
		{
			unsafe {
				if (fn__networkGetFoundGamer == null) fn__networkGetFoundGamer = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetFoundGamer");
				var ref_p0 = _p0;
				var result = fn__networkGetFoundGamer(&ref_p0, _p1);
				_p0 = ref_p0;
				return result;
			}
		}

		public void NetworkClearFoundGamers()
		{
			unsafe {
				if (fn__networkClearFoundGamers == null) fn__networkClearFoundGamers = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkClearFoundGamers");
				fn__networkClearFoundGamers();
			}
		}

		public bool NetworkQueueGamerForStatus(ref int _p0)
		{
			unsafe {
				if (fn__networkQueueGamerForStatus == null) fn__networkQueueGamerForStatus = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkQueueGamerForStatus");
				var ref_p0 = _p0;
				var result = fn__networkQueueGamerForStatus(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetworkGetGamerStatusFromQueue()
		{
			unsafe {
				if (fn__networkGetGamerStatusFromQueue == null) fn__networkGetGamerStatusFromQueue = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkGetGamerStatusFromQueue");
				var result = fn__networkGetGamerStatusFromQueue();
				return result;
			}
		}

		public bool NetworkIsGettingGamerStatus()
		{
			unsafe {
				if (fn__networkIsGettingGamerStatus == null) fn__networkIsGettingGamerStatus = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsGettingGamerStatus");
				var result = fn__networkIsGettingGamerStatus();
				return result;
			}
		}

		public bool NetworkDidGetGamerStatusSucceed()
		{
			unsafe {
				if (fn__networkDidGetGamerStatusSucceed == null) fn__networkDidGetGamerStatusSucceed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkDidGetGamerStatusSucceed");
				var result = fn__networkDidGetGamerStatusSucceed();
				return result;
			}
		}

		public bool NetworkGetGamerStatusResult(ref int _p0, int _p1)
		{
			unsafe {
				if (fn__networkGetGamerStatusResult == null) fn__networkGetGamerStatusResult = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetGamerStatusResult");
				var ref_p0 = _p0;
				var result = fn__networkGetGamerStatusResult(&ref_p0, _p1);
				_p0 = ref_p0;
				return result;
			}
		}

		public void NetworkClearGetGamerStatus()
		{
			unsafe {
				if (fn__networkClearGetGamerStatus == null) fn__networkClearGetGamerStatus = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkClearGetGamerStatus");
				fn__networkClearGetGamerStatus();
			}
		}

		public void NetworkSessionJoinInvite()
		{
			unsafe {
				if (fn__networkSessionJoinInvite == null) fn__networkSessionJoinInvite = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkSessionJoinInvite");
				fn__networkSessionJoinInvite();
			}
		}

		public void NetworkSessionCancelInvite()
		{
			unsafe {
				if (fn__networkSessionCancelInvite == null) fn__networkSessionCancelInvite = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkSessionCancelInvite");
				fn__networkSessionCancelInvite();
			}
		}

		public void NetworkSessionForceCancelInvite()
		{
			unsafe {
				if (fn__networkSessionForceCancelInvite == null) fn__networkSessionForceCancelInvite = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkSessionForceCancelInvite");
				fn__networkSessionForceCancelInvite();
			}
		}

		public bool NetworkHasPendingInvite()
		{
			unsafe {
				if (fn__networkHasPendingInvite == null) fn__networkHasPendingInvite = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHasPendingInvite");
				var result = fn__networkHasPendingInvite();
				return result;
			}
		}

		public bool _0xC42DD763159F3461()
		{
			unsafe {
				if (fn__0xC42DD763159F3461 == null) fn__0xC42DD763159F3461 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xC42DD763159F3461");
				var result = fn__0xC42DD763159F3461();
				return result;
			}
		}

		public bool NetworkAcceptInvite()
		{
			unsafe {
				if (fn__networkAcceptInvite == null) fn__networkAcceptInvite = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkAcceptInvite");
				var result = fn__networkAcceptInvite();
				return result;
			}
		}

		public bool NetworkSessionWasInvited()
		{
			unsafe {
				if (fn__networkSessionWasInvited == null) fn__networkSessionWasInvited = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkSessionWasInvited");
				var result = fn__networkSessionWasInvited();
				return result;
			}
		}

		public void NetworkSessionGetInviter(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkSessionGetInviter == null) fn__networkSessionGetInviter = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_networkSessionGetInviter");
				var ref_gamerHandle = _gamerHandle;
				fn__networkSessionGetInviter(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public bool _0xD313DE83394AF134()
		{
			unsafe {
				if (fn__0xD313DE83394AF134 == null) fn__0xD313DE83394AF134 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xD313DE83394AF134");
				var result = fn__0xD313DE83394AF134();
				return result;
			}
		}

		public bool _0xBDB6F89C729CF388()
		{
			unsafe {
				if (fn__0xBDB6F89C729CF388 == null) fn__0xBDB6F89C729CF388 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xBDB6F89C729CF388");
				var result = fn__0xBDB6F89C729CF388();
				return result;
			}
		}

		public void NetworkSuppressInvite(bool _toggle)
		{
			unsafe {
				if (fn__networkSuppressInvite == null) fn__networkSuppressInvite = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSuppressInvite");
				fn__networkSuppressInvite(_toggle);
			}
		}

		public void NetworkBlockInvites(bool _toggle)
		{
			unsafe {
				if (fn__networkBlockInvites == null) fn__networkBlockInvites = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkBlockInvites");
				fn__networkBlockInvites(_toggle);
			}
		}

		public void NetworkBlockJoinQueueInvites(bool _toggle)
		{
			unsafe {
				if (fn__networkBlockJoinQueueInvites == null) fn__networkBlockJoinQueueInvites = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkBlockJoinQueueInvites");
				fn__networkBlockJoinQueueInvites(_toggle);
			}
		}

		public void _0xF814FEC6A19FD6E0()
		{
			unsafe {
				if (fn__0xF814FEC6A19FD6E0 == null) fn__0xF814FEC6A19FD6E0 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xF814FEC6A19FD6E0");
				fn__0xF814FEC6A19FD6E0();
			}
		}

		public void NetworkBlockKickedPlayers(bool _p0)
		{
			unsafe {
				if (fn__networkBlockKickedPlayers == null) fn__networkBlockKickedPlayers = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkBlockKickedPlayers");
				fn__networkBlockKickedPlayers(_p0);
			}
		}

		public void NetworkSetScriptReadyForEvents(bool _toggle)
		{
			unsafe {
				if (fn__networkSetScriptReadyForEvents == null) fn__networkSetScriptReadyForEvents = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetScriptReadyForEvents");
				fn__networkSetScriptReadyForEvents(_toggle);
			}
		}

		public bool NetworkIsOfflineInvitePending()
		{
			unsafe {
				if (fn__networkIsOfflineInvitePending == null) fn__networkIsOfflineInvitePending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsOfflineInvitePending");
				var result = fn__networkIsOfflineInvitePending();
				return result;
			}
		}

		public void NetworkClearOfflineInvitePending()
		{
			unsafe {
				if (fn__networkClearOfflineInvitePending == null) fn__networkClearOfflineInvitePending = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkClearOfflineInvitePending");
				fn__networkClearOfflineInvitePending();
			}
		}

		public void NetworkSessionHostSinglePlayer(int _p0)
		{
			unsafe {
				if (fn__networkSessionHostSinglePlayer == null) fn__networkSessionHostSinglePlayer = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSessionHostSinglePlayer");
				fn__networkSessionHostSinglePlayer(_p0);
			}
		}

		public void NetworkSessionLeaveSinglePlayer()
		{
			unsafe {
				if (fn__networkSessionLeaveSinglePlayer == null) fn__networkSessionLeaveSinglePlayer = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkSessionLeaveSinglePlayer");
				fn__networkSessionLeaveSinglePlayer();
			}
		}

		public bool NetworkIsGameInProgress()
		{
			unsafe {
				if (fn__networkIsGameInProgress == null) fn__networkIsGameInProgress = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsGameInProgress");
				var result = fn__networkIsGameInProgress();
				return result;
			}
		}

		public bool NetworkIsSessionActive()
		{
			unsafe {
				if (fn__networkIsSessionActive == null) fn__networkIsSessionActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsSessionActive");
				var result = fn__networkIsSessionActive();
				return result;
			}
		}

		public bool NetworkIsInSession()
		{
			unsafe {
				if (fn__networkIsInSession == null) fn__networkIsInSession = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsInSession");
				var result = fn__networkIsInSession();
				return result;
			}
		}

		public bool NetworkIsSessionStarted()
		{
			unsafe {
				if (fn__networkIsSessionStarted == null) fn__networkIsSessionStarted = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsSessionStarted");
				var result = fn__networkIsSessionStarted();
				return result;
			}
		}

		public bool NetworkIsSessionBusy()
		{
			unsafe {
				if (fn__networkIsSessionBusy == null) fn__networkIsSessionBusy = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsSessionBusy");
				var result = fn__networkIsSessionBusy();
				return result;
			}
		}

		public bool NetworkCanSessionEnd()
		{
			unsafe {
				if (fn__networkCanSessionEnd == null) fn__networkCanSessionEnd = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkCanSessionEnd");
				var result = fn__networkCanSessionEnd();
				return result;
			}
		}

		public int _0x4C9034162368E206()
		{
			unsafe {
				if (fn__0x4C9034162368E206 == null) fn__0x4C9034162368E206 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x4C9034162368E206");
				var result = fn__0x4C9034162368E206();
				return result;
			}
		}

		public void NetworkSessionMarkVisible(bool _toggle)
		{
			unsafe {
				if (fn__networkSessionMarkVisible == null) fn__networkSessionMarkVisible = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSessionMarkVisible");
				fn__networkSessionMarkVisible(_toggle);
			}
		}

		public bool NetworkSessionIsVisible()
		{
			unsafe {
				if (fn__networkSessionIsVisible == null) fn__networkSessionIsVisible = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkSessionIsVisible");
				var result = fn__networkSessionIsVisible();
				return result;
			}
		}

		public void NetworkSessionBlockJoinRequests(bool _toggle)
		{
			unsafe {
				if (fn__networkSessionBlockJoinRequests == null) fn__networkSessionBlockJoinRequests = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSessionBlockJoinRequests");
				fn__networkSessionBlockJoinRequests(_toggle);
			}
		}

		public void NetworkSessionChangeSlots(int _p0, bool _p1)
		{
			unsafe {
				if (fn__networkSessionChangeSlots == null) fn__networkSessionChangeSlots = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSessionChangeSlots");
				fn__networkSessionChangeSlots(_p0, _p1);
			}
		}

		public int NetworkSessionGetPrivateSlots()
		{
			unsafe {
				if (fn__networkSessionGetPrivateSlots == null) fn__networkSessionGetPrivateSlots = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkSessionGetPrivateSlots");
				var result = fn__networkSessionGetPrivateSlots();
				return result;
			}
		}

		public void NetworkSessionVoiceHost()
		{
			unsafe {
				if (fn__networkSessionVoiceHost == null) fn__networkSessionVoiceHost = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkSessionVoiceHost");
				fn__networkSessionVoiceHost();
			}
		}

		public void NetworkSessionVoiceLeave()
		{
			unsafe {
				if (fn__networkSessionVoiceLeave == null) fn__networkSessionVoiceLeave = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkSessionVoiceLeave");
				fn__networkSessionVoiceLeave();
			}
		}

		public void NetworkSessionVoiceConnectToPlayer(ref int _p0)
		{
			unsafe {
				if (fn__networkSessionVoiceConnectToPlayer == null) fn__networkSessionVoiceConnectToPlayer = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_networkSessionVoiceConnectToPlayer");
				var ref_p0 = _p0;
				fn__networkSessionVoiceConnectToPlayer(&ref_p0);
				_p0 = ref_p0;
			}
		}

		public void NetworkSessionVoiceRespondToRequest(bool _p0, int _p1)
		{
			unsafe {
				if (fn__networkSessionVoiceRespondToRequest == null) fn__networkSessionVoiceRespondToRequest = (delegate* unmanaged[Cdecl]<bool, int, void>) NativeLibrary.GetExport(handle, "Native_networkSessionVoiceRespondToRequest");
				fn__networkSessionVoiceRespondToRequest(_p0, _p1);
			}
		}

		public void NetworkSessionVoiceSetTimeout(int _timeout)
		{
			unsafe {
				if (fn__networkSessionVoiceSetTimeout == null) fn__networkSessionVoiceSetTimeout = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSessionVoiceSetTimeout");
				fn__networkSessionVoiceSetTimeout(_timeout);
			}
		}

		public bool NetworkSessionIsInVoiceSession()
		{
			unsafe {
				if (fn__networkSessionIsInVoiceSession == null) fn__networkSessionIsInVoiceSession = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkSessionIsInVoiceSession");
				var result = fn__networkSessionIsInVoiceSession();
				return result;
			}
		}

		public int _0xB5D3453C98456528()
		{
			unsafe {
				if (fn__0xB5D3453C98456528 == null) fn__0xB5D3453C98456528 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xB5D3453C98456528");
				var result = fn__0xB5D3453C98456528();
				return result;
			}
		}

		public bool NetworkSessionIsVoiceSessionBusy()
		{
			unsafe {
				if (fn__networkSessionIsVoiceSessionBusy == null) fn__networkSessionIsVoiceSessionBusy = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkSessionIsVoiceSessionBusy");
				var result = fn__networkSessionIsVoiceSessionBusy();
				return result;
			}
		}

		public bool NetworkSendTextMessage(string _message, ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkSendTextMessage == null) fn__networkSendTextMessage = (delegate* unmanaged[Cdecl]<nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkSendTextMessage");
				var ptr_message = MemoryUtils.StringToHGlobalUtf8(_message);
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkSendTextMessage(ptr_message, &ref_gamerHandle);
				Marshal.FreeHGlobal(ptr_message);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public void NetworkSetActivitySpectator(bool _toggle)
		{
			unsafe {
				if (fn__networkSetActivitySpectator == null) fn__networkSetActivitySpectator = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetActivitySpectator");
				fn__networkSetActivitySpectator(_toggle);
			}
		}

		public bool NetworkIsActivitySpectator()
		{
			unsafe {
				if (fn__networkIsActivitySpectator == null) fn__networkIsActivitySpectator = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsActivitySpectator");
				var result = fn__networkIsActivitySpectator();
				return result;
			}
		}

		public void _0x0E4F77F7B9D74D84(int _p0)
		{
			unsafe {
				if (fn__0x0E4F77F7B9D74D84 == null) fn__0x0E4F77F7B9D74D84 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x0E4F77F7B9D74D84");
				fn__0x0E4F77F7B9D74D84(_p0);
			}
		}

		public void NetworkSetActivitySpectatorMax(int _maxSpectators)
		{
			unsafe {
				if (fn__networkSetActivitySpectatorMax == null) fn__networkSetActivitySpectatorMax = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSetActivitySpectatorMax");
				fn__networkSetActivitySpectatorMax(_maxSpectators);
			}
		}

		public int NetworkGetActivityPlayerNum(bool _p0)
		{
			unsafe {
				if (fn__networkGetActivityPlayerNum == null) fn__networkGetActivityPlayerNum = (delegate* unmanaged[Cdecl]<bool, int>) NativeLibrary.GetExport(handle, "Native_networkGetActivityPlayerNum");
				var result = fn__networkGetActivityPlayerNum(_p0);
				return result;
			}
		}

		public bool NetworkIsActivitySpectatorFromHandle(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkIsActivitySpectatorFromHandle == null) fn__networkIsActivitySpectatorFromHandle = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsActivitySpectatorFromHandle");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsActivitySpectatorFromHandle(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkHostTransition(int _p0, int _p1, int _p2, int _p3, int _p4, bool _p5, bool _p6, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__networkHostTransition == null) fn__networkHostTransition = (delegate* unmanaged[Cdecl]<int, int, int, int, int, bool, bool, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkHostTransition");
				var result = fn__networkHostTransition(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
				return result;
			}
		}

		public bool NetworkDoTransitionQuickmatch(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__networkDoTransitionQuickmatch == null) fn__networkDoTransitionQuickmatch = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkDoTransitionQuickmatch");
				var result = fn__networkDoTransitionQuickmatch(_p0, _p1, _p2, _p3, _p4, _p5);
				return result;
			}
		}

		public bool NetworkDoTransitionQuickmatchAsync(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__networkDoTransitionQuickmatchAsync == null) fn__networkDoTransitionQuickmatchAsync = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkDoTransitionQuickmatchAsync");
				var result = fn__networkDoTransitionQuickmatchAsync(_p0, _p1, _p2, _p3, _p4, _p5);
				return result;
			}
		}

		public bool NetworkDoTransitionQuickmatchWithGroup(int _p0, int _p1, int _p2, int _p3, ref int _p4, int _p5, int _p6, int _p7)
		{
			unsafe {
				if (fn__networkDoTransitionQuickmatchWithGroup == null) fn__networkDoTransitionQuickmatchWithGroup = (delegate* unmanaged[Cdecl]<int, int, int, int, int*, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkDoTransitionQuickmatchWithGroup");
				var ref_p4 = _p4;
				var result = fn__networkDoTransitionQuickmatchWithGroup(_p0, _p1, _p2, _p3, &ref_p4, _p5, _p6, _p7);
				_p4 = ref_p4;
				return result;
			}
		}

		public int NetworkJoinGroupActivity()
		{
			unsafe {
				if (fn__networkJoinGroupActivity == null) fn__networkJoinGroupActivity = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkJoinGroupActivity");
				var result = fn__networkJoinGroupActivity();
				return result;
			}
		}

		public void _0x1888694923EF4591()
		{
			unsafe {
				if (fn__0x1888694923EF4591 == null) fn__0x1888694923EF4591 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x1888694923EF4591");
				fn__0x1888694923EF4591();
			}
		}

		public void _0xB13E88E655E5A3BC()
		{
			unsafe {
				if (fn__0xB13E88E655E5A3BC == null) fn__0xB13E88E655E5A3BC = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xB13E88E655E5A3BC");
				fn__0xB13E88E655E5A3BC();
			}
		}

		public bool NetworkIsTransitionClosedFriends()
		{
			unsafe {
				if (fn__networkIsTransitionClosedFriends == null) fn__networkIsTransitionClosedFriends = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionClosedFriends");
				var result = fn__networkIsTransitionClosedFriends();
				return result;
			}
		}

		public bool NetworkIsTransitionClosedCrew()
		{
			unsafe {
				if (fn__networkIsTransitionClosedCrew == null) fn__networkIsTransitionClosedCrew = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionClosedCrew");
				var result = fn__networkIsTransitionClosedCrew();
				return result;
			}
		}

		public bool NetworkIsTransitionSolo()
		{
			unsafe {
				if (fn__networkIsTransitionSolo == null) fn__networkIsTransitionSolo = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionSolo");
				var result = fn__networkIsTransitionSolo();
				return result;
			}
		}

		public bool NetworkIsTransitionPrivate()
		{
			unsafe {
				if (fn__networkIsTransitionPrivate == null) fn__networkIsTransitionPrivate = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionPrivate");
				var result = fn__networkIsTransitionPrivate();
				return result;
			}
		}

		public int _0x617F49C2668E6155()
		{
			unsafe {
				if (fn__0x617F49C2668E6155 == null) fn__0x617F49C2668E6155 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x617F49C2668E6155");
				var result = fn__0x617F49C2668E6155();
				return result;
			}
		}

		public void _0x261E97AD7BCF3D40(bool _p0)
		{
			unsafe {
				if (fn__0x261E97AD7BCF3D40 == null) fn__0x261E97AD7BCF3D40 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x261E97AD7BCF3D40");
				fn__0x261E97AD7BCF3D40(_p0);
			}
		}

		public void _0x39917E1B4CB0F911(bool _p0)
		{
			unsafe {
				if (fn__0x39917E1B4CB0F911 == null) fn__0x39917E1B4CB0F911 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x39917E1B4CB0F911");
				fn__0x39917E1B4CB0F911(_p0);
			}
		}

		public void _0x2CE9D95E4051AECD(int _p0)
		{
			unsafe {
				if (fn__0x2CE9D95E4051AECD == null) fn__0x2CE9D95E4051AECD = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x2CE9D95E4051AECD");
				fn__0x2CE9D95E4051AECD(_p0);
			}
		}

		public void NetworkSetTransitionCreatorHandle(ref int _p0)
		{
			unsafe {
				if (fn__networkSetTransitionCreatorHandle == null) fn__networkSetTransitionCreatorHandle = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_networkSetTransitionCreatorHandle");
				var ref_p0 = _p0;
				fn__networkSetTransitionCreatorHandle(&ref_p0);
				_p0 = ref_p0;
			}
		}

		public void NetworkClearTransitionCreatorHandle()
		{
			unsafe {
				if (fn__networkClearTransitionCreatorHandle == null) fn__networkClearTransitionCreatorHandle = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkClearTransitionCreatorHandle");
				fn__networkClearTransitionCreatorHandle();
			}
		}

		public bool NetworkInviteGamersToTransition(ref int _p0, int _p1)
		{
			unsafe {
				if (fn__networkInviteGamersToTransition == null) fn__networkInviteGamersToTransition = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_networkInviteGamersToTransition");
				var ref_p0 = _p0;
				var result = fn__networkInviteGamersToTransition(&ref_p0, _p1);
				_p0 = ref_p0;
				return result;
			}
		}

		public void NetworkSetGamerInvitedToTransition(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkSetGamerInvitedToTransition == null) fn__networkSetGamerInvitedToTransition = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_networkSetGamerInvitedToTransition");
				var ref_gamerHandle = _gamerHandle;
				fn__networkSetGamerInvitedToTransition(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public bool NetworkLeaveTransition()
		{
			unsafe {
				if (fn__networkLeaveTransition == null) fn__networkLeaveTransition = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkLeaveTransition");
				var result = fn__networkLeaveTransition();
				return result;
			}
		}

		public bool NetworkLaunchTransition()
		{
			unsafe {
				if (fn__networkLaunchTransition == null) fn__networkLaunchTransition = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkLaunchTransition");
				var result = fn__networkLaunchTransition();
				return result;
			}
		}

		public void _0xA2E9C1AB8A92E8CD(bool _toggle)
		{
			unsafe {
				if (fn__0xA2E9C1AB8A92E8CD == null) fn__0xA2E9C1AB8A92E8CD = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xA2E9C1AB8A92E8CD");
				fn__0xA2E9C1AB8A92E8CD(_toggle);
			}
		}

		public void NetworkBailTransition(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkBailTransition == null) fn__networkBailTransition = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkBailTransition");
				fn__networkBailTransition(_p0, _p1, _p2);
			}
		}

		public bool NetworkDoTransitionToGame(bool _p0, int _maxPlayers)
		{
			unsafe {
				if (fn__networkDoTransitionToGame == null) fn__networkDoTransitionToGame = (delegate* unmanaged[Cdecl]<bool, int, bool>) NativeLibrary.GetExport(handle, "Native_networkDoTransitionToGame");
				var result = fn__networkDoTransitionToGame(_p0, _maxPlayers);
				return result;
			}
		}

		public bool NetworkDoTransitionToNewGame(bool _p0, int _maxPlayers, bool _p2)
		{
			unsafe {
				if (fn__networkDoTransitionToNewGame == null) fn__networkDoTransitionToNewGame = (delegate* unmanaged[Cdecl]<bool, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkDoTransitionToNewGame");
				var result = fn__networkDoTransitionToNewGame(_p0, _maxPlayers, _p2);
				return result;
			}
		}

		public bool NetworkDoTransitionToFreemode(ref int _p0, int _p1, bool _p2, int _players, bool _p4)
		{
			unsafe {
				if (fn__networkDoTransitionToFreemode == null) fn__networkDoTransitionToFreemode = (delegate* unmanaged[Cdecl]<int*, int, bool, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkDoTransitionToFreemode");
				var ref_p0 = _p0;
				var result = fn__networkDoTransitionToFreemode(&ref_p0, _p1, _p2, _players, _p4);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetworkDoTransitionToNewFreemode(ref int _p0, ref int _p1, int _players, bool _p3, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__networkDoTransitionToNewFreemode == null) fn__networkDoTransitionToNewFreemode = (delegate* unmanaged[Cdecl]<int*, int*, int, bool, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkDoTransitionToNewFreemode");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__networkDoTransitionToNewFreemode(&ref_p0, &ref_p1, _players, _p3, _p4, _p5);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public bool NetworkIsTransitionToGame()
		{
			unsafe {
				if (fn__networkIsTransitionToGame == null) fn__networkIsTransitionToGame = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionToGame");
				var result = fn__networkIsTransitionToGame();
				return result;
			}
		}

		public int NetworkGetTransitionMembers(ref int _data, int _dataCount)
		{
			unsafe {
				if (fn__networkGetTransitionMembers == null) fn__networkGetTransitionMembers = (delegate* unmanaged[Cdecl]<int*, int, int>) NativeLibrary.GetExport(handle, "Native_networkGetTransitionMembers");
				var ref_data = _data;
				var result = fn__networkGetTransitionMembers(&ref_data, _dataCount);
				_data = ref_data;
				return result;
			}
		}

		public void NetworkApplyTransitionParameter(int _p0, int _p1)
		{
			unsafe {
				if (fn__networkApplyTransitionParameter == null) fn__networkApplyTransitionParameter = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkApplyTransitionParameter");
				fn__networkApplyTransitionParameter(_p0, _p1);
			}
		}

		public void NetworkApplyTransitionParameterString(int _p0, string _string, bool _p2)
		{
			unsafe {
				if (fn__networkApplyTransitionParameterString == null) fn__networkApplyTransitionParameterString = (delegate* unmanaged[Cdecl]<int, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_networkApplyTransitionParameterString");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				fn__networkApplyTransitionParameterString(_p0, ptr_string, _p2);
				Marshal.FreeHGlobal(ptr_string);
			}
		}

		public bool NetworkSendTransitionGamerInstruction(ref int _gamerHandle, string _p1, int _p2, int _p3, bool _p4)
		{
			unsafe {
				if (fn__networkSendTransitionGamerInstruction == null) fn__networkSendTransitionGamerInstruction = (delegate* unmanaged[Cdecl]<int*, nint, int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkSendTransitionGamerInstruction");
				var ref_gamerHandle = _gamerHandle;
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var result = fn__networkSendTransitionGamerInstruction(&ref_gamerHandle, ptr_p1, _p2, _p3, _p4);
				_gamerHandle = ref_gamerHandle;
				Marshal.FreeHGlobal(ptr_p1);
				return result;
			}
		}

		public bool NetworkMarkTransitionGamerAsFullyJoined(ref int _p0)
		{
			unsafe {
				if (fn__networkMarkTransitionGamerAsFullyJoined == null) fn__networkMarkTransitionGamerAsFullyJoined = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkMarkTransitionGamerAsFullyJoined");
				var ref_p0 = _p0;
				var result = fn__networkMarkTransitionGamerAsFullyJoined(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetworkIsTransitionHost()
		{
			unsafe {
				if (fn__networkIsTransitionHost == null) fn__networkIsTransitionHost = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionHost");
				var result = fn__networkIsTransitionHost();
				return result;
			}
		}

		public bool NetworkIsTransitionHostFromHandle(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkIsTransitionHostFromHandle == null) fn__networkIsTransitionHostFromHandle = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionHostFromHandle");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsTransitionHostFromHandle(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkGetTransitionHost(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkGetTransitionHost == null) fn__networkGetTransitionHost = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkGetTransitionHost");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkGetTransitionHost(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkIsInTransition()
		{
			unsafe {
				if (fn__networkIsInTransition == null) fn__networkIsInTransition = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsInTransition");
				var result = fn__networkIsInTransition();
				return result;
			}
		}

		public bool NetworkIsTransitionStarted()
		{
			unsafe {
				if (fn__networkIsTransitionStarted == null) fn__networkIsTransitionStarted = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionStarted");
				var result = fn__networkIsTransitionStarted();
				return result;
			}
		}

		public bool NetworkIsTransitionBusy()
		{
			unsafe {
				if (fn__networkIsTransitionBusy == null) fn__networkIsTransitionBusy = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionBusy");
				var result = fn__networkIsTransitionBusy();
				return result;
			}
		}

		public bool NetworkIsTransitionMatchmaking()
		{
			unsafe {
				if (fn__networkIsTransitionMatchmaking == null) fn__networkIsTransitionMatchmaking = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionMatchmaking");
				var result = fn__networkIsTransitionMatchmaking();
				return result;
			}
		}

		public bool _0xC571D0E77D8BBC29()
		{
			unsafe {
				if (fn__0xC571D0E77D8BBC29 == null) fn__0xC571D0E77D8BBC29 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xC571D0E77D8BBC29");
				var result = fn__0xC571D0E77D8BBC29();
				return result;
			}
		}

		public void _0x1398582B7F72B3ED(int _p0)
		{
			unsafe {
				if (fn__0x1398582B7F72B3ED == null) fn__0x1398582B7F72B3ED = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x1398582B7F72B3ED");
				fn__0x1398582B7F72B3ED(_p0);
			}
		}

		public void _0x1F8E00FB18239600(int _p0)
		{
			unsafe {
				if (fn__0x1F8E00FB18239600 == null) fn__0x1F8E00FB18239600 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x1F8E00FB18239600");
				fn__0x1F8E00FB18239600(_p0);
			}
		}

		public void _0xF6F4383B7C92F11A(int _p0)
		{
			unsafe {
				if (fn__0xF6F4383B7C92F11A == null) fn__0xF6F4383B7C92F11A = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xF6F4383B7C92F11A");
				fn__0xF6F4383B7C92F11A(_p0);
			}
		}

		public void NetworkOpenTransitionMatchmaking()
		{
			unsafe {
				if (fn__networkOpenTransitionMatchmaking == null) fn__networkOpenTransitionMatchmaking = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkOpenTransitionMatchmaking");
				fn__networkOpenTransitionMatchmaking();
			}
		}

		public void NetworkCloseTransitionMatchmaking()
		{
			unsafe {
				if (fn__networkCloseTransitionMatchmaking == null) fn__networkCloseTransitionMatchmaking = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkCloseTransitionMatchmaking");
				fn__networkCloseTransitionMatchmaking();
			}
		}

		public bool NetworkIsTransitionOpenToMatchmaking()
		{
			unsafe {
				if (fn__networkIsTransitionOpenToMatchmaking == null) fn__networkIsTransitionOpenToMatchmaking = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionOpenToMatchmaking");
				var result = fn__networkIsTransitionOpenToMatchmaking();
				return result;
			}
		}

		public void NetworkSetTransitionVisibilityLock(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__networkSetTransitionVisibilityLock == null) fn__networkSetTransitionVisibilityLock = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetTransitionVisibilityLock");
				fn__networkSetTransitionVisibilityLock(_p0, _p1);
			}
		}

		public bool NetworkIsTransitionVisibilityLocked()
		{
			unsafe {
				if (fn__networkIsTransitionVisibilityLocked == null) fn__networkIsTransitionVisibilityLocked = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTransitionVisibilityLocked");
				var result = fn__networkIsTransitionVisibilityLocked();
				return result;
			}
		}

		public void NetworkSetTransitionActivityId(int _p0)
		{
			unsafe {
				if (fn__networkSetTransitionActivityId == null) fn__networkSetTransitionActivityId = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSetTransitionActivityId");
				fn__networkSetTransitionActivityId(_p0);
			}
		}

		public void NetworkChangeTransitionSlots(int _p0, int _p1)
		{
			unsafe {
				if (fn__networkChangeTransitionSlots == null) fn__networkChangeTransitionSlots = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkChangeTransitionSlots");
				fn__networkChangeTransitionSlots(_p0, _p1);
			}
		}

		public void _0x973D76AA760A6CB6(bool _p0)
		{
			unsafe {
				if (fn__0x973D76AA760A6CB6 == null) fn__0x973D76AA760A6CB6 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x973D76AA760A6CB6");
				fn__0x973D76AA760A6CB6(_p0);
			}
		}

		public bool NetworkHasPlayerStartedTransition(int _player)
		{
			unsafe {
				if (fn__networkHasPlayerStartedTransition == null) fn__networkHasPlayerStartedTransition = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkHasPlayerStartedTransition");
				var result = fn__networkHasPlayerStartedTransition(_player);
				return result;
			}
		}

		public bool NetworkAreTransitionDetailsValid(int _p0)
		{
			unsafe {
				if (fn__networkAreTransitionDetailsValid == null) fn__networkAreTransitionDetailsValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkAreTransitionDetailsValid");
				var result = fn__networkAreTransitionDetailsValid(_p0);
				return result;
			}
		}

		public bool NetworkJoinTransition(int _player)
		{
			unsafe {
				if (fn__networkJoinTransition == null) fn__networkJoinTransition = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkJoinTransition");
				var result = fn__networkJoinTransition(_player);
				return result;
			}
		}

		public bool NetworkHasInvitedGamerToTransition(ref int _p0)
		{
			unsafe {
				if (fn__networkHasInvitedGamerToTransition == null) fn__networkHasInvitedGamerToTransition = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkHasInvitedGamerToTransition");
				var ref_p0 = _p0;
				var result = fn__networkHasInvitedGamerToTransition(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool _0x3F9990BF5F22759C(ref int _p0)
		{
			unsafe {
				if (fn__0x3F9990BF5F22759C == null) fn__0x3F9990BF5F22759C = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native__0x3F9990BF5F22759C");
				var ref_p0 = _p0;
				var result = fn__0x3F9990BF5F22759C(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetworkIsActivitySession()
		{
			unsafe {
				if (fn__networkIsActivitySession == null) fn__networkIsActivitySession = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsActivitySession");
				var result = fn__networkIsActivitySession();
				return result;
			}
		}

		public void _0x4A9FDE3A5A6D0437(bool _toggle)
		{
			unsafe {
				if (fn__0x4A9FDE3A5A6D0437 == null) fn__0x4A9FDE3A5A6D0437 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x4A9FDE3A5A6D0437");
				fn__0x4A9FDE3A5A6D0437(_toggle);
			}
		}

		public bool NetworkSendInviteViaPresence(ref int _gamerHandle, ref int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSendInviteViaPresence == null) fn__networkSendInviteViaPresence = (delegate* unmanaged[Cdecl]<int*, int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkSendInviteViaPresence");
				var ref_gamerHandle = _gamerHandle;
				var ref_p1 = _p1;
				var result = fn__networkSendInviteViaPresence(&ref_gamerHandle, &ref_p1, _p2, _p3);
				_gamerHandle = ref_gamerHandle;
				_p1 = ref_p1;
				return result;
			}
		}

		public bool NetworkSendPresenceTransitionInvite(ref int _p0, ref int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSendPresenceTransitionInvite == null) fn__networkSendPresenceTransitionInvite = (delegate* unmanaged[Cdecl]<int*, int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkSendPresenceTransitionInvite");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__networkSendPresenceTransitionInvite(&ref_p0, &ref_p1, _p2, _p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public bool _0x1171A97A3D3981B6(ref int _p0, ref int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x1171A97A3D3981B6 == null) fn__0x1171A97A3D3981B6 = (delegate* unmanaged[Cdecl]<int*, int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native__0x1171A97A3D3981B6");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__0x1171A97A3D3981B6(&ref_p0, &ref_p1, _p2, _p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public int _0x742B58F723233ED9(int _p0)
		{
			unsafe {
				if (fn__0x742B58F723233ED9 == null) fn__0x742B58F723233ED9 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x742B58F723233ED9");
				var result = fn__0x742B58F723233ED9(_p0);
				return result;
			}
		}

		public int NetworkGetNumPresenceInvites()
		{
			unsafe {
				if (fn__networkGetNumPresenceInvites == null) fn__networkGetNumPresenceInvites = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetNumPresenceInvites");
				var result = fn__networkGetNumPresenceInvites();
				return result;
			}
		}

		public bool NetworkAcceptPresenceInvite(int _p0)
		{
			unsafe {
				if (fn__networkAcceptPresenceInvite == null) fn__networkAcceptPresenceInvite = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkAcceptPresenceInvite");
				var result = fn__networkAcceptPresenceInvite(_p0);
				return result;
			}
		}

		public bool NetworkRemovePresenceInvite(int _p0)
		{
			unsafe {
				if (fn__networkRemovePresenceInvite == null) fn__networkRemovePresenceInvite = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkRemovePresenceInvite");
				var result = fn__networkRemovePresenceInvite(_p0);
				return result;
			}
		}

		public int NetworkGetPresenceInviteId(int _p0)
		{
			unsafe {
				if (fn__networkGetPresenceInviteId == null) fn__networkGetPresenceInviteId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPresenceInviteId");
				var result = fn__networkGetPresenceInviteId(_p0);
				return result;
			}
		}

		public int NetworkGetPresenceInviteInviter(int _p0)
		{
			unsafe {
				if (fn__networkGetPresenceInviteInviter == null) fn__networkGetPresenceInviteInviter = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPresenceInviteInviter");
				var result = fn__networkGetPresenceInviteInviter(_p0);
				return result;
			}
		}

		public bool NetworkGetPresenceInviteHandle(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__networkGetPresenceInviteHandle == null) fn__networkGetPresenceInviteHandle = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkGetPresenceInviteHandle");
				var ref_p1 = _p1;
				var result = fn__networkGetPresenceInviteHandle(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public int NetworkGetPresenceInviteSessionId(int _p0)
		{
			unsafe {
				if (fn__networkGetPresenceInviteSessionId == null) fn__networkGetPresenceInviteSessionId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPresenceInviteSessionId");
				var result = fn__networkGetPresenceInviteSessionId(_p0);
				return result;
			}
		}

		public int NetworkGetPresenceInviteContentId(int _p0)
		{
			unsafe {
				if (fn__networkGetPresenceInviteContentId == null) fn__networkGetPresenceInviteContentId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPresenceInviteContentId");
				var result = fn__networkGetPresenceInviteContentId(_p0);
				return result;
			}
		}

		public int NetworkGetPresenceInvitePlaylistLength(int _p0)
		{
			unsafe {
				if (fn__networkGetPresenceInvitePlaylistLength == null) fn__networkGetPresenceInvitePlaylistLength = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPresenceInvitePlaylistLength");
				var result = fn__networkGetPresenceInvitePlaylistLength(_p0);
				return result;
			}
		}

		public int NetworkGetPresenceInvitePlaylistCurrent(int _p0)
		{
			unsafe {
				if (fn__networkGetPresenceInvitePlaylistCurrent == null) fn__networkGetPresenceInvitePlaylistCurrent = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPresenceInvitePlaylistCurrent");
				var result = fn__networkGetPresenceInvitePlaylistCurrent(_p0);
				return result;
			}
		}

		public bool NetworkGetPresenceInviteFromAdmin(int _p0)
		{
			unsafe {
				if (fn__networkGetPresenceInviteFromAdmin == null) fn__networkGetPresenceInviteFromAdmin = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetPresenceInviteFromAdmin");
				var result = fn__networkGetPresenceInviteFromAdmin(_p0);
				return result;
			}
		}

		public bool NetworkGetPresenceInviteIsTournament(int _p0)
		{
			unsafe {
				if (fn__networkGetPresenceInviteIsTournament == null) fn__networkGetPresenceInviteIsTournament = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetPresenceInviteIsTournament");
				var result = fn__networkGetPresenceInviteIsTournament(_p0);
				return result;
			}
		}

		public bool NetworkHasFollowInvite()
		{
			unsafe {
				if (fn__networkHasFollowInvite == null) fn__networkHasFollowInvite = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHasFollowInvite");
				var result = fn__networkHasFollowInvite();
				return result;
			}
		}

		public int NetworkActionFollowInvite()
		{
			unsafe {
				if (fn__networkActionFollowInvite == null) fn__networkActionFollowInvite = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkActionFollowInvite");
				var result = fn__networkActionFollowInvite();
				return result;
			}
		}

		public int NetworkClearFollowInvite()
		{
			unsafe {
				if (fn__networkClearFollowInvite == null) fn__networkClearFollowInvite = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkClearFollowInvite");
				var result = fn__networkClearFollowInvite();
				return result;
			}
		}

		public void _0xEBF8284D8CADEB53()
		{
			unsafe {
				if (fn__0xEBF8284D8CADEB53 == null) fn__0xEBF8284D8CADEB53 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xEBF8284D8CADEB53");
				fn__0xEBF8284D8CADEB53();
			}
		}

		public void NetworkRemoveTransitionInvite(ref int _p0)
		{
			unsafe {
				if (fn__networkRemoveTransitionInvite == null) fn__networkRemoveTransitionInvite = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_networkRemoveTransitionInvite");
				var ref_p0 = _p0;
				fn__networkRemoveTransitionInvite(&ref_p0);
				_p0 = ref_p0;
			}
		}

		public void NetworkRemoveAllTransitionInvite()
		{
			unsafe {
				if (fn__networkRemoveAllTransitionInvite == null) fn__networkRemoveAllTransitionInvite = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkRemoveAllTransitionInvite");
				fn__networkRemoveAllTransitionInvite();
			}
		}

		public void _0xF083835B70BA9BFE()
		{
			unsafe {
				if (fn__0xF083835B70BA9BFE == null) fn__0xF083835B70BA9BFE = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xF083835B70BA9BFE");
				fn__0xF083835B70BA9BFE();
			}
		}

		public bool NetworkInviteGamers(ref int _p0, int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__networkInviteGamers == null) fn__networkInviteGamers = (delegate* unmanaged[Cdecl]<int*, int, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkInviteGamers");
				var ref_p0 = _p0;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				var result = fn__networkInviteGamers(&ref_p0, _p1, &ref_p2, &ref_p3);
				_p0 = ref_p0;
				_p2 = ref_p2;
				_p3 = ref_p3;
				return result;
			}
		}

		public bool NetworkHasInvitedGamer(ref int _p0)
		{
			unsafe {
				if (fn__networkHasInvitedGamer == null) fn__networkHasInvitedGamer = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkHasInvitedGamer");
				var ref_p0 = _p0;
				var result = fn__networkHasInvitedGamer(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool _0x71DC455F5CD1C2B1(ref int _gamerHandle)
		{
			unsafe {
				if (fn__0x71DC455F5CD1C2B1 == null) fn__0x71DC455F5CD1C2B1 = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native__0x71DC455F5CD1C2B1");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__0x71DC455F5CD1C2B1(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public int _0x3855FB5EB2C5E8B2(int _p0)
		{
			unsafe {
				if (fn__0x3855FB5EB2C5E8B2 == null) fn__0x3855FB5EB2C5E8B2 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x3855FB5EB2C5E8B2");
				var result = fn__0x3855FB5EB2C5E8B2(_p0);
				return result;
			}
		}

		public bool NetworkGetCurrentlySelectedGamerHandleFromInviteMenu(ref int _p0)
		{
			unsafe {
				if (fn__networkGetCurrentlySelectedGamerHandleFromInviteMenu == null) fn__networkGetCurrentlySelectedGamerHandleFromInviteMenu = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkGetCurrentlySelectedGamerHandleFromInviteMenu");
				var ref_p0 = _p0;
				var result = fn__networkGetCurrentlySelectedGamerHandleFromInviteMenu(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetworkSetCurrentlySelectedGamerHandleFromInviteMenu(ref int _p0)
		{
			unsafe {
				if (fn__networkSetCurrentlySelectedGamerHandleFromInviteMenu == null) fn__networkSetCurrentlySelectedGamerHandleFromInviteMenu = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkSetCurrentlySelectedGamerHandleFromInviteMenu");
				var ref_p0 = _p0;
				var result = fn__networkSetCurrentlySelectedGamerHandleFromInviteMenu(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public void NetworkSetInviteOnCallForInviteMenu(ref int _p0)
		{
			unsafe {
				if (fn__networkSetInviteOnCallForInviteMenu == null) fn__networkSetInviteOnCallForInviteMenu = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_networkSetInviteOnCallForInviteMenu");
				var ref_p0 = _p0;
				fn__networkSetInviteOnCallForInviteMenu(&ref_p0);
				_p0 = ref_p0;
			}
		}

		public bool NetworkCheckDataManagerSucceededForHandle(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__networkCheckDataManagerSucceededForHandle == null) fn__networkCheckDataManagerSucceededForHandle = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkCheckDataManagerSucceededForHandle");
				var ref_p1 = _p1;
				var result = fn__networkCheckDataManagerSucceededForHandle(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public int _0x4AD490AE1536933B(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x4AD490AE1536933B == null) fn__0x4AD490AE1536933B = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x4AD490AE1536933B");
				var result = fn__0x4AD490AE1536933B(_p0, _p1);
				return result;
			}
		}

		public void _0x0D77A82DC2D0DA59(ref int _p0, ref int _p1)
		{
			unsafe {
				if (fn__0x0D77A82DC2D0DA59 == null) fn__0x0D77A82DC2D0DA59 = (delegate* unmanaged[Cdecl]<int*, int*, void>) NativeLibrary.GetExport(handle, "Native__0x0D77A82DC2D0DA59");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				fn__0x0D77A82DC2D0DA59(&ref_p0, &ref_p1);
				_p0 = ref_p0;
				_p1 = ref_p1;
			}
		}

		public bool FilloutPmPlayerList(ref int _gamerHandle, int _p1, int _p2)
		{
			unsafe {
				if (fn__filloutPmPlayerList == null) fn__filloutPmPlayerList = (delegate* unmanaged[Cdecl]<int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_filloutPmPlayerList");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__filloutPmPlayerList(&ref_gamerHandle, _p1, _p2);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool FilloutPmPlayerListWithNames(ref int _p0, ref int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__filloutPmPlayerListWithNames == null) fn__filloutPmPlayerListWithNames = (delegate* unmanaged[Cdecl]<int*, int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_filloutPmPlayerListWithNames");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__filloutPmPlayerListWithNames(&ref_p0, &ref_p1, _p2, _p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public bool RefreshPlayerListStats(int _p0)
		{
			unsafe {
				if (fn__refreshPlayerListStats == null) fn__refreshPlayerListStats = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_refreshPlayerListStats");
				var result = fn__refreshPlayerListStats(_p0);
				return result;
			}
		}

		public bool NetworkSetCurrentDataManagerHandle(ref int _p0)
		{
			unsafe {
				if (fn__networkSetCurrentDataManagerHandle == null) fn__networkSetCurrentDataManagerHandle = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkSetCurrentDataManagerHandle");
				var ref_p0 = _p0;
				var result = fn__networkSetCurrentDataManagerHandle(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetworkIsInPlatformParty()
		{
			unsafe {
				if (fn__networkIsInPlatformParty == null) fn__networkIsInPlatformParty = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsInPlatformParty");
				var result = fn__networkIsInPlatformParty();
				return result;
			}
		}

		public int NetworkGetPlatformPartyUnk()
		{
			unsafe {
				if (fn__networkGetPlatformPartyUnk == null) fn__networkGetPlatformPartyUnk = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetPlatformPartyUnk");
				var result = fn__networkGetPlatformPartyUnk();
				return result;
			}
		}

		public int NetworkGetPlatformPartyMembers(ref int _data, int _dataSize)
		{
			unsafe {
				if (fn__networkGetPlatformPartyMembers == null) fn__networkGetPlatformPartyMembers = (delegate* unmanaged[Cdecl]<int*, int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPlatformPartyMembers");
				var ref_data = _data;
				var result = fn__networkGetPlatformPartyMembers(&ref_data, _dataSize);
				_data = ref_data;
				return result;
			}
		}

		public bool NetworkIsInPlatformPartyChat()
		{
			unsafe {
				if (fn__networkIsInPlatformPartyChat == null) fn__networkIsInPlatformPartyChat = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsInPlatformPartyChat");
				var result = fn__networkIsInPlatformPartyChat();
				return result;
			}
		}

		public bool NetworkIsChattingInPlatformParty(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkIsChattingInPlatformParty == null) fn__networkIsChattingInPlatformParty = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsChattingInPlatformParty");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsChattingInPlatformParty(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public int _0x2BF66D2E7414F686()
		{
			unsafe {
				if (fn__0x2BF66D2E7414F686 == null) fn__0x2BF66D2E7414F686 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x2BF66D2E7414F686");
				var result = fn__0x2BF66D2E7414F686();
				return result;
			}
		}

		public bool _0x14922ED3E38761F0()
		{
			unsafe {
				if (fn__0x14922ED3E38761F0 == null) fn__0x14922ED3E38761F0 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x14922ED3E38761F0");
				var result = fn__0x14922ED3E38761F0();
				return result;
			}
		}

		public void _0x6CE50E47F5543D0C()
		{
			unsafe {
				if (fn__0x6CE50E47F5543D0C == null) fn__0x6CE50E47F5543D0C = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x6CE50E47F5543D0C");
				fn__0x6CE50E47F5543D0C();
			}
		}

		public void _0xFA2888E3833C8E96()
		{
			unsafe {
				if (fn__0xFA2888E3833C8E96 == null) fn__0xFA2888E3833C8E96 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xFA2888E3833C8E96");
				fn__0xFA2888E3833C8E96();
			}
		}

		public void _0x25D990F8E0E3F13C()
		{
			unsafe {
				if (fn__0x25D990F8E0E3F13C == null) fn__0x25D990F8E0E3F13C = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x25D990F8E0E3F13C");
				fn__0x25D990F8E0E3F13C();
			}
		}

		public void NetworkSeedRandomNumberGenerator(int _seed)
		{
			unsafe {
				if (fn__networkSeedRandomNumberGenerator == null) fn__networkSeedRandomNumberGenerator = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSeedRandomNumberGenerator");
				fn__networkSeedRandomNumberGenerator(_seed);
			}
		}

		public int NetworkGetRandomInt()
		{
			unsafe {
				if (fn__networkGetRandomInt == null) fn__networkGetRandomInt = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetRandomInt");
				var result = fn__networkGetRandomInt();
				return result;
			}
		}

		public int NetworkGetRandomIntRanged(int _rangeStart, int _rangeEnd)
		{
			unsafe {
				if (fn__networkGetRandomIntRanged == null) fn__networkGetRandomIntRanged = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_networkGetRandomIntRanged");
				var result = fn__networkGetRandomIntRanged(_rangeStart, _rangeEnd);
				return result;
			}
		}

		public bool NetworkPlayerIsCheater()
		{
			unsafe {
				if (fn__networkPlayerIsCheater == null) fn__networkPlayerIsCheater = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkPlayerIsCheater");
				var result = fn__networkPlayerIsCheater();
				return result;
			}
		}

		public int NetworkPlayerGetCheaterReason()
		{
			unsafe {
				if (fn__networkPlayerGetCheaterReason == null) fn__networkPlayerGetCheaterReason = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkPlayerGetCheaterReason");
				var result = fn__networkPlayerGetCheaterReason();
				return result;
			}
		}

		public bool NetworkPlayerIsBadsport()
		{
			unsafe {
				if (fn__networkPlayerIsBadsport == null) fn__networkPlayerIsBadsport = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkPlayerIsBadsport");
				var result = fn__networkPlayerIsBadsport();
				return result;
			}
		}

		public bool TriggerScriptCrcCheckOnPlayer(int _player, int _p1, int _scriptHash)
		{
			unsafe {
				if (fn__triggerScriptCrcCheckOnPlayer == null) fn__triggerScriptCrcCheckOnPlayer = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_triggerScriptCrcCheckOnPlayer");
				var result = fn__triggerScriptCrcCheckOnPlayer(_player, _p1, _scriptHash);
				return result;
			}
		}

		public int _0xA12D3A5A3753CC23()
		{
			unsafe {
				if (fn__0xA12D3A5A3753CC23 == null) fn__0xA12D3A5A3753CC23 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xA12D3A5A3753CC23");
				var result = fn__0xA12D3A5A3753CC23();
				return result;
			}
		}

		public int _0xF287F506767CC8A9()
		{
			unsafe {
				if (fn__0xF287F506767CC8A9 == null) fn__0xF287F506767CC8A9 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xF287F506767CC8A9");
				var result = fn__0xF287F506767CC8A9();
				return result;
			}
		}

		public bool RemoteCheatDetected(int _player, int _a, int _b)
		{
			unsafe {
				if (fn__remoteCheatDetected == null) fn__remoteCheatDetected = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_remoteCheatDetected");
				var result = fn__remoteCheatDetected(_player, _a, _b);
				return result;
			}
		}

		public bool BadSportPlayerLeftDetected(ref int _gamerHandle, int _event, int _amountReceived)
		{
			unsafe {
				if (fn__badSportPlayerLeftDetected == null) fn__badSportPlayerLeftDetected = (delegate* unmanaged[Cdecl]<int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_badSportPlayerLeftDetected");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__badSportPlayerLeftDetected(&ref_gamerHandle, _event, _amountReceived);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public void NetworkApplyPedScarData(int _ped, int _p1)
		{
			unsafe {
				if (fn__networkApplyPedScarData == null) fn__networkApplyPedScarData = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkApplyPedScarData");
				fn__networkApplyPedScarData(_ped, _p1);
			}
		}

		public void NetworkSetThisScriptIsNetworkScript(int _maxNumMissionParticipants, bool _p1, int _instanceId)
		{
			unsafe {
				if (fn__networkSetThisScriptIsNetworkScript == null) fn__networkSetThisScriptIsNetworkScript = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_networkSetThisScriptIsNetworkScript");
				fn__networkSetThisScriptIsNetworkScript(_maxNumMissionParticipants, _p1, _instanceId);
			}
		}

		public bool NetworkIsThisScriptMarked(int _p0, bool _p1, int _p2)
		{
			unsafe {
				if (fn__networkIsThisScriptMarked == null) fn__networkIsThisScriptMarked = (delegate* unmanaged[Cdecl]<int, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsThisScriptMarked");
				var result = fn__networkIsThisScriptMarked(_p0, _p1, _p2);
				return result;
			}
		}

		public bool NetworkGetThisScriptIsNetworkScript()
		{
			unsafe {
				if (fn__networkGetThisScriptIsNetworkScript == null) fn__networkGetThisScriptIsNetworkScript = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkGetThisScriptIsNetworkScript");
				var result = fn__networkGetThisScriptIsNetworkScript();
				return result;
			}
		}

		public int NetworkGetMaxNumParticipants()
		{
			unsafe {
				if (fn__networkGetMaxNumParticipants == null) fn__networkGetMaxNumParticipants = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetMaxNumParticipants");
				var result = fn__networkGetMaxNumParticipants();
				return result;
			}
		}

		public int NetworkGetNumParticipants()
		{
			unsafe {
				if (fn__networkGetNumParticipants == null) fn__networkGetNumParticipants = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetNumParticipants");
				var result = fn__networkGetNumParticipants();
				return result;
			}
		}

		public int NetworkGetScriptStatus()
		{
			unsafe {
				if (fn__networkGetScriptStatus == null) fn__networkGetScriptStatus = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetScriptStatus");
				var result = fn__networkGetScriptStatus();
				return result;
			}
		}

		public void NetworkRegisterHostBroadcastVariables(ref int _unkVars, int _numVars)
		{
			unsafe {
				if (fn__networkRegisterHostBroadcastVariables == null) fn__networkRegisterHostBroadcastVariables = (delegate* unmanaged[Cdecl]<int*, int, void>) NativeLibrary.GetExport(handle, "Native_networkRegisterHostBroadcastVariables");
				var ref_unkVars = _unkVars;
				fn__networkRegisterHostBroadcastVariables(&ref_unkVars, _numVars);
				_unkVars = ref_unkVars;
			}
		}

		public void NetworkRegisterPlayerBroadcastVariables(ref int _unkVars, int _numVars)
		{
			unsafe {
				if (fn__networkRegisterPlayerBroadcastVariables == null) fn__networkRegisterPlayerBroadcastVariables = (delegate* unmanaged[Cdecl]<int*, int, void>) NativeLibrary.GetExport(handle, "Native_networkRegisterPlayerBroadcastVariables");
				var ref_unkVars = _unkVars;
				fn__networkRegisterPlayerBroadcastVariables(&ref_unkVars, _numVars);
				_unkVars = ref_unkVars;
			}
		}

		public void _0xEA8C0DDB10E2822A(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xEA8C0DDB10E2822A == null) fn__0xEA8C0DDB10E2822A = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xEA8C0DDB10E2822A");
				fn__0xEA8C0DDB10E2822A(_p0, _p1);
			}
		}

		public void _0xD6D7478CA62B8D41(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xD6D7478CA62B8D41 == null) fn__0xD6D7478CA62B8D41 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xD6D7478CA62B8D41");
				fn__0xD6D7478CA62B8D41(_p0, _p1);
			}
		}

		public void NetworkFinishBroadcastingData()
		{
			unsafe {
				if (fn__networkFinishBroadcastingData == null) fn__networkFinishBroadcastingData = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkFinishBroadcastingData");
				fn__networkFinishBroadcastingData();
			}
		}

		public bool NetworkHasReceivedHostBroadcastData()
		{
			unsafe {
				if (fn__networkHasReceivedHostBroadcastData == null) fn__networkHasReceivedHostBroadcastData = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHasReceivedHostBroadcastData");
				var result = fn__networkHasReceivedHostBroadcastData();
				return result;
			}
		}

		public int NetworkGetPlayerIndex(int _player)
		{
			unsafe {
				if (fn__networkGetPlayerIndex == null) fn__networkGetPlayerIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPlayerIndex");
				var result = fn__networkGetPlayerIndex(_player);
				return result;
			}
		}

		public int NetworkGetParticipantIndex(int _index)
		{
			unsafe {
				if (fn__networkGetParticipantIndex == null) fn__networkGetParticipantIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetParticipantIndex");
				var result = fn__networkGetParticipantIndex(_index);
				return result;
			}
		}

		public int NetworkGetPlayerIndexFromPed(int _ped)
		{
			unsafe {
				if (fn__networkGetPlayerIndexFromPed == null) fn__networkGetPlayerIndexFromPed = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPlayerIndexFromPed");
				var result = fn__networkGetPlayerIndexFromPed(_ped);
				return result;
			}
		}

		public int NetworkGetNumConnectedPlayers()
		{
			unsafe {
				if (fn__networkGetNumConnectedPlayers == null) fn__networkGetNumConnectedPlayers = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetNumConnectedPlayers");
				var result = fn__networkGetNumConnectedPlayers();
				return result;
			}
		}

		public bool NetworkIsPlayerConnected(int _player)
		{
			unsafe {
				if (fn__networkIsPlayerConnected == null) fn__networkIsPlayerConnected = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerConnected");
				var result = fn__networkIsPlayerConnected(_player);
				return result;
			}
		}

		public int NetworkGetTotalNumPlayers()
		{
			unsafe {
				if (fn__networkGetTotalNumPlayers == null) fn__networkGetTotalNumPlayers = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetTotalNumPlayers");
				var result = fn__networkGetTotalNumPlayers();
				return result;
			}
		}

		public bool NetworkIsParticipantActive(int _p0)
		{
			unsafe {
				if (fn__networkIsParticipantActive == null) fn__networkIsParticipantActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsParticipantActive");
				var result = fn__networkIsParticipantActive(_p0);
				return result;
			}
		}

		public bool NetworkIsPlayerActive(int _player)
		{
			unsafe {
				if (fn__networkIsPlayerActive == null) fn__networkIsPlayerActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerActive");
				var result = fn__networkIsPlayerActive(_player);
				return result;
			}
		}

		public bool NetworkIsPlayerAParticipant(int _player)
		{
			unsafe {
				if (fn__networkIsPlayerAParticipant == null) fn__networkIsPlayerAParticipant = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerAParticipant");
				var result = fn__networkIsPlayerAParticipant(_player);
				return result;
			}
		}

		public bool NetworkIsHostOfThisScript()
		{
			unsafe {
				if (fn__networkIsHostOfThisScript == null) fn__networkIsHostOfThisScript = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsHostOfThisScript");
				var result = fn__networkIsHostOfThisScript();
				return result;
			}
		}

		public int NetworkGetHostOfThisScript()
		{
			unsafe {
				if (fn__networkGetHostOfThisScript == null) fn__networkGetHostOfThisScript = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetHostOfThisScript");
				var result = fn__networkGetHostOfThisScript();
				return result;
			}
		}

		public int NetworkGetHostOfScript(string _scriptName, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkGetHostOfScript == null) fn__networkGetHostOfScript = (delegate* unmanaged[Cdecl]<nint, int, int, int>) NativeLibrary.GetExport(handle, "Native_networkGetHostOfScript");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				var result = fn__networkGetHostOfScript(ptr_scriptName, _p1, _p2);
				Marshal.FreeHGlobal(ptr_scriptName);
				return result;
			}
		}

		public void NetworkSetMissionFinished()
		{
			unsafe {
				if (fn__networkSetMissionFinished == null) fn__networkSetMissionFinished = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkSetMissionFinished");
				fn__networkSetMissionFinished();
			}
		}

		public bool NetworkIsScriptActive(string _scriptName, int _player, bool _p2, int _p3)
		{
			unsafe {
				if (fn__networkIsScriptActive == null) fn__networkIsScriptActive = (delegate* unmanaged[Cdecl]<nint, int, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsScriptActive");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				var result = fn__networkIsScriptActive(ptr_scriptName, _player, _p2, _p3);
				Marshal.FreeHGlobal(ptr_scriptName);
				return result;
			}
		}

		public bool NetworkIsScriptActiveByHash(int _scriptHash, int _p1, bool _p2, int _p3)
		{
			unsafe {
				if (fn__networkIsScriptActiveByHash == null) fn__networkIsScriptActiveByHash = (delegate* unmanaged[Cdecl]<int, int, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsScriptActiveByHash");
				var result = fn__networkIsScriptActiveByHash(_scriptHash, _p1, _p2, _p3);
				return result;
			}
		}

		public int _0x560B423D73015E77(int _p0)
		{
			unsafe {
				if (fn__0x560B423D73015E77 == null) fn__0x560B423D73015E77 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x560B423D73015E77");
				var result = fn__0x560B423D73015E77(_p0);
				return result;
			}
		}

		public int NetworkGetNumScriptParticipants(ref int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkGetNumScriptParticipants == null) fn__networkGetNumScriptParticipants = (delegate* unmanaged[Cdecl]<int*, int, int, int>) NativeLibrary.GetExport(handle, "Native_networkGetNumScriptParticipants");
				var ref_p0 = _p0;
				var result = fn__networkGetNumScriptParticipants(&ref_p0, _p1, _p2);
				_p0 = ref_p0;
				return result;
			}
		}

		public int NetworkGetInstanceIdOfThisScript()
		{
			unsafe {
				if (fn__networkGetInstanceIdOfThisScript == null) fn__networkGetInstanceIdOfThisScript = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetInstanceIdOfThisScript");
				var result = fn__networkGetInstanceIdOfThisScript();
				return result;
			}
		}

		public int NetworkGetPositionHashOfThisScript()
		{
			unsafe {
				if (fn__networkGetPositionHashOfThisScript == null) fn__networkGetPositionHashOfThisScript = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetPositionHashOfThisScript");
				var result = fn__networkGetPositionHashOfThisScript();
				return result;
			}
		}

		public bool NetworkIsPlayerAParticipantOnScript(int _player1, string _script, int _player2)
		{
			unsafe {
				if (fn__networkIsPlayerAParticipantOnScript == null) fn__networkIsPlayerAParticipantOnScript = (delegate* unmanaged[Cdecl]<int, nint, int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerAParticipantOnScript");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				var result = fn__networkIsPlayerAParticipantOnScript(_player1, ptr_script, _player2);
				Marshal.FreeHGlobal(ptr_script);
				return result;
			}
		}

		public void _0x2302C0264EA58D31()
		{
			unsafe {
				if (fn__0x2302C0264EA58D31 == null) fn__0x2302C0264EA58D31 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x2302C0264EA58D31");
				fn__0x2302C0264EA58D31();
			}
		}

		public void _0x741A3D8380319A81()
		{
			unsafe {
				if (fn__0x741A3D8380319A81 == null) fn__0x741A3D8380319A81 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x741A3D8380319A81");
				fn__0x741A3D8380319A81();
			}
		}

		public int ParticipantId()
		{
			unsafe {
				if (fn__participantId == null) fn__participantId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_participantId");
				var result = fn__participantId();
				return result;
			}
		}

		public int ParticipantIdToInt()
		{
			unsafe {
				if (fn__participantIdToInt == null) fn__participantIdToInt = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_participantIdToInt");
				var result = fn__participantIdToInt();
				return result;
			}
		}

		public int _0x2DA41ED6E1FCD7A5(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x2DA41ED6E1FCD7A5 == null) fn__0x2DA41ED6E1FCD7A5 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x2DA41ED6E1FCD7A5");
				var result = fn__0x2DA41ED6E1FCD7A5(_p0, _p1);
				return result;
			}
		}

		public int NetworkGetDestroyerOfNetworkId(int _netId, ref int _weaponHash)
		{
			unsafe {
				if (fn__networkGetDestroyerOfNetworkId == null) fn__networkGetDestroyerOfNetworkId = (delegate* unmanaged[Cdecl]<int, int*, int>) NativeLibrary.GetExport(handle, "Native_networkGetDestroyerOfNetworkId");
				var ref_weaponHash = _weaponHash;
				var result = fn__networkGetDestroyerOfNetworkId(_netId, &ref_weaponHash);
				_weaponHash = ref_weaponHash;
				return result;
			}
		}

		public int _0xC434133D9BA52777(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xC434133D9BA52777 == null) fn__0xC434133D9BA52777 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0xC434133D9BA52777");
				var result = fn__0xC434133D9BA52777(_p0, _p1);
				return result;
			}
		}

		public int _0x83660B734994124D(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x83660B734994124D == null) fn__0x83660B734994124D = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x83660B734994124D");
				var result = fn__0x83660B734994124D(_p0, _p1, _p2);
				return result;
			}
		}

		public bool NetworkGetDestroyerOfEntity(int _p0, int _p1, ref int _weaponHash)
		{
			unsafe {
				if (fn__networkGetDestroyerOfEntity == null) fn__networkGetDestroyerOfEntity = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkGetDestroyerOfEntity");
				var ref_weaponHash = _weaponHash;
				var result = fn__networkGetDestroyerOfEntity(_p0, _p1, &ref_weaponHash);
				_weaponHash = ref_weaponHash;
				return result;
			}
		}

		public int NetworkGetEntityKillerOfPlayer(int _player, ref int _weaponHash)
		{
			unsafe {
				if (fn__networkGetEntityKillerOfPlayer == null) fn__networkGetEntityKillerOfPlayer = (delegate* unmanaged[Cdecl]<int, int*, int>) NativeLibrary.GetExport(handle, "Native_networkGetEntityKillerOfPlayer");
				var ref_weaponHash = _weaponHash;
				var result = fn__networkGetEntityKillerOfPlayer(_player, &ref_weaponHash);
				_weaponHash = ref_weaponHash;
				return result;
			}
		}

		public void NetworkResurrectLocalPlayer(float _x, float _y, float _z, float _heading, bool _unk, bool _changetime, int _p6)
		{
			unsafe {
				if (fn__networkResurrectLocalPlayer == null) fn__networkResurrectLocalPlayer = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_networkResurrectLocalPlayer");
				fn__networkResurrectLocalPlayer(_x, _y, _z, _heading, _unk, _changetime, _p6);
			}
		}

		public void NetworkSetLocalPlayerInvincibleTime(int _time)
		{
			unsafe {
				if (fn__networkSetLocalPlayerInvincibleTime == null) fn__networkSetLocalPlayerInvincibleTime = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSetLocalPlayerInvincibleTime");
				fn__networkSetLocalPlayerInvincibleTime(_time);
			}
		}

		public bool NetworkIsLocalPlayerInvincible()
		{
			unsafe {
				if (fn__networkIsLocalPlayerInvincible == null) fn__networkIsLocalPlayerInvincible = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsLocalPlayerInvincible");
				var result = fn__networkIsLocalPlayerInvincible();
				return result;
			}
		}

		public void NetworkDisableInvincibleFlashing(int _player, bool _toggle)
		{
			unsafe {
				if (fn__networkDisableInvincibleFlashing == null) fn__networkDisableInvincibleFlashing = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkDisableInvincibleFlashing");
				fn__networkDisableInvincibleFlashing(_player, _toggle);
			}
		}

		public void NetworkPedForceGameStateUpdate(int _ped)
		{
			unsafe {
				if (fn__networkPedForceGameStateUpdate == null) fn__networkPedForceGameStateUpdate = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkPedForceGameStateUpdate");
				fn__networkPedForceGameStateUpdate(_ped);
			}
		}

		public void NetworkSetLocalPlayerSyncLookAt(bool _toggle)
		{
			unsafe {
				if (fn__networkSetLocalPlayerSyncLookAt == null) fn__networkSetLocalPlayerSyncLookAt = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetLocalPlayerSyncLookAt");
				fn__networkSetLocalPlayerSyncLookAt(_toggle);
			}
		}

		public bool NetworkHasEntityBeenRegisteredWithThisThread(int _entity)
		{
			unsafe {
				if (fn__networkHasEntityBeenRegisteredWithThisThread == null) fn__networkHasEntityBeenRegisteredWithThisThread = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkHasEntityBeenRegisteredWithThisThread");
				var result = fn__networkHasEntityBeenRegisteredWithThisThread(_entity);
				return result;
			}
		}

		public int NetworkGetNetworkIdFromEntity(int _entity)
		{
			unsafe {
				if (fn__networkGetNetworkIdFromEntity == null) fn__networkGetNetworkIdFromEntity = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetNetworkIdFromEntity");
				var result = fn__networkGetNetworkIdFromEntity(_entity);
				return result;
			}
		}

		public int NetworkGetEntityFromNetworkId(int _netId)
		{
			unsafe {
				if (fn__networkGetEntityFromNetworkId == null) fn__networkGetEntityFromNetworkId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetEntityFromNetworkId");
				var result = fn__networkGetEntityFromNetworkId(_netId);
				return result;
			}
		}

		public bool NetworkGetEntityIsNetworked(int _entity)
		{
			unsafe {
				if (fn__networkGetEntityIsNetworked == null) fn__networkGetEntityIsNetworked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetEntityIsNetworked");
				var result = fn__networkGetEntityIsNetworked(_entity);
				return result;
			}
		}

		public bool NetworkGetEntityIsLocal(int _entity)
		{
			unsafe {
				if (fn__networkGetEntityIsLocal == null) fn__networkGetEntityIsLocal = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetEntityIsLocal");
				var result = fn__networkGetEntityIsLocal(_entity);
				return result;
			}
		}

		public void NetworkRegisterEntityAsNetworked(int _entity)
		{
			unsafe {
				if (fn__networkRegisterEntityAsNetworked == null) fn__networkRegisterEntityAsNetworked = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkRegisterEntityAsNetworked");
				fn__networkRegisterEntityAsNetworked(_entity);
			}
		}

		public void NetworkUnregisterNetworkedEntity(int _entity)
		{
			unsafe {
				if (fn__networkUnregisterNetworkedEntity == null) fn__networkUnregisterNetworkedEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkUnregisterNetworkedEntity");
				fn__networkUnregisterNetworkedEntity(_entity);
			}
		}

		public bool NetworkDoesNetworkIdExist(int _netId)
		{
			unsafe {
				if (fn__networkDoesNetworkIdExist == null) fn__networkDoesNetworkIdExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkDoesNetworkIdExist");
				var result = fn__networkDoesNetworkIdExist(_netId);
				return result;
			}
		}

		public bool NetworkDoesEntityExistWithNetworkId(int _netId)
		{
			unsafe {
				if (fn__networkDoesEntityExistWithNetworkId == null) fn__networkDoesEntityExistWithNetworkId = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkDoesEntityExistWithNetworkId");
				var result = fn__networkDoesEntityExistWithNetworkId(_netId);
				return result;
			}
		}

		public bool NetworkRequestControlOfNetworkId(int _netId)
		{
			unsafe {
				if (fn__networkRequestControlOfNetworkId == null) fn__networkRequestControlOfNetworkId = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkRequestControlOfNetworkId");
				var result = fn__networkRequestControlOfNetworkId(_netId);
				return result;
			}
		}

		public bool NetworkHasControlOfNetworkId(int _netId)
		{
			unsafe {
				if (fn__networkHasControlOfNetworkId == null) fn__networkHasControlOfNetworkId = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkHasControlOfNetworkId");
				var result = fn__networkHasControlOfNetworkId(_netId);
				return result;
			}
		}

		public bool NetworkIsNetworkIdAClone(int _netId)
		{
			unsafe {
				if (fn__networkIsNetworkIdAClone == null) fn__networkIsNetworkIdAClone = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsNetworkIdAClone");
				var result = fn__networkIsNetworkIdAClone(_netId);
				return result;
			}
		}

		public bool NetworkRequestControlOfEntity(int _entity)
		{
			unsafe {
				if (fn__networkRequestControlOfEntity == null) fn__networkRequestControlOfEntity = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkRequestControlOfEntity");
				var result = fn__networkRequestControlOfEntity(_entity);
				return result;
			}
		}

		public bool NetworkRequestControlOfDoor(int _doorID)
		{
			unsafe {
				if (fn__networkRequestControlOfDoor == null) fn__networkRequestControlOfDoor = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkRequestControlOfDoor");
				var result = fn__networkRequestControlOfDoor(_doorID);
				return result;
			}
		}

		public bool NetworkHasControlOfEntity(int _entity)
		{
			unsafe {
				if (fn__networkHasControlOfEntity == null) fn__networkHasControlOfEntity = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkHasControlOfEntity");
				var result = fn__networkHasControlOfEntity(_entity);
				return result;
			}
		}

		public bool NetworkHasControlOfPickup(int _pickup)
		{
			unsafe {
				if (fn__networkHasControlOfPickup == null) fn__networkHasControlOfPickup = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkHasControlOfPickup");
				var result = fn__networkHasControlOfPickup(_pickup);
				return result;
			}
		}

		public bool NetworkHasControlOfDoor(int _doorHash)
		{
			unsafe {
				if (fn__networkHasControlOfDoor == null) fn__networkHasControlOfDoor = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkHasControlOfDoor");
				var result = fn__networkHasControlOfDoor(_doorHash);
				return result;
			}
		}

		public bool NetworkIsDoorNetworked(int _doorHash)
		{
			unsafe {
				if (fn__networkIsDoorNetworked == null) fn__networkIsDoorNetworked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsDoorNetworked");
				var result = fn__networkIsDoorNetworked(_doorHash);
				return result;
			}
		}

		public int VehToNet(int _vehicle)
		{
			unsafe {
				if (fn__vehToNet == null) fn__vehToNet = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_vehToNet");
				var result = fn__vehToNet(_vehicle);
				return result;
			}
		}

		public int PedToNet(int _ped)
		{
			unsafe {
				if (fn__pedToNet == null) fn__pedToNet = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_pedToNet");
				var result = fn__pedToNet(_ped);
				return result;
			}
		}

		public int ObjToNet(int _object)
		{
			unsafe {
				if (fn__objToNet == null) fn__objToNet = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_objToNet");
				var result = fn__objToNet(_object);
				return result;
			}
		}

		public int NetToVeh(int _netHandle)
		{
			unsafe {
				if (fn__netToVeh == null) fn__netToVeh = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_netToVeh");
				var result = fn__netToVeh(_netHandle);
				return result;
			}
		}

		public int NetToPed(int _netHandle)
		{
			unsafe {
				if (fn__netToPed == null) fn__netToPed = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_netToPed");
				var result = fn__netToPed(_netHandle);
				return result;
			}
		}

		public int NetToObj(int _netHandle)
		{
			unsafe {
				if (fn__netToObj == null) fn__netToObj = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_netToObj");
				var result = fn__netToObj(_netHandle);
				return result;
			}
		}

		public int NetToEnt(int _netHandle)
		{
			unsafe {
				if (fn__netToEnt == null) fn__netToEnt = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_netToEnt");
				var result = fn__netToEnt(_netHandle);
				return result;
			}
		}

		public void NetworkGetLocalHandle(ref int _gamerHandle, int _gamerHandleSize)
		{
			unsafe {
				if (fn__networkGetLocalHandle == null) fn__networkGetLocalHandle = (delegate* unmanaged[Cdecl]<int*, int, void>) NativeLibrary.GetExport(handle, "Native_networkGetLocalHandle");
				var ref_gamerHandle = _gamerHandle;
				fn__networkGetLocalHandle(&ref_gamerHandle, _gamerHandleSize);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public void NetworkHandleFromUserId(string _userId, ref int _gamerHandle, int _gamerHandleSize)
		{
			unsafe {
				if (fn__networkHandleFromUserId == null) fn__networkHandleFromUserId = (delegate* unmanaged[Cdecl]<nint, int*, int, void>) NativeLibrary.GetExport(handle, "Native_networkHandleFromUserId");
				var ptr_userId = MemoryUtils.StringToHGlobalUtf8(_userId);
				var ref_gamerHandle = _gamerHandle;
				fn__networkHandleFromUserId(ptr_userId, &ref_gamerHandle, _gamerHandleSize);
				Marshal.FreeHGlobal(ptr_userId);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public void NetworkHandleFromMemberId(string _memberId, ref int _gamerHandle, int _gamerHandleSize)
		{
			unsafe {
				if (fn__networkHandleFromMemberId == null) fn__networkHandleFromMemberId = (delegate* unmanaged[Cdecl]<nint, int*, int, void>) NativeLibrary.GetExport(handle, "Native_networkHandleFromMemberId");
				var ptr_memberId = MemoryUtils.StringToHGlobalUtf8(_memberId);
				var ref_gamerHandle = _gamerHandle;
				fn__networkHandleFromMemberId(ptr_memberId, &ref_gamerHandle, _gamerHandleSize);
				Marshal.FreeHGlobal(ptr_memberId);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public void NetworkHandleFromPlayer(int _player, ref int _gamerHandle, int _gamerHandleSize)
		{
			unsafe {
				if (fn__networkHandleFromPlayer == null) fn__networkHandleFromPlayer = (delegate* unmanaged[Cdecl]<int, int*, int, void>) NativeLibrary.GetExport(handle, "Native_networkHandleFromPlayer");
				var ref_gamerHandle = _gamerHandle;
				fn__networkHandleFromPlayer(_player, &ref_gamerHandle, _gamerHandleSize);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public int NetworkHashFromPlayerHandle(int _player)
		{
			unsafe {
				if (fn__networkHashFromPlayerHandle == null) fn__networkHashFromPlayerHandle = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkHashFromPlayerHandle");
				var result = fn__networkHashFromPlayerHandle(_player);
				return result;
			}
		}

		public int NetworkHashFromGamerHandle(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkHashFromGamerHandle == null) fn__networkHashFromGamerHandle = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_networkHashFromGamerHandle");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkHashFromGamerHandle(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public void NetworkHandleFromFriend(int _friendIndex, ref int _gamerHandle, int _gamerHandleSize)
		{
			unsafe {
				if (fn__networkHandleFromFriend == null) fn__networkHandleFromFriend = (delegate* unmanaged[Cdecl]<int, int*, int, void>) NativeLibrary.GetExport(handle, "Native_networkHandleFromFriend");
				var ref_gamerHandle = _gamerHandle;
				fn__networkHandleFromFriend(_friendIndex, &ref_gamerHandle, _gamerHandleSize);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public bool NetworkGamertagFromHandleStart(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkGamertagFromHandleStart == null) fn__networkGamertagFromHandleStart = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkGamertagFromHandleStart");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkGamertagFromHandleStart(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkGamertagFromHandlePending()
		{
			unsafe {
				if (fn__networkGamertagFromHandlePending == null) fn__networkGamertagFromHandlePending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkGamertagFromHandlePending");
				var result = fn__networkGamertagFromHandlePending();
				return result;
			}
		}

		public bool NetworkGamertagFromHandleSucceeded()
		{
			unsafe {
				if (fn__networkGamertagFromHandleSucceeded == null) fn__networkGamertagFromHandleSucceeded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkGamertagFromHandleSucceeded");
				var result = fn__networkGamertagFromHandleSucceeded();
				return result;
			}
		}

		public string NetworkGetGamertagFromHandle(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkGetGamertagFromHandle == null) fn__networkGetGamertagFromHandle = (delegate* unmanaged[Cdecl]<int*, nint>) NativeLibrary.GetExport(handle, "Native_networkGetGamertagFromHandle");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkGetGamertagFromHandle(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int NetworkDisplaynamesFromHandlesStart(ref int _p0, int _p1)
		{
			unsafe {
				if (fn__networkDisplaynamesFromHandlesStart == null) fn__networkDisplaynamesFromHandlesStart = (delegate* unmanaged[Cdecl]<int*, int, int>) NativeLibrary.GetExport(handle, "Native_networkDisplaynamesFromHandlesStart");
				var ref_p0 = _p0;
				var result = fn__networkDisplaynamesFromHandlesStart(&ref_p0, _p1);
				_p0 = ref_p0;
				return result;
			}
		}

		public int NetworkGetDisplaynamesFromHandles(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__networkGetDisplaynamesFromHandles == null) fn__networkGetDisplaynamesFromHandles = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_networkGetDisplaynamesFromHandles");
				var result = fn__networkGetDisplaynamesFromHandles(_p0, _p1, _p2);
				return result;
			}
		}

		public bool NetworkAreHandlesTheSame(ref int _gamerHandle1, ref int _gamerHandle2)
		{
			unsafe {
				if (fn__networkAreHandlesTheSame == null) fn__networkAreHandlesTheSame = (delegate* unmanaged[Cdecl]<int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkAreHandlesTheSame");
				var ref_gamerHandle1 = _gamerHandle1;
				var ref_gamerHandle2 = _gamerHandle2;
				var result = fn__networkAreHandlesTheSame(&ref_gamerHandle1, &ref_gamerHandle2);
				_gamerHandle1 = ref_gamerHandle1;
				_gamerHandle2 = ref_gamerHandle2;
				return result;
			}
		}

		public bool NetworkIsHandleValid(ref int _gamerHandle, int _gamerHandleSize)
		{
			unsafe {
				if (fn__networkIsHandleValid == null) fn__networkIsHandleValid = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsHandleValid");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsHandleValid(&ref_gamerHandle, _gamerHandleSize);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public int NetworkGetPlayerFromGamerHandle(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkGetPlayerFromGamerHandle == null) fn__networkGetPlayerFromGamerHandle = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_networkGetPlayerFromGamerHandle");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkGetPlayerFromGamerHandle(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public string NetworkMemberIdFromGamerHandle(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkMemberIdFromGamerHandle == null) fn__networkMemberIdFromGamerHandle = (delegate* unmanaged[Cdecl]<int*, nint>) NativeLibrary.GetExport(handle, "Native_networkMemberIdFromGamerHandle");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkMemberIdFromGamerHandle(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool NetworkIsGamerInMySession(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkIsGamerInMySession == null) fn__networkIsGamerInMySession = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsGamerInMySession");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsGamerInMySession(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public void NetworkShowProfileUi(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkShowProfileUi == null) fn__networkShowProfileUi = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_networkShowProfileUi");
				var ref_gamerHandle = _gamerHandle;
				fn__networkShowProfileUi(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public string NetworkPlayerGetName(int _player)
		{
			unsafe {
				if (fn__networkPlayerGetName == null) fn__networkPlayerGetName = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_networkPlayerGetName");
				var result = fn__networkPlayerGetName(_player);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string NetworkPlayerGetUserid(int _player, ref int _userID)
		{
			unsafe {
				if (fn__networkPlayerGetUserid == null) fn__networkPlayerGetUserid = (delegate* unmanaged[Cdecl]<int, int*, nint>) NativeLibrary.GetExport(handle, "Native_networkPlayerGetUserid");
				var ref_userID = _userID;
				var result = fn__networkPlayerGetUserid(_player, &ref_userID);
				_userID = ref_userID;
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool NetworkPlayerIsRockstarDev(int _player)
		{
			unsafe {
				if (fn__networkPlayerIsRockstarDev == null) fn__networkPlayerIsRockstarDev = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkPlayerIsRockstarDev");
				var result = fn__networkPlayerIsRockstarDev(_player);
				return result;
			}
		}

		public bool NetworkPlayerIndexIsCheater(int _player)
		{
			unsafe {
				if (fn__networkPlayerIndexIsCheater == null) fn__networkPlayerIndexIsCheater = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkPlayerIndexIsCheater");
				var result = fn__networkPlayerIndexIsCheater(_player);
				return result;
			}
		}

		public int NetworkGetEntityNetScriptId(int _entity)
		{
			unsafe {
				if (fn__networkGetEntityNetScriptId == null) fn__networkGetEntityNetScriptId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetEntityNetScriptId");
				var result = fn__networkGetEntityNetScriptId(_entity);
				return result;
			}
		}

		public int _0x37D5F739FD494675(int _p0)
		{
			unsafe {
				if (fn__0x37D5F739FD494675 == null) fn__0x37D5F739FD494675 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x37D5F739FD494675");
				var result = fn__0x37D5F739FD494675(_p0);
				return result;
			}
		}

		public bool NetworkIsInactiveProfile(ref int _p0)
		{
			unsafe {
				if (fn__networkIsInactiveProfile == null) fn__networkIsInactiveProfile = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsInactiveProfile");
				var ref_p0 = _p0;
				var result = fn__networkIsInactiveProfile(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public int NetworkGetMaxFriends()
		{
			unsafe {
				if (fn__networkGetMaxFriends == null) fn__networkGetMaxFriends = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetMaxFriends");
				var result = fn__networkGetMaxFriends();
				return result;
			}
		}

		public int NetworkGetFriendCount()
		{
			unsafe {
				if (fn__networkGetFriendCount == null) fn__networkGetFriendCount = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetFriendCount");
				var result = fn__networkGetFriendCount();
				return result;
			}
		}

		public string NetworkGetFriendName(int _friendIndex)
		{
			unsafe {
				if (fn__networkGetFriendName == null) fn__networkGetFriendName = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_networkGetFriendName");
				var result = fn__networkGetFriendName(_friendIndex);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string NetworkGetFriendNameFromIndex(int _friendIndex)
		{
			unsafe {
				if (fn__networkGetFriendNameFromIndex == null) fn__networkGetFriendNameFromIndex = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_networkGetFriendNameFromIndex");
				var result = fn__networkGetFriendNameFromIndex(_friendIndex);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool NetworkIsFriendOnline(string _name)
		{
			unsafe {
				if (fn__networkIsFriendOnline == null) fn__networkIsFriendOnline = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_networkIsFriendOnline");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__networkIsFriendOnline(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public bool NetworkIsFriendHandleOnline(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkIsFriendHandleOnline == null) fn__networkIsFriendHandleOnline = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsFriendHandleOnline");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsFriendHandleOnline(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkIsFriendInSameTitle(string _friendName)
		{
			unsafe {
				if (fn__networkIsFriendInSameTitle == null) fn__networkIsFriendInSameTitle = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_networkIsFriendInSameTitle");
				var ptr_friendName = MemoryUtils.StringToHGlobalUtf8(_friendName);
				var result = fn__networkIsFriendInSameTitle(ptr_friendName);
				Marshal.FreeHGlobal(ptr_friendName);
				return result;
			}
		}

		public bool NetworkIsFriendInMultiplayer(string _friendName)
		{
			unsafe {
				if (fn__networkIsFriendInMultiplayer == null) fn__networkIsFriendInMultiplayer = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_networkIsFriendInMultiplayer");
				var ptr_friendName = MemoryUtils.StringToHGlobalUtf8(_friendName);
				var result = fn__networkIsFriendInMultiplayer(ptr_friendName);
				Marshal.FreeHGlobal(ptr_friendName);
				return result;
			}
		}

		public bool NetworkIsFriend(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkIsFriend == null) fn__networkIsFriend = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsFriend");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsFriend(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public int NetworkIsPendingFriend(int _p0)
		{
			unsafe {
				if (fn__networkIsPendingFriend == null) fn__networkIsPendingFriend = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkIsPendingFriend");
				var result = fn__networkIsPendingFriend(_p0);
				return result;
			}
		}

		public int NetworkIsAddingFriend()
		{
			unsafe {
				if (fn__networkIsAddingFriend == null) fn__networkIsAddingFriend = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkIsAddingFriend");
				var result = fn__networkIsAddingFriend();
				return result;
			}
		}

		public bool NetworkAddFriend(ref int _gamerHandle, string _message)
		{
			unsafe {
				if (fn__networkAddFriend == null) fn__networkAddFriend = (delegate* unmanaged[Cdecl]<int*, nint, bool>) NativeLibrary.GetExport(handle, "Native_networkAddFriend");
				var ref_gamerHandle = _gamerHandle;
				var ptr_message = MemoryUtils.StringToHGlobalUtf8(_message);
				var result = fn__networkAddFriend(&ref_gamerHandle, ptr_message);
				_gamerHandle = ref_gamerHandle;
				Marshal.FreeHGlobal(ptr_message);
				return result;
			}
		}

		public bool NetworkIsFriendIndexOnline(int _friendIndex)
		{
			unsafe {
				if (fn__networkIsFriendIndexOnline == null) fn__networkIsFriendIndexOnline = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsFriendIndexOnline");
				var result = fn__networkIsFriendIndexOnline(_friendIndex);
				return result;
			}
		}

		public void NetworkSetPlayerIsPassive(bool _toggle)
		{
			unsafe {
				if (fn__networkSetPlayerIsPassive == null) fn__networkSetPlayerIsPassive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetPlayerIsPassive");
				fn__networkSetPlayerIsPassive(_toggle);
			}
		}

		public bool NetworkGetPlayerOwnsWaypoint(int _player)
		{
			unsafe {
				if (fn__networkGetPlayerOwnsWaypoint == null) fn__networkGetPlayerOwnsWaypoint = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetPlayerOwnsWaypoint");
				var result = fn__networkGetPlayerOwnsWaypoint(_player);
				return result;
			}
		}

		public bool NetworkCanSetWaypoint()
		{
			unsafe {
				if (fn__networkCanSetWaypoint == null) fn__networkCanSetWaypoint = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkCanSetWaypoint");
				var result = fn__networkCanSetWaypoint();
				return result;
			}
		}

		public void _0x4C2A9FDC22377075()
		{
			unsafe {
				if (fn__0x4C2A9FDC22377075 == null) fn__0x4C2A9FDC22377075 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x4C2A9FDC22377075");
				fn__0x4C2A9FDC22377075();
			}
		}

		public int _0xB309EBEA797E001F(int _p0)
		{
			unsafe {
				if (fn__0xB309EBEA797E001F == null) fn__0xB309EBEA797E001F = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xB309EBEA797E001F");
				var result = fn__0xB309EBEA797E001F(_p0);
				return result;
			}
		}

		public int _0x26F07DD83A5F7F98()
		{
			unsafe {
				if (fn__0x26F07DD83A5F7F98 == null) fn__0x26F07DD83A5F7F98 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x26F07DD83A5F7F98");
				var result = fn__0x26F07DD83A5F7F98();
				return result;
			}
		}

		public bool NetworkHasHeadset()
		{
			unsafe {
				if (fn__networkHasHeadset == null) fn__networkHasHeadset = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHasHeadset");
				var result = fn__networkHasHeadset();
				return result;
			}
		}

		public void _0x7D395EA61622E116(bool _p0)
		{
			unsafe {
				if (fn__0x7D395EA61622E116 == null) fn__0x7D395EA61622E116 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x7D395EA61622E116");
				fn__0x7D395EA61622E116(_p0);
			}
		}

		public bool NetworkIsLocalTalking()
		{
			unsafe {
				if (fn__networkIsLocalTalking == null) fn__networkIsLocalTalking = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsLocalTalking");
				var result = fn__networkIsLocalTalking();
				return result;
			}
		}

		public bool NetworkGamerHasHeadset(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkGamerHasHeadset == null) fn__networkGamerHasHeadset = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkGamerHasHeadset");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkGamerHasHeadset(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkIsGamerTalking(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkIsGamerTalking == null) fn__networkIsGamerTalking = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsGamerTalking");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsGamerTalking(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkCanCommunicateWithGamer2(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkCanCommunicateWithGamer2 == null) fn__networkCanCommunicateWithGamer2 = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkCanCommunicateWithGamer2");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkCanCommunicateWithGamer2(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkCanCommunicateWithGamer(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkCanCommunicateWithGamer == null) fn__networkCanCommunicateWithGamer = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkCanCommunicateWithGamer");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkCanCommunicateWithGamer(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkIsGamerMutedByMe(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkIsGamerMutedByMe == null) fn__networkIsGamerMutedByMe = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsGamerMutedByMe");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsGamerMutedByMe(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkAmIMutedByGamer(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkAmIMutedByGamer == null) fn__networkAmIMutedByGamer = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkAmIMutedByGamer");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkAmIMutedByGamer(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkIsGamerBlockedByMe(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkIsGamerBlockedByMe == null) fn__networkIsGamerBlockedByMe = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkIsGamerBlockedByMe");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkIsGamerBlockedByMe(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkAmIBlockedByGamer(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkAmIBlockedByGamer == null) fn__networkAmIBlockedByGamer = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkAmIBlockedByGamer");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkAmIBlockedByGamer(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkCanViewGamerUserContent(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkCanViewGamerUserContent == null) fn__networkCanViewGamerUserContent = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkCanViewGamerUserContent");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkCanViewGamerUserContent(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkHasViewGamerUserContentResult(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkHasViewGamerUserContentResult == null) fn__networkHasViewGamerUserContentResult = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkHasViewGamerUserContentResult");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkHasViewGamerUserContentResult(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkCanPlayMultiplayerWithGamer(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkCanPlayMultiplayerWithGamer == null) fn__networkCanPlayMultiplayerWithGamer = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkCanPlayMultiplayerWithGamer");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkCanPlayMultiplayerWithGamer(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkCanGamerPlayMultiplayerWithMe(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkCanGamerPlayMultiplayerWithMe == null) fn__networkCanGamerPlayMultiplayerWithMe = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkCanGamerPlayMultiplayerWithMe");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkCanGamerPlayMultiplayerWithMe(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkIsPlayerTalking(int _player)
		{
			unsafe {
				if (fn__networkIsPlayerTalking == null) fn__networkIsPlayerTalking = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerTalking");
				var result = fn__networkIsPlayerTalking(_player);
				return result;
			}
		}

		public bool NetworkPlayerHasHeadset(int _player)
		{
			unsafe {
				if (fn__networkPlayerHasHeadset == null) fn__networkPlayerHasHeadset = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkPlayerHasHeadset");
				var result = fn__networkPlayerHasHeadset(_player);
				return result;
			}
		}

		public bool NetworkIsPlayerMutedByMe(int _player)
		{
			unsafe {
				if (fn__networkIsPlayerMutedByMe == null) fn__networkIsPlayerMutedByMe = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerMutedByMe");
				var result = fn__networkIsPlayerMutedByMe(_player);
				return result;
			}
		}

		public bool NetworkAmIMutedByPlayer(int _player)
		{
			unsafe {
				if (fn__networkAmIMutedByPlayer == null) fn__networkAmIMutedByPlayer = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkAmIMutedByPlayer");
				var result = fn__networkAmIMutedByPlayer(_player);
				return result;
			}
		}

		public bool NetworkIsPlayerBlockedByMe(int _player)
		{
			unsafe {
				if (fn__networkIsPlayerBlockedByMe == null) fn__networkIsPlayerBlockedByMe = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerBlockedByMe");
				var result = fn__networkIsPlayerBlockedByMe(_player);
				return result;
			}
		}

		public bool NetworkAmIBlockedByPlayer(int _player)
		{
			unsafe {
				if (fn__networkAmIBlockedByPlayer == null) fn__networkAmIBlockedByPlayer = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkAmIBlockedByPlayer");
				var result = fn__networkAmIBlockedByPlayer(_player);
				return result;
			}
		}

		public float NetworkGetPlayerLoudness(int _player)
		{
			unsafe {
				if (fn__networkGetPlayerLoudness == null) fn__networkGetPlayerLoudness = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_networkGetPlayerLoudness");
				var result = fn__networkGetPlayerLoudness(_player);
				return result;
			}
		}

		public void NetworkSetTalkerProximity(float _value)
		{
			unsafe {
				if (fn__networkSetTalkerProximity == null) fn__networkSetTalkerProximity = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_networkSetTalkerProximity");
				fn__networkSetTalkerProximity(_value);
			}
		}

		public float NetworkGetTalkerProximity()
		{
			unsafe {
				if (fn__networkGetTalkerProximity == null) fn__networkGetTalkerProximity = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_networkGetTalkerProximity");
				var result = fn__networkGetTalkerProximity();
				return result;
			}
		}

		public void NetworkSetVoiceActive(bool _toggle)
		{
			unsafe {
				if (fn__networkSetVoiceActive == null) fn__networkSetVoiceActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetVoiceActive");
				fn__networkSetVoiceActive(_toggle);
			}
		}

		public void _0xCFEB46DCD7D8D5EB(bool _p0)
		{
			unsafe {
				if (fn__0xCFEB46DCD7D8D5EB == null) fn__0xCFEB46DCD7D8D5EB = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xCFEB46DCD7D8D5EB");
				fn__0xCFEB46DCD7D8D5EB(_p0);
			}
		}

		public void NetworkOverrideTransitionChat(bool _p0)
		{
			unsafe {
				if (fn__networkOverrideTransitionChat == null) fn__networkOverrideTransitionChat = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideTransitionChat");
				fn__networkOverrideTransitionChat(_p0);
			}
		}

		public void NetworkSetTeamOnlyChat(bool _toggle)
		{
			unsafe {
				if (fn__networkSetTeamOnlyChat == null) fn__networkSetTeamOnlyChat = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetTeamOnlyChat");
				fn__networkSetTeamOnlyChat(_toggle);
			}
		}

		public void _0x265559DA40B3F327(int _p0)
		{
			unsafe {
				if (fn__0x265559DA40B3F327 == null) fn__0x265559DA40B3F327 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x265559DA40B3F327");
				fn__0x265559DA40B3F327(_p0);
			}
		}

		public int _0x4348BFDA56023A2F(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x4348BFDA56023A2F == null) fn__0x4348BFDA56023A2F = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x4348BFDA56023A2F");
				var result = fn__0x4348BFDA56023A2F(_p0, _p1);
				return result;
			}
		}

		public void NetworkOverrideTeamRestrictions(int _team, bool _toggle)
		{
			unsafe {
				if (fn__networkOverrideTeamRestrictions == null) fn__networkOverrideTeamRestrictions = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideTeamRestrictions");
				fn__networkOverrideTeamRestrictions(_team, _toggle);
			}
		}

		public void NetworkSetOverrideSpectatorMode(bool _toggle)
		{
			unsafe {
				if (fn__networkSetOverrideSpectatorMode == null) fn__networkSetOverrideSpectatorMode = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetOverrideSpectatorMode");
				fn__networkSetOverrideSpectatorMode(_toggle);
			}
		}

		public void _0x3C5C1E2C2FF814B1(bool _toggle)
		{
			unsafe {
				if (fn__0x3C5C1E2C2FF814B1 == null) fn__0x3C5C1E2C2FF814B1 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x3C5C1E2C2FF814B1");
				fn__0x3C5C1E2C2FF814B1(_toggle);
			}
		}

		public void _0x9D7AFCBF21C51712(bool _toggle)
		{
			unsafe {
				if (fn__0x9D7AFCBF21C51712 == null) fn__0x9D7AFCBF21C51712 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x9D7AFCBF21C51712");
				fn__0x9D7AFCBF21C51712(_toggle);
			}
		}

		public void NetworkSetNoSpectatorChat(bool _toggle)
		{
			unsafe {
				if (fn__networkSetNoSpectatorChat == null) fn__networkSetNoSpectatorChat = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetNoSpectatorChat");
				fn__networkSetNoSpectatorChat(_toggle);
			}
		}

		public void _0x6A5D89D7769A40D8(bool _toggle)
		{
			unsafe {
				if (fn__0x6A5D89D7769A40D8 == null) fn__0x6A5D89D7769A40D8 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x6A5D89D7769A40D8");
				fn__0x6A5D89D7769A40D8(_toggle);
			}
		}

		public void NetworkOverrideChatRestrictions(int _player, bool _toggle)
		{
			unsafe {
				if (fn__networkOverrideChatRestrictions == null) fn__networkOverrideChatRestrictions = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideChatRestrictions");
				fn__networkOverrideChatRestrictions(_player, _toggle);
			}
		}

		public void NetworkOverrideSendRestrictions(int _player, bool _toggle)
		{
			unsafe {
				if (fn__networkOverrideSendRestrictions == null) fn__networkOverrideSendRestrictions = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideSendRestrictions");
				fn__networkOverrideSendRestrictions(_player, _toggle);
			}
		}

		public void NetworkOverrideSendRestrictionsAll(bool _toggle)
		{
			unsafe {
				if (fn__networkOverrideSendRestrictionsAll == null) fn__networkOverrideSendRestrictionsAll = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideSendRestrictionsAll");
				fn__networkOverrideSendRestrictionsAll(_toggle);
			}
		}

		public void NetworkOverrideReceiveRestrictions(int _player, bool _toggle)
		{
			unsafe {
				if (fn__networkOverrideReceiveRestrictions == null) fn__networkOverrideReceiveRestrictions = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideReceiveRestrictions");
				fn__networkOverrideReceiveRestrictions(_player, _toggle);
			}
		}

		public void NetworkOverrideReceiveRestrictionsAll(bool _toggle)
		{
			unsafe {
				if (fn__networkOverrideReceiveRestrictionsAll == null) fn__networkOverrideReceiveRestrictionsAll = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideReceiveRestrictionsAll");
				fn__networkOverrideReceiveRestrictionsAll(_toggle);
			}
		}

		public void NetworkSetVoiceChannel(int _channel)
		{
			unsafe {
				if (fn__networkSetVoiceChannel == null) fn__networkSetVoiceChannel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSetVoiceChannel");
				fn__networkSetVoiceChannel(_channel);
			}
		}

		public void NetworkClearVoiceChannel()
		{
			unsafe {
				if (fn__networkClearVoiceChannel == null) fn__networkClearVoiceChannel = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkClearVoiceChannel");
				fn__networkClearVoiceChannel();
			}
		}

		public void NetworkApplyVoiceProximityOverride(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__networkApplyVoiceProximityOverride == null) fn__networkApplyVoiceProximityOverride = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_networkApplyVoiceProximityOverride");
				fn__networkApplyVoiceProximityOverride(_x, _y, _z);
			}
		}

		public void NetworkClearVoiceProximityOverride()
		{
			unsafe {
				if (fn__networkClearVoiceProximityOverride == null) fn__networkClearVoiceProximityOverride = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkClearVoiceProximityOverride");
				fn__networkClearVoiceProximityOverride();
			}
		}

		public void _0x5E3AA4CA2B6FB0EE(int _p0)
		{
			unsafe {
				if (fn__0x5E3AA4CA2B6FB0EE == null) fn__0x5E3AA4CA2B6FB0EE = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x5E3AA4CA2B6FB0EE");
				fn__0x5E3AA4CA2B6FB0EE(_p0);
			}
		}

		public void _0xCA575C391FEA25CC(int _p0)
		{
			unsafe {
				if (fn__0xCA575C391FEA25CC == null) fn__0xCA575C391FEA25CC = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xCA575C391FEA25CC");
				fn__0xCA575C391FEA25CC(_p0);
			}
		}

		public void _0xADB57E5B663CCA8B(int _p0, ref float _p1, ref float _p2)
		{
			unsafe {
				if (fn__0xADB57E5B663CCA8B == null) fn__0xADB57E5B663CCA8B = (delegate* unmanaged[Cdecl]<int, float*, float*, void>) NativeLibrary.GetExport(handle, "Native__0xADB57E5B663CCA8B");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				fn__0xADB57E5B663CCA8B(_p0, &ref_p1, &ref_p2);
				_p1 = ref_p1;
				_p2 = ref_p2;
			}
		}

		public void _0x8EF52ACAECC51D9C(bool _toggle)
		{
			unsafe {
				if (fn__0x8EF52ACAECC51D9C == null) fn__0x8EF52ACAECC51D9C = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x8EF52ACAECC51D9C");
				fn__0x8EF52ACAECC51D9C(_toggle);
			}
		}

		public bool NetworkIsTextChatActive()
		{
			unsafe {
				if (fn__networkIsTextChatActive == null) fn__networkIsTextChatActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTextChatActive");
				var result = fn__networkIsTextChatActive();
				return result;
			}
		}

		public void ShutdownAndLaunchSinglePlayerGame()
		{
			unsafe {
				if (fn__shutdownAndLaunchSinglePlayerGame == null) fn__shutdownAndLaunchSinglePlayerGame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_shutdownAndLaunchSinglePlayerGame");
				fn__shutdownAndLaunchSinglePlayerGame();
			}
		}

		public bool ShutdownAndLoadMostRecentSave()
		{
			unsafe {
				if (fn__shutdownAndLoadMostRecentSave == null) fn__shutdownAndLoadMostRecentSave = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_shutdownAndLoadMostRecentSave");
				var result = fn__shutdownAndLoadMostRecentSave();
				return result;
			}
		}

		public void NetworkSetFriendlyFireOption(bool _toggle)
		{
			unsafe {
				if (fn__networkSetFriendlyFireOption == null) fn__networkSetFriendlyFireOption = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetFriendlyFireOption");
				fn__networkSetFriendlyFireOption(_toggle);
			}
		}

		public void NetworkSetRichPresence(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__networkSetRichPresence == null) fn__networkSetRichPresence = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkSetRichPresence");
				fn__networkSetRichPresence(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkSetRichPresenceString(int _p0, string _textLabel)
		{
			unsafe {
				if (fn__networkSetRichPresenceString == null) fn__networkSetRichPresenceString = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_networkSetRichPresenceString");
				var ptr_textLabel = MemoryUtils.StringToHGlobalUtf8(_textLabel);
				fn__networkSetRichPresenceString(_p0, ptr_textLabel);
				Marshal.FreeHGlobal(ptr_textLabel);
			}
		}

		public int NetworkGetTimeoutTime()
		{
			unsafe {
				if (fn__networkGetTimeoutTime == null) fn__networkGetTimeoutTime = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetTimeoutTime");
				var result = fn__networkGetTimeoutTime();
				return result;
			}
		}

		public void NetworkLeavePedBehindBeforeWarp(int _player, float _x, float _y, float _z, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__networkLeavePedBehindBeforeWarp == null) fn__networkLeavePedBehindBeforeWarp = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkLeavePedBehindBeforeWarp");
				fn__networkLeavePedBehindBeforeWarp(_player, _x, _y, _z, _p4, _p5);
			}
		}

		public void NetworkLeavePedBehindBeforeCutscene(int _player, bool _p1)
		{
			unsafe {
				if (fn__networkLeavePedBehindBeforeCutscene == null) fn__networkLeavePedBehindBeforeCutscene = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkLeavePedBehindBeforeCutscene");
				fn__networkLeavePedBehindBeforeCutscene(_player, _p1);
			}
		}

		public void RemoveAllStickyBombsFromEntity(int _entity, int _ped)
		{
			unsafe {
				if (fn__removeAllStickyBombsFromEntity == null) fn__removeAllStickyBombsFromEntity = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_removeAllStickyBombsFromEntity");
				fn__removeAllStickyBombsFromEntity(_entity, _ped);
			}
		}

		public void _0x17C9E241111A674D(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x17C9E241111A674D == null) fn__0x17C9E241111A674D = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x17C9E241111A674D");
				fn__0x17C9E241111A674D(_p0, _p1);
			}
		}

		public int _0x2E4C123D1C8A710E(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__0x2E4C123D1C8A710E == null) fn__0x2E4C123D1C8A710E = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x2E4C123D1C8A710E");
				var result = fn__0x2E4C123D1C8A710E(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
				return result;
			}
		}

		public bool NetworkClanServiceIsValid()
		{
			unsafe {
				if (fn__networkClanServiceIsValid == null) fn__networkClanServiceIsValid = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkClanServiceIsValid");
				var result = fn__networkClanServiceIsValid();
				return result;
			}
		}

		public bool NetworkClanPlayerIsActive(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkClanPlayerIsActive == null) fn__networkClanPlayerIsActive = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkClanPlayerIsActive");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkClanPlayerIsActive(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkClanPlayerGetDesc(ref int _clanDesc, int _bufferSize, ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkClanPlayerGetDesc == null) fn__networkClanPlayerGetDesc = (delegate* unmanaged[Cdecl]<int*, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkClanPlayerGetDesc");
				var ref_clanDesc = _clanDesc;
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkClanPlayerGetDesc(&ref_clanDesc, _bufferSize, &ref_gamerHandle);
				_clanDesc = ref_clanDesc;
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkClanIsRockstarClan(ref int _clanDesc, int _bufferSize)
		{
			unsafe {
				if (fn__networkClanIsRockstarClan == null) fn__networkClanIsRockstarClan = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_networkClanIsRockstarClan");
				var ref_clanDesc = _clanDesc;
				var result = fn__networkClanIsRockstarClan(&ref_clanDesc, _bufferSize);
				_clanDesc = ref_clanDesc;
				return result;
			}
		}

		public void NetworkClanGetUiFormattedTag(ref int _clanDesc, int _bufferSize, ref string _formattedTag)
		{
			unsafe {
				if (fn__networkClanGetUiFormattedTag == null) fn__networkClanGetUiFormattedTag = (delegate* unmanaged[Cdecl]<int*, int, nint*, void>) NativeLibrary.GetExport(handle, "Native_networkClanGetUiFormattedTag");
				var ref_clanDesc = _clanDesc;
				var ptr_formattedTag = MemoryUtils.StringToHGlobalUtf8(_formattedTag);
				var ref_formattedTag = ptr_formattedTag;
				fn__networkClanGetUiFormattedTag(&ref_clanDesc, _bufferSize, &ref_formattedTag);
				_clanDesc = ref_clanDesc;
				_formattedTag = Marshal.PtrToStringUTF8(ref_formattedTag);
				freeString(ref_formattedTag);
				Marshal.FreeHGlobal(ptr_formattedTag);
			}
		}

		public int NetworkClanGetLocalMembershipsCount()
		{
			unsafe {
				if (fn__networkClanGetLocalMembershipsCount == null) fn__networkClanGetLocalMembershipsCount = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkClanGetLocalMembershipsCount");
				var result = fn__networkClanGetLocalMembershipsCount();
				return result;
			}
		}

		public bool NetworkClanGetMembershipDesc(ref int _memberDesc, int _p1)
		{
			unsafe {
				if (fn__networkClanGetMembershipDesc == null) fn__networkClanGetMembershipDesc = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_networkClanGetMembershipDesc");
				var ref_memberDesc = _memberDesc;
				var result = fn__networkClanGetMembershipDesc(&ref_memberDesc, _p1);
				_memberDesc = ref_memberDesc;
				return result;
			}
		}

		public bool NetworkClanDownloadMembership(ref int _gamerHandle)
		{
			unsafe {
				if (fn__networkClanDownloadMembership == null) fn__networkClanDownloadMembership = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkClanDownloadMembership");
				var ref_gamerHandle = _gamerHandle;
				var result = fn__networkClanDownloadMembership(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
				return result;
			}
		}

		public bool NetworkClanDownloadMembershipPending(ref int _p0)
		{
			unsafe {
				if (fn__networkClanDownloadMembershipPending == null) fn__networkClanDownloadMembershipPending = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkClanDownloadMembershipPending");
				var ref_p0 = _p0;
				var result = fn__networkClanDownloadMembershipPending(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetworkClanAnyDownloadMembershipPending()
		{
			unsafe {
				if (fn__networkClanAnyDownloadMembershipPending == null) fn__networkClanAnyDownloadMembershipPending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkClanAnyDownloadMembershipPending");
				var result = fn__networkClanAnyDownloadMembershipPending();
				return result;
			}
		}

		public bool NetworkClanRemoteMembershipsAreInCache(ref int _p0)
		{
			unsafe {
				if (fn__networkClanRemoteMembershipsAreInCache == null) fn__networkClanRemoteMembershipsAreInCache = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_networkClanRemoteMembershipsAreInCache");
				var ref_p0 = _p0;
				var result = fn__networkClanRemoteMembershipsAreInCache(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public int NetworkClanGetMembershipCount(ref int _p0)
		{
			unsafe {
				if (fn__networkClanGetMembershipCount == null) fn__networkClanGetMembershipCount = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_networkClanGetMembershipCount");
				var ref_p0 = _p0;
				var result = fn__networkClanGetMembershipCount(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetworkClanGetMembershipValid(ref int _p0, int _p1)
		{
			unsafe {
				if (fn__networkClanGetMembershipValid == null) fn__networkClanGetMembershipValid = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_networkClanGetMembershipValid");
				var ref_p0 = _p0;
				var result = fn__networkClanGetMembershipValid(&ref_p0, _p1);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool NetworkClanGetMembership(ref int _p0, ref int _clanMembership, int _p2)
		{
			unsafe {
				if (fn__networkClanGetMembership == null) fn__networkClanGetMembership = (delegate* unmanaged[Cdecl]<int*, int*, int, bool>) NativeLibrary.GetExport(handle, "Native_networkClanGetMembership");
				var ref_p0 = _p0;
				var ref_clanMembership = _clanMembership;
				var result = fn__networkClanGetMembership(&ref_p0, &ref_clanMembership, _p2);
				_p0 = ref_p0;
				_clanMembership = ref_clanMembership;
				return result;
			}
		}

		public bool NetworkClanJoin(int _clanDesc)
		{
			unsafe {
				if (fn__networkClanJoin == null) fn__networkClanJoin = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkClanJoin");
				var result = fn__networkClanJoin(_clanDesc);
				return result;
			}
		}

		public bool NetworkClanAnimation(string _animDict, string _animName)
		{
			unsafe {
				if (fn__networkClanAnimation == null) fn__networkClanAnimation = (delegate* unmanaged[Cdecl]<nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_networkClanAnimation");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var result = fn__networkClanAnimation(ptr_animDict, ptr_animName);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				return result;
			}
		}

		public bool _0x2B51EDBEFC301339(int _p0, string _p1)
		{
			unsafe {
				if (fn__0x2B51EDBEFC301339 == null) fn__0x2B51EDBEFC301339 = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native__0x2B51EDBEFC301339");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var result = fn__0x2B51EDBEFC301339(_p0, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
				return result;
			}
		}

		public int _0xC32EA7A2F6CA7557()
		{
			unsafe {
				if (fn__0xC32EA7A2F6CA7557 == null) fn__0xC32EA7A2F6CA7557 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xC32EA7A2F6CA7557");
				var result = fn__0xC32EA7A2F6CA7557();
				return result;
			}
		}

		public bool NetworkClanGetEmblemTxdName(ref int _netHandle, ref string _txdName)
		{
			unsafe {
				if (fn__networkClanGetEmblemTxdName == null) fn__networkClanGetEmblemTxdName = (delegate* unmanaged[Cdecl]<int*, nint*, bool>) NativeLibrary.GetExport(handle, "Native_networkClanGetEmblemTxdName");
				var ref_netHandle = _netHandle;
				var ptr_txdName = MemoryUtils.StringToHGlobalUtf8(_txdName);
				var ref_txdName = ptr_txdName;
				var result = fn__networkClanGetEmblemTxdName(&ref_netHandle, &ref_txdName);
				_netHandle = ref_netHandle;
				_txdName = Marshal.PtrToStringUTF8(ref_txdName);
				freeString(ref_txdName);
				Marshal.FreeHGlobal(ptr_txdName);
				return result;
			}
		}

		public bool NetworkClanRequestEmblem(int _p0)
		{
			unsafe {
				if (fn__networkClanRequestEmblem == null) fn__networkClanRequestEmblem = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkClanRequestEmblem");
				var result = fn__networkClanRequestEmblem(_p0);
				return result;
			}
		}

		public bool NetworkClanIsEmblemReady(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__networkClanIsEmblemReady == null) fn__networkClanIsEmblemReady = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkClanIsEmblemReady");
				var ref_p1 = _p1;
				var result = fn__networkClanIsEmblemReady(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public void NetworkClanReleaseEmblem(int _p0)
		{
			unsafe {
				if (fn__networkClanReleaseEmblem == null) fn__networkClanReleaseEmblem = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkClanReleaseEmblem");
				fn__networkClanReleaseEmblem(_p0);
			}
		}

		public int NetworkGetPrimaryClanDataClear()
		{
			unsafe {
				if (fn__networkGetPrimaryClanDataClear == null) fn__networkGetPrimaryClanDataClear = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetPrimaryClanDataClear");
				var result = fn__networkGetPrimaryClanDataClear();
				return result;
			}
		}

		public void NetworkGetPrimaryClanDataCancel()
		{
			unsafe {
				if (fn__networkGetPrimaryClanDataCancel == null) fn__networkGetPrimaryClanDataCancel = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkGetPrimaryClanDataCancel");
				fn__networkGetPrimaryClanDataCancel();
			}
		}

		public bool NetworkGetPrimaryClanDataStart(ref int _p0, int _p1)
		{
			unsafe {
				if (fn__networkGetPrimaryClanDataStart == null) fn__networkGetPrimaryClanDataStart = (delegate* unmanaged[Cdecl]<int*, int, bool>) NativeLibrary.GetExport(handle, "Native_networkGetPrimaryClanDataStart");
				var ref_p0 = _p0;
				var result = fn__networkGetPrimaryClanDataStart(&ref_p0, _p1);
				_p0 = ref_p0;
				return result;
			}
		}

		public int NetworkGetPrimaryClanDataPending()
		{
			unsafe {
				if (fn__networkGetPrimaryClanDataPending == null) fn__networkGetPrimaryClanDataPending = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetPrimaryClanDataPending");
				var result = fn__networkGetPrimaryClanDataPending();
				return result;
			}
		}

		public int NetworkGetPrimaryClanDataSuccess()
		{
			unsafe {
				if (fn__networkGetPrimaryClanDataSuccess == null) fn__networkGetPrimaryClanDataSuccess = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetPrimaryClanDataSuccess");
				var result = fn__networkGetPrimaryClanDataSuccess();
				return result;
			}
		}

		public bool NetworkGetPrimaryClanDataNew(ref int _p0, ref int _p1)
		{
			unsafe {
				if (fn__networkGetPrimaryClanDataNew == null) fn__networkGetPrimaryClanDataNew = (delegate* unmanaged[Cdecl]<int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkGetPrimaryClanDataNew");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__networkGetPrimaryClanDataNew(&ref_p0, &ref_p1);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public void SetNetworkIdCanMigrate(int _netId, bool _toggle)
		{
			unsafe {
				if (fn__setNetworkIdCanMigrate == null) fn__setNetworkIdCanMigrate = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setNetworkIdCanMigrate");
				fn__setNetworkIdCanMigrate(_netId, _toggle);
			}
		}

		public void SetNetworkIdExistsOnAllMachines(int _netId, bool _toggle)
		{
			unsafe {
				if (fn__setNetworkIdExistsOnAllMachines == null) fn__setNetworkIdExistsOnAllMachines = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setNetworkIdExistsOnAllMachines");
				fn__setNetworkIdExistsOnAllMachines(_netId, _toggle);
			}
		}

		public void SetNetworkIdAlwaysExistsForPlayer(int _netId, int _player, bool _toggle)
		{
			unsafe {
				if (fn__setNetworkIdAlwaysExistsForPlayer == null) fn__setNetworkIdAlwaysExistsForPlayer = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setNetworkIdAlwaysExistsForPlayer");
				fn__setNetworkIdAlwaysExistsForPlayer(_netId, _player, _toggle);
			}
		}

		public void _0x9D724B400A7E8FFC(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x9D724B400A7E8FFC == null) fn__0x9D724B400A7E8FFC = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x9D724B400A7E8FFC");
				fn__0x9D724B400A7E8FFC(_p0, _p1);
			}
		}

		public void NetworkSetEntityCanBlend(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__networkSetEntityCanBlend == null) fn__networkSetEntityCanBlend = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetEntityCanBlend");
				fn__networkSetEntityCanBlend(_entity, _toggle);
			}
		}

		public void _0x0379DAF89BA09AA5(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x0379DAF89BA09AA5 == null) fn__0x0379DAF89BA09AA5 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0379DAF89BA09AA5");
				fn__0x0379DAF89BA09AA5(_p0, _p1);
			}
		}

		public void NetworkSetEntityInvisibleToNetwork(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__networkSetEntityInvisibleToNetwork == null) fn__networkSetEntityInvisibleToNetwork = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetEntityInvisibleToNetwork");
				fn__networkSetEntityInvisibleToNetwork(_entity, _toggle);
			}
		}

		public void SetNetworkIdVisibleInCutscene(int _netId, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setNetworkIdVisibleInCutscene == null) fn__setNetworkIdVisibleInCutscene = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setNetworkIdVisibleInCutscene");
				fn__setNetworkIdVisibleInCutscene(_netId, _p1, _p2);
			}
		}

		public void _0x32EBD154CB6B8B99(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x32EBD154CB6B8B99 == null) fn__0x32EBD154CB6B8B99 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x32EBD154CB6B8B99");
				fn__0x32EBD154CB6B8B99(_p0, _p1, _p2);
			}
		}

		public void _0x76B3F29D3F967692(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x76B3F29D3F967692 == null) fn__0x76B3F29D3F967692 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x76B3F29D3F967692");
				fn__0x76B3F29D3F967692(_p0, _p1);
			}
		}

		public void SetNetworkCutsceneEntities(bool _toggle)
		{
			unsafe {
				if (fn__setNetworkCutsceneEntities == null) fn__setNetworkCutsceneEntities = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setNetworkCutsceneEntities");
				fn__setNetworkCutsceneEntities(_toggle);
			}
		}

		public void _0x3FA36981311FA4FF(int _netId, bool _state)
		{
			unsafe {
				if (fn__0x3FA36981311FA4FF == null) fn__0x3FA36981311FA4FF = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x3FA36981311FA4FF");
				fn__0x3FA36981311FA4FF(_netId, _state);
			}
		}

		public bool IsNetworkIdOwnedByParticipant(int _netId)
		{
			unsafe {
				if (fn__isNetworkIdOwnedByParticipant == null) fn__isNetworkIdOwnedByParticipant = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isNetworkIdOwnedByParticipant");
				var result = fn__isNetworkIdOwnedByParticipant(_netId);
				return result;
			}
		}

		public void SetLocalPlayerVisibleInCutscene(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__setLocalPlayerVisibleInCutscene == null) fn__setLocalPlayerVisibleInCutscene = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setLocalPlayerVisibleInCutscene");
				fn__setLocalPlayerVisibleInCutscene(_p0, _p1);
			}
		}

		public void SetLocalPlayerInvisibleLocally(bool _p0)
		{
			unsafe {
				if (fn__setLocalPlayerInvisibleLocally == null) fn__setLocalPlayerInvisibleLocally = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setLocalPlayerInvisibleLocally");
				fn__setLocalPlayerInvisibleLocally(_p0);
			}
		}

		public void SetLocalPlayerVisibleLocally(bool _p0)
		{
			unsafe {
				if (fn__setLocalPlayerVisibleLocally == null) fn__setLocalPlayerVisibleLocally = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setLocalPlayerVisibleLocally");
				fn__setLocalPlayerVisibleLocally(_p0);
			}
		}

		public void SetPlayerInvisibleLocally(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerInvisibleLocally == null) fn__setPlayerInvisibleLocally = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerInvisibleLocally");
				fn__setPlayerInvisibleLocally(_player, _toggle);
			}
		}

		public void SetPlayerVisibleLocally(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerVisibleLocally == null) fn__setPlayerVisibleLocally = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerVisibleLocally");
				fn__setPlayerVisibleLocally(_player, _toggle);
			}
		}

		public void FadeOutLocalPlayer(bool _p0)
		{
			unsafe {
				if (fn__fadeOutLocalPlayer == null) fn__fadeOutLocalPlayer = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_fadeOutLocalPlayer");
				fn__fadeOutLocalPlayer(_p0);
			}
		}

		public void NetworkFadeOutEntity(int _entity, bool _normal, bool _slow)
		{
			unsafe {
				if (fn__networkFadeOutEntity == null) fn__networkFadeOutEntity = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkFadeOutEntity");
				fn__networkFadeOutEntity(_entity, _normal, _slow);
			}
		}

		public void NetworkFadeInEntity(int _entity, bool _state, int _p2)
		{
			unsafe {
				if (fn__networkFadeInEntity == null) fn__networkFadeInEntity = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_networkFadeInEntity");
				fn__networkFadeInEntity(_entity, _state, _p2);
			}
		}

		public bool NetworkIsPlayerFading(int _player)
		{
			unsafe {
				if (fn__networkIsPlayerFading == null) fn__networkIsPlayerFading = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerFading");
				var result = fn__networkIsPlayerFading(_player);
				return result;
			}
		}

		public bool NetworkIsEntityFading(int _entity)
		{
			unsafe {
				if (fn__networkIsEntityFading == null) fn__networkIsEntityFading = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsEntityFading");
				var result = fn__networkIsEntityFading(_entity);
				return result;
			}
		}

		public bool IsPlayerInCutscene(int _player)
		{
			unsafe {
				if (fn__isPlayerInCutscene == null) fn__isPlayerInCutscene = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerInCutscene");
				var result = fn__isPlayerInCutscene(_player);
				return result;
			}
		}

		public void SetEntityVisibleInCutscene(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setEntityVisibleInCutscene == null) fn__setEntityVisibleInCutscene = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityVisibleInCutscene");
				fn__setEntityVisibleInCutscene(_p0, _p1, _p2);
			}
		}

		public void SetEntityLocallyInvisible(int _entity)
		{
			unsafe {
				if (fn__setEntityLocallyInvisible == null) fn__setEntityLocallyInvisible = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setEntityLocallyInvisible");
				fn__setEntityLocallyInvisible(_entity);
			}
		}

		public void SetEntityLocallyVisible(int _entity)
		{
			unsafe {
				if (fn__setEntityLocallyVisible == null) fn__setEntityLocallyVisible = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setEntityLocallyVisible");
				fn__setEntityLocallyVisible(_entity);
			}
		}

		public bool IsDamageTrackerActiveOnNetworkId(int _netID)
		{
			unsafe {
				if (fn__isDamageTrackerActiveOnNetworkId == null) fn__isDamageTrackerActiveOnNetworkId = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isDamageTrackerActiveOnNetworkId");
				var result = fn__isDamageTrackerActiveOnNetworkId(_netID);
				return result;
			}
		}

		public void ActivateDamageTrackerOnNetworkId(int _netID, bool _toggle)
		{
			unsafe {
				if (fn__activateDamageTrackerOnNetworkId == null) fn__activateDamageTrackerOnNetworkId = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_activateDamageTrackerOnNetworkId");
				fn__activateDamageTrackerOnNetworkId(_netID, _toggle);
			}
		}

		public bool IsDamageTrackerActiveOnPlayer(int _player)
		{
			unsafe {
				if (fn__isDamageTrackerActiveOnPlayer == null) fn__isDamageTrackerActiveOnPlayer = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isDamageTrackerActiveOnPlayer");
				var result = fn__isDamageTrackerActiveOnPlayer(_player);
				return result;
			}
		}

		public void ActivateDamageTrackerOnPlayer(int _player, bool _toggle)
		{
			unsafe {
				if (fn__activateDamageTrackerOnPlayer == null) fn__activateDamageTrackerOnPlayer = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_activateDamageTrackerOnPlayer");
				fn__activateDamageTrackerOnPlayer(_player, _toggle);
			}
		}

		public bool IsSphereVisibleToAnotherMachine(float _p0, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__isSphereVisibleToAnotherMachine == null) fn__isSphereVisibleToAnotherMachine = (delegate* unmanaged[Cdecl]<float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isSphereVisibleToAnotherMachine");
				var result = fn__isSphereVisibleToAnotherMachine(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public bool IsSphereVisibleToPlayer(int _p0, float _p1, float _p2, float _p3, float _p4)
		{
			unsafe {
				if (fn__isSphereVisibleToPlayer == null) fn__isSphereVisibleToPlayer = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isSphereVisibleToPlayer");
				var result = fn__isSphereVisibleToPlayer(_p0, _p1, _p2, _p3, _p4);
				return result;
			}
		}

		public void ReserveNetworkMissionObjects(int _amount)
		{
			unsafe {
				if (fn__reserveNetworkMissionObjects == null) fn__reserveNetworkMissionObjects = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_reserveNetworkMissionObjects");
				fn__reserveNetworkMissionObjects(_amount);
			}
		}

		public void ReserveNetworkMissionPeds(int _amount)
		{
			unsafe {
				if (fn__reserveNetworkMissionPeds == null) fn__reserveNetworkMissionPeds = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_reserveNetworkMissionPeds");
				fn__reserveNetworkMissionPeds(_amount);
			}
		}

		public void ReserveNetworkMissionVehicles(int _amount)
		{
			unsafe {
				if (fn__reserveNetworkMissionVehicles == null) fn__reserveNetworkMissionVehicles = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_reserveNetworkMissionVehicles");
				fn__reserveNetworkMissionVehicles(_amount);
			}
		}

		public void ReserveNetworkLocalObjects(int _amount)
		{
			unsafe {
				if (fn__reserveNetworkLocalObjects == null) fn__reserveNetworkLocalObjects = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_reserveNetworkLocalObjects");
				fn__reserveNetworkLocalObjects(_amount);
			}
		}

		public void ReserveNetworkLocalPeds(int _amount)
		{
			unsafe {
				if (fn__reserveNetworkLocalPeds == null) fn__reserveNetworkLocalPeds = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_reserveNetworkLocalPeds");
				fn__reserveNetworkLocalPeds(_amount);
			}
		}

		public void ReserveNetworkLocalVehicles(int _amount)
		{
			unsafe {
				if (fn__reserveNetworkLocalVehicles == null) fn__reserveNetworkLocalVehicles = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_reserveNetworkLocalVehicles");
				fn__reserveNetworkLocalVehicles(_amount);
			}
		}

		public bool CanRegisterMissionObjects(int _amount)
		{
			unsafe {
				if (fn__canRegisterMissionObjects == null) fn__canRegisterMissionObjects = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canRegisterMissionObjects");
				var result = fn__canRegisterMissionObjects(_amount);
				return result;
			}
		}

		public bool CanRegisterMissionPeds(int _amount)
		{
			unsafe {
				if (fn__canRegisterMissionPeds == null) fn__canRegisterMissionPeds = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canRegisterMissionPeds");
				var result = fn__canRegisterMissionPeds(_amount);
				return result;
			}
		}

		public bool CanRegisterMissionVehicles(int _amount)
		{
			unsafe {
				if (fn__canRegisterMissionVehicles == null) fn__canRegisterMissionVehicles = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canRegisterMissionVehicles");
				var result = fn__canRegisterMissionVehicles(_amount);
				return result;
			}
		}

		public bool CanRegisterMissionPickups(int _amount)
		{
			unsafe {
				if (fn__canRegisterMissionPickups == null) fn__canRegisterMissionPickups = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canRegisterMissionPickups");
				var result = fn__canRegisterMissionPickups(_amount);
				return result;
			}
		}

		public int _0xE16AA70CE9BEEDC3(int _p0)
		{
			unsafe {
				if (fn__0xE16AA70CE9BEEDC3 == null) fn__0xE16AA70CE9BEEDC3 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xE16AA70CE9BEEDC3");
				var result = fn__0xE16AA70CE9BEEDC3(_p0);
				return result;
			}
		}

		public bool CanRegisterMissionEntities(int _ped_amt, int _vehicle_amt, int _object_amt, int _pickup_amt)
		{
			unsafe {
				if (fn__canRegisterMissionEntities == null) fn__canRegisterMissionEntities = (delegate* unmanaged[Cdecl]<int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_canRegisterMissionEntities");
				var result = fn__canRegisterMissionEntities(_ped_amt, _vehicle_amt, _object_amt, _pickup_amt);
				return result;
			}
		}

		public int GetNumReservedMissionObjects(bool _p0, int _p1)
		{
			unsafe {
				if (fn__getNumReservedMissionObjects == null) fn__getNumReservedMissionObjects = (delegate* unmanaged[Cdecl]<bool, int, int>) NativeLibrary.GetExport(handle, "Native_getNumReservedMissionObjects");
				var result = fn__getNumReservedMissionObjects(_p0, _p1);
				return result;
			}
		}

		public int GetNumReservedMissionPeds(bool _p0, int _p1)
		{
			unsafe {
				if (fn__getNumReservedMissionPeds == null) fn__getNumReservedMissionPeds = (delegate* unmanaged[Cdecl]<bool, int, int>) NativeLibrary.GetExport(handle, "Native_getNumReservedMissionPeds");
				var result = fn__getNumReservedMissionPeds(_p0, _p1);
				return result;
			}
		}

		public int GetNumReservedMissionVehicles(bool _p0, int _p1)
		{
			unsafe {
				if (fn__getNumReservedMissionVehicles == null) fn__getNumReservedMissionVehicles = (delegate* unmanaged[Cdecl]<bool, int, int>) NativeLibrary.GetExport(handle, "Native_getNumReservedMissionVehicles");
				var result = fn__getNumReservedMissionVehicles(_p0, _p1);
				return result;
			}
		}

		public int GetNumCreatedMissionObjects(bool _p0)
		{
			unsafe {
				if (fn__getNumCreatedMissionObjects == null) fn__getNumCreatedMissionObjects = (delegate* unmanaged[Cdecl]<bool, int>) NativeLibrary.GetExport(handle, "Native_getNumCreatedMissionObjects");
				var result = fn__getNumCreatedMissionObjects(_p0);
				return result;
			}
		}

		public int GetNumCreatedMissionPeds(bool _p0)
		{
			unsafe {
				if (fn__getNumCreatedMissionPeds == null) fn__getNumCreatedMissionPeds = (delegate* unmanaged[Cdecl]<bool, int>) NativeLibrary.GetExport(handle, "Native_getNumCreatedMissionPeds");
				var result = fn__getNumCreatedMissionPeds(_p0);
				return result;
			}
		}

		public int GetNumCreatedMissionVehicles(bool _p0)
		{
			unsafe {
				if (fn__getNumCreatedMissionVehicles == null) fn__getNumCreatedMissionVehicles = (delegate* unmanaged[Cdecl]<bool, int>) NativeLibrary.GetExport(handle, "Native_getNumCreatedMissionVehicles");
				var result = fn__getNumCreatedMissionVehicles(_p0);
				return result;
			}
		}

		public void _0xE42D626EEC94E5D9(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__0xE42D626EEC94E5D9 == null) fn__0xE42D626EEC94E5D9 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xE42D626EEC94E5D9");
				fn__0xE42D626EEC94E5D9(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public int GetMaxNumNetworkObjects()
		{
			unsafe {
				if (fn__getMaxNumNetworkObjects == null) fn__getMaxNumNetworkObjects = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMaxNumNetworkObjects");
				var result = fn__getMaxNumNetworkObjects();
				return result;
			}
		}

		public int GetMaxNumNetworkPeds()
		{
			unsafe {
				if (fn__getMaxNumNetworkPeds == null) fn__getMaxNumNetworkPeds = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMaxNumNetworkPeds");
				var result = fn__getMaxNumNetworkPeds();
				return result;
			}
		}

		public int GetMaxNumNetworkVehicles()
		{
			unsafe {
				if (fn__getMaxNumNetworkVehicles == null) fn__getMaxNumNetworkVehicles = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMaxNumNetworkVehicles");
				var result = fn__getMaxNumNetworkVehicles();
				return result;
			}
		}

		public int GetMaxNumNetworkPickups()
		{
			unsafe {
				if (fn__getMaxNumNetworkPickups == null) fn__getMaxNumNetworkPickups = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMaxNumNetworkPickups");
				var result = fn__getMaxNumNetworkPickups();
				return result;
			}
		}

		public void _0xBA7F0B77D80A4EB7(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xBA7F0B77D80A4EB7 == null) fn__0xBA7F0B77D80A4EB7 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xBA7F0B77D80A4EB7");
				fn__0xBA7F0B77D80A4EB7(_p0, _p1);
			}
		}

		public void _0x0F1A4B45B7693B95(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x0F1A4B45B7693B95 == null) fn__0x0F1A4B45B7693B95 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0F1A4B45B7693B95");
				fn__0x0F1A4B45B7693B95(_p0, _p1);
			}
		}

		public int GetNetworkTime()
		{
			unsafe {
				if (fn__getNetworkTime == null) fn__getNetworkTime = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNetworkTime");
				var result = fn__getNetworkTime();
				return result;
			}
		}

		public int GetNetworkTimeAccurate()
		{
			unsafe {
				if (fn__getNetworkTimeAccurate == null) fn__getNetworkTimeAccurate = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNetworkTimeAccurate");
				var result = fn__getNetworkTimeAccurate();
				return result;
			}
		}

		public bool HasNetworkTimeStarted()
		{
			unsafe {
				if (fn__hasNetworkTimeStarted == null) fn__hasNetworkTimeStarted = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasNetworkTimeStarted");
				var result = fn__hasNetworkTimeStarted();
				return result;
			}
		}

		public int GetTimeOffset(int _timeA, int _timeB)
		{
			unsafe {
				if (fn__getTimeOffset == null) fn__getTimeOffset = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getTimeOffset");
				var result = fn__getTimeOffset(_timeA, _timeB);
				return result;
			}
		}

		public bool IsTimeLessThan(int _timeA, int _timeB)
		{
			unsafe {
				if (fn__isTimeLessThan == null) fn__isTimeLessThan = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isTimeLessThan");
				var result = fn__isTimeLessThan(_timeA, _timeB);
				return result;
			}
		}

		public bool IsTimeMoreThan(int _timeA, int _timeB)
		{
			unsafe {
				if (fn__isTimeMoreThan == null) fn__isTimeMoreThan = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isTimeMoreThan");
				var result = fn__isTimeMoreThan(_timeA, _timeB);
				return result;
			}
		}

		public bool IsTimeEqualTo(int _timeA, int _timeB)
		{
			unsafe {
				if (fn__isTimeEqualTo == null) fn__isTimeEqualTo = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isTimeEqualTo");
				var result = fn__isTimeEqualTo(_timeA, _timeB);
				return result;
			}
		}

		public int GetTimeDifference(int _timeA, int _timeB)
		{
			unsafe {
				if (fn__getTimeDifference == null) fn__getTimeDifference = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getTimeDifference");
				var result = fn__getTimeDifference(_timeA, _timeB);
				return result;
			}
		}

		public string GetTimeAsString(int _time)
		{
			unsafe {
				if (fn__getTimeAsString == null) fn__getTimeAsString = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getTimeAsString");
				var result = fn__getTimeAsString(_time);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetCloudTimeAsString()
		{
			unsafe {
				if (fn__getCloudTimeAsString == null) fn__getCloudTimeAsString = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_getCloudTimeAsString");
				var result = fn__getCloudTimeAsString();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int GetCloudTimeAsInt()
		{
			unsafe {
				if (fn__getCloudTimeAsInt == null) fn__getCloudTimeAsInt = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCloudTimeAsInt");
				var result = fn__getCloudTimeAsInt();
				return result;
			}
		}

		public void ConvertPosixTime(int _posixTime, ref int _timeStructure)
		{
			unsafe {
				if (fn__convertPosixTime == null) fn__convertPosixTime = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_convertPosixTime");
				var ref_timeStructure = _timeStructure;
				fn__convertPosixTime(_posixTime, &ref_timeStructure);
				_timeStructure = ref_timeStructure;
			}
		}

		public void NetworkSetInSpectatorMode(bool _toggle, int _playerPed)
		{
			unsafe {
				if (fn__networkSetInSpectatorMode == null) fn__networkSetInSpectatorMode = (delegate* unmanaged[Cdecl]<bool, int, void>) NativeLibrary.GetExport(handle, "Native_networkSetInSpectatorMode");
				fn__networkSetInSpectatorMode(_toggle, _playerPed);
			}
		}

		public void NetworkSetInSpectatorModeExtended(bool _toggle, int _playerPed, bool _p2)
		{
			unsafe {
				if (fn__networkSetInSpectatorModeExtended == null) fn__networkSetInSpectatorModeExtended = (delegate* unmanaged[Cdecl]<bool, int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetInSpectatorModeExtended");
				fn__networkSetInSpectatorModeExtended(_toggle, _playerPed, _p2);
			}
		}

		public void NetworkSetInFreeCamMode(bool _toggle)
		{
			unsafe {
				if (fn__networkSetInFreeCamMode == null) fn__networkSetInFreeCamMode = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetInFreeCamMode");
				fn__networkSetInFreeCamMode(_toggle);
			}
		}

		public void NetworkSetChoiceMigrateOptions(bool _toggle, int _player)
		{
			unsafe {
				if (fn__networkSetChoiceMigrateOptions == null) fn__networkSetChoiceMigrateOptions = (delegate* unmanaged[Cdecl]<bool, int, void>) NativeLibrary.GetExport(handle, "Native_networkSetChoiceMigrateOptions");
				fn__networkSetChoiceMigrateOptions(_toggle, _player);
			}
		}

		public bool NetworkIsInSpectatorMode()
		{
			unsafe {
				if (fn__networkIsInSpectatorMode == null) fn__networkIsInSpectatorMode = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsInSpectatorMode");
				var result = fn__networkIsInSpectatorMode();
				return result;
			}
		}

		public void NetworkSetInMpCutscene(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__networkSetInMpCutscene == null) fn__networkSetInMpCutscene = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetInMpCutscene");
				fn__networkSetInMpCutscene(_p0, _p1);
			}
		}

		public bool NetworkIsInMpCutscene()
		{
			unsafe {
				if (fn__networkIsInMpCutscene == null) fn__networkIsInMpCutscene = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsInMpCutscene");
				var result = fn__networkIsInMpCutscene();
				return result;
			}
		}

		public bool NetworkIsPlayerInMpCutscene(int _player)
		{
			unsafe {
				if (fn__networkIsPlayerInMpCutscene == null) fn__networkIsPlayerInMpCutscene = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerInMpCutscene");
				var result = fn__networkIsPlayerInMpCutscene(_player);
				return result;
			}
		}

		public void _0xFAC18E7356BD3210()
		{
			unsafe {
				if (fn__0xFAC18E7356BD3210 == null) fn__0xFAC18E7356BD3210 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xFAC18E7356BD3210");
				fn__0xFAC18E7356BD3210();
			}
		}

		public void SetNetworkVehicleRespotTimer(int _netId, int _time, int _p2, int _p3)
		{
			unsafe {
				if (fn__setNetworkVehicleRespotTimer == null) fn__setNetworkVehicleRespotTimer = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setNetworkVehicleRespotTimer");
				fn__setNetworkVehicleRespotTimer(_netId, _time, _p2, _p3);
			}
		}

		public void SetNetworkVehicleAsGhost(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setNetworkVehicleAsGhost == null) fn__setNetworkVehicleAsGhost = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setNetworkVehicleAsGhost");
				fn__setNetworkVehicleAsGhost(_vehicle, _toggle);
			}
		}

		public void SetNetworkVehiclePositionUpdateMultiplier(int _vehicle, float _multiplier)
		{
			unsafe {
				if (fn__setNetworkVehiclePositionUpdateMultiplier == null) fn__setNetworkVehiclePositionUpdateMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setNetworkVehiclePositionUpdateMultiplier");
				fn__setNetworkVehiclePositionUpdateMultiplier(_vehicle, _multiplier);
			}
		}

		public void SetNetworkEnableVehiclePositionCorrection(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setNetworkEnableVehiclePositionCorrection == null) fn__setNetworkEnableVehiclePositionCorrection = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setNetworkEnableVehiclePositionCorrection");
				fn__setNetworkEnableVehiclePositionCorrection(_vehicle, _toggle);
			}
		}

		public void SetLocalPlayerAsGhost(bool _toggle, bool _p1)
		{
			unsafe {
				if (fn__setLocalPlayerAsGhost == null) fn__setLocalPlayerAsGhost = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setLocalPlayerAsGhost");
				fn__setLocalPlayerAsGhost(_toggle, _p1);
			}
		}

		public bool IsEntityGhostedToLocalPlayer(int _entity)
		{
			unsafe {
				if (fn__isEntityGhostedToLocalPlayer == null) fn__isEntityGhostedToLocalPlayer = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityGhostedToLocalPlayer");
				var result = fn__isEntityGhostedToLocalPlayer(_entity);
				return result;
			}
		}

		public void _0x13F1FCB111B820B0(bool _p0)
		{
			unsafe {
				if (fn__0x13F1FCB111B820B0 == null) fn__0x13F1FCB111B820B0 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x13F1FCB111B820B0");
				fn__0x13F1FCB111B820B0(_p0);
			}
		}

		public void SetRelationshipToPlayer(int _player, bool _p1)
		{
			unsafe {
				if (fn__setRelationshipToPlayer == null) fn__setRelationshipToPlayer = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setRelationshipToPlayer");
				fn__setRelationshipToPlayer(_player, _p1);
			}
		}

		public void SetGhostedEntityAlpha(int _alpha)
		{
			unsafe {
				if (fn__setGhostedEntityAlpha == null) fn__setGhostedEntityAlpha = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setGhostedEntityAlpha");
				fn__setGhostedEntityAlpha(_alpha);
			}
		}

		public void ResetGhostedEntityAlpha()
		{
			unsafe {
				if (fn__resetGhostedEntityAlpha == null) fn__resetGhostedEntityAlpha = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetGhostedEntityAlpha");
				fn__resetGhostedEntityAlpha();
			}
		}

		public void NetworkSetEntityGhostedWithOwner(int _entity, bool _p1)
		{
			unsafe {
				if (fn__networkSetEntityGhostedWithOwner == null) fn__networkSetEntityGhostedWithOwner = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetEntityGhostedWithOwner");
				fn__networkSetEntityGhostedWithOwner(_entity, _p1);
			}
		}

		public void _0xD7B6C73CAD419BCF(bool _p0)
		{
			unsafe {
				if (fn__0xD7B6C73CAD419BCF == null) fn__0xD7B6C73CAD419BCF = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xD7B6C73CAD419BCF");
				fn__0xD7B6C73CAD419BCF(_p0);
			}
		}

		public bool _0x7EF7649B64D7FF10(int _entity)
		{
			unsafe {
				if (fn__0x7EF7649B64D7FF10 == null) fn__0x7EF7649B64D7FF10 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x7EF7649B64D7FF10");
				var result = fn__0x7EF7649B64D7FF10(_entity);
				return result;
			}
		}

		public void UsePlayerColourInsteadOfTeamColour(bool _toggle)
		{
			unsafe {
				if (fn__usePlayerColourInsteadOfTeamColour == null) fn__usePlayerColourInsteadOfTeamColour = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_usePlayerColourInsteadOfTeamColour");
				fn__usePlayerColourInsteadOfTeamColour(_toggle);
			}
		}

		public int NetworkCreateSynchronisedScene(float _x, float _y, float _z, float _xRot, float _yRot, float _zRot, int _rotationOrder, bool _useOcclusionPortal, bool _looped, float _p9, float _animTime, float _p11)
		{
			unsafe {
				if (fn__networkCreateSynchronisedScene == null) fn__networkCreateSynchronisedScene = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, bool, bool, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_networkCreateSynchronisedScene");
				var result = fn__networkCreateSynchronisedScene(_x, _y, _z, _xRot, _yRot, _zRot, _rotationOrder, _useOcclusionPortal, _looped, _p9, _animTime, _p11);
				return result;
			}
		}

		public void NetworkAddPedToSynchronisedScene(int _ped, int _netScene, string _animDict, string _animnName, float _speed, float _speedMultiplier, int _duration, int _flag, float _playbackRate, int _p9)
		{
			unsafe {
				if (fn__networkAddPedToSynchronisedScene == null) fn__networkAddPedToSynchronisedScene = (delegate* unmanaged[Cdecl]<int, int, nint, nint, float, float, int, int, float, int, void>) NativeLibrary.GetExport(handle, "Native_networkAddPedToSynchronisedScene");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animnName = MemoryUtils.StringToHGlobalUtf8(_animnName);
				fn__networkAddPedToSynchronisedScene(_ped, _netScene, ptr_animDict, ptr_animnName, _speed, _speedMultiplier, _duration, _flag, _playbackRate, _p9);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animnName);
			}
		}

		public void _0xA5EAFE473E45C442(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__0xA5EAFE473E45C442 == null) fn__0xA5EAFE473E45C442 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xA5EAFE473E45C442");
				fn__0xA5EAFE473E45C442(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void NetworkAddEntityToSynchronisedScene(int _entity, int _netScene, string _animDict, string _animName, float _speed, float _speedMulitiplier, int _flag)
		{
			unsafe {
				if (fn__networkAddEntityToSynchronisedScene == null) fn__networkAddEntityToSynchronisedScene = (delegate* unmanaged[Cdecl]<int, int, nint, nint, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_networkAddEntityToSynchronisedScene");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				fn__networkAddEntityToSynchronisedScene(_entity, _netScene, ptr_animDict, ptr_animName, _speed, _speedMulitiplier, _flag);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
			}
		}

		public void _0x45F35C0EDC33B03B(int _netScene, int _modelHash, float _x, float _y, float _z, float _p5, string _p6, float _p7, float _p8, int _flags)
		{
			unsafe {
				if (fn__0x45F35C0EDC33B03B == null) fn__0x45F35C0EDC33B03B = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, nint, float, float, int, void>) NativeLibrary.GetExport(handle, "Native__0x45F35C0EDC33B03B");
				var ptr_p6 = MemoryUtils.StringToHGlobalUtf8(_p6);
				fn__0x45F35C0EDC33B03B(_netScene, _modelHash, _x, _y, _z, _p5, ptr_p6, _p7, _p8, _flags);
				Marshal.FreeHGlobal(ptr_p6);
			}
		}

		public void NetworkAddSynchronisedSceneCamera(int _netScene, string _animDict, string _animName)
		{
			unsafe {
				if (fn__networkAddSynchronisedSceneCamera == null) fn__networkAddSynchronisedSceneCamera = (delegate* unmanaged[Cdecl]<int, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_networkAddSynchronisedSceneCamera");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				fn__networkAddSynchronisedSceneCamera(_netScene, ptr_animDict, ptr_animName);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
			}
		}

		public void NetworkAttachSynchronisedSceneToEntity(int _netScene, int _entity, int _bone)
		{
			unsafe {
				if (fn__networkAttachSynchronisedSceneToEntity == null) fn__networkAttachSynchronisedSceneToEntity = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkAttachSynchronisedSceneToEntity");
				fn__networkAttachSynchronisedSceneToEntity(_netScene, _entity, _bone);
			}
		}

		public void NetworkStartSynchronisedScene(int _netScene)
		{
			unsafe {
				if (fn__networkStartSynchronisedScene == null) fn__networkStartSynchronisedScene = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkStartSynchronisedScene");
				fn__networkStartSynchronisedScene(_netScene);
			}
		}

		public void NetworkStopSynchronisedScene(int _netScene)
		{
			unsafe {
				if (fn__networkStopSynchronisedScene == null) fn__networkStopSynchronisedScene = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkStopSynchronisedScene");
				fn__networkStopSynchronisedScene(_netScene);
			}
		}

		public int NetworkGetLocalSceneFromNetworkId(int _netId)
		{
			unsafe {
				if (fn__networkGetLocalSceneFromNetworkId == null) fn__networkGetLocalSceneFromNetworkId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetLocalSceneFromNetworkId");
				var result = fn__networkGetLocalSceneFromNetworkId(_netId);
				return result;
			}
		}

		public void _0xC9B43A33D09CADA7(int _p0)
		{
			unsafe {
				if (fn__0xC9B43A33D09CADA7 == null) fn__0xC9B43A33D09CADA7 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC9B43A33D09CADA7");
				fn__0xC9B43A33D09CADA7(_p0);
			}
		}

		public void _0x144DA052257AE7D8(int _p0)
		{
			unsafe {
				if (fn__0x144DA052257AE7D8 == null) fn__0x144DA052257AE7D8 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x144DA052257AE7D8");
				fn__0x144DA052257AE7D8(_p0);
			}
		}

		public int _0xFB1F9381E80FA13F(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xFB1F9381E80FA13F == null) fn__0xFB1F9381E80FA13F = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0xFB1F9381E80FA13F");
				var result = fn__0xFB1F9381E80FA13F(_p0, _p1);
				return result;
			}
		}

		public bool NetworkStartRespawnSearchForPlayer(int _player, float _x, float _y, float _z, float _radius, float _p5, float _p6, float _p7, int _flags)
		{
			unsafe {
				if (fn__networkStartRespawnSearchForPlayer == null) fn__networkStartRespawnSearchForPlayer = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int, bool>) NativeLibrary.GetExport(handle, "Native_networkStartRespawnSearchForPlayer");
				var result = fn__networkStartRespawnSearchForPlayer(_player, _x, _y, _z, _radius, _p5, _p6, _p7, _flags);
				return result;
			}
		}

		public bool NetworkStartRespawnSearchInAngledAreaForPlayer(int _player, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width, float _p8, float _p9, float _p10, int _flags)
		{
			unsafe {
				if (fn__networkStartRespawnSearchInAngledAreaForPlayer == null) fn__networkStartRespawnSearchInAngledAreaForPlayer = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, int, bool>) NativeLibrary.GetExport(handle, "Native_networkStartRespawnSearchInAngledAreaForPlayer");
				var result = fn__networkStartRespawnSearchInAngledAreaForPlayer(_player, _x1, _y1, _z1, _x2, _y2, _z2, _width, _p8, _p9, _p10, _flags);
				return result;
			}
		}

		public int NetworkQueryRespawnResults(ref int _p0)
		{
			unsafe {
				if (fn__networkQueryRespawnResults == null) fn__networkQueryRespawnResults = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_networkQueryRespawnResults");
				var ref_p0 = _p0;
				var result = fn__networkQueryRespawnResults(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public void NetworkCancelRespawnSearch()
		{
			unsafe {
				if (fn__networkCancelRespawnSearch == null) fn__networkCancelRespawnSearch = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkCancelRespawnSearch");
				fn__networkCancelRespawnSearch();
			}
		}

		public void NetworkGetRespawnResult(int _randomInt, ref Vector3 _coordinates, ref float _heading)
		{
			unsafe {
				if (fn__networkGetRespawnResult == null) fn__networkGetRespawnResult = (delegate* unmanaged[Cdecl]<int, Vector3*, float*, void>) NativeLibrary.GetExport(handle, "Native_networkGetRespawnResult");
				var ref_coordinates = _coordinates;
				var ref_heading = _heading;
				fn__networkGetRespawnResult(_randomInt, &ref_coordinates, &ref_heading);
				_coordinates = ref_coordinates;
				_heading = ref_heading;
			}
		}

		public int NetworkGetRespawnResultFlags(int _p0)
		{
			unsafe {
				if (fn__networkGetRespawnResultFlags == null) fn__networkGetRespawnResultFlags = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetRespawnResultFlags");
				var result = fn__networkGetRespawnResultFlags(_p0);
				return result;
			}
		}

		public void NetworkStartSoloTutorialSession()
		{
			unsafe {
				if (fn__networkStartSoloTutorialSession == null) fn__networkStartSoloTutorialSession = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkStartSoloTutorialSession");
				fn__networkStartSoloTutorialSession();
			}
		}

		public void _0xFB680D403909DC70(int _teamId, int _instanceId)
		{
			unsafe {
				if (fn__0xFB680D403909DC70 == null) fn__0xFB680D403909DC70 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xFB680D403909DC70");
				fn__0xFB680D403909DC70(_teamId, _instanceId);
			}
		}

		public void NetworkEndTutorialSession()
		{
			unsafe {
				if (fn__networkEndTutorialSession == null) fn__networkEndTutorialSession = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkEndTutorialSession");
				fn__networkEndTutorialSession();
			}
		}

		public bool NetworkIsInTutorialSession()
		{
			unsafe {
				if (fn__networkIsInTutorialSession == null) fn__networkIsInTutorialSession = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsInTutorialSession");
				var result = fn__networkIsInTutorialSession();
				return result;
			}
		}

		public bool _0xB37E4E6A2388CA7B()
		{
			unsafe {
				if (fn__0xB37E4E6A2388CA7B == null) fn__0xB37E4E6A2388CA7B = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xB37E4E6A2388CA7B");
				var result = fn__0xB37E4E6A2388CA7B();
				return result;
			}
		}

		public bool NetworkIsTutorialSessionChangePending()
		{
			unsafe {
				if (fn__networkIsTutorialSessionChangePending == null) fn__networkIsTutorialSessionChangePending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTutorialSessionChangePending");
				var result = fn__networkIsTutorialSessionChangePending();
				return result;
			}
		}

		public int NetworkGetPlayerTutorialSessionInstance(int _player)
		{
			unsafe {
				if (fn__networkGetPlayerTutorialSessionInstance == null) fn__networkGetPlayerTutorialSessionInstance = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetPlayerTutorialSessionInstance");
				var result = fn__networkGetPlayerTutorialSessionInstance(_player);
				return result;
			}
		}

		public bool NetworkIsPlayerEqualToIndex(int _player, int _index)
		{
			unsafe {
				if (fn__networkIsPlayerEqualToIndex == null) fn__networkIsPlayerEqualToIndex = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerEqualToIndex");
				var result = fn__networkIsPlayerEqualToIndex(_player, _index);
				return result;
			}
		}

		public void NetworkConcealPlayer(int _player, bool _toggle, bool _p2)
		{
			unsafe {
				if (fn__networkConcealPlayer == null) fn__networkConcealPlayer = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkConcealPlayer");
				fn__networkConcealPlayer(_player, _toggle, _p2);
			}
		}

		public bool NetworkIsPlayerConcealed(int _player)
		{
			unsafe {
				if (fn__networkIsPlayerConcealed == null) fn__networkIsPlayerConcealed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsPlayerConcealed");
				var result = fn__networkIsPlayerConcealed(_player);
				return result;
			}
		}

		public void NetworkConcealEntity(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__networkConcealEntity == null) fn__networkConcealEntity = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkConcealEntity");
				fn__networkConcealEntity(_entity, _toggle);
			}
		}

		public bool NetworkIsEntityConcealed(int _entity)
		{
			unsafe {
				if (fn__networkIsEntityConcealed == null) fn__networkIsEntityConcealed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsEntityConcealed");
				var result = fn__networkIsEntityConcealed(_entity);
				return result;
			}
		}

		public void NetworkOverrideClockTime(int _hours, int _minutes, int _seconds)
		{
			unsafe {
				if (fn__networkOverrideClockTime == null) fn__networkOverrideClockTime = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideClockTime");
				fn__networkOverrideClockTime(_hours, _minutes, _seconds);
			}
		}

		public void NetworkOverrideClockMillisecondsPerGameMinute(int _ms)
		{
			unsafe {
				if (fn__networkOverrideClockMillisecondsPerGameMinute == null) fn__networkOverrideClockMillisecondsPerGameMinute = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideClockMillisecondsPerGameMinute");
				fn__networkOverrideClockMillisecondsPerGameMinute(_ms);
			}
		}

		public void NetworkClearClockTimeOverride()
		{
			unsafe {
				if (fn__networkClearClockTimeOverride == null) fn__networkClearClockTimeOverride = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkClearClockTimeOverride");
				fn__networkClearClockTimeOverride();
			}
		}

		public bool NetworkIsClockTimeOverridden()
		{
			unsafe {
				if (fn__networkIsClockTimeOverridden == null) fn__networkIsClockTimeOverridden = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsClockTimeOverridden");
				var result = fn__networkIsClockTimeOverridden();
				return result;
			}
		}

		public int NetworkAddEntityArea(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5)
		{
			unsafe {
				if (fn__networkAddEntityArea == null) fn__networkAddEntityArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_networkAddEntityArea");
				var result = fn__networkAddEntityArea(_p0, _p1, _p2, _p3, _p4, _p5);
				return result;
			}
		}

		public int NetworkAddEntityAngledArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width)
		{
			unsafe {
				if (fn__networkAddEntityAngledArea == null) fn__networkAddEntityAngledArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_networkAddEntityAngledArea");
				var result = fn__networkAddEntityAngledArea(_x1, _y1, _z1, _x2, _y2, _z2, _width);
				return result;
			}
		}

		public int NetworkAddEntityDisplayedBoundaries(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5)
		{
			unsafe {
				if (fn__networkAddEntityDisplayedBoundaries == null) fn__networkAddEntityDisplayedBoundaries = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_networkAddEntityDisplayedBoundaries");
				var result = fn__networkAddEntityDisplayedBoundaries(_p0, _p1, _p2, _p3, _p4, _p5);
				return result;
			}
		}

		public int _0x2B1C623823DB0D9D(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__0x2B1C623823DB0D9D == null) fn__0x2B1C623823DB0D9D = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x2B1C623823DB0D9D");
				var result = fn__0x2B1C623823DB0D9D(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
				return result;
			}
		}

		public bool NetworkRemoveEntityArea(int _p0)
		{
			unsafe {
				if (fn__networkRemoveEntityArea == null) fn__networkRemoveEntityArea = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkRemoveEntityArea");
				var result = fn__networkRemoveEntityArea(_p0);
				return result;
			}
		}

		public bool NetworkEntityAreaDoesExist(int _areaHandle)
		{
			unsafe {
				if (fn__networkEntityAreaDoesExist == null) fn__networkEntityAreaDoesExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkEntityAreaDoesExist");
				var result = fn__networkEntityAreaDoesExist(_areaHandle);
				return result;
			}
		}

		public bool _0x4DF7CFFF471A7FB1(int _p0)
		{
			unsafe {
				if (fn__0x4DF7CFFF471A7FB1 == null) fn__0x4DF7CFFF471A7FB1 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x4DF7CFFF471A7FB1");
				var result = fn__0x4DF7CFFF471A7FB1(_p0);
				return result;
			}
		}

		public bool NetworkEntityAreaIsOccupied(int _areaHandle)
		{
			unsafe {
				if (fn__networkEntityAreaIsOccupied == null) fn__networkEntityAreaIsOccupied = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkEntityAreaIsOccupied");
				var result = fn__networkEntityAreaIsOccupied(_areaHandle);
				return result;
			}
		}

		public void NetworkUseHighPrecisionBlending(int _netID, bool _toggle)
		{
			unsafe {
				if (fn__networkUseHighPrecisionBlending == null) fn__networkUseHighPrecisionBlending = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkUseHighPrecisionBlending");
				fn__networkUseHighPrecisionBlending(_netID, _toggle);
			}
		}

		public void _0xA6FCECCF4721D679(int _p0)
		{
			unsafe {
				if (fn__0xA6FCECCF4721D679 == null) fn__0xA6FCECCF4721D679 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xA6FCECCF4721D679");
				fn__0xA6FCECCF4721D679(_p0);
			}
		}

		public void _0x95BAF97C82464629(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x95BAF97C82464629 == null) fn__0x95BAF97C82464629 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x95BAF97C82464629");
				fn__0x95BAF97C82464629(_p0, _p1);
			}
		}

		public bool NetworkRequestCloudBackgroundScripts()
		{
			unsafe {
				if (fn__networkRequestCloudBackgroundScripts == null) fn__networkRequestCloudBackgroundScripts = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkRequestCloudBackgroundScripts");
				var result = fn__networkRequestCloudBackgroundScripts();
				return result;
			}
		}

		public bool NetworkIsCloudBackgroundScriptRequestPending()
		{
			unsafe {
				if (fn__networkIsCloudBackgroundScriptRequestPending == null) fn__networkIsCloudBackgroundScriptRequestPending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsCloudBackgroundScriptRequestPending");
				var result = fn__networkIsCloudBackgroundScriptRequestPending();
				return result;
			}
		}

		public void NetworkRequestCloudTunables()
		{
			unsafe {
				if (fn__networkRequestCloudTunables == null) fn__networkRequestCloudTunables = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkRequestCloudTunables");
				fn__networkRequestCloudTunables();
			}
		}

		public bool NetworkIsTunableCloudRequestPending()
		{
			unsafe {
				if (fn__networkIsTunableCloudRequestPending == null) fn__networkIsTunableCloudRequestPending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsTunableCloudRequestPending");
				var result = fn__networkIsTunableCloudRequestPending();
				return result;
			}
		}

		public int NetworkGetTunableCloudCrc()
		{
			unsafe {
				if (fn__networkGetTunableCloudCrc == null) fn__networkGetTunableCloudCrc = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetTunableCloudCrc");
				var result = fn__networkGetTunableCloudCrc();
				return result;
			}
		}

		public bool NetworkDoesTunableExist(string _tunableContext, string _tunableName)
		{
			unsafe {
				if (fn__networkDoesTunableExist == null) fn__networkDoesTunableExist = (delegate* unmanaged[Cdecl]<nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_networkDoesTunableExist");
				var ptr_tunableContext = MemoryUtils.StringToHGlobalUtf8(_tunableContext);
				var ptr_tunableName = MemoryUtils.StringToHGlobalUtf8(_tunableName);
				var result = fn__networkDoesTunableExist(ptr_tunableContext, ptr_tunableName);
				Marshal.FreeHGlobal(ptr_tunableContext);
				Marshal.FreeHGlobal(ptr_tunableName);
				return result;
			}
		}

		public bool NetworkAccessTunableInt(string _tunableContext, string _tunableName, ref int _value)
		{
			unsafe {
				if (fn__networkAccessTunableInt == null) fn__networkAccessTunableInt = (delegate* unmanaged[Cdecl]<nint, nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkAccessTunableInt");
				var ptr_tunableContext = MemoryUtils.StringToHGlobalUtf8(_tunableContext);
				var ptr_tunableName = MemoryUtils.StringToHGlobalUtf8(_tunableName);
				var ref_value = _value;
				var result = fn__networkAccessTunableInt(ptr_tunableContext, ptr_tunableName, &ref_value);
				Marshal.FreeHGlobal(ptr_tunableContext);
				Marshal.FreeHGlobal(ptr_tunableName);
				_value = ref_value;
				return result;
			}
		}

		public bool NetworkAccessTunableFloat(string _tunableContext, string _tunableName, ref float _value)
		{
			unsafe {
				if (fn__networkAccessTunableFloat == null) fn__networkAccessTunableFloat = (delegate* unmanaged[Cdecl]<nint, nint, float*, bool>) NativeLibrary.GetExport(handle, "Native_networkAccessTunableFloat");
				var ptr_tunableContext = MemoryUtils.StringToHGlobalUtf8(_tunableContext);
				var ptr_tunableName = MemoryUtils.StringToHGlobalUtf8(_tunableName);
				var ref_value = _value;
				var result = fn__networkAccessTunableFloat(ptr_tunableContext, ptr_tunableName, &ref_value);
				Marshal.FreeHGlobal(ptr_tunableContext);
				Marshal.FreeHGlobal(ptr_tunableName);
				_value = ref_value;
				return result;
			}
		}

		public bool NetworkAccessTunableBool(string _tunableContext, string _tunableName)
		{
			unsafe {
				if (fn__networkAccessTunableBool == null) fn__networkAccessTunableBool = (delegate* unmanaged[Cdecl]<nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_networkAccessTunableBool");
				var ptr_tunableContext = MemoryUtils.StringToHGlobalUtf8(_tunableContext);
				var ptr_tunableName = MemoryUtils.StringToHGlobalUtf8(_tunableName);
				var result = fn__networkAccessTunableBool(ptr_tunableContext, ptr_tunableName);
				Marshal.FreeHGlobal(ptr_tunableContext);
				Marshal.FreeHGlobal(ptr_tunableName);
				return result;
			}
		}

		public bool NetworkDoesTunableExistHash(int _tunableContext, int _tunableName)
		{
			unsafe {
				if (fn__networkDoesTunableExistHash == null) fn__networkDoesTunableExistHash = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkDoesTunableExistHash");
				var result = fn__networkDoesTunableExistHash(_tunableContext, _tunableName);
				return result;
			}
		}

		public bool NetworkAllocateTunablesRegistrationDataMap()
		{
			unsafe {
				if (fn__networkAllocateTunablesRegistrationDataMap == null) fn__networkAllocateTunablesRegistrationDataMap = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkAllocateTunablesRegistrationDataMap");
				var result = fn__networkAllocateTunablesRegistrationDataMap();
				return result;
			}
		}

		public bool NetworkAccessTunableIntHash(int _tunableContext, int _tunableName, ref int _value)
		{
			unsafe {
				if (fn__networkAccessTunableIntHash == null) fn__networkAccessTunableIntHash = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkAccessTunableIntHash");
				var ref_value = _value;
				var result = fn__networkAccessTunableIntHash(_tunableContext, _tunableName, &ref_value);
				_value = ref_value;
				return result;
			}
		}

		public bool NetworkRegisterTunableIntHash(int _contextHash, int _nameHash, ref int _value)
		{
			unsafe {
				if (fn__networkRegisterTunableIntHash == null) fn__networkRegisterTunableIntHash = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkRegisterTunableIntHash");
				var ref_value = _value;
				var result = fn__networkRegisterTunableIntHash(_contextHash, _nameHash, &ref_value);
				_value = ref_value;
				return result;
			}
		}

		public bool NetworkAccessTunableFloatHash(int _tunableContext, int _tunableName, ref float _value)
		{
			unsafe {
				if (fn__networkAccessTunableFloatHash == null) fn__networkAccessTunableFloatHash = (delegate* unmanaged[Cdecl]<int, int, float*, bool>) NativeLibrary.GetExport(handle, "Native_networkAccessTunableFloatHash");
				var ref_value = _value;
				var result = fn__networkAccessTunableFloatHash(_tunableContext, _tunableName, &ref_value);
				_value = ref_value;
				return result;
			}
		}

		public bool NetworkRegisterTunableFloatHash(int _contextHash, int _nameHash, ref float _value)
		{
			unsafe {
				if (fn__networkRegisterTunableFloatHash == null) fn__networkRegisterTunableFloatHash = (delegate* unmanaged[Cdecl]<int, int, float*, bool>) NativeLibrary.GetExport(handle, "Native_networkRegisterTunableFloatHash");
				var ref_value = _value;
				var result = fn__networkRegisterTunableFloatHash(_contextHash, _nameHash, &ref_value);
				_value = ref_value;
				return result;
			}
		}

		public bool NetworkAccessTunableBoolHash(int _tunableContext, int _tunableName)
		{
			unsafe {
				if (fn__networkAccessTunableBoolHash == null) fn__networkAccessTunableBoolHash = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkAccessTunableBoolHash");
				var result = fn__networkAccessTunableBoolHash(_tunableContext, _tunableName);
				return result;
			}
		}

		public bool NetworkRegisterTunableBoolHash(int _contextHash, int _nameHash, ref bool _value)
		{
			unsafe {
				if (fn__networkRegisterTunableBoolHash == null) fn__networkRegisterTunableBoolHash = (delegate* unmanaged[Cdecl]<int, int, bool*, bool>) NativeLibrary.GetExport(handle, "Native_networkRegisterTunableBoolHash");
				var ref_value = _value;
				var result = fn__networkRegisterTunableBoolHash(_contextHash, _nameHash, &ref_value);
				_value = ref_value;
				return result;
			}
		}

		public bool NetworkTryAccessTunableBoolHash(int _tunableContext, int _tunableName, bool _defaultValue)
		{
			unsafe {
				if (fn__networkTryAccessTunableBoolHash == null) fn__networkTryAccessTunableBoolHash = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_networkTryAccessTunableBoolHash");
				var result = fn__networkTryAccessTunableBoolHash(_tunableContext, _tunableName, _defaultValue);
				return result;
			}
		}

		public int NetworkGetContentModifierListId(int _contentHash)
		{
			unsafe {
				if (fn__networkGetContentModifierListId == null) fn__networkGetContentModifierListId = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetContentModifierListId");
				var result = fn__networkGetContentModifierListId(_contentHash);
				return result;
			}
		}

		public int _0x7DB53B37A2F211A0()
		{
			unsafe {
				if (fn__0x7DB53B37A2F211A0 == null) fn__0x7DB53B37A2F211A0 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x7DB53B37A2F211A0");
				var result = fn__0x7DB53B37A2F211A0();
				return result;
			}
		}

		public void NetworkResetBodyTracker()
		{
			unsafe {
				if (fn__networkResetBodyTracker == null) fn__networkResetBodyTracker = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkResetBodyTracker");
				fn__networkResetBodyTracker();
			}
		}

		public int NetworkGetNumBodyTrackers()
		{
			unsafe {
				if (fn__networkGetNumBodyTrackers == null) fn__networkGetNumBodyTrackers = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkGetNumBodyTrackers");
				var result = fn__networkGetNumBodyTrackers();
				return result;
			}
		}

		public bool _0x2E0BF682CC778D49(int _p0)
		{
			unsafe {
				if (fn__0x2E0BF682CC778D49 == null) fn__0x2E0BF682CC778D49 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x2E0BF682CC778D49");
				var result = fn__0x2E0BF682CC778D49(_p0);
				return result;
			}
		}

		public bool _0x0EDE326D47CD0F3E(int _ped, int _player)
		{
			unsafe {
				if (fn__0x0EDE326D47CD0F3E == null) fn__0x0EDE326D47CD0F3E = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native__0x0EDE326D47CD0F3E");
				var result = fn__0x0EDE326D47CD0F3E(_ped, _player);
				return result;
			}
		}

		public void NetworkSetVehicleWheelsDestructible(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__networkSetVehicleWheelsDestructible == null) fn__networkSetVehicleWheelsDestructible = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkSetVehicleWheelsDestructible");
				fn__networkSetVehicleWheelsDestructible(_entity, _toggle);
			}
		}

		public void _0x38B7C51AB1EDC7D8(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__0x38B7C51AB1EDC7D8 == null) fn__0x38B7C51AB1EDC7D8 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x38B7C51AB1EDC7D8");
				fn__0x38B7C51AB1EDC7D8(_entity, _toggle);
			}
		}

		public void _0x3FC795691834481D(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x3FC795691834481D == null) fn__0x3FC795691834481D = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x3FC795691834481D");
				fn__0x3FC795691834481D(_p0, _p1);
			}
		}

		public void NetworkExplodeVehicle(int _vehicle, bool _isAudible, bool _isInvisible, bool _p3)
		{
			unsafe {
				if (fn__networkExplodeVehicle == null) fn__networkExplodeVehicle = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_networkExplodeVehicle");
				fn__networkExplodeVehicle(_vehicle, _isAudible, _isInvisible, _p3);
			}
		}

		public void _0x2A5E0621DD815A9A(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x2A5E0621DD815A9A == null) fn__0x2A5E0621DD815A9A = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2A5E0621DD815A9A");
				fn__0x2A5E0621DD815A9A(_p0, _p1, _p2, _p3);
			}
		}

		public void NetworkUseLogarithmicBlendingThisFrame(int _entity)
		{
			unsafe {
				if (fn__networkUseLogarithmicBlendingThisFrame == null) fn__networkUseLogarithmicBlendingThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkUseLogarithmicBlendingThisFrame");
				fn__networkUseLogarithmicBlendingThisFrame(_entity);
			}
		}

		public void NetworkOverrideCoordsAndHeading(int _entity, float _x, float _y, float _z, float _heading)
		{
			unsafe {
				if (fn__networkOverrideCoordsAndHeading == null) fn__networkOverrideCoordsAndHeading = (delegate* unmanaged[Cdecl]<int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_networkOverrideCoordsAndHeading");
				fn__networkOverrideCoordsAndHeading(_entity, _x, _y, _z, _heading);
			}
		}

		public void _0xE6717E652B8C8D8A(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xE6717E652B8C8D8A == null) fn__0xE6717E652B8C8D8A = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xE6717E652B8C8D8A");
				fn__0xE6717E652B8C8D8A(_p0, _p1);
			}
		}

		public void NetworkDisableProximityMigration(int _netID)
		{
			unsafe {
				if (fn__networkDisableProximityMigration == null) fn__networkDisableProximityMigration = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkDisableProximityMigration");
				fn__networkDisableProximityMigration(_netID);
			}
		}

		public void NetworkSetPropertyId(int _id)
		{
			unsafe {
				if (fn__networkSetPropertyId == null) fn__networkSetPropertyId = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_networkSetPropertyId");
				fn__networkSetPropertyId(_id);
			}
		}

		public void NetworkClearPropertyId()
		{
			unsafe {
				if (fn__networkClearPropertyId == null) fn__networkClearPropertyId = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkClearPropertyId");
				fn__networkClearPropertyId();
			}
		}

		public void _0x367EF5E2F439B4C6(int _p0)
		{
			unsafe {
				if (fn__0x367EF5E2F439B4C6 == null) fn__0x367EF5E2F439B4C6 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x367EF5E2F439B4C6");
				fn__0x367EF5E2F439B4C6(_p0);
			}
		}

		public void _0x94538037EE44F5CF(bool _p0)
		{
			unsafe {
				if (fn__0x94538037EE44F5CF == null) fn__0x94538037EE44F5CF = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x94538037EE44F5CF");
				fn__0x94538037EE44F5CF(_p0);
			}
		}

		public void NetworkCacheLocalPlayerHeadBlendData()
		{
			unsafe {
				if (fn__networkCacheLocalPlayerHeadBlendData == null) fn__networkCacheLocalPlayerHeadBlendData = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkCacheLocalPlayerHeadBlendData");
				fn__networkCacheLocalPlayerHeadBlendData();
			}
		}

		public bool NetworkHasCachedPlayerHeadBlendData(int _player)
		{
			unsafe {
				if (fn__networkHasCachedPlayerHeadBlendData == null) fn__networkHasCachedPlayerHeadBlendData = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkHasCachedPlayerHeadBlendData");
				var result = fn__networkHasCachedPlayerHeadBlendData(_player);
				return result;
			}
		}

		public bool NetworkApplyCachedPlayerHeadBlendData(int _ped, int _player)
		{
			unsafe {
				if (fn__networkApplyCachedPlayerHeadBlendData == null) fn__networkApplyCachedPlayerHeadBlendData = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_networkApplyCachedPlayerHeadBlendData");
				var result = fn__networkApplyCachedPlayerHeadBlendData(_ped, _player);
				return result;
			}
		}

		public int GetNumCommerceItems()
		{
			unsafe {
				if (fn__getNumCommerceItems == null) fn__getNumCommerceItems = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumCommerceItems");
				var result = fn__getNumCommerceItems();
				return result;
			}
		}

		public bool IsCommerceDataValid()
		{
			unsafe {
				if (fn__isCommerceDataValid == null) fn__isCommerceDataValid = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isCommerceDataValid");
				var result = fn__isCommerceDataValid();
				return result;
			}
		}

		public void _0xB606E6CC59664972(int _p0)
		{
			unsafe {
				if (fn__0xB606E6CC59664972 == null) fn__0xB606E6CC59664972 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xB606E6CC59664972");
				fn__0xB606E6CC59664972(_p0);
			}
		}

		public bool _0x1D4DC17C38FEAFF0()
		{
			unsafe {
				if (fn__0x1D4DC17C38FEAFF0 == null) fn__0x1D4DC17C38FEAFF0 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x1D4DC17C38FEAFF0");
				var result = fn__0x1D4DC17C38FEAFF0();
				return result;
			}
		}

		public string GetCommerceItemId(int _index)
		{
			unsafe {
				if (fn__getCommerceItemId == null) fn__getCommerceItemId = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getCommerceItemId");
				var result = fn__getCommerceItemId(_index);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetCommerceItemName(int _index)
		{
			unsafe {
				if (fn__getCommerceItemName == null) fn__getCommerceItemName = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getCommerceItemName");
				var result = fn__getCommerceItemName(_index);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetCommerceProductPrice(int _index)
		{
			unsafe {
				if (fn__getCommerceProductPrice == null) fn__getCommerceProductPrice = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getCommerceProductPrice");
				var result = fn__getCommerceProductPrice(_index);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int GetCommerceItemNumCats(int _index)
		{
			unsafe {
				if (fn__getCommerceItemNumCats == null) fn__getCommerceItemNumCats = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getCommerceItemNumCats");
				var result = fn__getCommerceItemNumCats(_index);
				return result;
			}
		}

		public string GetCommerceItemCat(int _index, int _index2)
		{
			unsafe {
				if (fn__getCommerceItemCat == null) fn__getCommerceItemCat = (delegate* unmanaged[Cdecl]<int, int, nint>) NativeLibrary.GetExport(handle, "Native_getCommerceItemCat");
				var result = fn__getCommerceItemCat(_index, _index2);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void OpenCommerceStore(string _p0, string _p1, int _p2)
		{
			unsafe {
				if (fn__openCommerceStore == null) fn__openCommerceStore = (delegate* unmanaged[Cdecl]<nint, nint, int, void>) NativeLibrary.GetExport(handle, "Native_openCommerceStore");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__openCommerceStore(ptr_p0, ptr_p1, _p2);
				Marshal.FreeHGlobal(ptr_p0);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public bool IsCommerceStoreOpen()
		{
			unsafe {
				if (fn__isCommerceStoreOpen == null) fn__isCommerceStoreOpen = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isCommerceStoreOpen");
				var result = fn__isCommerceStoreOpen();
				return result;
			}
		}

		public void SetStoreEnabled(bool _toggle)
		{
			unsafe {
				if (fn__setStoreEnabled == null) fn__setStoreEnabled = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setStoreEnabled");
				fn__setStoreEnabled(_toggle);
			}
		}

		public bool RequestCommerceItemImage(int _index)
		{
			unsafe {
				if (fn__requestCommerceItemImage == null) fn__requestCommerceItemImage = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_requestCommerceItemImage");
				var result = fn__requestCommerceItemImage(_index);
				return result;
			}
		}

		public void ReleaseAllCommerceItemImages()
		{
			unsafe {
				if (fn__releaseAllCommerceItemImages == null) fn__releaseAllCommerceItemImages = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_releaseAllCommerceItemImages");
				fn__releaseAllCommerceItemImages();
			}
		}

		public string GetCommerceItemTexturename(int _index)
		{
			unsafe {
				if (fn__getCommerceItemTexturename == null) fn__getCommerceItemTexturename = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getCommerceItemTexturename");
				var result = fn__getCommerceItemTexturename(_index);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool IsStoreAvailableToUser()
		{
			unsafe {
				if (fn__isStoreAvailableToUser == null) fn__isStoreAvailableToUser = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isStoreAvailableToUser");
				var result = fn__isStoreAvailableToUser();
				return result;
			}
		}

		public void _0x265635150FB0D82E()
		{
			unsafe {
				if (fn__0x265635150FB0D82E == null) fn__0x265635150FB0D82E = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x265635150FB0D82E");
				fn__0x265635150FB0D82E();
			}
		}

		public void _0x444C4525ECE0A4B9()
		{
			unsafe {
				if (fn__0x444C4525ECE0A4B9 == null) fn__0x444C4525ECE0A4B9 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x444C4525ECE0A4B9");
				fn__0x444C4525ECE0A4B9();
			}
		}

		public bool _0x59328EB08C5CEB2B()
		{
			unsafe {
				if (fn__0x59328EB08C5CEB2B == null) fn__0x59328EB08C5CEB2B = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x59328EB08C5CEB2B");
				var result = fn__0x59328EB08C5CEB2B();
				return result;
			}
		}

		public void _0xFAE628F1E9ADB239(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xFAE628F1E9ADB239 == null) fn__0xFAE628F1E9ADB239 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xFAE628F1E9ADB239");
				fn__0xFAE628F1E9ADB239(_p0, _p1, _p2);
			}
		}

		public int _0x754615490A029508()
		{
			unsafe {
				if (fn__0x754615490A029508 == null) fn__0x754615490A029508 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x754615490A029508");
				var result = fn__0x754615490A029508();
				return result;
			}
		}

		public int _0x155467ACA0F55705()
		{
			unsafe {
				if (fn__0x155467ACA0F55705 == null) fn__0x155467ACA0F55705 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x155467ACA0F55705");
				var result = fn__0x155467ACA0F55705();
				return result;
			}
		}

		public int CloudDeleteMemberFile(string _p0)
		{
			unsafe {
				if (fn__cloudDeleteMemberFile == null) fn__cloudDeleteMemberFile = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_cloudDeleteMemberFile");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var result = fn__cloudDeleteMemberFile(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
				return result;
			}
		}

		public bool CloudHasRequestCompleted(int _handle)
		{
			unsafe {
				if (fn__cloudHasRequestCompleted == null) fn__cloudHasRequestCompleted = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_cloudHasRequestCompleted");
				var result = fn__cloudHasRequestCompleted(_handle);
				return result;
			}
		}

		public bool CloudDidRequestSucceed(int _handle)
		{
			unsafe {
				if (fn__cloudDidRequestSucceed == null) fn__cloudDidRequestSucceed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_cloudDidRequestSucceed");
				var result = fn__cloudDidRequestSucceed(_handle);
				return result;
			}
		}

		public void CloudCheckAvailability()
		{
			unsafe {
				if (fn__cloudCheckAvailability == null) fn__cloudCheckAvailability = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_cloudCheckAvailability");
				fn__cloudCheckAvailability();
			}
		}

		public bool CloudIsCheckingAvailability()
		{
			unsafe {
				if (fn__cloudIsCheckingAvailability == null) fn__cloudIsCheckingAvailability = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_cloudIsCheckingAvailability");
				var result = fn__cloudIsCheckingAvailability();
				return result;
			}
		}

		public bool CloudGetAvailabilityCheckResult()
		{
			unsafe {
				if (fn__cloudGetAvailabilityCheckResult == null) fn__cloudGetAvailabilityCheckResult = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_cloudGetAvailabilityCheckResult");
				var result = fn__cloudGetAvailabilityCheckResult();
				return result;
			}
		}

		public int _0x8B0C2964BA471961()
		{
			unsafe {
				if (fn__0x8B0C2964BA471961 == null) fn__0x8B0C2964BA471961 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x8B0C2964BA471961");
				var result = fn__0x8B0C2964BA471961();
				return result;
			}
		}

		public int _0x88B588B41FF7868E()
		{
			unsafe {
				if (fn__0x88B588B41FF7868E == null) fn__0x88B588B41FF7868E = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x88B588B41FF7868E");
				var result = fn__0x88B588B41FF7868E();
				return result;
			}
		}

		public int _0x67FC09BC554A75E5()
		{
			unsafe {
				if (fn__0x67FC09BC554A75E5 == null) fn__0x67FC09BC554A75E5 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x67FC09BC554A75E5");
				var result = fn__0x67FC09BC554A75E5();
				return result;
			}
		}

		public void ClearLaunchParams()
		{
			unsafe {
				if (fn__clearLaunchParams == null) fn__clearLaunchParams = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearLaunchParams");
				fn__clearLaunchParams();
			}
		}

		public bool UgcCopyContent(ref int _p0, ref int _p1)
		{
			unsafe {
				if (fn__ugcCopyContent == null) fn__ugcCopyContent = (delegate* unmanaged[Cdecl]<int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_ugcCopyContent");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__ugcCopyContent(&ref_p0, &ref_p1);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public int _0x9FEDF86898F100E9()
		{
			unsafe {
				if (fn__0x9FEDF86898F100E9 == null) fn__0x9FEDF86898F100E9 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x9FEDF86898F100E9");
				var result = fn__0x9FEDF86898F100E9();
				return result;
			}
		}

		public bool UgcHasCreateFinished()
		{
			unsafe {
				if (fn__ugcHasCreateFinished == null) fn__ugcHasCreateFinished = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_ugcHasCreateFinished");
				var result = fn__ugcHasCreateFinished();
				return result;
			}
		}

		public int UgcDidCreateSucceed()
		{
			unsafe {
				if (fn__ugcDidCreateSucceed == null) fn__ugcDidCreateSucceed = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcDidCreateSucceed");
				var result = fn__ugcDidCreateSucceed();
				return result;
			}
		}

		public int UgcGetCreateResult()
		{
			unsafe {
				if (fn__ugcGetCreateResult == null) fn__ugcGetCreateResult = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcGetCreateResult");
				var result = fn__ugcGetCreateResult();
				return result;
			}
		}

		public int UgcGetCreateContentId()
		{
			unsafe {
				if (fn__ugcGetCreateContentId == null) fn__ugcGetCreateContentId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcGetCreateContentId");
				var result = fn__ugcGetCreateContentId();
				return result;
			}
		}

		public void UgcClearCreateResult()
		{
			unsafe {
				if (fn__ugcClearCreateResult == null) fn__ugcClearCreateResult = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_ugcClearCreateResult");
				fn__ugcClearCreateResult();
			}
		}

		public bool UgcQueryMyContent(int _p0, int _p1, ref int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__ugcQueryMyContent == null) fn__ugcQueryMyContent = (delegate* unmanaged[Cdecl]<int, int, int*, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_ugcQueryMyContent");
				var ref_p2 = _p2;
				var result = fn__ugcQueryMyContent(_p0, _p1, &ref_p2, _p3, _p4, _p5);
				_p2 = ref_p2;
				return result;
			}
		}

		public bool _0x692D58DF40657E8C(int _p0, int _p1, int _p2, string _p3, int _p4, bool _p5)
		{
			unsafe {
				if (fn__0x692D58DF40657E8C == null) fn__0x692D58DF40657E8C = (delegate* unmanaged[Cdecl]<int, int, int, nint, int, bool, bool>) NativeLibrary.GetExport(handle, "Native__0x692D58DF40657E8C");
				var ptr_p3 = MemoryUtils.StringToHGlobalUtf8(_p3);
				var result = fn__0x692D58DF40657E8C(_p0, _p1, _p2, ptr_p3, _p4, _p5);
				Marshal.FreeHGlobal(ptr_p3);
				return result;
			}
		}

		public bool UgcQueryByContentId(string _contentId, bool _latestVersion, string _contentTypeName)
		{
			unsafe {
				if (fn__ugcQueryByContentId == null) fn__ugcQueryByContentId = (delegate* unmanaged[Cdecl]<nint, bool, nint, bool>) NativeLibrary.GetExport(handle, "Native_ugcQueryByContentId");
				var ptr_contentId = MemoryUtils.StringToHGlobalUtf8(_contentId);
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcQueryByContentId(ptr_contentId, _latestVersion, ptr_contentTypeName);
				Marshal.FreeHGlobal(ptr_contentId);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool UgcQueryByContentIds(ref int _data, int _count, bool _latestVersion, string _contentTypeName)
		{
			unsafe {
				if (fn__ugcQueryByContentIds == null) fn__ugcQueryByContentIds = (delegate* unmanaged[Cdecl]<int*, int, bool, nint, bool>) NativeLibrary.GetExport(handle, "Native_ugcQueryByContentIds");
				var ref_data = _data;
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcQueryByContentIds(&ref_data, _count, _latestVersion, ptr_contentTypeName);
				_data = ref_data;
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool UgcQueryRecentlyCreatedContent(int _offset, int _count, string _contentTypeName, int _p3)
		{
			unsafe {
				if (fn__ugcQueryRecentlyCreatedContent == null) fn__ugcQueryRecentlyCreatedContent = (delegate* unmanaged[Cdecl]<int, int, nint, int, bool>) NativeLibrary.GetExport(handle, "Native_ugcQueryRecentlyCreatedContent");
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcQueryRecentlyCreatedContent(_offset, _count, ptr_contentTypeName, _p3);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool UgcGetBookmarkedContent(int _p0, int _p1, string _p2, ref int _p3)
		{
			unsafe {
				if (fn__ugcGetBookmarkedContent == null) fn__ugcGetBookmarkedContent = (delegate* unmanaged[Cdecl]<int, int, nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_ugcGetBookmarkedContent");
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var ref_p3 = _p3;
				var result = fn__ugcGetBookmarkedContent(_p0, _p1, ptr_p2, &ref_p3);
				Marshal.FreeHGlobal(ptr_p2);
				_p3 = ref_p3;
				return result;
			}
		}

		public bool UgcGetMyContent(int _p0, int _p1, string _p2, ref int _p3)
		{
			unsafe {
				if (fn__ugcGetMyContent == null) fn__ugcGetMyContent = (delegate* unmanaged[Cdecl]<int, int, nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_ugcGetMyContent");
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var ref_p3 = _p3;
				var result = fn__ugcGetMyContent(_p0, _p1, ptr_p2, &ref_p3);
				Marshal.FreeHGlobal(ptr_p2);
				_p3 = ref_p3;
				return result;
			}
		}

		public bool UgcGetFriendContent(int _p0, int _p1, string _p2, ref int _p3)
		{
			unsafe {
				if (fn__ugcGetFriendContent == null) fn__ugcGetFriendContent = (delegate* unmanaged[Cdecl]<int, int, nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_ugcGetFriendContent");
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var ref_p3 = _p3;
				var result = fn__ugcGetFriendContent(_p0, _p1, ptr_p2, &ref_p3);
				Marshal.FreeHGlobal(ptr_p2);
				_p3 = ref_p3;
				return result;
			}
		}

		public bool UgcGetCrewContent(int _p0, int _p1, int _p2, string _p3, ref int _p4)
		{
			unsafe {
				if (fn__ugcGetCrewContent == null) fn__ugcGetCrewContent = (delegate* unmanaged[Cdecl]<int, int, int, nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_ugcGetCrewContent");
				var ptr_p3 = MemoryUtils.StringToHGlobalUtf8(_p3);
				var ref_p4 = _p4;
				var result = fn__ugcGetCrewContent(_p0, _p1, _p2, ptr_p3, &ref_p4);
				Marshal.FreeHGlobal(ptr_p3);
				_p4 = ref_p4;
				return result;
			}
		}

		public bool UgcGetGetByCategory(int _p0, int _p1, int _p2, string _p3, ref int _p4)
		{
			unsafe {
				if (fn__ugcGetGetByCategory == null) fn__ugcGetGetByCategory = (delegate* unmanaged[Cdecl]<int, int, int, nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_ugcGetGetByCategory");
				var ptr_p3 = MemoryUtils.StringToHGlobalUtf8(_p3);
				var ref_p4 = _p4;
				var result = fn__ugcGetGetByCategory(_p0, _p1, _p2, ptr_p3, &ref_p4);
				Marshal.FreeHGlobal(ptr_p3);
				_p4 = ref_p4;
				return result;
			}
		}

		public bool SetBalanceAddMachine(string _contentId, string _contentTypeName)
		{
			unsafe {
				if (fn__setBalanceAddMachine == null) fn__setBalanceAddMachine = (delegate* unmanaged[Cdecl]<nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_setBalanceAddMachine");
				var ptr_contentId = MemoryUtils.StringToHGlobalUtf8(_contentId);
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__setBalanceAddMachine(ptr_contentId, ptr_contentTypeName);
				Marshal.FreeHGlobal(ptr_contentId);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool SetBalanceAddMachines(ref int _data, int _dataCount, string _contentTypeName)
		{
			unsafe {
				if (fn__setBalanceAddMachines == null) fn__setBalanceAddMachines = (delegate* unmanaged[Cdecl]<int*, int, nint, bool>) NativeLibrary.GetExport(handle, "Native_setBalanceAddMachines");
				var ref_data = _data;
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__setBalanceAddMachines(&ref_data, _dataCount, ptr_contentTypeName);
				_data = ref_data;
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool _0xA7862BC5ED1DFD7E(int _p0, int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__0xA7862BC5ED1DFD7E == null) fn__0xA7862BC5ED1DFD7E = (delegate* unmanaged[Cdecl]<int, int, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0xA7862BC5ED1DFD7E");
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				var result = fn__0xA7862BC5ED1DFD7E(_p0, _p1, &ref_p2, &ref_p3);
				_p2 = ref_p2;
				_p3 = ref_p3;
				return result;
			}
		}

		public bool _0x97A770BEEF227E2B(int _p0, int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__0x97A770BEEF227E2B == null) fn__0x97A770BEEF227E2B = (delegate* unmanaged[Cdecl]<int, int, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x97A770BEEF227E2B");
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				var result = fn__0x97A770BEEF227E2B(_p0, _p1, &ref_p2, &ref_p3);
				_p2 = ref_p2;
				_p3 = ref_p3;
				return result;
			}
		}

		public bool _0x5324A0E3E4CE3570(int _p0, int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__0x5324A0E3E4CE3570 == null) fn__0x5324A0E3E4CE3570 = (delegate* unmanaged[Cdecl]<int, int, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x5324A0E3E4CE3570");
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				var result = fn__0x5324A0E3E4CE3570(_p0, _p1, &ref_p2, &ref_p3);
				_p2 = ref_p2;
				_p3 = ref_p3;
				return result;
			}
		}

		public void UgcCancelQuery()
		{
			unsafe {
				if (fn__ugcCancelQuery == null) fn__ugcCancelQuery = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_ugcCancelQuery");
				fn__ugcCancelQuery();
			}
		}

		public bool UgcIsGetting()
		{
			unsafe {
				if (fn__ugcIsGetting == null) fn__ugcIsGetting = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_ugcIsGetting");
				var result = fn__ugcIsGetting();
				return result;
			}
		}

		public bool UgcHasGetFinished()
		{
			unsafe {
				if (fn__ugcHasGetFinished == null) fn__ugcHasGetFinished = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_ugcHasGetFinished");
				var result = fn__ugcHasGetFinished();
				return result;
			}
		}

		public int UgcDidGetSucceed()
		{
			unsafe {
				if (fn__ugcDidGetSucceed == null) fn__ugcDidGetSucceed = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcDidGetSucceed");
				var result = fn__ugcDidGetSucceed();
				return result;
			}
		}

		public int _0xC87E740D9F3872CC()
		{
			unsafe {
				if (fn__0xC87E740D9F3872CC == null) fn__0xC87E740D9F3872CC = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xC87E740D9F3872CC");
				var result = fn__0xC87E740D9F3872CC();
				return result;
			}
		}

		public int UgcGetQueryResult()
		{
			unsafe {
				if (fn__ugcGetQueryResult == null) fn__ugcGetQueryResult = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcGetQueryResult");
				var result = fn__ugcGetQueryResult();
				return result;
			}
		}

		public int UgcGetContentNum()
		{
			unsafe {
				if (fn__ugcGetContentNum == null) fn__ugcGetContentNum = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentNum");
				var result = fn__ugcGetContentNum();
				return result;
			}
		}

		public int UgcGetContentTotal()
		{
			unsafe {
				if (fn__ugcGetContentTotal == null) fn__ugcGetContentTotal = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentTotal");
				var result = fn__ugcGetContentTotal();
				return result;
			}
		}

		public int UgcGetContentHash()
		{
			unsafe {
				if (fn__ugcGetContentHash == null) fn__ugcGetContentHash = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentHash");
				var result = fn__ugcGetContentHash();
				return result;
			}
		}

		public void UgcClearQueryResults()
		{
			unsafe {
				if (fn__ugcClearQueryResults == null) fn__ugcClearQueryResults = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_ugcClearQueryResults");
				fn__ugcClearQueryResults();
			}
		}

		public string UgcGetContentUserId(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentUserId == null) fn__ugcGetContentUserId = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_ugcGetContentUserId");
				var result = fn__ugcGetContentUserId(_p0);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool _0x584770794D758C18(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__0x584770794D758C18 == null) fn__0x584770794D758C18 = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x584770794D758C18");
				var ref_p1 = _p1;
				var result = fn__0x584770794D758C18(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool _0x8C8D2739BA44AF0F(int _p0)
		{
			unsafe {
				if (fn__0x8C8D2739BA44AF0F == null) fn__0x8C8D2739BA44AF0F = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x8C8D2739BA44AF0F");
				var result = fn__0x8C8D2739BA44AF0F(_p0);
				return result;
			}
		}

		public int UgcGetContentUserName(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentUserName == null) fn__ugcGetContentUserName = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentUserName");
				var result = fn__ugcGetContentUserName(_p0);
				return result;
			}
		}

		public bool _0xAEAB987727C5A8A4(int _p0)
		{
			unsafe {
				if (fn__0xAEAB987727C5A8A4 == null) fn__0xAEAB987727C5A8A4 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xAEAB987727C5A8A4");
				var result = fn__0xAEAB987727C5A8A4(_p0);
				return result;
			}
		}

		public int UgcGetContentCategory(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentCategory == null) fn__ugcGetContentCategory = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentCategory");
				var result = fn__ugcGetContentCategory(_p0);
				return result;
			}
		}

		public string UgcGetContentId(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentId == null) fn__ugcGetContentId = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_ugcGetContentId");
				var result = fn__ugcGetContentId(_p0);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string UgcGetRootContentId(int _p0)
		{
			unsafe {
				if (fn__ugcGetRootContentId == null) fn__ugcGetRootContentId = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_ugcGetRootContentId");
				var result = fn__ugcGetRootContentId(_p0);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int UgcGetContentName(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentName == null) fn__ugcGetContentName = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentName");
				var result = fn__ugcGetContentName(_p0);
				return result;
			}
		}

		public int UgcGetContentDescriptionHash(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentDescriptionHash == null) fn__ugcGetContentDescriptionHash = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentDescriptionHash");
				var result = fn__ugcGetContentDescriptionHash(_p0);
				return result;
			}
		}

		public string UgcGetContentPath(int _p0, int _p1)
		{
			unsafe {
				if (fn__ugcGetContentPath == null) fn__ugcGetContentPath = (delegate* unmanaged[Cdecl]<int, int, nint>) NativeLibrary.GetExport(handle, "Native_ugcGetContentPath");
				var result = fn__ugcGetContentPath(_p0, _p1);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void UgcGetContentUpdatedDate(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__ugcGetContentUpdatedDate == null) fn__ugcGetContentUpdatedDate = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_ugcGetContentUpdatedDate");
				var ref_p1 = _p1;
				fn__ugcGetContentUpdatedDate(_p0, &ref_p1);
				_p1 = ref_p1;
			}
		}

		public int UgcGetContentFileVersion(int _p0, int _p1)
		{
			unsafe {
				if (fn__ugcGetContentFileVersion == null) fn__ugcGetContentFileVersion = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentFileVersion");
				var result = fn__ugcGetContentFileVersion(_p0, _p1);
				return result;
			}
		}

		public bool _0x1D610EB0FEA716D9(int _p0)
		{
			unsafe {
				if (fn__0x1D610EB0FEA716D9 == null) fn__0x1D610EB0FEA716D9 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x1D610EB0FEA716D9");
				var result = fn__0x1D610EB0FEA716D9(_p0);
				return result;
			}
		}

		public bool _0x7FCC39C46C3C03BD(int _p0)
		{
			unsafe {
				if (fn__0x7FCC39C46C3C03BD == null) fn__0x7FCC39C46C3C03BD = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x7FCC39C46C3C03BD");
				var result = fn__0x7FCC39C46C3C03BD(_p0);
				return result;
			}
		}

		public int UgcGetContentLanguage(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentLanguage == null) fn__ugcGetContentLanguage = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentLanguage");
				var result = fn__ugcGetContentLanguage(_p0);
				return result;
			}
		}

		public bool UgcGetContentIsPublished(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentIsPublished == null) fn__ugcGetContentIsPublished = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_ugcGetContentIsPublished");
				var result = fn__ugcGetContentIsPublished(_p0);
				return result;
			}
		}

		public bool UgcGetContentIsVerified(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentIsVerified == null) fn__ugcGetContentIsVerified = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_ugcGetContentIsVerified");
				var result = fn__ugcGetContentIsVerified(_p0);
				return result;
			}
		}

		public int UgcGetContentRating(int _p0, int _p1)
		{
			unsafe {
				if (fn__ugcGetContentRating == null) fn__ugcGetContentRating = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentRating");
				var result = fn__ugcGetContentRating(_p0, _p1);
				return result;
			}
		}

		public int UgcGetContentRatingCount(int _p0, int _p1)
		{
			unsafe {
				if (fn__ugcGetContentRatingCount == null) fn__ugcGetContentRatingCount = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentRatingCount");
				var result = fn__ugcGetContentRatingCount(_p0, _p1);
				return result;
			}
		}

		public int UgcGetContentRatingPositiveCount(int _p0, int _p1)
		{
			unsafe {
				if (fn__ugcGetContentRatingPositiveCount == null) fn__ugcGetContentRatingPositiveCount = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentRatingPositiveCount");
				var result = fn__ugcGetContentRatingPositiveCount(_p0, _p1);
				return result;
			}
		}

		public int UgcGetContentRatingNegativeCount(int _p0, int _p1)
		{
			unsafe {
				if (fn__ugcGetContentRatingNegativeCount == null) fn__ugcGetContentRatingNegativeCount = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetContentRatingNegativeCount");
				var result = fn__ugcGetContentRatingNegativeCount(_p0, _p1);
				return result;
			}
		}

		public bool UgcGetContentHasPlayerRecord(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentHasPlayerRecord == null) fn__ugcGetContentHasPlayerRecord = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_ugcGetContentHasPlayerRecord");
				var result = fn__ugcGetContentHasPlayerRecord(_p0);
				return result;
			}
		}

		public bool UgcGetContentHasPlayerBookmarked(int _p0)
		{
			unsafe {
				if (fn__ugcGetContentHasPlayerBookmarked == null) fn__ugcGetContentHasPlayerBookmarked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_ugcGetContentHasPlayerBookmarked");
				var result = fn__ugcGetContentHasPlayerBookmarked(_p0);
				return result;
			}
		}

		public int UgcRequestContentDataFromIndex(int _p0, int _p1)
		{
			unsafe {
				if (fn__ugcRequestContentDataFromIndex == null) fn__ugcRequestContentDataFromIndex = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_ugcRequestContentDataFromIndex");
				var result = fn__ugcRequestContentDataFromIndex(_p0, _p1);
				return result;
			}
		}

		public int UgcRequestContentDataFromParams(string _contentTypeName, string _contentId, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__ugcRequestContentDataFromParams == null) fn__ugcRequestContentDataFromParams = (delegate* unmanaged[Cdecl]<nint, nint, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_ugcRequestContentDataFromParams");
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var ptr_contentId = MemoryUtils.StringToHGlobalUtf8(_contentId);
				var result = fn__ugcRequestContentDataFromParams(ptr_contentTypeName, ptr_contentId, _p2, _p3, _p4);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				Marshal.FreeHGlobal(ptr_contentId);
				return result;
			}
		}

		public int UgcRequestCachedDescription(int _p0)
		{
			unsafe {
				if (fn__ugcRequestCachedDescription == null) fn__ugcRequestCachedDescription = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_ugcRequestCachedDescription");
				var result = fn__ugcRequestCachedDescription(_p0);
				return result;
			}
		}

		public bool _0x2D5DC831176D0114(int _p0)
		{
			unsafe {
				if (fn__0x2D5DC831176D0114 == null) fn__0x2D5DC831176D0114 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x2D5DC831176D0114");
				var result = fn__0x2D5DC831176D0114(_p0);
				return result;
			}
		}

		public bool _0xEBFA8D50ADDC54C4(int _p0)
		{
			unsafe {
				if (fn__0xEBFA8D50ADDC54C4 == null) fn__0xEBFA8D50ADDC54C4 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xEBFA8D50ADDC54C4");
				var result = fn__0xEBFA8D50ADDC54C4(_p0);
				return result;
			}
		}

		public bool _0x162C23CA83ED0A62(int _p0)
		{
			unsafe {
				if (fn__0x162C23CA83ED0A62 == null) fn__0x162C23CA83ED0A62 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x162C23CA83ED0A62");
				var result = fn__0x162C23CA83ED0A62(_p0);
				return result;
			}
		}

		public int UgcGetCachedDescription(int _p0, int _p1)
		{
			unsafe {
				if (fn__ugcGetCachedDescription == null) fn__ugcGetCachedDescription = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_ugcGetCachedDescription");
				var result = fn__ugcGetCachedDescription(_p0, _p1);
				return result;
			}
		}

		public bool _0x5A34CD9C3C5BEC44(int _p0)
		{
			unsafe {
				if (fn__0x5A34CD9C3C5BEC44 == null) fn__0x5A34CD9C3C5BEC44 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x5A34CD9C3C5BEC44");
				var result = fn__0x5A34CD9C3C5BEC44(_p0);
				return result;
			}
		}

		public void _0x68103E2247887242()
		{
			unsafe {
				if (fn__0x68103E2247887242 == null) fn__0x68103E2247887242 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x68103E2247887242");
				fn__0x68103E2247887242();
			}
		}

		public bool UgcPublish(string _contentId, string _baseContentId, string _contentTypeName)
		{
			unsafe {
				if (fn__ugcPublish == null) fn__ugcPublish = (delegate* unmanaged[Cdecl]<nint, nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_ugcPublish");
				var ptr_contentId = MemoryUtils.StringToHGlobalUtf8(_contentId);
				var ptr_baseContentId = MemoryUtils.StringToHGlobalUtf8(_baseContentId);
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcPublish(ptr_contentId, ptr_baseContentId, ptr_contentTypeName);
				Marshal.FreeHGlobal(ptr_contentId);
				Marshal.FreeHGlobal(ptr_baseContentId);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool UgcSetBookmarked(string _contentId, bool _bookmarked, string _contentTypeName)
		{
			unsafe {
				if (fn__ugcSetBookmarked == null) fn__ugcSetBookmarked = (delegate* unmanaged[Cdecl]<nint, bool, nint, bool>) NativeLibrary.GetExport(handle, "Native_ugcSetBookmarked");
				var ptr_contentId = MemoryUtils.StringToHGlobalUtf8(_contentId);
				var ptr_contentTypeName = MemoryUtils.StringToHGlobalUtf8(_contentTypeName);
				var result = fn__ugcSetBookmarked(ptr_contentId, _bookmarked, ptr_contentTypeName);
				Marshal.FreeHGlobal(ptr_contentId);
				Marshal.FreeHGlobal(ptr_contentTypeName);
				return result;
			}
		}

		public bool UgcSetDeleted(ref int _p0, bool _p1, string _p2)
		{
			unsafe {
				if (fn__ugcSetDeleted == null) fn__ugcSetDeleted = (delegate* unmanaged[Cdecl]<int*, bool, nint, bool>) NativeLibrary.GetExport(handle, "Native_ugcSetDeleted");
				var ref_p0 = _p0;
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var result = fn__ugcSetDeleted(&ref_p0, _p1, ptr_p2);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_p2);
				return result;
			}
		}

		public int _0x45E816772E93A9DB()
		{
			unsafe {
				if (fn__0x45E816772E93A9DB == null) fn__0x45E816772E93A9DB = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x45E816772E93A9DB");
				var result = fn__0x45E816772E93A9DB();
				return result;
			}
		}

		public bool UgcHasModifyFinished()
		{
			unsafe {
				if (fn__ugcHasModifyFinished == null) fn__ugcHasModifyFinished = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_ugcHasModifyFinished");
				var result = fn__ugcHasModifyFinished();
				return result;
			}
		}

		public int _0x793FF272D5B365F4()
		{
			unsafe {
				if (fn__0x793FF272D5B365F4 == null) fn__0x793FF272D5B365F4 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x793FF272D5B365F4");
				var result = fn__0x793FF272D5B365F4();
				return result;
			}
		}

		public int UgcGetModifyResult()
		{
			unsafe {
				if (fn__ugcGetModifyResult == null) fn__ugcGetModifyResult = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcGetModifyResult");
				var result = fn__ugcGetModifyResult();
				return result;
			}
		}

		public void UgcClearModifyResult()
		{
			unsafe {
				if (fn__ugcClearModifyResult == null) fn__ugcClearModifyResult = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_ugcClearModifyResult");
				fn__ugcClearModifyResult();
			}
		}

		public bool _0xB746D20B17F2A229(ref int _p0, ref int _p1)
		{
			unsafe {
				if (fn__0xB746D20B17F2A229 == null) fn__0xB746D20B17F2A229 = (delegate* unmanaged[Cdecl]<int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0xB746D20B17F2A229");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__0xB746D20B17F2A229(&ref_p0, &ref_p1);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public int _0x63B406D7884BFA95()
		{
			unsafe {
				if (fn__0x63B406D7884BFA95 == null) fn__0x63B406D7884BFA95 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x63B406D7884BFA95");
				var result = fn__0x63B406D7884BFA95();
				return result;
			}
		}

		public int _0x4D02279C83BE69FE()
		{
			unsafe {
				if (fn__0x4D02279C83BE69FE == null) fn__0x4D02279C83BE69FE = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x4D02279C83BE69FE");
				var result = fn__0x4D02279C83BE69FE();
				return result;
			}
		}

		public int UgcGetCreatorNum()
		{
			unsafe {
				if (fn__ugcGetCreatorNum == null) fn__ugcGetCreatorNum = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_ugcGetCreatorNum");
				var result = fn__ugcGetCreatorNum();
				return result;
			}
		}

		public bool UgcPoliciesMakePrivate(int _p0)
		{
			unsafe {
				if (fn__ugcPoliciesMakePrivate == null) fn__ugcPoliciesMakePrivate = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_ugcPoliciesMakePrivate");
				var result = fn__ugcPoliciesMakePrivate(_p0);
				return result;
			}
		}

		public void UgcClearOfflineQuery()
		{
			unsafe {
				if (fn__ugcClearOfflineQuery == null) fn__ugcClearOfflineQuery = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_ugcClearOfflineQuery");
				fn__ugcClearOfflineQuery();
			}
		}

		public void UgcSetQueryDataFromOffline(bool _p0)
		{
			unsafe {
				if (fn__ugcSetQueryDataFromOffline == null) fn__ugcSetQueryDataFromOffline = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_ugcSetQueryDataFromOffline");
				fn__ugcSetQueryDataFromOffline(_p0);
			}
		}

		public void _0xFD75DABC0957BF33(bool _p0)
		{
			unsafe {
				if (fn__0xFD75DABC0957BF33 == null) fn__0xFD75DABC0957BF33 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xFD75DABC0957BF33");
				fn__0xFD75DABC0957BF33(_p0);
			}
		}

		public bool UgcIsLanguageSupported(int _p0)
		{
			unsafe {
				if (fn__ugcIsLanguageSupported == null) fn__ugcIsLanguageSupported = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_ugcIsLanguageSupported");
				var result = fn__ugcIsLanguageSupported(_p0);
				return result;
			}
		}

		public bool FacebookSetHeistComplete(string _heistName, int _cashEarned, int _xpEarned)
		{
			unsafe {
				if (fn__facebookSetHeistComplete == null) fn__facebookSetHeistComplete = (delegate* unmanaged[Cdecl]<nint, int, int, bool>) NativeLibrary.GetExport(handle, "Native_facebookSetHeistComplete");
				var ptr_heistName = MemoryUtils.StringToHGlobalUtf8(_heistName);
				var result = fn__facebookSetHeistComplete(ptr_heistName, _cashEarned, _xpEarned);
				Marshal.FreeHGlobal(ptr_heistName);
				return result;
			}
		}

		public bool FacebookSetCreateCharacterComplete()
		{
			unsafe {
				if (fn__facebookSetCreateCharacterComplete == null) fn__facebookSetCreateCharacterComplete = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_facebookSetCreateCharacterComplete");
				var result = fn__facebookSetCreateCharacterComplete();
				return result;
			}
		}

		public bool FacebookSetMilestoneComplete(int _milestoneId)
		{
			unsafe {
				if (fn__facebookSetMilestoneComplete == null) fn__facebookSetMilestoneComplete = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_facebookSetMilestoneComplete");
				var result = fn__facebookSetMilestoneComplete(_milestoneId);
				return result;
			}
		}

		public bool FacebookIsSendingData()
		{
			unsafe {
				if (fn__facebookIsSendingData == null) fn__facebookIsSendingData = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_facebookIsSendingData");
				var result = fn__facebookIsSendingData();
				return result;
			}
		}

		public bool FacebookDoUnkCheck()
		{
			unsafe {
				if (fn__facebookDoUnkCheck == null) fn__facebookDoUnkCheck = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_facebookDoUnkCheck");
				var result = fn__facebookDoUnkCheck();
				return result;
			}
		}

		public bool FacebookIsAvailable()
		{
			unsafe {
				if (fn__facebookIsAvailable == null) fn__facebookIsAvailable = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_facebookIsAvailable");
				var result = fn__facebookIsAvailable();
				return result;
			}
		}

		public int TextureDownloadRequest(ref int _gamerHandle, string _filePath, string _name, bool _p3)
		{
			unsafe {
				if (fn__textureDownloadRequest == null) fn__textureDownloadRequest = (delegate* unmanaged[Cdecl]<int*, nint, nint, bool, int>) NativeLibrary.GetExport(handle, "Native_textureDownloadRequest");
				var ref_gamerHandle = _gamerHandle;
				var ptr_filePath = MemoryUtils.StringToHGlobalUtf8(_filePath);
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__textureDownloadRequest(&ref_gamerHandle, ptr_filePath, ptr_name, _p3);
				_gamerHandle = ref_gamerHandle;
				Marshal.FreeHGlobal(ptr_filePath);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public int TitleTextureDownloadRequest(string _filePath, string _name, bool _p2)
		{
			unsafe {
				if (fn__titleTextureDownloadRequest == null) fn__titleTextureDownloadRequest = (delegate* unmanaged[Cdecl]<nint, nint, bool, int>) NativeLibrary.GetExport(handle, "Native_titleTextureDownloadRequest");
				var ptr_filePath = MemoryUtils.StringToHGlobalUtf8(_filePath);
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__titleTextureDownloadRequest(ptr_filePath, ptr_name, _p2);
				Marshal.FreeHGlobal(ptr_filePath);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public int UgcTextureDownloadRequest(string _p0, int _p1, int _p2, int _p3, string _p4, bool _p5)
		{
			unsafe {
				if (fn__ugcTextureDownloadRequest == null) fn__ugcTextureDownloadRequest = (delegate* unmanaged[Cdecl]<nint, int, int, int, nint, bool, int>) NativeLibrary.GetExport(handle, "Native_ugcTextureDownloadRequest");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p4 = MemoryUtils.StringToHGlobalUtf8(_p4);
				var result = fn__ugcTextureDownloadRequest(ptr_p0, _p1, _p2, _p3, ptr_p4, _p5);
				Marshal.FreeHGlobal(ptr_p0);
				Marshal.FreeHGlobal(ptr_p4);
				return result;
			}
		}

		public void TextureDownloadRelease(int _p0)
		{
			unsafe {
				if (fn__textureDownloadRelease == null) fn__textureDownloadRelease = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_textureDownloadRelease");
				fn__textureDownloadRelease(_p0);
			}
		}

		public bool TextureDownloadHasFailed(int _p0)
		{
			unsafe {
				if (fn__textureDownloadHasFailed == null) fn__textureDownloadHasFailed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_textureDownloadHasFailed");
				var result = fn__textureDownloadHasFailed(_p0);
				return result;
			}
		}

		public string TextureDownloadGetName(int _p0)
		{
			unsafe {
				if (fn__textureDownloadGetName == null) fn__textureDownloadGetName = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_textureDownloadGetName");
				var result = fn__textureDownloadGetName(_p0);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int GetStatusOfTextureDownload(int _p0)
		{
			unsafe {
				if (fn__getStatusOfTextureDownload == null) fn__getStatusOfTextureDownload = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getStatusOfTextureDownload");
				var result = fn__getStatusOfTextureDownload(_p0);
				return result;
			}
		}

		public bool _0x60EDD13EB3AC1FF3()
		{
			unsafe {
				if (fn__0x60EDD13EB3AC1FF3 == null) fn__0x60EDD13EB3AC1FF3 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x60EDD13EB3AC1FF3");
				var result = fn__0x60EDD13EB3AC1FF3();
				return result;
			}
		}

		public bool NetworkShouldShowConnectivityTroubleshooting()
		{
			unsafe {
				if (fn__networkShouldShowConnectivityTroubleshooting == null) fn__networkShouldShowConnectivityTroubleshooting = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkShouldShowConnectivityTroubleshooting");
				var result = fn__networkShouldShowConnectivityTroubleshooting();
				return result;
			}
		}

		public bool NetworkIsCableConnected()
		{
			unsafe {
				if (fn__networkIsCableConnected == null) fn__networkIsCableConnected = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkIsCableConnected");
				var result = fn__networkIsCableConnected();
				return result;
			}
		}

		public bool NetworkGetRosPrivilege9()
		{
			unsafe {
				if (fn__networkGetRosPrivilege9 == null) fn__networkGetRosPrivilege9 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkGetRosPrivilege9");
				var result = fn__networkGetRosPrivilege9();
				return result;
			}
		}

		public bool NetworkHaveRosSocialClubPriv()
		{
			unsafe {
				if (fn__networkHaveRosSocialClubPriv == null) fn__networkHaveRosSocialClubPriv = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHaveRosSocialClubPriv");
				var result = fn__networkHaveRosSocialClubPriv();
				return result;
			}
		}

		public bool NetworkHaveRosBannedPriv()
		{
			unsafe {
				if (fn__networkHaveRosBannedPriv == null) fn__networkHaveRosBannedPriv = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHaveRosBannedPriv");
				var result = fn__networkHaveRosBannedPriv();
				return result;
			}
		}

		public bool NetworkHaveRosCreateTicketPriv()
		{
			unsafe {
				if (fn__networkHaveRosCreateTicketPriv == null) fn__networkHaveRosCreateTicketPriv = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHaveRosCreateTicketPriv");
				var result = fn__networkHaveRosCreateTicketPriv();
				return result;
			}
		}

		public bool NetworkHaveRosMultiplayerPriv()
		{
			unsafe {
				if (fn__networkHaveRosMultiplayerPriv == null) fn__networkHaveRosMultiplayerPriv = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHaveRosMultiplayerPriv");
				var result = fn__networkHaveRosMultiplayerPriv();
				return result;
			}
		}

		public bool NetworkHaveRosLeaderboardWritePriv()
		{
			unsafe {
				if (fn__networkHaveRosLeaderboardWritePriv == null) fn__networkHaveRosLeaderboardWritePriv = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHaveRosLeaderboardWritePriv");
				var result = fn__networkHaveRosLeaderboardWritePriv();
				return result;
			}
		}

		public bool NetworkHasRosPrivilege(int _index)
		{
			unsafe {
				if (fn__networkHasRosPrivilege == null) fn__networkHasRosPrivilege = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkHasRosPrivilege");
				var result = fn__networkHasRosPrivilege(_index);
				return result;
			}
		}

		public bool NetworkHasRosPrivilegeEndDate(int _privilege, ref int _banType, ref int _timeData)
		{
			unsafe {
				if (fn__networkHasRosPrivilegeEndDate == null) fn__networkHasRosPrivilegeEndDate = (delegate* unmanaged[Cdecl]<int, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_networkHasRosPrivilegeEndDate");
				var ref_banType = _banType;
				var ref_timeData = _timeData;
				var result = fn__networkHasRosPrivilegeEndDate(_privilege, &ref_banType, &ref_timeData);
				_banType = ref_banType;
				_timeData = ref_timeData;
				return result;
			}
		}

		public bool NetworkGetRosPrivilege24()
		{
			unsafe {
				if (fn__networkGetRosPrivilege24 == null) fn__networkGetRosPrivilege24 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkGetRosPrivilege24");
				var result = fn__networkGetRosPrivilege24();
				return result;
			}
		}

		public bool NetworkGetRosPrivilege25()
		{
			unsafe {
				if (fn__networkGetRosPrivilege25 == null) fn__networkGetRosPrivilege25 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkGetRosPrivilege25");
				var result = fn__networkGetRosPrivilege25();
				return result;
			}
		}

		public int _0x36391F397731595D(int _p0)
		{
			unsafe {
				if (fn__0x36391F397731595D == null) fn__0x36391F397731595D = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x36391F397731595D");
				var result = fn__0x36391F397731595D(_p0);
				return result;
			}
		}

		public int NetworkStartUserContentPermissionsCheck(ref int _netHandle)
		{
			unsafe {
				if (fn__networkStartUserContentPermissionsCheck == null) fn__networkStartUserContentPermissionsCheck = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_networkStartUserContentPermissionsCheck");
				var ref_netHandle = _netHandle;
				var result = fn__networkStartUserContentPermissionsCheck(&ref_netHandle);
				_netHandle = ref_netHandle;
				return result;
			}
		}

		public void _0x9465E683B12D3F6B()
		{
			unsafe {
				if (fn__0x9465E683B12D3F6B == null) fn__0x9465E683B12D3F6B = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x9465E683B12D3F6B");
				fn__0x9465E683B12D3F6B();
			}
		}

		public void _0xCA59CCAE5D01E4CE()
		{
			unsafe {
				if (fn__0xCA59CCAE5D01E4CE == null) fn__0xCA59CCAE5D01E4CE = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xCA59CCAE5D01E4CE");
				fn__0xCA59CCAE5D01E4CE();
			}
		}

		public bool NetworkHasGameBeenAltered()
		{
			unsafe {
				if (fn__networkHasGameBeenAltered == null) fn__networkHasGameBeenAltered = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkHasGameBeenAltered");
				var result = fn__networkHasGameBeenAltered();
				return result;
			}
		}

		public void NetworkUpdatePlayerScars()
		{
			unsafe {
				if (fn__networkUpdatePlayerScars == null) fn__networkUpdatePlayerScars = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkUpdatePlayerScars");
				fn__networkUpdatePlayerScars();
			}
		}

		public void NetworkDisableLeaveRemotePedBehind(bool _toggle)
		{
			unsafe {
				if (fn__networkDisableLeaveRemotePedBehind == null) fn__networkDisableLeaveRemotePedBehind = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_networkDisableLeaveRemotePedBehind");
				fn__networkDisableLeaveRemotePedBehind(_toggle);
			}
		}

		public void NetworkAllowLocalEntityAttachment(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__networkAllowLocalEntityAttachment == null) fn__networkAllowLocalEntityAttachment = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkAllowLocalEntityAttachment");
				fn__networkAllowLocalEntityAttachment(_entity, _toggle);
			}
		}

		public void _0x6BFF5F84102DF80A(int _player)
		{
			unsafe {
				if (fn__0x6BFF5F84102DF80A == null) fn__0x6BFF5F84102DF80A = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x6BFF5F84102DF80A");
				fn__0x6BFF5F84102DF80A(_player);
			}
		}

		public void _0x5C497525F803486B()
		{
			unsafe {
				if (fn__0x5C497525F803486B == null) fn__0x5C497525F803486B = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x5C497525F803486B");
				fn__0x5C497525F803486B();
			}
		}

		public int _0x6FB7BB3607D27FA2()
		{
			unsafe {
				if (fn__0x6FB7BB3607D27FA2 == null) fn__0x6FB7BB3607D27FA2 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x6FB7BB3607D27FA2");
				var result = fn__0x6FB7BB3607D27FA2();
				return result;
			}
		}

		public void _0x45A83257ED02D9BC()
		{
			unsafe {
				if (fn__0x45A83257ED02D9BC == null) fn__0x45A83257ED02D9BC = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x45A83257ED02D9BC");
				fn__0x45A83257ED02D9BC();
			}
		}

		public bool NetworkIsConnectionEndpointRelayServer(int _player)
		{
			unsafe {
				if (fn__networkIsConnectionEndpointRelayServer == null) fn__networkIsConnectionEndpointRelayServer = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_networkIsConnectionEndpointRelayServer");
				var result = fn__networkIsConnectionEndpointRelayServer(_player);
				return result;
			}
		}

		public float NetworkGetAverageLatencyForPlayer(int _player)
		{
			unsafe {
				if (fn__networkGetAverageLatencyForPlayer == null) fn__networkGetAverageLatencyForPlayer = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_networkGetAverageLatencyForPlayer");
				var result = fn__networkGetAverageLatencyForPlayer(_player);
				return result;
			}
		}

		public float NetworkGetAverageLatencyForPlayer2(int _player)
		{
			unsafe {
				if (fn__networkGetAverageLatencyForPlayer2 == null) fn__networkGetAverageLatencyForPlayer2 = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_networkGetAverageLatencyForPlayer2");
				var result = fn__networkGetAverageLatencyForPlayer2(_player);
				return result;
			}
		}

		public float NetworkGetAveragePacketLossForPlayer(int _player)
		{
			unsafe {
				if (fn__networkGetAveragePacketLossForPlayer == null) fn__networkGetAveragePacketLossForPlayer = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_networkGetAveragePacketLossForPlayer");
				var result = fn__networkGetAveragePacketLossForPlayer(_player);
				return result;
			}
		}

		public int NetworkGetNumUnackedForPlayer(int _player)
		{
			unsafe {
				if (fn__networkGetNumUnackedForPlayer == null) fn__networkGetNumUnackedForPlayer = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetNumUnackedForPlayer");
				var result = fn__networkGetNumUnackedForPlayer(_player);
				return result;
			}
		}

		public int NetworkGetUnreliableResendCountForPlayer(int _player)
		{
			unsafe {
				if (fn__networkGetUnreliableResendCountForPlayer == null) fn__networkGetUnreliableResendCountForPlayer = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetUnreliableResendCountForPlayer");
				var result = fn__networkGetUnreliableResendCountForPlayer(_player);
				return result;
			}
		}

		public int NetworkGetOldestResendCountForPlayer(int _player)
		{
			unsafe {
				if (fn__networkGetOldestResendCountForPlayer == null) fn__networkGetOldestResendCountForPlayer = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_networkGetOldestResendCountForPlayer");
				var result = fn__networkGetOldestResendCountForPlayer(_player);
				return result;
			}
		}

		public void NetworkReportMyself()
		{
			unsafe {
				if (fn__networkReportMyself == null) fn__networkReportMyself = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_networkReportMyself");
				fn__networkReportMyself();
			}
		}

		public Vector3 _0x64D779659BC37B19(int _entity)
		{
			unsafe {
				if (fn__0x64D779659BC37B19 == null) fn__0x64D779659BC37B19 = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native__0x64D779659BC37B19");
				var result = fn__0x64D779659BC37B19(_entity);
				return result;
			}
		}

		public Vector3 NetworkGetPlayerCoords(int _player)
		{
			unsafe {
				if (fn__networkGetPlayerCoords == null) fn__networkGetPlayerCoords = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_networkGetPlayerCoords");
				var result = fn__networkGetPlayerCoords(_player);
				return result;
			}
		}

		public Vector3 NetworkGetLastVelocityReceived(int _entity)
		{
			unsafe {
				if (fn__networkGetLastVelocityReceived == null) fn__networkGetLastVelocityReceived = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_networkGetLastVelocityReceived");
				var result = fn__networkGetLastVelocityReceived(_entity);
				return result;
			}
		}

		public Vector3 _0xAA5FAFCD2C5F5E47(int _entity)
		{
			unsafe {
				if (fn__0xAA5FAFCD2C5F5E47 == null) fn__0xAA5FAFCD2C5F5E47 = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native__0xAA5FAFCD2C5F5E47");
				var result = fn__0xAA5FAFCD2C5F5E47(_entity);
				return result;
			}
		}

		public int _0xAEDF1BC1C133D6E3()
		{
			unsafe {
				if (fn__0xAEDF1BC1C133D6E3 == null) fn__0xAEDF1BC1C133D6E3 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xAEDF1BC1C133D6E3");
				var result = fn__0xAEDF1BC1C133D6E3();
				return result;
			}
		}

		public int _0x2555CF7DA5473794()
		{
			unsafe {
				if (fn__0x2555CF7DA5473794 == null) fn__0x2555CF7DA5473794 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x2555CF7DA5473794");
				var result = fn__0x2555CF7DA5473794();
				return result;
			}
		}

		public int _0x6FD992C4A1C1B986()
		{
			unsafe {
				if (fn__0x6FD992C4A1C1B986 == null) fn__0x6FD992C4A1C1B986 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x6FD992C4A1C1B986");
				var result = fn__0x6FD992C4A1C1B986();
				return result;
			}
		}

		public int _0xDB663CC9FF3407A9(int _player)
		{
			unsafe {
				if (fn__0xDB663CC9FF3407A9 == null) fn__0xDB663CC9FF3407A9 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xDB663CC9FF3407A9");
				var result = fn__0xDB663CC9FF3407A9(_player);
				return result;
			}
		}

		public void NetworkUgcNav(int _p0, int _p1)
		{
			unsafe {
				if (fn__networkUgcNav == null) fn__networkUgcNav = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_networkUgcNav");
				fn__networkUgcNav(_p0, _p1);
			}
		}

		public int CreateObject(int _modelHash, float _x, float _y, float _z, bool _isNetwork, bool _bScriptHostObj, bool _dynamic)
		{
			unsafe {
				if (fn__createObject == null) fn__createObject = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_createObject");
				var result = fn__createObject(_modelHash, _x, _y, _z, _isNetwork, _bScriptHostObj, _dynamic);
				return result;
			}
		}

		public int CreateObjectNoOffset(int _modelHash, float _x, float _y, float _z, bool _isNetwork, bool _bScriptHostObj, bool _dynamic)
		{
			unsafe {
				if (fn__createObjectNoOffset == null) fn__createObjectNoOffset = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_createObjectNoOffset");
				var result = fn__createObjectNoOffset(_modelHash, _x, _y, _z, _isNetwork, _bScriptHostObj, _dynamic);
				return result;
			}
		}

		public void DeleteObject(ref int _object)
		{
			unsafe {
				if (fn__deleteObject == null) fn__deleteObject = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_deleteObject");
				var ref_object = _object;
				fn__deleteObject(&ref_object);
				_object = ref_object;
			}
		}

		public bool PlaceObjectOnGroundProperly(int _object)
		{
			unsafe {
				if (fn__placeObjectOnGroundProperly == null) fn__placeObjectOnGroundProperly = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_placeObjectOnGroundProperly");
				var result = fn__placeObjectOnGroundProperly(_object);
				return result;
			}
		}

		public bool PlaceObjectOnGroundProperly2(int _object)
		{
			unsafe {
				if (fn__placeObjectOnGroundProperly2 == null) fn__placeObjectOnGroundProperly2 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_placeObjectOnGroundProperly2");
				var result = fn__placeObjectOnGroundProperly2(_object);
				return result;
			}
		}

		public bool _0xAFE24E4D29249E4A(int _object, float _p1, float _p2, bool _p3)
		{
			unsafe {
				if (fn__0xAFE24E4D29249E4A == null) fn__0xAFE24E4D29249E4A = (delegate* unmanaged[Cdecl]<int, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native__0xAFE24E4D29249E4A");
				var result = fn__0xAFE24E4D29249E4A(_object, _p1, _p2, _p3);
				return result;
			}
		}

		public bool SlideObject(int _object, float _toX, float _toY, float _toZ, float _speedX, float _speedY, float _speedZ, bool _collision)
		{
			unsafe {
				if (fn__slideObject == null) fn__slideObject = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_slideObject");
				var result = fn__slideObject(_object, _toX, _toY, _toZ, _speedX, _speedY, _speedZ, _collision);
				return result;
			}
		}

		public void SetObjectTargettable(int _object, bool _targettable)
		{
			unsafe {
				if (fn__setObjectTargettable == null) fn__setObjectTargettable = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setObjectTargettable");
				fn__setObjectTargettable(_object, _targettable);
			}
		}

		public void SetObjectForceVehiclesToAvoid(int _object, bool _toggle)
		{
			unsafe {
				if (fn__setObjectForceVehiclesToAvoid == null) fn__setObjectForceVehiclesToAvoid = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setObjectForceVehiclesToAvoid");
				fn__setObjectForceVehiclesToAvoid(_object, _toggle);
			}
		}

		public int GetClosestObjectOfType(float _x, float _y, float _z, float _radius, int _modelHash, bool _isMission, bool _p6, bool _p7)
		{
			unsafe {
				if (fn__getClosestObjectOfType == null) fn__getClosestObjectOfType = (delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_getClosestObjectOfType");
				var result = fn__getClosestObjectOfType(_x, _y, _z, _radius, _modelHash, _isMission, _p6, _p7);
				return result;
			}
		}

		public bool HasObjectBeenBroken(int _object, int _p1)
		{
			unsafe {
				if (fn__hasObjectBeenBroken == null) fn__hasObjectBeenBroken = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasObjectBeenBroken");
				var result = fn__hasObjectBeenBroken(_object, _p1);
				return result;
			}
		}

		public bool HasClosestObjectOfTypeBeenBroken(float _p0, float _p1, float _p2, float _p3, int _modelHash, int _p5)
		{
			unsafe {
				if (fn__hasClosestObjectOfTypeBeenBroken == null) fn__hasClosestObjectOfTypeBeenBroken = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasClosestObjectOfTypeBeenBroken");
				var result = fn__hasClosestObjectOfTypeBeenBroken(_p0, _p1, _p2, _p3, _modelHash, _p5);
				return result;
			}
		}

		public bool HasClosestObjectOfTypeBeenCompletelyDestroyed(float _x, float _y, float _z, float _radius, int _modelHash, bool _p5)
		{
			unsafe {
				if (fn__hasClosestObjectOfTypeBeenCompletelyDestroyed == null) fn__hasClosestObjectOfTypeBeenCompletelyDestroyed = (delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_hasClosestObjectOfTypeBeenCompletelyDestroyed");
				var result = fn__hasClosestObjectOfTypeBeenCompletelyDestroyed(_x, _y, _z, _radius, _modelHash, _p5);
				return result;
			}
		}

		public int _0x2542269291C6AC84(int _p0)
		{
			unsafe {
				if (fn__0x2542269291C6AC84 == null) fn__0x2542269291C6AC84 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x2542269291C6AC84");
				var result = fn__0x2542269291C6AC84(_p0);
				return result;
			}
		}

		public Vector3 GetObjectOffsetFromCoords(float _xPos, float _yPos, float _zPos, float _heading, float _xOffset, float _yOffset, float _zOffset)
		{
			unsafe {
				if (fn__getObjectOffsetFromCoords == null) fn__getObjectOffsetFromCoords = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getObjectOffsetFromCoords");
				var result = fn__getObjectOffsetFromCoords(_xPos, _yPos, _zPos, _heading, _xOffset, _yOffset, _zOffset);
				return result;
			}
		}

		public int GetCoordsAndRotationOfClosestObjectOfType(float _x, float _y, float _z, float _radius, int _modelHash, ref Vector3 _outPosition, ref Vector3 _outRotation, int _rotationOrder)
		{
			unsafe {
				if (fn__getCoordsAndRotationOfClosestObjectOfType == null) fn__getCoordsAndRotationOfClosestObjectOfType = (delegate* unmanaged[Cdecl]<float, float, float, float, int, Vector3*, Vector3*, int, int>) NativeLibrary.GetExport(handle, "Native_getCoordsAndRotationOfClosestObjectOfType");
				var ref_outPosition = _outPosition;
				var ref_outRotation = _outRotation;
				var result = fn__getCoordsAndRotationOfClosestObjectOfType(_x, _y, _z, _radius, _modelHash, &ref_outPosition, &ref_outRotation, _rotationOrder);
				_outPosition = ref_outPosition;
				_outRotation = ref_outRotation;
				return result;
			}
		}

		public void SetStateOfClosestDoorOfType(int _type, float _x, float _y, float _z, bool _locked, float _heading, bool _p6)
		{
			unsafe {
				if (fn__setStateOfClosestDoorOfType == null) fn__setStateOfClosestDoorOfType = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setStateOfClosestDoorOfType");
				fn__setStateOfClosestDoorOfType(_type, _x, _y, _z, _locked, _heading, _p6);
			}
		}

		public void GetStateOfClosestDoorOfType(int _type, float _x, float _y, float _z, ref bool _locked, ref float _heading)
		{
			unsafe {
				if (fn__getStateOfClosestDoorOfType == null) fn__getStateOfClosestDoorOfType = (delegate* unmanaged[Cdecl]<int, float, float, float, bool*, float*, void>) NativeLibrary.GetExport(handle, "Native_getStateOfClosestDoorOfType");
				var ref_locked = _locked;
				var ref_heading = _heading;
				fn__getStateOfClosestDoorOfType(_type, _x, _y, _z, &ref_locked, &ref_heading);
				_locked = ref_locked;
				_heading = ref_heading;
			}
		}

		public void DoorControl(int _modelHash, float _x, float _y, float _z, bool _locked, float _xRotMult, float _yRotMult, float _zRotMult)
		{
			unsafe {
				if (fn__doorControl == null) fn__doorControl = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_doorControl");
				fn__doorControl(_modelHash, _x, _y, _z, _locked, _xRotMult, _yRotMult, _zRotMult);
			}
		}

		public void _0x006E4B040ED37EC3(int _p0)
		{
			unsafe {
				if (fn__0x006E4B040ED37EC3 == null) fn__0x006E4B040ED37EC3 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x006E4B040ED37EC3");
				fn__0x006E4B040ED37EC3(_p0);
			}
		}

		public void AddDoorToSystem(int _doorHash, int _modelHash, float _x, float _y, float _z, bool _p5, bool _scriptDoor, bool _isLocal)
		{
			unsafe {
				if (fn__addDoorToSystem == null) fn__addDoorToSystem = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_addDoorToSystem");
				fn__addDoorToSystem(_doorHash, _modelHash, _x, _y, _z, _p5, _scriptDoor, _isLocal);
			}
		}

		public void RemoveDoorFromSystem(int _doorHash)
		{
			unsafe {
				if (fn__removeDoorFromSystem == null) fn__removeDoorFromSystem = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeDoorFromSystem");
				fn__removeDoorFromSystem(_doorHash);
			}
		}

		public void DoorSystemSetDoorState(int _doorHash, int _state, bool _requestDoor, bool _forceUpdate)
		{
			unsafe {
				if (fn__doorSystemSetDoorState == null) fn__doorSystemSetDoorState = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_doorSystemSetDoorState");
				fn__doorSystemSetDoorState(_doorHash, _state, _requestDoor, _forceUpdate);
			}
		}

		public int DoorSystemGetDoorState(int _doorHash)
		{
			unsafe {
				if (fn__doorSystemGetDoorState == null) fn__doorSystemGetDoorState = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_doorSystemGetDoorState");
				var result = fn__doorSystemGetDoorState(_doorHash);
				return result;
			}
		}

		public int DoorSystemGetDoorPendingState(int _doorHash)
		{
			unsafe {
				if (fn__doorSystemGetDoorPendingState == null) fn__doorSystemGetDoorPendingState = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_doorSystemGetDoorPendingState");
				var result = fn__doorSystemGetDoorPendingState(_doorHash);
				return result;
			}
		}

		public void DoorSystemSetAutomaticRate(int _doorHash, float _rate, bool _requestDoor, bool _forceUpdate)
		{
			unsafe {
				if (fn__doorSystemSetAutomaticRate == null) fn__doorSystemSetAutomaticRate = (delegate* unmanaged[Cdecl]<int, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_doorSystemSetAutomaticRate");
				fn__doorSystemSetAutomaticRate(_doorHash, _rate, _requestDoor, _forceUpdate);
			}
		}

		public void DoorSystemSetAutomaticDistance(int _doorHash, float _distance, bool _requestDoor, bool _forceUpdate)
		{
			unsafe {
				if (fn__doorSystemSetAutomaticDistance == null) fn__doorSystemSetAutomaticDistance = (delegate* unmanaged[Cdecl]<int, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_doorSystemSetAutomaticDistance");
				fn__doorSystemSetAutomaticDistance(_doorHash, _distance, _requestDoor, _forceUpdate);
			}
		}

		public void DoorSystemSetOpenRatio(int _doorHash, float _ajar, bool _requestDoor, bool _forceUpdate)
		{
			unsafe {
				if (fn__doorSystemSetOpenRatio == null) fn__doorSystemSetOpenRatio = (delegate* unmanaged[Cdecl]<int, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_doorSystemSetOpenRatio");
				fn__doorSystemSetOpenRatio(_doorHash, _ajar, _requestDoor, _forceUpdate);
			}
		}

		public int _0xE851471AEFC3374F(int _p0)
		{
			unsafe {
				if (fn__0xE851471AEFC3374F == null) fn__0xE851471AEFC3374F = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xE851471AEFC3374F");
				var result = fn__0xE851471AEFC3374F(_p0);
				return result;
			}
		}

		public float DoorSystemGetOpenRatio(int _doorHash)
		{
			unsafe {
				if (fn__doorSystemGetOpenRatio == null) fn__doorSystemGetOpenRatio = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_doorSystemGetOpenRatio");
				var result = fn__doorSystemGetOpenRatio(_doorHash);
				return result;
			}
		}

		public void DoorSystemSetSpringRemoved(int _doorHash, bool _removed, bool _requestDoor, bool _forceUpdate)
		{
			unsafe {
				if (fn__doorSystemSetSpringRemoved == null) fn__doorSystemSetSpringRemoved = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_doorSystemSetSpringRemoved");
				fn__doorSystemSetSpringRemoved(_doorHash, _removed, _requestDoor, _forceUpdate);
			}
		}

		public void DoorSystemSetHoldOpen(int _doorHash, bool _toggle)
		{
			unsafe {
				if (fn__doorSystemSetHoldOpen == null) fn__doorSystemSetHoldOpen = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_doorSystemSetHoldOpen");
				fn__doorSystemSetHoldOpen(_doorHash, _toggle);
			}
		}

		public void _0xA85A21582451E951(int _doorHash, bool _p1)
		{
			unsafe {
				if (fn__0xA85A21582451E951 == null) fn__0xA85A21582451E951 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xA85A21582451E951");
				fn__0xA85A21582451E951(_doorHash, _p1);
			}
		}

		public bool IsDoorRegisteredWithSystem(int _doorHash)
		{
			unsafe {
				if (fn__isDoorRegisteredWithSystem == null) fn__isDoorRegisteredWithSystem = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isDoorRegisteredWithSystem");
				var result = fn__isDoorRegisteredWithSystem(_doorHash);
				return result;
			}
		}

		public bool IsDoorClosed(int _doorHash)
		{
			unsafe {
				if (fn__isDoorClosed == null) fn__isDoorClosed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isDoorClosed");
				var result = fn__isDoorClosed(_doorHash);
				return result;
			}
		}

		public void _0xC7F29CA00F46350E(bool _p0)
		{
			unsafe {
				if (fn__0xC7F29CA00F46350E == null) fn__0xC7F29CA00F46350E = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xC7F29CA00F46350E");
				fn__0xC7F29CA00F46350E(_p0);
			}
		}

		public void _0x701FDA1E82076BA4()
		{
			unsafe {
				if (fn__0x701FDA1E82076BA4 == null) fn__0x701FDA1E82076BA4 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x701FDA1E82076BA4");
				fn__0x701FDA1E82076BA4();
			}
		}

		public bool DoorSystemGetIsPhysicsLoaded(int _p0)
		{
			unsafe {
				if (fn__doorSystemGetIsPhysicsLoaded == null) fn__doorSystemGetIsPhysicsLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doorSystemGetIsPhysicsLoaded");
				var result = fn__doorSystemGetIsPhysicsLoaded(_p0);
				return result;
			}
		}

		public bool DoorSystemFindExistingDoor(float _x, float _y, float _z, int _modelHash, ref int _outDoorHash)
		{
			unsafe {
				if (fn__doorSystemFindExistingDoor == null) fn__doorSystemFindExistingDoor = (delegate* unmanaged[Cdecl]<float, float, float, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_doorSystemFindExistingDoor");
				var ref_outDoorHash = _outDoorHash;
				var result = fn__doorSystemFindExistingDoor(_x, _y, _z, _modelHash, &ref_outDoorHash);
				_outDoorHash = ref_outDoorHash;
				return result;
			}
		}

		public bool IsGarageEmpty(int _garageHash, bool _p1, int _p2)
		{
			unsafe {
				if (fn__isGarageEmpty == null) fn__isGarageEmpty = (delegate* unmanaged[Cdecl]<int, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_isGarageEmpty");
				var result = fn__isGarageEmpty(_garageHash, _p1, _p2);
				return result;
			}
		}

		public bool IsPlayerEntirelyInsideGarage(int _garageHash, int _player, float _p2, int _p3)
		{
			unsafe {
				if (fn__isPlayerEntirelyInsideGarage == null) fn__isPlayerEntirelyInsideGarage = (delegate* unmanaged[Cdecl]<int, int, float, int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerEntirelyInsideGarage");
				var result = fn__isPlayerEntirelyInsideGarage(_garageHash, _player, _p2, _p3);
				return result;
			}
		}

		public bool IsPlayerPartiallyInsideGarage(int _garageHash, int _player, int _p2)
		{
			unsafe {
				if (fn__isPlayerPartiallyInsideGarage == null) fn__isPlayerPartiallyInsideGarage = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerPartiallyInsideGarage");
				var result = fn__isPlayerPartiallyInsideGarage(_garageHash, _player, _p2);
				return result;
			}
		}

		public bool AreEntitiesEntirelyInsideGarage(int _garageHash, bool _p1, bool _p2, bool _p3, int _p4)
		{
			unsafe {
				if (fn__areEntitiesEntirelyInsideGarage == null) fn__areEntitiesEntirelyInsideGarage = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_areEntitiesEntirelyInsideGarage");
				var result = fn__areEntitiesEntirelyInsideGarage(_garageHash, _p1, _p2, _p3, _p4);
				return result;
			}
		}

		public bool IsAnyEntityEntirelyInsideGarage(int _garageHash, bool _p1, bool _p2, bool _p3, int _p4)
		{
			unsafe {
				if (fn__isAnyEntityEntirelyInsideGarage == null) fn__isAnyEntityEntirelyInsideGarage = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_isAnyEntityEntirelyInsideGarage");
				var result = fn__isAnyEntityEntirelyInsideGarage(_garageHash, _p1, _p2, _p3, _p4);
				return result;
			}
		}

		public bool IsObjectEntirelyInsideGarage(int _garageHash, int _entity, float _p2, int _p3)
		{
			unsafe {
				if (fn__isObjectEntirelyInsideGarage == null) fn__isObjectEntirelyInsideGarage = (delegate* unmanaged[Cdecl]<int, int, float, int, bool>) NativeLibrary.GetExport(handle, "Native_isObjectEntirelyInsideGarage");
				var result = fn__isObjectEntirelyInsideGarage(_garageHash, _entity, _p2, _p3);
				return result;
			}
		}

		public bool IsObjectPartiallyInsideGarage(int _garageHash, int _entity, int _p2)
		{
			unsafe {
				if (fn__isObjectPartiallyInsideGarage == null) fn__isObjectPartiallyInsideGarage = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_isObjectPartiallyInsideGarage");
				var result = fn__isObjectPartiallyInsideGarage(_garageHash, _entity, _p2);
				return result;
			}
		}

		public void ClearGarageArea(int _garageHash, bool _isNetwork)
		{
			unsafe {
				if (fn__clearGarageArea == null) fn__clearGarageArea = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_clearGarageArea");
				fn__clearGarageArea(_garageHash, _isNetwork);
			}
		}

		public void ClearObjectsInsideGarage(int _garageHash, bool _vehicles, bool _peds, bool _objects, bool _isNetwork)
		{
			unsafe {
				if (fn__clearObjectsInsideGarage == null) fn__clearObjectsInsideGarage = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_clearObjectsInsideGarage");
				fn__clearObjectsInsideGarage(_garageHash, _vehicles, _peds, _objects, _isNetwork);
			}
		}

		public void _0x659F9D71F52843F8(int _id, bool _toggle)
		{
			unsafe {
				if (fn__0x659F9D71F52843F8 == null) fn__0x659F9D71F52843F8 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x659F9D71F52843F8");
				fn__0x659F9D71F52843F8(_id, _toggle);
			}
		}

		public void EnableSavingInGarage(int _garageHash, bool _toggle)
		{
			unsafe {
				if (fn__enableSavingInGarage == null) fn__enableSavingInGarage = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_enableSavingInGarage");
				fn__enableSavingInGarage(_garageHash, _toggle);
			}
		}

		public void _0x66A49D021870FE88()
		{
			unsafe {
				if (fn__0x66A49D021870FE88 == null) fn__0x66A49D021870FE88 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x66A49D021870FE88");
				fn__0x66A49D021870FE88();
			}
		}

		public bool DoesObjectOfTypeExistAtCoords(float _x, float _y, float _z, float _radius, int _hash, bool _p5)
		{
			unsafe {
				if (fn__doesObjectOfTypeExistAtCoords == null) fn__doesObjectOfTypeExistAtCoords = (delegate* unmanaged[Cdecl]<float, float, float, float, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_doesObjectOfTypeExistAtCoords");
				var result = fn__doesObjectOfTypeExistAtCoords(_x, _y, _z, _radius, _hash, _p5);
				return result;
			}
		}

		public bool IsPointInAngledArea(float _xPos, float _yPos, float _zPos, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width, bool _debug, bool _includeZ)
		{
			unsafe {
				if (fn__isPointInAngledArea == null) fn__isPointInAngledArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_isPointInAngledArea");
				var result = fn__isPointInAngledArea(_xPos, _yPos, _zPos, _x1, _y1, _z1, _x2, _y2, _z2, _width, _debug, _includeZ);
				return result;
			}
		}

		public void SetObjectAllowLowLodBuoyancy(int _object, bool _toggle)
		{
			unsafe {
				if (fn__setObjectAllowLowLodBuoyancy == null) fn__setObjectAllowLowLodBuoyancy = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setObjectAllowLowLodBuoyancy");
				fn__setObjectAllowLowLodBuoyancy(_object, _toggle);
			}
		}

		public void SetObjectPhysicsParams(int _object, float _weight, float _p2, float _p3, float _p4, float _p5, float _gravity, float _p7, float _p8, float _p9, float _p10, float _buoyancy)
		{
			unsafe {
				if (fn__setObjectPhysicsParams == null) fn__setObjectPhysicsParams = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setObjectPhysicsParams");
				fn__setObjectPhysicsParams(_object, _weight, _p2, _p3, _p4, _p5, _gravity, _p7, _p8, _p9, _p10, _buoyancy);
			}
		}

		public float GetObjectFragmentDamageHealth(int _p0, bool _p1)
		{
			unsafe {
				if (fn__getObjectFragmentDamageHealth == null) fn__getObjectFragmentDamageHealth = (delegate* unmanaged[Cdecl]<int, bool, float>) NativeLibrary.GetExport(handle, "Native_getObjectFragmentDamageHealth");
				var result = fn__getObjectFragmentDamageHealth(_p0, _p1);
				return result;
			}
		}

		public void SetActivateObjectPhysicsAsSoonAsItIsUnfrozen(int _object, bool _toggle)
		{
			unsafe {
				if (fn__setActivateObjectPhysicsAsSoonAsItIsUnfrozen == null) fn__setActivateObjectPhysicsAsSoonAsItIsUnfrozen = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setActivateObjectPhysicsAsSoonAsItIsUnfrozen");
				fn__setActivateObjectPhysicsAsSoonAsItIsUnfrozen(_object, _toggle);
			}
		}

		public bool IsAnyObjectNearPoint(float _x, float _y, float _z, float _range, bool _p4)
		{
			unsafe {
				if (fn__isAnyObjectNearPoint == null) fn__isAnyObjectNearPoint = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_isAnyObjectNearPoint");
				var result = fn__isAnyObjectNearPoint(_x, _y, _z, _range, _p4);
				return result;
			}
		}

		public bool IsObjectNearPoint(int _objectHash, float _x, float _y, float _z, float _range)
		{
			unsafe {
				if (fn__isObjectNearPoint == null) fn__isObjectNearPoint = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isObjectNearPoint");
				var result = fn__isObjectNearPoint(_objectHash, _x, _y, _z, _range);
				return result;
			}
		}

		public void RemoveObjectHighDetailModel(int _object)
		{
			unsafe {
				if (fn__removeObjectHighDetailModel == null) fn__removeObjectHighDetailModel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeObjectHighDetailModel");
				fn__removeObjectHighDetailModel(_object);
			}
		}

		public void BreakObjectFragmentChild(int _p0, int _p1, bool _p2)
		{
			unsafe {
				if (fn__breakObjectFragmentChild == null) fn__breakObjectFragmentChild = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_breakObjectFragmentChild");
				fn__breakObjectFragmentChild(_p0, _p1, _p2);
			}
		}

		public void _0xE05F6AEEFEB0BB02(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xE05F6AEEFEB0BB02 == null) fn__0xE05F6AEEFEB0BB02 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xE05F6AEEFEB0BB02");
				fn__0xE05F6AEEFEB0BB02(_p0, _p1, _p2);
			}
		}

		public void _0xF9C1681347C8BD15(int _object)
		{
			unsafe {
				if (fn__0xF9C1681347C8BD15 == null) fn__0xF9C1681347C8BD15 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xF9C1681347C8BD15");
				fn__0xF9C1681347C8BD15(_object);
			}
		}

		public void TrackObjectVisibility(int _object)
		{
			unsafe {
				if (fn__trackObjectVisibility == null) fn__trackObjectVisibility = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_trackObjectVisibility");
				fn__trackObjectVisibility(_object);
			}
		}

		public bool IsObjectVisible(int _object)
		{
			unsafe {
				if (fn__isObjectVisible == null) fn__isObjectVisible = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isObjectVisible");
				var result = fn__isObjectVisible(_object);
				return result;
			}
		}

		public void _0xC6033D32241F6FB5(int _object, bool _toggle)
		{
			unsafe {
				if (fn__0xC6033D32241F6FB5 == null) fn__0xC6033D32241F6FB5 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xC6033D32241F6FB5");
				fn__0xC6033D32241F6FB5(_object, _toggle);
			}
		}

		public void _0xEB6F1A9B5510A5D2(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0xEB6F1A9B5510A5D2 == null) fn__0xEB6F1A9B5510A5D2 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xEB6F1A9B5510A5D2");
				fn__0xEB6F1A9B5510A5D2(_p0, _p1);
			}
		}

		public void SetUnkGlobalBoolRelatedToDamage(bool _value)
		{
			unsafe {
				if (fn__setUnkGlobalBoolRelatedToDamage == null) fn__setUnkGlobalBoolRelatedToDamage = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setUnkGlobalBoolRelatedToDamage");
				fn__setUnkGlobalBoolRelatedToDamage(_value);
			}
		}

		public void SetCreateWeaponObjectLightSource(int _object, bool _toggle)
		{
			unsafe {
				if (fn__setCreateWeaponObjectLightSource == null) fn__setCreateWeaponObjectLightSource = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCreateWeaponObjectLightSource");
				fn__setCreateWeaponObjectLightSource(_object, _toggle);
			}
		}

		public int GetRayfireMapObject(float _x, float _y, float _z, float _radius, string _name)
		{
			unsafe {
				if (fn__getRayfireMapObject == null) fn__getRayfireMapObject = (delegate* unmanaged[Cdecl]<float, float, float, float, nint, int>) NativeLibrary.GetExport(handle, "Native_getRayfireMapObject");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__getRayfireMapObject(_x, _y, _z, _radius, ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public void SetStateOfRayfireMapObject(int _object, int _state)
		{
			unsafe {
				if (fn__setStateOfRayfireMapObject == null) fn__setStateOfRayfireMapObject = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setStateOfRayfireMapObject");
				fn__setStateOfRayfireMapObject(_object, _state);
			}
		}

		public int GetStateOfRayfireMapObject(int _object)
		{
			unsafe {
				if (fn__getStateOfRayfireMapObject == null) fn__getStateOfRayfireMapObject = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getStateOfRayfireMapObject");
				var result = fn__getStateOfRayfireMapObject(_object);
				return result;
			}
		}

		public bool DoesRayfireMapObjectExist(int _object)
		{
			unsafe {
				if (fn__doesRayfireMapObjectExist == null) fn__doesRayfireMapObjectExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesRayfireMapObjectExist");
				var result = fn__doesRayfireMapObjectExist(_object);
				return result;
			}
		}

		public float GetRayfireMapObjectAnimPhase(int _object)
		{
			unsafe {
				if (fn__getRayfireMapObjectAnimPhase == null) fn__getRayfireMapObjectAnimPhase = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getRayfireMapObjectAnimPhase");
				var result = fn__getRayfireMapObjectAnimPhase(_object);
				return result;
			}
		}

		public int CreatePickup(int _pickupHash, float _posX, float _posY, float _posZ, int _p4, int _value, bool _p6, int _modelHash)
		{
			unsafe {
				if (fn__createPickup == null) fn__createPickup = (delegate* unmanaged[Cdecl]<int, float, float, float, int, int, bool, int, int>) NativeLibrary.GetExport(handle, "Native_createPickup");
				var result = fn__createPickup(_pickupHash, _posX, _posY, _posZ, _p4, _value, _p6, _modelHash);
				return result;
			}
		}

		public int CreatePickupRotate(int _pickupHash, float _posX, float _posY, float _posZ, float _rotX, float _rotY, float _rotZ, int _flag, int _amount, int _p9, bool _p10, int _modelHash)
		{
			unsafe {
				if (fn__createPickupRotate == null) fn__createPickupRotate = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, int, int, int, bool, int, int>) NativeLibrary.GetExport(handle, "Native_createPickupRotate");
				var result = fn__createPickupRotate(_pickupHash, _posX, _posY, _posZ, _rotX, _rotY, _rotZ, _flag, _amount, _p9, _p10, _modelHash);
				return result;
			}
		}

		public void _0x394CD08E31313C28()
		{
			unsafe {
				if (fn__0x394CD08E31313C28 == null) fn__0x394CD08E31313C28 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x394CD08E31313C28");
				fn__0x394CD08E31313C28();
			}
		}

		public void _0x826D1EE4D1CAFC78(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x826D1EE4D1CAFC78 == null) fn__0x826D1EE4D1CAFC78 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x826D1EE4D1CAFC78");
				fn__0x826D1EE4D1CAFC78(_p0, _p1);
			}
		}

		public int CreateAmbientPickup(int _pickupHash, float _posX, float _posY, float _posZ, int _flags, int _value, int _modelHash, bool _p7, bool _p8)
		{
			unsafe {
				if (fn__createAmbientPickup == null) fn__createAmbientPickup = (delegate* unmanaged[Cdecl]<int, float, float, float, int, int, int, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_createAmbientPickup");
				var result = fn__createAmbientPickup(_pickupHash, _posX, _posY, _posZ, _flags, _value, _modelHash, _p7, _p8);
				return result;
			}
		}

		public int CreateNonNetworkedAmbientPickup(int _pickupHash, float _posX, float _posY, float _posZ, int _flags, int _value, int _modelHash, bool _p7, bool _p8)
		{
			unsafe {
				if (fn__createNonNetworkedAmbientPickup == null) fn__createNonNetworkedAmbientPickup = (delegate* unmanaged[Cdecl]<int, float, float, float, int, int, int, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_createNonNetworkedAmbientPickup");
				var result = fn__createNonNetworkedAmbientPickup(_pickupHash, _posX, _posY, _posZ, _flags, _value, _modelHash, _p7, _p8);
				return result;
			}
		}

		public void _0x1E3F1B1B891A2AAA(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x1E3F1B1B891A2AAA == null) fn__0x1E3F1B1B891A2AAA = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1E3F1B1B891A2AAA");
				fn__0x1E3F1B1B891A2AAA(_p0, _p1);
			}
		}

		public int CreatePortablePickup(int _pickupHash, float _x, float _y, float _z, bool _placeOnGround, int _modelHash)
		{
			unsafe {
				if (fn__createPortablePickup == null) fn__createPortablePickup = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int>) NativeLibrary.GetExport(handle, "Native_createPortablePickup");
				var result = fn__createPortablePickup(_pickupHash, _x, _y, _z, _placeOnGround, _modelHash);
				return result;
			}
		}

		public int CreateNonNetworkedPortablePickup(int _pickupHash, float _x, float _y, float _z, bool _placeOnGround, int _modelHash)
		{
			unsafe {
				if (fn__createNonNetworkedPortablePickup == null) fn__createNonNetworkedPortablePickup = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int>) NativeLibrary.GetExport(handle, "Native_createNonNetworkedPortablePickup");
				var result = fn__createNonNetworkedPortablePickup(_pickupHash, _x, _y, _z, _placeOnGround, _modelHash);
				return result;
			}
		}

		public void AttachPortablePickupToPed(int _pickupObject, int _ped)
		{
			unsafe {
				if (fn__attachPortablePickupToPed == null) fn__attachPortablePickupToPed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_attachPortablePickupToPed");
				fn__attachPortablePickupToPed(_pickupObject, _ped);
			}
		}

		public void DetachPortablePickupFromPed(int _pickupObject)
		{
			unsafe {
				if (fn__detachPortablePickupFromPed == null) fn__detachPortablePickupFromPed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_detachPortablePickupFromPed");
				fn__detachPortablePickupFromPed(_pickupObject);
			}
		}

		public void HidePickup(int _pickupObject, bool _toggle)
		{
			unsafe {
				if (fn__hidePickup == null) fn__hidePickup = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_hidePickup");
				fn__hidePickup(_pickupObject, _toggle);
			}
		}

		public void SetMaxNumPortablePickupsCarriedByPlayer(int _modelHash, int _p1)
		{
			unsafe {
				if (fn__setMaxNumPortablePickupsCarriedByPlayer == null) fn__setMaxNumPortablePickupsCarriedByPlayer = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setMaxNumPortablePickupsCarriedByPlayer");
				fn__setMaxNumPortablePickupsCarriedByPlayer(_modelHash, _p1);
			}
		}

		public void SetLocalPlayerCanCollectPortablePickups(bool _p0)
		{
			unsafe {
				if (fn__setLocalPlayerCanCollectPortablePickups == null) fn__setLocalPlayerCanCollectPortablePickups = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setLocalPlayerCanCollectPortablePickups");
				fn__setLocalPlayerCanCollectPortablePickups(_p0);
			}
		}

		public Vector3 GetSafePickupCoords(float _x, float _y, float _z, float _p3, float _p4)
		{
			unsafe {
				if (fn__getSafePickupCoords == null) fn__getSafePickupCoords = (delegate* unmanaged[Cdecl]<float, float, float, float, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getSafePickupCoords");
				var result = fn__getSafePickupCoords(_x, _y, _z, _p3, _p4);
				return result;
			}
		}

		public void _0xD4A7A435B3710D05(float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__0xD4A7A435B3710D05 == null) fn__0xD4A7A435B3710D05 = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0xD4A7A435B3710D05");
				fn__0xD4A7A435B3710D05(_x, _y, _z, _radius);
			}
		}

		public void _0xB7C6D80FB371659A()
		{
			unsafe {
				if (fn__0xB7C6D80FB371659A == null) fn__0xB7C6D80FB371659A = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xB7C6D80FB371659A");
				fn__0xB7C6D80FB371659A();
			}
		}

		public Vector3 GetPickupCoords(int _pickup)
		{
			unsafe {
				if (fn__getPickupCoords == null) fn__getPickupCoords = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getPickupCoords");
				var result = fn__getPickupCoords(_pickup);
				return result;
			}
		}

		public void _0x8DCA505A5C196F05(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x8DCA505A5C196F05 == null) fn__0x8DCA505A5C196F05 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x8DCA505A5C196F05");
				fn__0x8DCA505A5C196F05(_p0, _p1);
			}
		}

		public void RemoveAllPickupsOfType(int _pickupHash)
		{
			unsafe {
				if (fn__removeAllPickupsOfType == null) fn__removeAllPickupsOfType = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeAllPickupsOfType");
				fn__removeAllPickupsOfType(_pickupHash);
			}
		}

		public bool HasPickupBeenCollected(int _pickup)
		{
			unsafe {
				if (fn__hasPickupBeenCollected == null) fn__hasPickupBeenCollected = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasPickupBeenCollected");
				var result = fn__hasPickupBeenCollected(_pickup);
				return result;
			}
		}

		public void RemovePickup(int _pickup)
		{
			unsafe {
				if (fn__removePickup == null) fn__removePickup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removePickup");
				fn__removePickup(_pickup);
			}
		}

		public void CreateMoneyPickups(float _x, float _y, float _z, int _value, int _amount, int _model)
		{
			unsafe {
				if (fn__createMoneyPickups == null) fn__createMoneyPickups = (delegate* unmanaged[Cdecl]<float, float, float, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_createMoneyPickups");
				fn__createMoneyPickups(_x, _y, _z, _value, _amount, _model);
			}
		}

		public bool DoesPickupExist(int _pickup)
		{
			unsafe {
				if (fn__doesPickupExist == null) fn__doesPickupExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesPickupExist");
				var result = fn__doesPickupExist(_pickup);
				return result;
			}
		}

		public bool DoesPickupObjectExist(int _pickupObject)
		{
			unsafe {
				if (fn__doesPickupObjectExist == null) fn__doesPickupObjectExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesPickupObjectExist");
				var result = fn__doesPickupObjectExist(_pickupObject);
				return result;
			}
		}

		public int GetPickupObject(int _pickup)
		{
			unsafe {
				if (fn__getPickupObject == null) fn__getPickupObject = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPickupObject");
				var result = fn__getPickupObject(_pickup);
				return result;
			}
		}

		public bool IsObjectAPortablePickup(int _object)
		{
			unsafe {
				if (fn__isObjectAPortablePickup == null) fn__isObjectAPortablePickup = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isObjectAPortablePickup");
				var result = fn__isObjectAPortablePickup(_object);
				return result;
			}
		}

		public bool IsObjectAPickup(int _object)
		{
			unsafe {
				if (fn__isObjectAPickup == null) fn__isObjectAPickup = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isObjectAPickup");
				var result = fn__isObjectAPickup(_object);
				return result;
			}
		}

		public bool DoesPickupOfTypeExistInArea(int _pickupHash, float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__doesPickupOfTypeExistInArea == null) fn__doesPickupOfTypeExistInArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_doesPickupOfTypeExistInArea");
				var result = fn__doesPickupOfTypeExistInArea(_pickupHash, _x, _y, _z, _radius);
				return result;
			}
		}

		public void SetPickupRegenerationTime(int _pickup, int _duration)
		{
			unsafe {
				if (fn__setPickupRegenerationTime == null) fn__setPickupRegenerationTime = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPickupRegenerationTime");
				fn__setPickupRegenerationTime(_pickup, _duration);
			}
		}

		public void ForcePickupRegenerate(int _p0)
		{
			unsafe {
				if (fn__forcePickupRegenerate == null) fn__forcePickupRegenerate = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_forcePickupRegenerate");
				fn__forcePickupRegenerate(_p0);
			}
		}

		public void ToggleUsePickupsForPlayer(int _player, int _pickupHash, bool _toggle)
		{
			unsafe {
				if (fn__toggleUsePickupsForPlayer == null) fn__toggleUsePickupsForPlayer = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_toggleUsePickupsForPlayer");
				fn__toggleUsePickupsForPlayer(_player, _pickupHash, _toggle);
			}
		}

		public void SetLocalPlayerCanUsePickupsWithThisModel(int _modelHash, bool _toggle)
		{
			unsafe {
				if (fn__setLocalPlayerCanUsePickupsWithThisModel == null) fn__setLocalPlayerCanUsePickupsWithThisModel = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setLocalPlayerCanUsePickupsWithThisModel");
				fn__setLocalPlayerCanUsePickupsWithThisModel(_modelHash, _toggle);
			}
		}

		public void _0xFDC07C58E8AAB715(int _pickupHash)
		{
			unsafe {
				if (fn__0xFDC07C58E8AAB715 == null) fn__0xFDC07C58E8AAB715 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xFDC07C58E8AAB715");
				fn__0xFDC07C58E8AAB715(_pickupHash);
			}
		}

		public void SetTeamPickupObject(int _object, int _p1, bool _p2)
		{
			unsafe {
				if (fn__setTeamPickupObject == null) fn__setTeamPickupObject = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setTeamPickupObject");
				fn__setTeamPickupObject(_object, _p1, _p2);
			}
		}

		public void PreventCollectionOfPortablePickup(int _object, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__preventCollectionOfPortablePickup == null) fn__preventCollectionOfPortablePickup = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_preventCollectionOfPortablePickup");
				fn__preventCollectionOfPortablePickup(_object, _p1, _p2);
			}
		}

		public void _0x27F248C3FEBFAAD3(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x27F248C3FEBFAAD3 == null) fn__0x27F248C3FEBFAAD3 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x27F248C3FEBFAAD3");
				fn__0x27F248C3FEBFAAD3(_p0, _p1);
			}
		}

		public void _0x0596843B34B95CE5(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x0596843B34B95CE5 == null) fn__0x0596843B34B95CE5 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0596843B34B95CE5");
				fn__0x0596843B34B95CE5(_p0, _p1);
			}
		}

		public void _0xA08FE5E49BDC39DD(int _p0, float _p1, bool _p2)
		{
			unsafe {
				if (fn__0xA08FE5E49BDC39DD == null) fn__0xA08FE5E49BDC39DD = (delegate* unmanaged[Cdecl]<int, float, bool, void>) NativeLibrary.GetExport(handle, "Native__0xA08FE5E49BDC39DD");
				fn__0xA08FE5E49BDC39DD(_p0, _p1, _p2);
			}
		}

		public void _0x62454A641B41F3C5(int _p0)
		{
			unsafe {
				if (fn__0x62454A641B41F3C5 == null) fn__0x62454A641B41F3C5 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x62454A641B41F3C5");
				fn__0x62454A641B41F3C5(_p0);
			}
		}

		public void _0x39A5FB7EAF150840(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x39A5FB7EAF150840 == null) fn__0x39A5FB7EAF150840 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x39A5FB7EAF150840");
				fn__0x39A5FB7EAF150840(_p0, _p1);
			}
		}

		public void _0x834344A414C7C85D(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x834344A414C7C85D == null) fn__0x834344A414C7C85D = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x834344A414C7C85D");
				fn__0x834344A414C7C85D(_p0, _p1);
			}
		}

		public int _0xDB41D07A45A6D4B7(int _p0)
		{
			unsafe {
				if (fn__0xDB41D07A45A6D4B7 == null) fn__0xDB41D07A45A6D4B7 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xDB41D07A45A6D4B7");
				var result = fn__0xDB41D07A45A6D4B7(_p0);
				return result;
			}
		}

		public void SetPickupGenerationRangeMultiplier(float _multiplier)
		{
			unsafe {
				if (fn__setPickupGenerationRangeMultiplier == null) fn__setPickupGenerationRangeMultiplier = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setPickupGenerationRangeMultiplier");
				fn__setPickupGenerationRangeMultiplier(_multiplier);
			}
		}

		public float GetPickupGenerationRangeMultiplier()
		{
			unsafe {
				if (fn__getPickupGenerationRangeMultiplier == null) fn__getPickupGenerationRangeMultiplier = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getPickupGenerationRangeMultiplier");
				var result = fn__getPickupGenerationRangeMultiplier();
				return result;
			}
		}

		public void _0x31F924B53EADDF65(bool _p0)
		{
			unsafe {
				if (fn__0x31F924B53EADDF65 == null) fn__0x31F924B53EADDF65 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x31F924B53EADDF65");
				fn__0x31F924B53EADDF65(_p0);
			}
		}

		public void SetPickupUncollectable(int _p0, int _p1)
		{
			unsafe {
				if (fn__setPickupUncollectable == null) fn__setPickupUncollectable = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPickupUncollectable");
				fn__setPickupUncollectable(_p0, _p1);
			}
		}

		public void _0x858EC9FD25DE04AA(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x858EC9FD25DE04AA == null) fn__0x858EC9FD25DE04AA = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x858EC9FD25DE04AA");
				fn__0x858EC9FD25DE04AA(_p0, _p1);
			}
		}

		public void SetPickupHiddenWhenUncollectable(int _p0, int _p1)
		{
			unsafe {
				if (fn__setPickupHiddenWhenUncollectable == null) fn__setPickupHiddenWhenUncollectable = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPickupHiddenWhenUncollectable");
				fn__setPickupHiddenWhenUncollectable(_p0, _p1);
			}
		}

		public void _0x8881C98A31117998(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x8881C98A31117998 == null) fn__0x8881C98A31117998 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x8881C98A31117998");
				fn__0x8881C98A31117998(_p0, _p1);
			}
		}

		public void _0x8CFF648FBD7330F1(int _p0)
		{
			unsafe {
				if (fn__0x8CFF648FBD7330F1 == null) fn__0x8CFF648FBD7330F1 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x8CFF648FBD7330F1");
				fn__0x8CFF648FBD7330F1(_p0);
			}
		}

		public void _0x46F3ADD1E2D5BAF2(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x46F3ADD1E2D5BAF2 == null) fn__0x46F3ADD1E2D5BAF2 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x46F3ADD1E2D5BAF2");
				fn__0x46F3ADD1E2D5BAF2(_p0, _p1);
			}
		}

		public void _0x641F272B52E2F0F8(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x641F272B52E2F0F8 == null) fn__0x641F272B52E2F0F8 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x641F272B52E2F0F8");
				fn__0x641F272B52E2F0F8(_p0, _p1);
			}
		}

		public void _0x4C134B4DF76025D0(int _pickup, bool _toggle)
		{
			unsafe {
				if (fn__0x4C134B4DF76025D0 == null) fn__0x4C134B4DF76025D0 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x4C134B4DF76025D0");
				fn__0x4C134B4DF76025D0(_pickup, _toggle);
			}
		}

		public void _0xAA059C615DE9DD03(int _pickup, bool _toggle)
		{
			unsafe {
				if (fn__0xAA059C615DE9DD03 == null) fn__0xAA059C615DE9DD03 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xAA059C615DE9DD03");
				fn__0xAA059C615DE9DD03(_pickup, _toggle);
			}
		}

		public void _0xF92099527DB8E2A7(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xF92099527DB8E2A7 == null) fn__0xF92099527DB8E2A7 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xF92099527DB8E2A7");
				fn__0xF92099527DB8E2A7(_p0, _p1);
			}
		}

		public void _0xA2C1F5E92AFE49ED()
		{
			unsafe {
				if (fn__0xA2C1F5E92AFE49ED == null) fn__0xA2C1F5E92AFE49ED = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xA2C1F5E92AFE49ED");
				fn__0xA2C1F5E92AFE49ED();
			}
		}

		public void _0x762DB2D380B48D04(int _p0)
		{
			unsafe {
				if (fn__0x762DB2D380B48D04 == null) fn__0x762DB2D380B48D04 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x762DB2D380B48D04");
				fn__0x762DB2D380B48D04(_p0);
			}
		}

		public void RenderFakePickupGlow(float _x, float _y, float _z, int _colorIndex)
		{
			unsafe {
				if (fn__renderFakePickupGlow == null) fn__renderFakePickupGlow = (delegate* unmanaged[Cdecl]<float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_renderFakePickupGlow");
				fn__renderFakePickupGlow(_x, _y, _z, _colorIndex);
			}
		}

		public void _0x7813E8B8C4AE4799(int _pickup)
		{
			unsafe {
				if (fn__0x7813E8B8C4AE4799 == null) fn__0x7813E8B8C4AE4799 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x7813E8B8C4AE4799");
				fn__0x7813E8B8C4AE4799(_pickup);
			}
		}

		public void _0xBFFE53AE7E67FCDC(int _pickup, bool _toggle)
		{
			unsafe {
				if (fn__0xBFFE53AE7E67FCDC == null) fn__0xBFFE53AE7E67FCDC = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xBFFE53AE7E67FCDC");
				fn__0xBFFE53AE7E67FCDC(_pickup, _toggle);
			}
		}

		public void _0xD05A3241B9A86F19(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__0xD05A3241B9A86F19 == null) fn__0xD05A3241B9A86F19 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xD05A3241B9A86F19");
				fn__0xD05A3241B9A86F19(_entity, _toggle);
			}
		}

		public void _0xB2D0BDE54F0E8E5A(int _object, bool _toggle)
		{
			unsafe {
				if (fn__0xB2D0BDE54F0E8E5A == null) fn__0xB2D0BDE54F0E8E5A = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xB2D0BDE54F0E8E5A");
				fn__0xB2D0BDE54F0E8E5A(_object, _toggle);
			}
		}

		public int GetWeaponTypeFromPickupType(int _pickupHash)
		{
			unsafe {
				if (fn__getWeaponTypeFromPickupType == null) fn__getWeaponTypeFromPickupType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeaponTypeFromPickupType");
				var result = fn__getWeaponTypeFromPickupType(_pickupHash);
				return result;
			}
		}

		public int GetPickupHashFromWeapon(int _weaponHash)
		{
			unsafe {
				if (fn__getPickupHashFromWeapon == null) fn__getPickupHashFromWeapon = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPickupHashFromWeapon");
				var result = fn__getPickupHashFromWeapon(_weaponHash);
				return result;
			}
		}

		public bool IsPickupWeaponObjectValid(int _object)
		{
			unsafe {
				if (fn__isPickupWeaponObjectValid == null) fn__isPickupWeaponObjectValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPickupWeaponObjectValid");
				var result = fn__isPickupWeaponObjectValid(_object);
				return result;
			}
		}

		public int GetObjectTextureVariation(int _object)
		{
			unsafe {
				if (fn__getObjectTextureVariation == null) fn__getObjectTextureVariation = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getObjectTextureVariation");
				var result = fn__getObjectTextureVariation(_object);
				return result;
			}
		}

		public void SetObjectTextureVariation(int _object, int _textureVariation)
		{
			unsafe {
				if (fn__setObjectTextureVariation == null) fn__setObjectTextureVariation = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setObjectTextureVariation");
				fn__setObjectTextureVariation(_object, _textureVariation);
			}
		}

		public bool SetTextureVariationOfClosestObjectOfType(float _x, float _y, float _z, float _radius, int _modelHash, int _textureVariation)
		{
			unsafe {
				if (fn__setTextureVariationOfClosestObjectOfType == null) fn__setTextureVariationOfClosestObjectOfType = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, bool>) NativeLibrary.GetExport(handle, "Native_setTextureVariationOfClosestObjectOfType");
				var result = fn__setTextureVariationOfClosestObjectOfType(_x, _y, _z, _radius, _modelHash, _textureVariation);
				return result;
			}
		}

		public int SetObjectLightColor(int _object, bool _p1, int _r, int _g, int _b)
		{
			unsafe {
				if (fn__setObjectLightColor == null) fn__setObjectLightColor = (delegate* unmanaged[Cdecl]<int, bool, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_setObjectLightColor");
				var result = fn__setObjectLightColor(_object, _p1, _r, _g, _b);
				return result;
			}
		}

		public bool _0xADF084FB8F075D06(int _object)
		{
			unsafe {
				if (fn__0xADF084FB8F075D06 == null) fn__0xADF084FB8F075D06 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xADF084FB8F075D06");
				var result = fn__0xADF084FB8F075D06(_object);
				return result;
			}
		}

		public void _0x3B2FD68DB5F8331C(int _object, bool _toggle)
		{
			unsafe {
				if (fn__0x3B2FD68DB5F8331C == null) fn__0x3B2FD68DB5F8331C = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x3B2FD68DB5F8331C");
				fn__0x3B2FD68DB5F8331C(_object, _toggle);
			}
		}

		public void SetObjectStuntPropSpeedup(int _object, int _p1)
		{
			unsafe {
				if (fn__setObjectStuntPropSpeedup == null) fn__setObjectStuntPropSpeedup = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setObjectStuntPropSpeedup");
				fn__setObjectStuntPropSpeedup(_object, _p1);
			}
		}

		public void SetObjectStuntPropDuration(int _object, float _duration)
		{
			unsafe {
				if (fn__setObjectStuntPropDuration == null) fn__setObjectStuntPropDuration = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setObjectStuntPropDuration");
				fn__setObjectStuntPropDuration(_object, _duration);
			}
		}

		public int GetPickupHash(int _pickupHash)
		{
			unsafe {
				if (fn__getPickupHash == null) fn__getPickupHash = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPickupHash");
				var result = fn__getPickupHash(_pickupHash);
				return result;
			}
		}

		public void SetForceObjectThisFrame(float _x, float _y, float _z, float _p3)
		{
			unsafe {
				if (fn__setForceObjectThisFrame == null) fn__setForceObjectThisFrame = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setForceObjectThisFrame");
				fn__setForceObjectThisFrame(_x, _y, _z, _p3);
			}
		}

		public void MarkObjectForDeletion(int _object)
		{
			unsafe {
				if (fn__markObjectForDeletion == null) fn__markObjectForDeletion = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_markObjectForDeletion");
				fn__markObjectForDeletion(_object);
			}
		}

		public void _0x8CAAB2BD3EA58BD4(int _p0)
		{
			unsafe {
				if (fn__0x8CAAB2BD3EA58BD4 == null) fn__0x8CAAB2BD3EA58BD4 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x8CAAB2BD3EA58BD4");
				fn__0x8CAAB2BD3EA58BD4(_p0);
			}
		}

		public void _0x63ECF581BC70E363(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x63ECF581BC70E363 == null) fn__0x63ECF581BC70E363 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x63ECF581BC70E363");
				fn__0x63ECF581BC70E363(_p0, _p1);
			}
		}

		public void SetEnableArenaPropPhysics(int _object, bool _toggle, int _p2)
		{
			unsafe {
				if (fn__setEnableArenaPropPhysics == null) fn__setEnableArenaPropPhysics = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setEnableArenaPropPhysics");
				fn__setEnableArenaPropPhysics(_object, _toggle, _p2);
			}
		}

		public void SetEnableArenaPropPhysicsOnPed(int _object, bool _toggle, int _p2, int _ped)
		{
			unsafe {
				if (fn__setEnableArenaPropPhysicsOnPed == null) fn__setEnableArenaPropPhysicsOnPed = (delegate* unmanaged[Cdecl]<int, bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_setEnableArenaPropPhysicsOnPed");
				fn__setEnableArenaPropPhysicsOnPed(_object, _toggle, _p2, _ped);
			}
		}

		public void _0x734E1714D077DA9A(int _object, bool _toggle)
		{
			unsafe {
				if (fn__0x734E1714D077DA9A == null) fn__0x734E1714D077DA9A = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x734E1714D077DA9A");
				fn__0x734E1714D077DA9A(_object, _toggle);
			}
		}

		public void _0x1A6CBB06E2D0D79D(int _object, bool _p1)
		{
			unsafe {
				if (fn__0x1A6CBB06E2D0D79D == null) fn__0x1A6CBB06E2D0D79D = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x1A6CBB06E2D0D79D");
				fn__0x1A6CBB06E2D0D79D(_object, _p1);
			}
		}

		public bool GetIsArenaPropPhysicsDisabled(int _object, int _p1)
		{
			unsafe {
				if (fn__getIsArenaPropPhysicsDisabled == null) fn__getIsArenaPropPhysicsDisabled = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_getIsArenaPropPhysicsDisabled");
				var result = fn__getIsArenaPropPhysicsDisabled(_object, _p1);
				return result;
			}
		}

		public int _0x3BD770D281982DB5(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x3BD770D281982DB5 == null) fn__0x3BD770D281982DB5 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x3BD770D281982DB5");
				var result = fn__0x3BD770D281982DB5(_p0, _p1);
				return result;
			}
		}

		public void _0x1C57C94A6446492A(int _object, bool _toggle)
		{
			unsafe {
				if (fn__0x1C57C94A6446492A == null) fn__0x1C57C94A6446492A = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x1C57C94A6446492A");
				fn__0x1C57C94A6446492A(_object, _toggle);
			}
		}

		public void _0xB5B7742424BD4445(int _object, bool _toggle)
		{
			unsafe {
				if (fn__0xB5B7742424BD4445 == null) fn__0xB5B7742424BD4445 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xB5B7742424BD4445");
				fn__0xB5B7742424BD4445(_object, _toggle);
			}
		}

		public bool IsControlEnabled(int _padIndex, int _control)
		{
			unsafe {
				if (fn__isControlEnabled == null) fn__isControlEnabled = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isControlEnabled");
				var result = fn__isControlEnabled(_padIndex, _control);
				return result;
			}
		}

		public bool IsControlPressed(int _padIndex, int _control)
		{
			unsafe {
				if (fn__isControlPressed == null) fn__isControlPressed = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isControlPressed");
				var result = fn__isControlPressed(_padIndex, _control);
				return result;
			}
		}

		public bool IsControlReleased(int _padIndex, int _control)
		{
			unsafe {
				if (fn__isControlReleased == null) fn__isControlReleased = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isControlReleased");
				var result = fn__isControlReleased(_padIndex, _control);
				return result;
			}
		}

		public bool IsControlJustPressed(int _padIndex, int _control)
		{
			unsafe {
				if (fn__isControlJustPressed == null) fn__isControlJustPressed = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isControlJustPressed");
				var result = fn__isControlJustPressed(_padIndex, _control);
				return result;
			}
		}

		public bool IsControlJustReleased(int _padIndex, int _control)
		{
			unsafe {
				if (fn__isControlJustReleased == null) fn__isControlJustReleased = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isControlJustReleased");
				var result = fn__isControlJustReleased(_padIndex, _control);
				return result;
			}
		}

		public int GetControlValue(int _padIndex, int _control)
		{
			unsafe {
				if (fn__getControlValue == null) fn__getControlValue = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getControlValue");
				var result = fn__getControlValue(_padIndex, _control);
				return result;
			}
		}

		public float GetControlNormal(int _padIndex, int _control)
		{
			unsafe {
				if (fn__getControlNormal == null) fn__getControlNormal = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getControlNormal");
				var result = fn__getControlNormal(_padIndex, _control);
				return result;
			}
		}

		public void _0x5B73C77D9EB66E24(bool _p0)
		{
			unsafe {
				if (fn__0x5B73C77D9EB66E24 == null) fn__0x5B73C77D9EB66E24 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x5B73C77D9EB66E24");
				fn__0x5B73C77D9EB66E24(_p0);
			}
		}

		public float GetControlUnboundNormal(int _padIndex, int _control)
		{
			unsafe {
				if (fn__getControlUnboundNormal == null) fn__getControlUnboundNormal = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getControlUnboundNormal");
				var result = fn__getControlUnboundNormal(_padIndex, _control);
				return result;
			}
		}

		public bool SetControlNormal(int _padIndex, int _control, float _amount)
		{
			unsafe {
				if (fn__setControlNormal == null) fn__setControlNormal = (delegate* unmanaged[Cdecl]<int, int, float, bool>) NativeLibrary.GetExport(handle, "Native_setControlNormal");
				var result = fn__setControlNormal(_padIndex, _control, _amount);
				return result;
			}
		}

		public bool IsDisabledControlPressed(int _padIndex, int _control)
		{
			unsafe {
				if (fn__isDisabledControlPressed == null) fn__isDisabledControlPressed = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isDisabledControlPressed");
				var result = fn__isDisabledControlPressed(_padIndex, _control);
				return result;
			}
		}

		public bool IsDisabledControlReleased(int _padIndex, int _control)
		{
			unsafe {
				if (fn__isDisabledControlReleased == null) fn__isDisabledControlReleased = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isDisabledControlReleased");
				var result = fn__isDisabledControlReleased(_padIndex, _control);
				return result;
			}
		}

		public bool IsDisabledControlJustPressed(int _padIndex, int _control)
		{
			unsafe {
				if (fn__isDisabledControlJustPressed == null) fn__isDisabledControlJustPressed = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isDisabledControlJustPressed");
				var result = fn__isDisabledControlJustPressed(_padIndex, _control);
				return result;
			}
		}

		public bool IsDisabledControlJustReleased(int _padIndex, int _control)
		{
			unsafe {
				if (fn__isDisabledControlJustReleased == null) fn__isDisabledControlJustReleased = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isDisabledControlJustReleased");
				var result = fn__isDisabledControlJustReleased(_padIndex, _control);
				return result;
			}
		}

		public float GetDisabledControlNormal(int _padIndex, int _control)
		{
			unsafe {
				if (fn__getDisabledControlNormal == null) fn__getDisabledControlNormal = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getDisabledControlNormal");
				var result = fn__getDisabledControlNormal(_padIndex, _control);
				return result;
			}
		}

		public float GetDisabledControlUnboundNormal(int _padIndex, int _control)
		{
			unsafe {
				if (fn__getDisabledControlUnboundNormal == null) fn__getDisabledControlUnboundNormal = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getDisabledControlUnboundNormal");
				var result = fn__getDisabledControlUnboundNormal(_padIndex, _control);
				return result;
			}
		}

		public int _0xD7D22F5592AED8BA(int _p0)
		{
			unsafe {
				if (fn__0xD7D22F5592AED8BA == null) fn__0xD7D22F5592AED8BA = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xD7D22F5592AED8BA");
				var result = fn__0xD7D22F5592AED8BA(_p0);
				return result;
			}
		}

		public bool IsUsingKeyboard(int _padIndex)
		{
			unsafe {
				if (fn__isUsingKeyboard == null) fn__isUsingKeyboard = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isUsingKeyboard");
				var result = fn__isUsingKeyboard(_padIndex);
				return result;
			}
		}

		public bool IsUsingKeyboard2(int _padIndex)
		{
			unsafe {
				if (fn__isUsingKeyboard2 == null) fn__isUsingKeyboard2 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isUsingKeyboard2");
				var result = fn__isUsingKeyboard2(_padIndex);
				return result;
			}
		}

		public bool SetCursorLocation(float _x, float _y)
		{
			unsafe {
				if (fn__setCursorLocation == null) fn__setCursorLocation = (delegate* unmanaged[Cdecl]<float, float, bool>) NativeLibrary.GetExport(handle, "Native_setCursorLocation");
				var result = fn__setCursorLocation(_x, _y);
				return result;
			}
		}

		public bool _0x23F09EADC01449D6(int _padIndex)
		{
			unsafe {
				if (fn__0x23F09EADC01449D6 == null) fn__0x23F09EADC01449D6 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x23F09EADC01449D6");
				var result = fn__0x23F09EADC01449D6(_padIndex);
				return result;
			}
		}

		public bool _0x6CD79468A1E595C6(int _padIndex)
		{
			unsafe {
				if (fn__0x6CD79468A1E595C6 == null) fn__0x6CD79468A1E595C6 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x6CD79468A1E595C6");
				var result = fn__0x6CD79468A1E595C6(_padIndex);
				return result;
			}
		}

		public string GetControlInstructionalButton(int _padIndex, int _control, bool _p2)
		{
			unsafe {
				if (fn__getControlInstructionalButton == null) fn__getControlInstructionalButton = (delegate* unmanaged[Cdecl]<int, int, bool, nint>) NativeLibrary.GetExport(handle, "Native_getControlInstructionalButton");
				var result = fn__getControlInstructionalButton(_padIndex, _control, _p2);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetControlGroupInstructionalButton(int _padIndex, int _controlGroup, bool _p2)
		{
			unsafe {
				if (fn__getControlGroupInstructionalButton == null) fn__getControlGroupInstructionalButton = (delegate* unmanaged[Cdecl]<int, int, bool, nint>) NativeLibrary.GetExport(handle, "Native_getControlGroupInstructionalButton");
				var result = fn__getControlGroupInstructionalButton(_padIndex, _controlGroup, _p2);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void SetControlLightEffectColor(int _padIndex, int _red, int _green, int _blue)
		{
			unsafe {
				if (fn__setControlLightEffectColor == null) fn__setControlLightEffectColor = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setControlLightEffectColor");
				fn__setControlLightEffectColor(_padIndex, _red, _green, _blue);
			}
		}

		public void _0xCB0360EFEFB2580D(int _padIndex)
		{
			unsafe {
				if (fn__0xCB0360EFEFB2580D == null) fn__0xCB0360EFEFB2580D = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xCB0360EFEFB2580D");
				fn__0xCB0360EFEFB2580D(_padIndex);
			}
		}

		public void SetPadShake(int _padIndex, int _duration, int _frequency)
		{
			unsafe {
				if (fn__setPadShake == null) fn__setPadShake = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPadShake");
				fn__setPadShake(_padIndex, _duration, _frequency);
			}
		}

		public void _0x14D29BB12D47F68C(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0x14D29BB12D47F68C == null) fn__0x14D29BB12D47F68C = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x14D29BB12D47F68C");
				fn__0x14D29BB12D47F68C(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void StopPadShake(int _padIndex)
		{
			unsafe {
				if (fn__stopPadShake == null) fn__stopPadShake = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopPadShake");
				fn__stopPadShake(_padIndex);
			}
		}

		public void SetPadShakeSuppressedId(int _padIndex, int _p1)
		{
			unsafe {
				if (fn__setPadShakeSuppressedId == null) fn__setPadShakeSuppressedId = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPadShakeSuppressedId");
				fn__setPadShakeSuppressedId(_padIndex, _p1);
			}
		}

		public void _0xA0CEFCEA390AAB9B(int _p0)
		{
			unsafe {
				if (fn__0xA0CEFCEA390AAB9B == null) fn__0xA0CEFCEA390AAB9B = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xA0CEFCEA390AAB9B");
				fn__0xA0CEFCEA390AAB9B(_p0);
			}
		}

		public bool IsLookInverted()
		{
			unsafe {
				if (fn__isLookInverted == null) fn__isLookInverted = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isLookInverted");
				var result = fn__isLookInverted();
				return result;
			}
		}

		public bool _0xE1615EC03B3BB4FD()
		{
			unsafe {
				if (fn__0xE1615EC03B3BB4FD == null) fn__0xE1615EC03B3BB4FD = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xE1615EC03B3BB4FD");
				var result = fn__0xE1615EC03B3BB4FD();
				return result;
			}
		}

		public int GetLocalPlayerAimState()
		{
			unsafe {
				if (fn__getLocalPlayerAimState == null) fn__getLocalPlayerAimState = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getLocalPlayerAimState");
				var result = fn__getLocalPlayerAimState();
				return result;
			}
		}

		public int GetLocalPlayerAimState2()
		{
			unsafe {
				if (fn__getLocalPlayerAimState2 == null) fn__getLocalPlayerAimState2 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getLocalPlayerAimState2");
				var result = fn__getLocalPlayerAimState2();
				return result;
			}
		}

		public int _0x25AAA32BDC98F2A3()
		{
			unsafe {
				if (fn__0x25AAA32BDC98F2A3 == null) fn__0x25AAA32BDC98F2A3 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x25AAA32BDC98F2A3");
				var result = fn__0x25AAA32BDC98F2A3();
				return result;
			}
		}

		public bool GetIsUsingAlternateDriveby()
		{
			unsafe {
				if (fn__getIsUsingAlternateDriveby == null) fn__getIsUsingAlternateDriveby = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getIsUsingAlternateDriveby");
				var result = fn__getIsUsingAlternateDriveby();
				return result;
			}
		}

		public bool GetAllowMovementWhileZoomed()
		{
			unsafe {
				if (fn__getAllowMovementWhileZoomed == null) fn__getAllowMovementWhileZoomed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getAllowMovementWhileZoomed");
				var result = fn__getAllowMovementWhileZoomed();
				return result;
			}
		}

		public void SetPlayerpadShakesWhenControllerDisabled(bool _toggle)
		{
			unsafe {
				if (fn__setPlayerpadShakesWhenControllerDisabled == null) fn__setPlayerpadShakesWhenControllerDisabled = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerpadShakesWhenControllerDisabled");
				fn__setPlayerpadShakesWhenControllerDisabled(_toggle);
			}
		}

		public void SetInputExclusive(int _padIndex, int _control)
		{
			unsafe {
				if (fn__setInputExclusive == null) fn__setInputExclusive = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setInputExclusive");
				fn__setInputExclusive(_padIndex, _control);
			}
		}

		public void DisableControlAction(int _padIndex, int _control, bool _disable)
		{
			unsafe {
				if (fn__disableControlAction == null) fn__disableControlAction = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_disableControlAction");
				fn__disableControlAction(_padIndex, _control, _disable);
			}
		}

		public void EnableControlAction(int _padIndex, int _control, bool _enable)
		{
			unsafe {
				if (fn__enableControlAction == null) fn__enableControlAction = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_enableControlAction");
				fn__enableControlAction(_padIndex, _control, _enable);
			}
		}

		public void DisableAllControlActions(int _padIndex)
		{
			unsafe {
				if (fn__disableAllControlActions == null) fn__disableAllControlActions = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableAllControlActions");
				fn__disableAllControlActions(_padIndex);
			}
		}

		public void EnableAllControlActions(int _padIndex)
		{
			unsafe {
				if (fn__enableAllControlActions == null) fn__enableAllControlActions = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_enableAllControlActions");
				fn__enableAllControlActions(_padIndex);
			}
		}

		public bool SwitchToInputMappingScheme(string _name)
		{
			unsafe {
				if (fn__switchToInputMappingScheme == null) fn__switchToInputMappingScheme = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_switchToInputMappingScheme");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__switchToInputMappingScheme(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public bool SwitchToInputMappingScheme2(string _name)
		{
			unsafe {
				if (fn__switchToInputMappingScheme2 == null) fn__switchToInputMappingScheme2 = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_switchToInputMappingScheme2");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__switchToInputMappingScheme2(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public void ResetInputMappingScheme()
		{
			unsafe {
				if (fn__resetInputMappingScheme == null) fn__resetInputMappingScheme = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetInputMappingScheme");
				fn__resetInputMappingScheme();
			}
		}

		public void DisableInputGroup(int _padIndex)
		{
			unsafe {
				if (fn__disableInputGroup == null) fn__disableInputGroup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableInputGroup");
				fn__disableInputGroup(_padIndex);
			}
		}

		public void SetRoadsInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _nodeEnabled, bool _unknown2)
		{
			unsafe {
				if (fn__setRoadsInArea == null) fn__setRoadsInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setRoadsInArea");
				fn__setRoadsInArea(_x1, _y1, _z1, _x2, _y2, _z2, _nodeEnabled, _unknown2);
			}
		}

		public void SetRoadsInAngledArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width, bool _unknown1, bool _unknown2, bool _unknown3)
		{
			unsafe {
				if (fn__setRoadsInAngledArea == null) fn__setRoadsInAngledArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setRoadsInAngledArea");
				fn__setRoadsInAngledArea(_x1, _y1, _z1, _x2, _y2, _z2, _width, _unknown1, _unknown2, _unknown3);
			}
		}

		public void SetPedPathsInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _unknown, int _p7)
		{
			unsafe {
				if (fn__setPedPathsInArea == null) fn__setPedPathsInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setPedPathsInArea");
				fn__setPedPathsInArea(_x1, _y1, _z1, _x2, _y2, _z2, _unknown, _p7);
			}
		}

		public bool GetSafeCoordForPed(float _x, float _y, float _z, bool _onGround, ref Vector3 _outPosition, int _flags)
		{
			unsafe {
				if (fn__getSafeCoordForPed == null) fn__getSafeCoordForPed = (delegate* unmanaged[Cdecl]<float, float, float, bool, Vector3*, int, bool>) NativeLibrary.GetExport(handle, "Native_getSafeCoordForPed");
				var ref_outPosition = _outPosition;
				var result = fn__getSafeCoordForPed(_x, _y, _z, _onGround, &ref_outPosition, _flags);
				_outPosition = ref_outPosition;
				return result;
			}
		}

		public bool GetClosestVehicleNode(float _x, float _y, float _z, ref Vector3 _outPosition, int _nodeType, float _p5, float _p6)
		{
			unsafe {
				if (fn__getClosestVehicleNode == null) fn__getClosestVehicleNode = (delegate* unmanaged[Cdecl]<float, float, float, Vector3*, int, float, float, bool>) NativeLibrary.GetExport(handle, "Native_getClosestVehicleNode");
				var ref_outPosition = _outPosition;
				var result = fn__getClosestVehicleNode(_x, _y, _z, &ref_outPosition, _nodeType, _p5, _p6);
				_outPosition = ref_outPosition;
				return result;
			}
		}

		public bool GetClosestMajorVehicleNode(float _x, float _y, float _z, ref Vector3 _outPosition, float _unknown1, int _unknown2)
		{
			unsafe {
				if (fn__getClosestMajorVehicleNode == null) fn__getClosestMajorVehicleNode = (delegate* unmanaged[Cdecl]<float, float, float, Vector3*, float, int, bool>) NativeLibrary.GetExport(handle, "Native_getClosestMajorVehicleNode");
				var ref_outPosition = _outPosition;
				var result = fn__getClosestMajorVehicleNode(_x, _y, _z, &ref_outPosition, _unknown1, _unknown2);
				_outPosition = ref_outPosition;
				return result;
			}
		}

		public bool GetClosestVehicleNodeWithHeading(float _x, float _y, float _z, ref Vector3 _outPosition, ref float _outHeading, int _nodeType, float _p6, int _p7)
		{
			unsafe {
				if (fn__getClosestVehicleNodeWithHeading == null) fn__getClosestVehicleNodeWithHeading = (delegate* unmanaged[Cdecl]<float, float, float, Vector3*, float*, int, float, int, bool>) NativeLibrary.GetExport(handle, "Native_getClosestVehicleNodeWithHeading");
				var ref_outPosition = _outPosition;
				var ref_outHeading = _outHeading;
				var result = fn__getClosestVehicleNodeWithHeading(_x, _y, _z, &ref_outPosition, &ref_outHeading, _nodeType, _p6, _p7);
				_outPosition = ref_outPosition;
				_outHeading = ref_outHeading;
				return result;
			}
		}

		public bool GetNthClosestVehicleNode(float _x, float _y, float _z, int _nthClosest, ref Vector3 _outPosition, int _unknown1, int _unknown2, int _unknown3)
		{
			unsafe {
				if (fn__getNthClosestVehicleNode == null) fn__getNthClosestVehicleNode = (delegate* unmanaged[Cdecl]<float, float, float, int, Vector3*, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_getNthClosestVehicleNode");
				var ref_outPosition = _outPosition;
				var result = fn__getNthClosestVehicleNode(_x, _y, _z, _nthClosest, &ref_outPosition, _unknown1, _unknown2, _unknown3);
				_outPosition = ref_outPosition;
				return result;
			}
		}

		public int GetNthClosestVehicleNodeId(float _x, float _y, float _z, int _nth, int _nodetype, float _p5, float _p6)
		{
			unsafe {
				if (fn__getNthClosestVehicleNodeId == null) fn__getNthClosestVehicleNodeId = (delegate* unmanaged[Cdecl]<float, float, float, int, int, float, float, int>) NativeLibrary.GetExport(handle, "Native_getNthClosestVehicleNodeId");
				var result = fn__getNthClosestVehicleNodeId(_x, _y, _z, _nth, _nodetype, _p5, _p6);
				return result;
			}
		}

		public bool GetNthClosestVehicleNodeWithHeading(float _x, float _y, float _z, int _nthClosest, ref Vector3 _outPosition, ref float _outHeading, ref int _unknown1, int _unknown2, float _unknown3, float _unknown4)
		{
			unsafe {
				if (fn__getNthClosestVehicleNodeWithHeading == null) fn__getNthClosestVehicleNodeWithHeading = (delegate* unmanaged[Cdecl]<float, float, float, int, Vector3*, float*, int*, int, float, float, bool>) NativeLibrary.GetExport(handle, "Native_getNthClosestVehicleNodeWithHeading");
				var ref_outPosition = _outPosition;
				var ref_outHeading = _outHeading;
				var ref_unknown1 = _unknown1;
				var result = fn__getNthClosestVehicleNodeWithHeading(_x, _y, _z, _nthClosest, &ref_outPosition, &ref_outHeading, &ref_unknown1, _unknown2, _unknown3, _unknown4);
				_outPosition = ref_outPosition;
				_outHeading = ref_outHeading;
				_unknown1 = ref_unknown1;
				return result;
			}
		}

		public int GetNthClosestVehicleNodeIdWithHeading(float _x, float _y, float _z, int _nthClosest, ref Vector3 _outPosition, ref float _outHeading, int _p6, float _p7, float _p8)
		{
			unsafe {
				if (fn__getNthClosestVehicleNodeIdWithHeading == null) fn__getNthClosestVehicleNodeIdWithHeading = (delegate* unmanaged[Cdecl]<float, float, float, int, Vector3*, float*, int, float, float, int>) NativeLibrary.GetExport(handle, "Native_getNthClosestVehicleNodeIdWithHeading");
				var ref_outPosition = _outPosition;
				var ref_outHeading = _outHeading;
				var result = fn__getNthClosestVehicleNodeIdWithHeading(_x, _y, _z, _nthClosest, &ref_outPosition, &ref_outHeading, _p6, _p7, _p8);
				_outPosition = ref_outPosition;
				_outHeading = ref_outHeading;
				return result;
			}
		}

		public bool GetNthClosestVehicleNodeFavourDirection(float _x, float _y, float _z, float _desiredX, float _desiredY, float _desiredZ, int _nthClosest, ref Vector3 _outPosition, ref float _outHeading, int _nodetype, float _p10, int _p11)
		{
			unsafe {
				if (fn__getNthClosestVehicleNodeFavourDirection == null) fn__getNthClosestVehicleNodeFavourDirection = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, Vector3*, float*, int, float, int, bool>) NativeLibrary.GetExport(handle, "Native_getNthClosestVehicleNodeFavourDirection");
				var ref_outPosition = _outPosition;
				var ref_outHeading = _outHeading;
				var result = fn__getNthClosestVehicleNodeFavourDirection(_x, _y, _z, _desiredX, _desiredY, _desiredZ, _nthClosest, &ref_outPosition, &ref_outHeading, _nodetype, _p10, _p11);
				_outPosition = ref_outPosition;
				_outHeading = ref_outHeading;
				return result;
			}
		}

		public bool GetVehicleNodeProperties(float _x, float _y, float _z, ref int _density, ref int _flags)
		{
			unsafe {
				if (fn__getVehicleNodeProperties == null) fn__getVehicleNodeProperties = (delegate* unmanaged[Cdecl]<float, float, float, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleNodeProperties");
				var ref_density = _density;
				var ref_flags = _flags;
				var result = fn__getVehicleNodeProperties(_x, _y, _z, &ref_density, &ref_flags);
				_density = ref_density;
				_flags = ref_flags;
				return result;
			}
		}

		public bool IsVehicleNodeIdValid(int _vehicleNodeId)
		{
			unsafe {
				if (fn__isVehicleNodeIdValid == null) fn__isVehicleNodeIdValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleNodeIdValid");
				var result = fn__isVehicleNodeIdValid(_vehicleNodeId);
				return result;
			}
		}

		public void GetVehicleNodePosition(int _nodeId, ref Vector3 _outPosition)
		{
			unsafe {
				if (fn__getVehicleNodePosition == null) fn__getVehicleNodePosition = (delegate* unmanaged[Cdecl]<int, Vector3*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleNodePosition");
				var ref_outPosition = _outPosition;
				fn__getVehicleNodePosition(_nodeId, &ref_outPosition);
				_outPosition = ref_outPosition;
			}
		}

		public bool GetVehicleNodeIsGpsAllowed(int _nodeID)
		{
			unsafe {
				if (fn__getVehicleNodeIsGpsAllowed == null) fn__getVehicleNodeIsGpsAllowed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleNodeIsGpsAllowed");
				var result = fn__getVehicleNodeIsGpsAllowed(_nodeID);
				return result;
			}
		}

		public bool GetVehicleNodeIsSwitchedOff(int _nodeID)
		{
			unsafe {
				if (fn__getVehicleNodeIsSwitchedOff == null) fn__getVehicleNodeIsSwitchedOff = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleNodeIsSwitchedOff");
				var result = fn__getVehicleNodeIsSwitchedOff(_nodeID);
				return result;
			}
		}

		public int GetClosestRoad(float _x, float _y, float _z, float _p3, int _p4, ref Vector3 _p5, ref Vector3 _p6, ref int _p7, ref int _p8, ref float _p9, bool _p10)
		{
			unsafe {
				if (fn__getClosestRoad == null) fn__getClosestRoad = (delegate* unmanaged[Cdecl]<float, float, float, float, int, Vector3*, Vector3*, int*, int*, float*, bool, int>) NativeLibrary.GetExport(handle, "Native_getClosestRoad");
				var ref_p5 = _p5;
				var ref_p6 = _p6;
				var ref_p7 = _p7;
				var ref_p8 = _p8;
				var ref_p9 = _p9;
				var result = fn__getClosestRoad(_x, _y, _z, _p3, _p4, &ref_p5, &ref_p6, &ref_p7, &ref_p8, &ref_p9, _p10);
				_p5 = ref_p5;
				_p6 = ref_p6;
				_p7 = ref_p7;
				_p8 = ref_p8;
				_p9 = ref_p9;
				return result;
			}
		}

		public void SetAllPathsCacheBoundingstruct(bool _toggle)
		{
			unsafe {
				if (fn__setAllPathsCacheBoundingstruct == null) fn__setAllPathsCacheBoundingstruct = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setAllPathsCacheBoundingstruct");
				fn__setAllPathsCacheBoundingstruct(_toggle);
			}
		}

		public void SetAiGlobalPathNodesType(int _type)
		{
			unsafe {
				if (fn__setAiGlobalPathNodesType == null) fn__setAiGlobalPathNodesType = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setAiGlobalPathNodesType");
				fn__setAiGlobalPathNodesType(_type);
			}
		}

		public bool AreNodesLoadedForArea(float _x1, float _y1, float _x2, float _y2)
		{
			unsafe {
				if (fn__areNodesLoadedForArea == null) fn__areNodesLoadedForArea = (delegate* unmanaged[Cdecl]<float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_areNodesLoadedForArea");
				var result = fn__areNodesLoadedForArea(_x1, _y1, _x2, _y2);
				return result;
			}
		}

		public bool RequestPathsPreferAccurateBoundingstruct(float _x1, float _y1, float _x2, float _y2)
		{
			unsafe {
				if (fn__requestPathsPreferAccurateBoundingstruct == null) fn__requestPathsPreferAccurateBoundingstruct = (delegate* unmanaged[Cdecl]<float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_requestPathsPreferAccurateBoundingstruct");
				var result = fn__requestPathsPreferAccurateBoundingstruct(_x1, _y1, _x2, _y2);
				return result;
			}
		}

		public void SetRoadsBackToOriginal(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, int _p6)
		{
			unsafe {
				if (fn__setRoadsBackToOriginal == null) fn__setRoadsBackToOriginal = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setRoadsBackToOriginal");
				fn__setRoadsBackToOriginal(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void SetRoadsBackToOriginalInAngledArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _width, int _p7)
		{
			unsafe {
				if (fn__setRoadsBackToOriginalInAngledArea == null) fn__setRoadsBackToOriginalInAngledArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setRoadsBackToOriginalInAngledArea");
				fn__setRoadsBackToOriginalInAngledArea(_x1, _y1, _z1, _x2, _y2, _z2, _width, _p7);
			}
		}

		public void SetAmbientPedRangeMultiplierThisFrame(float _multiplier)
		{
			unsafe {
				if (fn__setAmbientPedRangeMultiplierThisFrame == null) fn__setAmbientPedRangeMultiplierThisFrame = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setAmbientPedRangeMultiplierThisFrame");
				fn__setAmbientPedRangeMultiplierThisFrame(_multiplier);
			}
		}

		public void _0xAA76052DDA9BFC3E(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__0xAA76052DDA9BFC3E == null) fn__0xAA76052DDA9BFC3E = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xAA76052DDA9BFC3E");
				fn__0xAA76052DDA9BFC3E(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void SetPedPathsBackToOriginal(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__setPedPathsBackToOriginal == null) fn__setPedPathsBackToOriginal = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedPathsBackToOriginal");
				fn__setPedPathsBackToOriginal(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public bool GetRandomVehicleNode(float _x, float _y, float _z, float _radius, bool _p4, bool _p5, bool _p6, ref Vector3 _outPosition, ref int _nodeId)
		{
			unsafe {
				if (fn__getRandomVehicleNode == null) fn__getRandomVehicleNode = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, bool, Vector3*, int*, bool>) NativeLibrary.GetExport(handle, "Native_getRandomVehicleNode");
				var ref_outPosition = _outPosition;
				var ref_nodeId = _nodeId;
				var result = fn__getRandomVehicleNode(_x, _y, _z, _radius, _p4, _p5, _p6, &ref_outPosition, &ref_nodeId);
				_outPosition = ref_outPosition;
				_nodeId = ref_nodeId;
				return result;
			}
		}

		public void GetStreetNameAtCoord(float _x, float _y, float _z, ref int _streetName, ref int _crossingRoad)
		{
			unsafe {
				if (fn__getStreetNameAtCoord == null) fn__getStreetNameAtCoord = (delegate* unmanaged[Cdecl]<float, float, float, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getStreetNameAtCoord");
				var ref_streetName = _streetName;
				var ref_crossingRoad = _crossingRoad;
				fn__getStreetNameAtCoord(_x, _y, _z, &ref_streetName, &ref_crossingRoad);
				_streetName = ref_streetName;
				_crossingRoad = ref_crossingRoad;
			}
		}

		public int GenerateDirectionsToCoord(float _x, float _y, float _z, bool _p3, ref int _direction, ref float _p5, ref float _distToNxJunction)
		{
			unsafe {
				if (fn__generateDirectionsToCoord == null) fn__generateDirectionsToCoord = (delegate* unmanaged[Cdecl]<float, float, float, bool, int*, float*, float*, int>) NativeLibrary.GetExport(handle, "Native_generateDirectionsToCoord");
				var ref_direction = _direction;
				var ref_p5 = _p5;
				var ref_distToNxJunction = _distToNxJunction;
				var result = fn__generateDirectionsToCoord(_x, _y, _z, _p3, &ref_direction, &ref_p5, &ref_distToNxJunction);
				_direction = ref_direction;
				_p5 = ref_p5;
				_distToNxJunction = ref_distToNxJunction;
				return result;
			}
		}

		public void SetIgnoreNoGpsFlag(bool _toggle)
		{
			unsafe {
				if (fn__setIgnoreNoGpsFlag == null) fn__setIgnoreNoGpsFlag = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setIgnoreNoGpsFlag");
				fn__setIgnoreNoGpsFlag(_toggle);
			}
		}

		public void SetIgnoreSecondaryRouteNodes(bool _toggle)
		{
			unsafe {
				if (fn__setIgnoreSecondaryRouteNodes == null) fn__setIgnoreSecondaryRouteNodes = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setIgnoreSecondaryRouteNodes");
				fn__setIgnoreSecondaryRouteNodes(_toggle);
			}
		}

		public void SetGpsDisabledZone(float _x1, float _y1, float _z1, float _x2, float _y2, float _z3)
		{
			unsafe {
				if (fn__setGpsDisabledZone == null) fn__setGpsDisabledZone = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setGpsDisabledZone");
				fn__setGpsDisabledZone(_x1, _y1, _z1, _x2, _y2, _z3);
			}
		}

		public int GetGpsBlipRouteLength()
		{
			unsafe {
				if (fn__getGpsBlipRouteLength == null) fn__getGpsBlipRouteLength = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getGpsBlipRouteLength");
				var result = fn__getGpsBlipRouteLength();
				return result;
			}
		}

		public int _0xF3162836C28F9DA5(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xF3162836C28F9DA5 == null) fn__0xF3162836C28F9DA5 = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0xF3162836C28F9DA5");
				var result = fn__0xF3162836C28F9DA5(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public bool GetGpsBlipRouteFound()
		{
			unsafe {
				if (fn__getGpsBlipRouteFound == null) fn__getGpsBlipRouteFound = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getGpsBlipRouteFound");
				var result = fn__getGpsBlipRouteFound();
				return result;
			}
		}

		public bool GetRoadSidePointWithHeading(float _x, float _y, float _z, float _heading, ref Vector3 _outPosition)
		{
			unsafe {
				if (fn__getRoadSidePointWithHeading == null) fn__getRoadSidePointWithHeading = (delegate* unmanaged[Cdecl]<float, float, float, float, Vector3*, bool>) NativeLibrary.GetExport(handle, "Native_getRoadSidePointWithHeading");
				var ref_outPosition = _outPosition;
				var result = fn__getRoadSidePointWithHeading(_x, _y, _z, _heading, &ref_outPosition);
				_outPosition = ref_outPosition;
				return result;
			}
		}

		public bool GetPointOnRoadSide(float _x, float _y, float _z, int _p3, ref Vector3 _outPosition)
		{
			unsafe {
				if (fn__getPointOnRoadSide == null) fn__getPointOnRoadSide = (delegate* unmanaged[Cdecl]<float, float, float, int, Vector3*, bool>) NativeLibrary.GetExport(handle, "Native_getPointOnRoadSide");
				var ref_outPosition = _outPosition;
				var result = fn__getPointOnRoadSide(_x, _y, _z, _p3, &ref_outPosition);
				_outPosition = ref_outPosition;
				return result;
			}
		}

		public bool IsPointOnRoad(float _x, float _y, float _z, int _vehicle)
		{
			unsafe {
				if (fn__isPointOnRoad == null) fn__isPointOnRoad = (delegate* unmanaged[Cdecl]<float, float, float, int, bool>) NativeLibrary.GetExport(handle, "Native_isPointOnRoad");
				var result = fn__isPointOnRoad(_x, _y, _z, _vehicle);
				return result;
			}
		}

		public int GetNextGpsDisabledZoneIndex()
		{
			unsafe {
				if (fn__getNextGpsDisabledZoneIndex == null) fn__getNextGpsDisabledZoneIndex = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNextGpsDisabledZoneIndex");
				var result = fn__getNextGpsDisabledZoneIndex();
				return result;
			}
		}

		public void SetGpsDisabledZoneAtIndex(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _index)
		{
			unsafe {
				if (fn__setGpsDisabledZoneAtIndex == null) fn__setGpsDisabledZoneAtIndex = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setGpsDisabledZoneAtIndex");
				fn__setGpsDisabledZoneAtIndex(_x1, _y1, _z1, _x2, _y2, _z2, _index);
			}
		}

		public void ClearGpsDisabledZoneAtIndex(int _index)
		{
			unsafe {
				if (fn__clearGpsDisabledZoneAtIndex == null) fn__clearGpsDisabledZoneAtIndex = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearGpsDisabledZoneAtIndex");
				fn__clearGpsDisabledZoneAtIndex(_index);
			}
		}

		public void AddNavmeshRequiredRegion(float _x, float _y, float _radius)
		{
			unsafe {
				if (fn__addNavmeshRequiredRegion == null) fn__addNavmeshRequiredRegion = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_addNavmeshRequiredRegion");
				fn__addNavmeshRequiredRegion(_x, _y, _radius);
			}
		}

		public void RemoveNavmeshRequiredRegions()
		{
			unsafe {
				if (fn__removeNavmeshRequiredRegions == null) fn__removeNavmeshRequiredRegions = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeNavmeshRequiredRegions");
				fn__removeNavmeshRequiredRegions();
			}
		}

		public bool IsNavmeshRequiredRegionOwnedByAnyThread()
		{
			unsafe {
				if (fn__isNavmeshRequiredRegionOwnedByAnyThread == null) fn__isNavmeshRequiredRegionOwnedByAnyThread = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isNavmeshRequiredRegionOwnedByAnyThread");
				var result = fn__isNavmeshRequiredRegionOwnedByAnyThread();
				return result;
			}
		}

		public void DisableNavmeshInArea(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__disableNavmeshInArea == null) fn__disableNavmeshInArea = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_disableNavmeshInArea");
				fn__disableNavmeshInArea(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public bool AreAllNavmeshRegionsLoaded()
		{
			unsafe {
				if (fn__areAllNavmeshRegionsLoaded == null) fn__areAllNavmeshRegionsLoaded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_areAllNavmeshRegionsLoaded");
				var result = fn__areAllNavmeshRegionsLoaded();
				return result;
			}
		}

		public bool IsNavmeshLoadedInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__isNavmeshLoadedInArea == null) fn__isNavmeshLoadedInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isNavmeshLoadedInArea");
				var result = fn__isNavmeshLoadedInArea(_x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public int _0x01708E8DD3FF8C65(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5)
		{
			unsafe {
				if (fn__0x01708E8DD3FF8C65 == null) fn__0x01708E8DD3FF8C65 = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native__0x01708E8DD3FF8C65");
				var result = fn__0x01708E8DD3FF8C65(_p0, _p1, _p2, _p3, _p4, _p5);
				return result;
			}
		}

		public int AddNavmeshBlockingObject(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, bool _p7, int _p8)
		{
			unsafe {
				if (fn__addNavmeshBlockingObject == null) fn__addNavmeshBlockingObject = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, bool, int, int>) NativeLibrary.GetExport(handle, "Native_addNavmeshBlockingObject");
				var result = fn__addNavmeshBlockingObject(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
				return result;
			}
		}

		public void UpdateNavmeshBlockingObject(int _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, int _p8)
		{
			unsafe {
				if (fn__updateNavmeshBlockingObject == null) fn__updateNavmeshBlockingObject = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_updateNavmeshBlockingObject");
				fn__updateNavmeshBlockingObject(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
			}
		}

		public void RemoveNavmeshBlockingObject(int _p0)
		{
			unsafe {
				if (fn__removeNavmeshBlockingObject == null) fn__removeNavmeshBlockingObject = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeNavmeshBlockingObject");
				fn__removeNavmeshBlockingObject(_p0);
			}
		}

		public bool DoesNavmeshBlockingObjectExist(int _p0)
		{
			unsafe {
				if (fn__doesNavmeshBlockingObjectExist == null) fn__doesNavmeshBlockingObjectExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesNavmeshBlockingObjectExist");
				var result = fn__doesNavmeshBlockingObjectExist(_p0);
				return result;
			}
		}

		public float GetHeightmapTopZForPosition(float _x, float _y)
		{
			unsafe {
				if (fn__getHeightmapTopZForPosition == null) fn__getHeightmapTopZForPosition = (delegate* unmanaged[Cdecl]<float, float, float>) NativeLibrary.GetExport(handle, "Native_getHeightmapTopZForPosition");
				var result = fn__getHeightmapTopZForPosition(_x, _y);
				return result;
			}
		}

		public float GetHeightmapTopZForArea(float _x1, float _y1, float _x2, float _y2)
		{
			unsafe {
				if (fn__getHeightmapTopZForArea == null) fn__getHeightmapTopZForArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float>) NativeLibrary.GetExport(handle, "Native_getHeightmapTopZForArea");
				var result = fn__getHeightmapTopZForArea(_x1, _y1, _x2, _y2);
				return result;
			}
		}

		public float GetHeightmapBottomZForPosition(float _x, float _y)
		{
			unsafe {
				if (fn__getHeightmapBottomZForPosition == null) fn__getHeightmapBottomZForPosition = (delegate* unmanaged[Cdecl]<float, float, float>) NativeLibrary.GetExport(handle, "Native_getHeightmapBottomZForPosition");
				var result = fn__getHeightmapBottomZForPosition(_x, _y);
				return result;
			}
		}

		public float GetHeightmapBottomZForArea(float _x1, float _y1, float _x2, float _y2)
		{
			unsafe {
				if (fn__getHeightmapBottomZForArea == null) fn__getHeightmapBottomZForArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float>) NativeLibrary.GetExport(handle, "Native_getHeightmapBottomZForArea");
				var result = fn__getHeightmapBottomZForArea(_x1, _y1, _x2, _y2);
				return result;
			}
		}

		public float CalculateTravelDistanceBetweenPoints(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__calculateTravelDistanceBetweenPoints == null) fn__calculateTravelDistanceBetweenPoints = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float>) NativeLibrary.GetExport(handle, "Native_calculateTravelDistanceBetweenPoints");
				var result = fn__calculateTravelDistanceBetweenPoints(_x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public int CreatePed(int _pedType, int _modelHash, float _x, float _y, float _z, float _heading, bool _isNetwork, bool _bScriptHostPed)
		{
			unsafe {
				if (fn__createPed == null) fn__createPed = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_createPed");
				var result = fn__createPed(_pedType, _modelHash, _x, _y, _z, _heading, _isNetwork, _bScriptHostPed);
				return result;
			}
		}

		public void DeletePed(ref int _ped)
		{
			unsafe {
				if (fn__deletePed == null) fn__deletePed = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_deletePed");
				var ref_ped = _ped;
				fn__deletePed(&ref_ped);
				_ped = ref_ped;
			}
		}

		public int ClonePed(int _ped, bool _isNetwork, bool _bScriptHostPed, bool _copyHeadBlendFlag)
		{
			unsafe {
				if (fn__clonePed == null) fn__clonePed = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_clonePed");
				var result = fn__clonePed(_ped, _isNetwork, _bScriptHostPed, _copyHeadBlendFlag);
				return result;
			}
		}

		public int ClonePedEx(int _ped, bool _isNetwork, bool _bScriptHostPed, bool _copyHeadBlendFlag, bool _p4)
		{
			unsafe {
				if (fn__clonePedEx == null) fn__clonePedEx = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_clonePedEx");
				var result = fn__clonePedEx(_ped, _isNetwork, _bScriptHostPed, _copyHeadBlendFlag, _p4);
				return result;
			}
		}

		public void ClonePedToTarget(int _ped, int _targetPed)
		{
			unsafe {
				if (fn__clonePedToTarget == null) fn__clonePedToTarget = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_clonePedToTarget");
				fn__clonePedToTarget(_ped, _targetPed);
			}
		}

		public void ClonePedToTargetEx(int _ped, int _targetPed, bool _p2)
		{
			unsafe {
				if (fn__clonePedToTargetEx == null) fn__clonePedToTargetEx = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_clonePedToTargetEx");
				fn__clonePedToTargetEx(_ped, _targetPed, _p2);
			}
		}

		public bool IsPedInVehicle(int _ped, int _vehicle, bool _atGetIn)
		{
			unsafe {
				if (fn__isPedInVehicle == null) fn__isPedInVehicle = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isPedInVehicle");
				var result = fn__isPedInVehicle(_ped, _vehicle, _atGetIn);
				return result;
			}
		}

		public bool IsPedInModel(int _ped, int _modelHash)
		{
			unsafe {
				if (fn__isPedInModel == null) fn__isPedInModel = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInModel");
				var result = fn__isPedInModel(_ped, _modelHash);
				return result;
			}
		}

		public bool IsPedInAnyVehicle(int _ped, bool _atGetIn)
		{
			unsafe {
				if (fn__isPedInAnyVehicle == null) fn__isPedInAnyVehicle = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isPedInAnyVehicle");
				var result = fn__isPedInAnyVehicle(_ped, _atGetIn);
				return result;
			}
		}

		public bool IsCopPedInArea3d(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__isCopPedInArea3d == null) fn__isCopPedInArea3d = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isCopPedInArea3d");
				var result = fn__isCopPedInArea3d(_x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public bool IsPedInjured(int _ped)
		{
			unsafe {
				if (fn__isPedInjured == null) fn__isPedInjured = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInjured");
				var result = fn__isPedInjured(_ped);
				return result;
			}
		}

		public bool IsPedHurt(int _ped)
		{
			unsafe {
				if (fn__isPedHurt == null) fn__isPedHurt = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedHurt");
				var result = fn__isPedHurt(_ped);
				return result;
			}
		}

		public bool IsPedFatallyInjured(int _ped)
		{
			unsafe {
				if (fn__isPedFatallyInjured == null) fn__isPedFatallyInjured = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedFatallyInjured");
				var result = fn__isPedFatallyInjured(_ped);
				return result;
			}
		}

		public bool IsPedDeadOrDying(int _ped, bool _p1)
		{
			unsafe {
				if (fn__isPedDeadOrDying == null) fn__isPedDeadOrDying = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isPedDeadOrDying");
				var result = fn__isPedDeadOrDying(_ped, _p1);
				return result;
			}
		}

		public bool IsConversationPedDead(int _ped)
		{
			unsafe {
				if (fn__isConversationPedDead == null) fn__isConversationPedDead = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isConversationPedDead");
				var result = fn__isConversationPedDead(_ped);
				return result;
			}
		}

		public bool IsPedAimingFromCover(int _ped)
		{
			unsafe {
				if (fn__isPedAimingFromCover == null) fn__isPedAimingFromCover = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedAimingFromCover");
				var result = fn__isPedAimingFromCover(_ped);
				return result;
			}
		}

		public bool IsPedReloading(int _ped)
		{
			unsafe {
				if (fn__isPedReloading == null) fn__isPedReloading = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedReloading");
				var result = fn__isPedReloading(_ped);
				return result;
			}
		}

		public bool IsPedAPlayer(int _ped)
		{
			unsafe {
				if (fn__isPedAPlayer == null) fn__isPedAPlayer = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedAPlayer");
				var result = fn__isPedAPlayer(_ped);
				return result;
			}
		}

		public int CreatePedInsideVehicle(int _vehicle, int _pedType, int _modelHash, int _seat, bool _isNetwork, bool _bScriptHostPed)
		{
			unsafe {
				if (fn__createPedInsideVehicle == null) fn__createPedInsideVehicle = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_createPedInsideVehicle");
				var result = fn__createPedInsideVehicle(_vehicle, _pedType, _modelHash, _seat, _isNetwork, _bScriptHostPed);
				return result;
			}
		}

		public void SetPedDesiredHeading(int _ped, float _heading)
		{
			unsafe {
				if (fn__setPedDesiredHeading == null) fn__setPedDesiredHeading = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedDesiredHeading");
				fn__setPedDesiredHeading(_ped, _heading);
			}
		}

		public void FreezePedCameraRotation(int _ped)
		{
			unsafe {
				if (fn__freezePedCameraRotation == null) fn__freezePedCameraRotation = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_freezePedCameraRotation");
				fn__freezePedCameraRotation(_ped);
			}
		}

		public bool IsPedFacingPed(int _ped, int _otherPed, float _angle)
		{
			unsafe {
				if (fn__isPedFacingPed == null) fn__isPedFacingPed = (delegate* unmanaged[Cdecl]<int, int, float, bool>) NativeLibrary.GetExport(handle, "Native_isPedFacingPed");
				var result = fn__isPedFacingPed(_ped, _otherPed, _angle);
				return result;
			}
		}

		public bool IsPedInMeleeCombat(int _ped)
		{
			unsafe {
				if (fn__isPedInMeleeCombat == null) fn__isPedInMeleeCombat = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInMeleeCombat");
				var result = fn__isPedInMeleeCombat(_ped);
				return result;
			}
		}

		public bool IsPedStopped(int _ped)
		{
			unsafe {
				if (fn__isPedStopped == null) fn__isPedStopped = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedStopped");
				var result = fn__isPedStopped(_ped);
				return result;
			}
		}

		public bool IsPedShootingInArea(int _ped, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _p7, bool _p8)
		{
			unsafe {
				if (fn__isPedShootingInArea == null) fn__isPedShootingInArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_isPedShootingInArea");
				var result = fn__isPedShootingInArea(_ped, _x1, _y1, _z1, _x2, _y2, _z2, _p7, _p8);
				return result;
			}
		}

		public bool IsAnyPedShootingInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _p6, bool _p7)
		{
			unsafe {
				if (fn__isAnyPedShootingInArea == null) fn__isAnyPedShootingInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_isAnyPedShootingInArea");
				var result = fn__isAnyPedShootingInArea(_x1, _y1, _z1, _x2, _y2, _z2, _p6, _p7);
				return result;
			}
		}

		public bool IsPedShooting(int _ped)
		{
			unsafe {
				if (fn__isPedShooting == null) fn__isPedShooting = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedShooting");
				var result = fn__isPedShooting(_ped);
				return result;
			}
		}

		public void SetPedAccuracy(int _ped, int _accuracy)
		{
			unsafe {
				if (fn__setPedAccuracy == null) fn__setPedAccuracy = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedAccuracy");
				fn__setPedAccuracy(_ped, _accuracy);
			}
		}

		public int GetPedAccuracy(int _ped)
		{
			unsafe {
				if (fn__getPedAccuracy == null) fn__getPedAccuracy = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedAccuracy");
				var result = fn__getPedAccuracy(_ped);
				return result;
			}
		}

		public void _0x87DDEB611B329A9C(float _multiplier)
		{
			unsafe {
				if (fn__0x87DDEB611B329A9C == null) fn__0x87DDEB611B329A9C = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x87DDEB611B329A9C");
				fn__0x87DDEB611B329A9C(_multiplier);
			}
		}

		public bool IsPedModel(int _ped, int _modelHash)
		{
			unsafe {
				if (fn__isPedModel == null) fn__isPedModel = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedModel");
				var result = fn__isPedModel(_ped, _modelHash);
				return result;
			}
		}

		public void ExplodePedHead(int _ped, int _weaponHash)
		{
			unsafe {
				if (fn__explodePedHead == null) fn__explodePedHead = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_explodePedHead");
				fn__explodePedHead(_ped, _weaponHash);
			}
		}

		public void RemovePedElegantly(ref int _ped)
		{
			unsafe {
				if (fn__removePedElegantly == null) fn__removePedElegantly = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_removePedElegantly");
				var ref_ped = _ped;
				fn__removePedElegantly(&ref_ped);
				_ped = ref_ped;
			}
		}

		public void AddArmourToPed(int _ped, int _amount)
		{
			unsafe {
				if (fn__addArmourToPed == null) fn__addArmourToPed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_addArmourToPed");
				fn__addArmourToPed(_ped, _amount);
			}
		}

		public void SetPedArmour(int _ped, int _amount)
		{
			unsafe {
				if (fn__setPedArmour == null) fn__setPedArmour = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedArmour");
				fn__setPedArmour(_ped, _amount);
			}
		}

		public void SetPedIntoVehicle(int _ped, int _vehicle, int _seatIndex)
		{
			unsafe {
				if (fn__setPedIntoVehicle == null) fn__setPedIntoVehicle = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedIntoVehicle");
				fn__setPedIntoVehicle(_ped, _vehicle, _seatIndex);
			}
		}

		public void SetPedAllowVehiclesOverride(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedAllowVehiclesOverride == null) fn__setPedAllowVehiclesOverride = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAllowVehiclesOverride");
				fn__setPedAllowVehiclesOverride(_ped, _toggle);
			}
		}

		public bool CanCreateRandomPed(bool _unk)
		{
			unsafe {
				if (fn__canCreateRandomPed == null) fn__canCreateRandomPed = (delegate* unmanaged[Cdecl]<bool, bool>) NativeLibrary.GetExport(handle, "Native_canCreateRandomPed");
				var result = fn__canCreateRandomPed(_unk);
				return result;
			}
		}

		public int CreateRandomPed(float _posX, float _posY, float _posZ)
		{
			unsafe {
				if (fn__createRandomPed == null) fn__createRandomPed = (delegate* unmanaged[Cdecl]<float, float, float, int>) NativeLibrary.GetExport(handle, "Native_createRandomPed");
				var result = fn__createRandomPed(_posX, _posY, _posZ);
				return result;
			}
		}

		public int CreateRandomPedAsDriver(int _vehicle, bool _returnHandle)
		{
			unsafe {
				if (fn__createRandomPedAsDriver == null) fn__createRandomPedAsDriver = (delegate* unmanaged[Cdecl]<int, bool, int>) NativeLibrary.GetExport(handle, "Native_createRandomPedAsDriver");
				var result = fn__createRandomPedAsDriver(_vehicle, _returnHandle);
				return result;
			}
		}

		public bool CanCreateRandomDriver()
		{
			unsafe {
				if (fn__canCreateRandomDriver == null) fn__canCreateRandomDriver = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_canCreateRandomDriver");
				var result = fn__canCreateRandomDriver();
				return result;
			}
		}

		public bool CanCreateRandomBikeRider()
		{
			unsafe {
				if (fn__canCreateRandomBikeRider == null) fn__canCreateRandomBikeRider = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_canCreateRandomBikeRider");
				var result = fn__canCreateRandomBikeRider();
				return result;
			}
		}

		public void SetPedMoveAnimsBlendOut(int _ped)
		{
			unsafe {
				if (fn__setPedMoveAnimsBlendOut == null) fn__setPedMoveAnimsBlendOut = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedMoveAnimsBlendOut");
				fn__setPedMoveAnimsBlendOut(_ped);
			}
		}

		public void SetPedCanBeDraggedOut(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanBeDraggedOut == null) fn__setPedCanBeDraggedOut = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanBeDraggedOut");
				fn__setPedCanBeDraggedOut(_ped, _toggle);
			}
		}

		public void _0xF2BEBCDFAFDAA19E(bool _toggle)
		{
			unsafe {
				if (fn__0xF2BEBCDFAFDAA19E == null) fn__0xF2BEBCDFAFDAA19E = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xF2BEBCDFAFDAA19E");
				fn__0xF2BEBCDFAFDAA19E(_toggle);
			}
		}

		public bool IsPedMale(int _ped)
		{
			unsafe {
				if (fn__isPedMale == null) fn__isPedMale = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedMale");
				var result = fn__isPedMale(_ped);
				return result;
			}
		}

		public bool IsPedHuman(int _ped)
		{
			unsafe {
				if (fn__isPedHuman == null) fn__isPedHuman = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedHuman");
				var result = fn__isPedHuman(_ped);
				return result;
			}
		}

		public int GetVehiclePedIsIn(int _ped, bool _includeLastVehicle)
		{
			unsafe {
				if (fn__getVehiclePedIsIn == null) fn__getVehiclePedIsIn = (delegate* unmanaged[Cdecl]<int, bool, int>) NativeLibrary.GetExport(handle, "Native_getVehiclePedIsIn");
				var result = fn__getVehiclePedIsIn(_ped, _includeLastVehicle);
				return result;
			}
		}

		public void ResetPedLastVehicle(int _ped)
		{
			unsafe {
				if (fn__resetPedLastVehicle == null) fn__resetPedLastVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPedLastVehicle");
				fn__resetPedLastVehicle(_ped);
			}
		}

		public void SetPedDensityMultiplierThisFrame(float _multiplier)
		{
			unsafe {
				if (fn__setPedDensityMultiplierThisFrame == null) fn__setPedDensityMultiplierThisFrame = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setPedDensityMultiplierThisFrame");
				fn__setPedDensityMultiplierThisFrame(_multiplier);
			}
		}

		public void SetScenarioPedDensityMultiplierThisFrame(float _p0, float _p1)
		{
			unsafe {
				if (fn__setScenarioPedDensityMultiplierThisFrame == null) fn__setScenarioPedDensityMultiplierThisFrame = (delegate* unmanaged[Cdecl]<float, float, void>) NativeLibrary.GetExport(handle, "Native_setScenarioPedDensityMultiplierThisFrame");
				fn__setScenarioPedDensityMultiplierThisFrame(_p0, _p1);
			}
		}

		public void _0x5A7F62FDA59759BD()
		{
			unsafe {
				if (fn__0x5A7F62FDA59759BD == null) fn__0x5A7F62FDA59759BD = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x5A7F62FDA59759BD");
				fn__0x5A7F62FDA59759BD();
			}
		}

		public void SetScriptedConversionCoordThisFrame(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setScriptedConversionCoordThisFrame == null) fn__setScriptedConversionCoordThisFrame = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setScriptedConversionCoordThisFrame");
				fn__setScriptedConversionCoordThisFrame(_x, _y, _z);
			}
		}

		public void SetPedNonCreationArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__setPedNonCreationArea == null) fn__setPedNonCreationArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setPedNonCreationArea");
				fn__setPedNonCreationArea(_x1, _y1, _z1, _x2, _y2, _z2);
			}
		}

		public void ClearPedNonCreationArea()
		{
			unsafe {
				if (fn__clearPedNonCreationArea == null) fn__clearPedNonCreationArea = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearPedNonCreationArea");
				fn__clearPedNonCreationArea();
			}
		}

		public void InstantlyFillPedPopulation()
		{
			unsafe {
				if (fn__instantlyFillPedPopulation == null) fn__instantlyFillPedPopulation = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_instantlyFillPedPopulation");
				fn__instantlyFillPedPopulation();
			}
		}

		public bool IsPedOnMount(int _ped)
		{
			unsafe {
				if (fn__isPedOnMount == null) fn__isPedOnMount = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedOnMount");
				var result = fn__isPedOnMount(_ped);
				return result;
			}
		}

		public int GetMount(int _ped)
		{
			unsafe {
				if (fn__getMount == null) fn__getMount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getMount");
				var result = fn__getMount(_ped);
				return result;
			}
		}

		public bool IsPedOnVehicle(int _ped)
		{
			unsafe {
				if (fn__isPedOnVehicle == null) fn__isPedOnVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedOnVehicle");
				var result = fn__isPedOnVehicle(_ped);
				return result;
			}
		}

		public bool IsPedOnSpecificVehicle(int _ped, int _vehicle)
		{
			unsafe {
				if (fn__isPedOnSpecificVehicle == null) fn__isPedOnSpecificVehicle = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedOnSpecificVehicle");
				var result = fn__isPedOnSpecificVehicle(_ped, _vehicle);
				return result;
			}
		}

		public void SetPedMoney(int _ped, int _amount)
		{
			unsafe {
				if (fn__setPedMoney == null) fn__setPedMoney = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedMoney");
				fn__setPedMoney(_ped, _amount);
			}
		}

		public int GetPedMoney(int _ped)
		{
			unsafe {
				if (fn__getPedMoney == null) fn__getPedMoney = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedMoney");
				var result = fn__getPedMoney(_ped);
				return result;
			}
		}

		public void _0xFF4803BC019852D9(float _p0, int _p1)
		{
			unsafe {
				if (fn__0xFF4803BC019852D9 == null) fn__0xFF4803BC019852D9 = (delegate* unmanaged[Cdecl]<float, int, void>) NativeLibrary.GetExport(handle, "Native__0xFF4803BC019852D9");
				fn__0xFF4803BC019852D9(_p0, _p1);
			}
		}

		public void SetAmbientPedsDropMoney(bool _p0)
		{
			unsafe {
				if (fn__setAmbientPedsDropMoney == null) fn__setAmbientPedsDropMoney = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setAmbientPedsDropMoney");
				fn__setAmbientPedsDropMoney(_p0);
			}
		}

		public void _0x9911F4A24485F653(bool _p0)
		{
			unsafe {
				if (fn__0x9911F4A24485F653 == null) fn__0x9911F4A24485F653 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x9911F4A24485F653");
				fn__0x9911F4A24485F653(_p0);
			}
		}

		public void SetPedSuffersCriticalHits(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedSuffersCriticalHits == null) fn__setPedSuffersCriticalHits = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedSuffersCriticalHits");
				fn__setPedSuffersCriticalHits(_ped, _toggle);
			}
		}

		public void _0xAFC976FD0580C7B3(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__0xAFC976FD0580C7B3 == null) fn__0xAFC976FD0580C7B3 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xAFC976FD0580C7B3");
				fn__0xAFC976FD0580C7B3(_ped, _toggle);
			}
		}

		public bool IsPedSittingInVehicle(int _ped, int _vehicle)
		{
			unsafe {
				if (fn__isPedSittingInVehicle == null) fn__isPedSittingInVehicle = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedSittingInVehicle");
				var result = fn__isPedSittingInVehicle(_ped, _vehicle);
				return result;
			}
		}

		public bool IsPedSittingInAnyVehicle(int _ped)
		{
			unsafe {
				if (fn__isPedSittingInAnyVehicle == null) fn__isPedSittingInAnyVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedSittingInAnyVehicle");
				var result = fn__isPedSittingInAnyVehicle(_ped);
				return result;
			}
		}

		public bool IsPedOnFoot(int _ped)
		{
			unsafe {
				if (fn__isPedOnFoot == null) fn__isPedOnFoot = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedOnFoot");
				var result = fn__isPedOnFoot(_ped);
				return result;
			}
		}

		public bool IsPedOnAnyBike(int _ped)
		{
			unsafe {
				if (fn__isPedOnAnyBike == null) fn__isPedOnAnyBike = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedOnAnyBike");
				var result = fn__isPedOnAnyBike(_ped);
				return result;
			}
		}

		public bool IsPedPlantingBomb(int _ped)
		{
			unsafe {
				if (fn__isPedPlantingBomb == null) fn__isPedPlantingBomb = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedPlantingBomb");
				var result = fn__isPedPlantingBomb(_ped);
				return result;
			}
		}

		public Vector3 GetDeadPedPickupCoords(int _ped, float _p1, float _p2)
		{
			unsafe {
				if (fn__getDeadPedPickupCoords == null) fn__getDeadPedPickupCoords = (delegate* unmanaged[Cdecl]<int, float, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getDeadPedPickupCoords");
				var result = fn__getDeadPedPickupCoords(_ped, _p1, _p2);
				return result;
			}
		}

		public bool IsPedInAnyBoat(int _ped)
		{
			unsafe {
				if (fn__isPedInAnyBoat == null) fn__isPedInAnyBoat = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInAnyBoat");
				var result = fn__isPedInAnyBoat(_ped);
				return result;
			}
		}

		public bool IsPedInAnySub(int _ped)
		{
			unsafe {
				if (fn__isPedInAnySub == null) fn__isPedInAnySub = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInAnySub");
				var result = fn__isPedInAnySub(_ped);
				return result;
			}
		}

		public bool IsPedInAnyHeli(int _ped)
		{
			unsafe {
				if (fn__isPedInAnyHeli == null) fn__isPedInAnyHeli = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInAnyHeli");
				var result = fn__isPedInAnyHeli(_ped);
				return result;
			}
		}

		public bool IsPedInAnyPlane(int _ped)
		{
			unsafe {
				if (fn__isPedInAnyPlane == null) fn__isPedInAnyPlane = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInAnyPlane");
				var result = fn__isPedInAnyPlane(_ped);
				return result;
			}
		}

		public bool IsPedInFlyingVehicle(int _ped)
		{
			unsafe {
				if (fn__isPedInFlyingVehicle == null) fn__isPedInFlyingVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInFlyingVehicle");
				var result = fn__isPedInFlyingVehicle(_ped);
				return result;
			}
		}

		public void SetPedDiesInWater(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedDiesInWater == null) fn__setPedDiesInWater = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDiesInWater");
				fn__setPedDiesInWater(_ped, _toggle);
			}
		}

		public void SetPedDiesInSinkingVehicle(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedDiesInSinkingVehicle == null) fn__setPedDiesInSinkingVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDiesInSinkingVehicle");
				fn__setPedDiesInSinkingVehicle(_ped, _toggle);
			}
		}

		public int GetPedArmour(int _ped)
		{
			unsafe {
				if (fn__getPedArmour == null) fn__getPedArmour = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedArmour");
				var result = fn__getPedArmour(_ped);
				return result;
			}
		}

		public void SetPedStayInVehicleWhenJacked(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedStayInVehicleWhenJacked == null) fn__setPedStayInVehicleWhenJacked = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedStayInVehicleWhenJacked");
				fn__setPedStayInVehicleWhenJacked(_ped, _toggle);
			}
		}

		public void SetPedCanBeShotInVehicle(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanBeShotInVehicle == null) fn__setPedCanBeShotInVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanBeShotInVehicle");
				fn__setPedCanBeShotInVehicle(_ped, _toggle);
			}
		}

		public bool GetPedLastDamageBone(int _ped, ref int _outBone)
		{
			unsafe {
				if (fn__getPedLastDamageBone == null) fn__getPedLastDamageBone = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getPedLastDamageBone");
				var ref_outBone = _outBone;
				var result = fn__getPedLastDamageBone(_ped, &ref_outBone);
				_outBone = ref_outBone;
				return result;
			}
		}

		public void ClearPedLastDamageBone(int _ped)
		{
			unsafe {
				if (fn__clearPedLastDamageBone == null) fn__clearPedLastDamageBone = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedLastDamageBone");
				fn__clearPedLastDamageBone(_ped);
			}
		}

		public void SetAiWeaponDamageModifier(float _value)
		{
			unsafe {
				if (fn__setAiWeaponDamageModifier == null) fn__setAiWeaponDamageModifier = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setAiWeaponDamageModifier");
				fn__setAiWeaponDamageModifier(_value);
			}
		}

		public void ResetAiWeaponDamageModifier()
		{
			unsafe {
				if (fn__resetAiWeaponDamageModifier == null) fn__resetAiWeaponDamageModifier = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetAiWeaponDamageModifier");
				fn__resetAiWeaponDamageModifier();
			}
		}

		public void SetAiMeleeWeaponDamageModifier(float _modifier)
		{
			unsafe {
				if (fn__setAiMeleeWeaponDamageModifier == null) fn__setAiMeleeWeaponDamageModifier = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setAiMeleeWeaponDamageModifier");
				fn__setAiMeleeWeaponDamageModifier(_modifier);
			}
		}

		public void ResetAiMeleeWeaponDamageModifier()
		{
			unsafe {
				if (fn__resetAiMeleeWeaponDamageModifier == null) fn__resetAiMeleeWeaponDamageModifier = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetAiMeleeWeaponDamageModifier");
				fn__resetAiMeleeWeaponDamageModifier();
			}
		}

		public void _0x2F3C3D9F50681DE4(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0x2F3C3D9F50681DE4 == null) fn__0x2F3C3D9F50681DE4 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x2F3C3D9F50681DE4");
				fn__0x2F3C3D9F50681DE4(_p0, _p1);
			}
		}

		public void SetPedCanBeTargetted(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanBeTargetted == null) fn__setPedCanBeTargetted = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanBeTargetted");
				fn__setPedCanBeTargetted(_ped, _toggle);
			}
		}

		public void SetPedCanBeTargettedByTeam(int _ped, int _team, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanBeTargettedByTeam == null) fn__setPedCanBeTargettedByTeam = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanBeTargettedByTeam");
				fn__setPedCanBeTargettedByTeam(_ped, _team, _toggle);
			}
		}

		public void SetPedCanBeTargettedByPlayer(int _ped, int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanBeTargettedByPlayer == null) fn__setPedCanBeTargettedByPlayer = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanBeTargettedByPlayer");
				fn__setPedCanBeTargettedByPlayer(_ped, _player, _toggle);
			}
		}

		public void _0x061CB768363D6424(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__0x061CB768363D6424 == null) fn__0x061CB768363D6424 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x061CB768363D6424");
				fn__0x061CB768363D6424(_ped, _toggle);
			}
		}

		public void _0xFD325494792302D7(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__0xFD325494792302D7 == null) fn__0xFD325494792302D7 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xFD325494792302D7");
				fn__0xFD325494792302D7(_ped, _toggle);
			}
		}

		public bool IsPedInAnyPoliceVehicle(int _ped)
		{
			unsafe {
				if (fn__isPedInAnyPoliceVehicle == null) fn__isPedInAnyPoliceVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInAnyPoliceVehicle");
				var result = fn__isPedInAnyPoliceVehicle(_ped);
				return result;
			}
		}

		public void ForcePedToOpenParachute(int _ped)
		{
			unsafe {
				if (fn__forcePedToOpenParachute == null) fn__forcePedToOpenParachute = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_forcePedToOpenParachute");
				fn__forcePedToOpenParachute(_ped);
			}
		}

		public bool IsPedInParachuteFreeFall(int _ped)
		{
			unsafe {
				if (fn__isPedInParachuteFreeFall == null) fn__isPedInParachuteFreeFall = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInParachuteFreeFall");
				var result = fn__isPedInParachuteFreeFall(_ped);
				return result;
			}
		}

		public bool IsPedFalling(int _ped)
		{
			unsafe {
				if (fn__isPedFalling == null) fn__isPedFalling = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedFalling");
				var result = fn__isPedFalling(_ped);
				return result;
			}
		}

		public bool IsPedJumping(int _ped)
		{
			unsafe {
				if (fn__isPedJumping == null) fn__isPedJumping = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedJumping");
				var result = fn__isPedJumping(_ped);
				return result;
			}
		}

		public int _0x412F1364FA066CFB(int _p0)
		{
			unsafe {
				if (fn__0x412F1364FA066CFB == null) fn__0x412F1364FA066CFB = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x412F1364FA066CFB");
				var result = fn__0x412F1364FA066CFB(_p0);
				return result;
			}
		}

		public int _0x451D05012CCEC234(int _p0)
		{
			unsafe {
				if (fn__0x451D05012CCEC234 == null) fn__0x451D05012CCEC234 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x451D05012CCEC234");
				var result = fn__0x451D05012CCEC234(_p0);
				return result;
			}
		}

		public bool IsPedClimbing(int _ped)
		{
			unsafe {
				if (fn__isPedClimbing == null) fn__isPedClimbing = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedClimbing");
				var result = fn__isPedClimbing(_ped);
				return result;
			}
		}

		public bool IsPedVaulting(int _ped)
		{
			unsafe {
				if (fn__isPedVaulting == null) fn__isPedVaulting = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedVaulting");
				var result = fn__isPedVaulting(_ped);
				return result;
			}
		}

		public bool IsPedDiving(int _ped)
		{
			unsafe {
				if (fn__isPedDiving == null) fn__isPedDiving = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedDiving");
				var result = fn__isPedDiving(_ped);
				return result;
			}
		}

		public bool IsPedJumpingOutOfVehicle(int _ped)
		{
			unsafe {
				if (fn__isPedJumpingOutOfVehicle == null) fn__isPedJumpingOutOfVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedJumpingOutOfVehicle");
				var result = fn__isPedJumpingOutOfVehicle(_ped);
				return result;
			}
		}

		public bool IsPedOpeningADoor(int _ped)
		{
			unsafe {
				if (fn__isPedOpeningADoor == null) fn__isPedOpeningADoor = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedOpeningADoor");
				var result = fn__isPedOpeningADoor(_ped);
				return result;
			}
		}

		public int GetPedParachuteState(int _ped)
		{
			unsafe {
				if (fn__getPedParachuteState == null) fn__getPedParachuteState = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedParachuteState");
				var result = fn__getPedParachuteState(_ped);
				return result;
			}
		}

		public int GetPedParachuteLandingType(int _ped)
		{
			unsafe {
				if (fn__getPedParachuteLandingType == null) fn__getPedParachuteLandingType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedParachuteLandingType");
				var result = fn__getPedParachuteLandingType(_ped);
				return result;
			}
		}

		public void SetPedParachuteTintIndex(int _ped, int _tintIndex)
		{
			unsafe {
				if (fn__setPedParachuteTintIndex == null) fn__setPedParachuteTintIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedParachuteTintIndex");
				fn__setPedParachuteTintIndex(_ped, _tintIndex);
			}
		}

		public void GetPedParachuteTintIndex(int _ped, ref int _outTintIndex)
		{
			unsafe {
				if (fn__getPedParachuteTintIndex == null) fn__getPedParachuteTintIndex = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getPedParachuteTintIndex");
				var ref_outTintIndex = _outTintIndex;
				fn__getPedParachuteTintIndex(_ped, &ref_outTintIndex);
				_outTintIndex = ref_outTintIndex;
			}
		}

		public void SetPedReserveParachuteTintIndex(int _ped, int _p1)
		{
			unsafe {
				if (fn__setPedReserveParachuteTintIndex == null) fn__setPedReserveParachuteTintIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedReserveParachuteTintIndex");
				fn__setPedReserveParachuteTintIndex(_ped, _p1);
			}
		}

		public int CreateParachuteBagObject(int _ped, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__createParachuteBagObject == null) fn__createParachuteBagObject = (delegate* unmanaged[Cdecl]<int, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_createParachuteBagObject");
				var result = fn__createParachuteBagObject(_ped, _p1, _p2);
				return result;
			}
		}

		public void SetPedDucking(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedDucking == null) fn__setPedDucking = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDucking");
				fn__setPedDucking(_ped, _toggle);
			}
		}

		public bool IsPedDucking(int _ped)
		{
			unsafe {
				if (fn__isPedDucking == null) fn__isPedDucking = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedDucking");
				var result = fn__isPedDucking(_ped);
				return result;
			}
		}

		public bool IsPedInAnyTaxi(int _ped)
		{
			unsafe {
				if (fn__isPedInAnyTaxi == null) fn__isPedInAnyTaxi = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInAnyTaxi");
				var result = fn__isPedInAnyTaxi(_ped);
				return result;
			}
		}

		public void SetPedIdRange(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedIdRange == null) fn__setPedIdRange = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedIdRange");
				fn__setPedIdRange(_ped, _value);
			}
		}

		public void SetPedHighlyPerceptive(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedHighlyPerceptive == null) fn__setPedHighlyPerceptive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedHighlyPerceptive");
				fn__setPedHighlyPerceptive(_ped, _toggle);
			}
		}

		public void _0x2F074C904D85129E(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__0x2F074C904D85129E == null) fn__0x2F074C904D85129E = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2F074C904D85129E");
				fn__0x2F074C904D85129E(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void _0xEC4B4B3B9908052A(int _ped, float _unk)
		{
			unsafe {
				if (fn__0xEC4B4B3B9908052A == null) fn__0xEC4B4B3B9908052A = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0xEC4B4B3B9908052A");
				fn__0xEC4B4B3B9908052A(_ped, _unk);
			}
		}

		public void _0x733C87D4CE22BEA2(int _p0)
		{
			unsafe {
				if (fn__0x733C87D4CE22BEA2 == null) fn__0x733C87D4CE22BEA2 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x733C87D4CE22BEA2");
				fn__0x733C87D4CE22BEA2(_p0);
			}
		}

		public void SetPedSeeingRange(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedSeeingRange == null) fn__setPedSeeingRange = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedSeeingRange");
				fn__setPedSeeingRange(_ped, _value);
			}
		}

		public void SetPedHearingRange(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedHearingRange == null) fn__setPedHearingRange = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedHearingRange");
				fn__setPedHearingRange(_ped, _value);
			}
		}

		public void SetPedVisualFieldMinAngle(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedVisualFieldMinAngle == null) fn__setPedVisualFieldMinAngle = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedVisualFieldMinAngle");
				fn__setPedVisualFieldMinAngle(_ped, _value);
			}
		}

		public void SetPedVisualFieldMaxAngle(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedVisualFieldMaxAngle == null) fn__setPedVisualFieldMaxAngle = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedVisualFieldMaxAngle");
				fn__setPedVisualFieldMaxAngle(_ped, _value);
			}
		}

		public void SetPedVisualFieldMinElevationAngle(int _ped, float _angle)
		{
			unsafe {
				if (fn__setPedVisualFieldMinElevationAngle == null) fn__setPedVisualFieldMinElevationAngle = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedVisualFieldMinElevationAngle");
				fn__setPedVisualFieldMinElevationAngle(_ped, _angle);
			}
		}

		public void SetPedVisualFieldMaxElevationAngle(int _ped, float _angle)
		{
			unsafe {
				if (fn__setPedVisualFieldMaxElevationAngle == null) fn__setPedVisualFieldMaxElevationAngle = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedVisualFieldMaxElevationAngle");
				fn__setPedVisualFieldMaxElevationAngle(_ped, _angle);
			}
		}

		public void SetPedVisualFieldPeripheralRange(int _ped, float _range)
		{
			unsafe {
				if (fn__setPedVisualFieldPeripheralRange == null) fn__setPedVisualFieldPeripheralRange = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedVisualFieldPeripheralRange");
				fn__setPedVisualFieldPeripheralRange(_ped, _range);
			}
		}

		public void SetPedVisualFieldCenterAngle(int _ped, float _angle)
		{
			unsafe {
				if (fn__setPedVisualFieldCenterAngle == null) fn__setPedVisualFieldCenterAngle = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedVisualFieldCenterAngle");
				fn__setPedVisualFieldCenterAngle(_ped, _angle);
			}
		}

		public float GetPedVisualFieldCenterAngle(int _ped)
		{
			unsafe {
				if (fn__getPedVisualFieldCenterAngle == null) fn__getPedVisualFieldCenterAngle = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPedVisualFieldCenterAngle");
				var result = fn__getPedVisualFieldCenterAngle(_ped);
				return result;
			}
		}

		public void SetPedStealthMovement(int _ped, bool _p1, string _action)
		{
			unsafe {
				if (fn__setPedStealthMovement == null) fn__setPedStealthMovement = (delegate* unmanaged[Cdecl]<int, bool, nint, void>) NativeLibrary.GetExport(handle, "Native_setPedStealthMovement");
				var ptr_action = MemoryUtils.StringToHGlobalUtf8(_action);
				fn__setPedStealthMovement(_ped, _p1, ptr_action);
				Marshal.FreeHGlobal(ptr_action);
			}
		}

		public bool GetPedStealthMovement(int _ped)
		{
			unsafe {
				if (fn__getPedStealthMovement == null) fn__getPedStealthMovement = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getPedStealthMovement");
				var result = fn__getPedStealthMovement(_ped);
				return result;
			}
		}

		public int CreateGroup(int _unused)
		{
			unsafe {
				if (fn__createGroup == null) fn__createGroup = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_createGroup");
				var result = fn__createGroup(_unused);
				return result;
			}
		}

		public void SetPedAsGroupLeader(int _ped, int _groupId)
		{
			unsafe {
				if (fn__setPedAsGroupLeader == null) fn__setPedAsGroupLeader = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedAsGroupLeader");
				fn__setPedAsGroupLeader(_ped, _groupId);
			}
		}

		public void SetPedAsGroupMember(int _ped, int _groupId)
		{
			unsafe {
				if (fn__setPedAsGroupMember == null) fn__setPedAsGroupMember = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedAsGroupMember");
				fn__setPedAsGroupMember(_ped, _groupId);
			}
		}

		public void SetPedCanTeleportToGroupLeader(int _pedHandle, int _groupHandle, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanTeleportToGroupLeader == null) fn__setPedCanTeleportToGroupLeader = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanTeleportToGroupLeader");
				fn__setPedCanTeleportToGroupLeader(_pedHandle, _groupHandle, _toggle);
			}
		}

		public void RemoveGroup(int _groupId)
		{
			unsafe {
				if (fn__removeGroup == null) fn__removeGroup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeGroup");
				fn__removeGroup(_groupId);
			}
		}

		public void RemovePedFromGroup(int _ped)
		{
			unsafe {
				if (fn__removePedFromGroup == null) fn__removePedFromGroup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removePedFromGroup");
				fn__removePedFromGroup(_ped);
			}
		}

		public bool IsPedGroupMember(int _ped, int _groupId)
		{
			unsafe {
				if (fn__isPedGroupMember == null) fn__isPedGroupMember = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedGroupMember");
				var result = fn__isPedGroupMember(_ped, _groupId);
				return result;
			}
		}

		public bool IsPedHangingOnToVehicle(int _ped)
		{
			unsafe {
				if (fn__isPedHangingOnToVehicle == null) fn__isPedHangingOnToVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedHangingOnToVehicle");
				var result = fn__isPedHangingOnToVehicle(_ped);
				return result;
			}
		}

		public void SetGroupSeparationRange(int _groupHandle, float _separationRange)
		{
			unsafe {
				if (fn__setGroupSeparationRange == null) fn__setGroupSeparationRange = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setGroupSeparationRange");
				fn__setGroupSeparationRange(_groupHandle, _separationRange);
			}
		}

		public void SetPedMinGroundTimeForStungun(int _ped, int _ms)
		{
			unsafe {
				if (fn__setPedMinGroundTimeForStungun == null) fn__setPedMinGroundTimeForStungun = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedMinGroundTimeForStungun");
				fn__setPedMinGroundTimeForStungun(_ped, _ms);
			}
		}

		public bool IsPedProne(int _ped)
		{
			unsafe {
				if (fn__isPedProne == null) fn__isPedProne = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedProne");
				var result = fn__isPedProne(_ped);
				return result;
			}
		}

		public bool IsPedInCombat(int _ped, int _target)
		{
			unsafe {
				if (fn__isPedInCombat == null) fn__isPedInCombat = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInCombat");
				var result = fn__isPedInCombat(_ped, _target);
				return result;
			}
		}

		public int GetPedTaskCombatTarget(int _ped, int _p1)
		{
			unsafe {
				if (fn__getPedTaskCombatTarget == null) fn__getPedTaskCombatTarget = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedTaskCombatTarget");
				var result = fn__getPedTaskCombatTarget(_ped, _p1);
				return result;
			}
		}

		public bool CanPedInCombatSeeTarget(int _ped, int _target)
		{
			unsafe {
				if (fn__canPedInCombatSeeTarget == null) fn__canPedInCombatSeeTarget = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_canPedInCombatSeeTarget");
				var result = fn__canPedInCombatSeeTarget(_ped, _target);
				return result;
			}
		}

		public bool IsPedDoingDriveby(int _ped)
		{
			unsafe {
				if (fn__isPedDoingDriveby == null) fn__isPedDoingDriveby = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedDoingDriveby");
				var result = fn__isPedDoingDriveby(_ped);
				return result;
			}
		}

		public bool IsPedJacking(int _ped)
		{
			unsafe {
				if (fn__isPedJacking == null) fn__isPedJacking = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedJacking");
				var result = fn__isPedJacking(_ped);
				return result;
			}
		}

		public bool IsPedBeingJacked(int _ped)
		{
			unsafe {
				if (fn__isPedBeingJacked == null) fn__isPedBeingJacked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedBeingJacked");
				var result = fn__isPedBeingJacked(_ped);
				return result;
			}
		}

		public bool IsPedBeingStunned(int _ped, int _p1)
		{
			unsafe {
				if (fn__isPedBeingStunned == null) fn__isPedBeingStunned = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedBeingStunned");
				var result = fn__isPedBeingStunned(_ped, _p1);
				return result;
			}
		}

		public int GetPedsJacker(int _ped)
		{
			unsafe {
				if (fn__getPedsJacker == null) fn__getPedsJacker = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedsJacker");
				var result = fn__getPedsJacker(_ped);
				return result;
			}
		}

		public int GetJackTarget(int _ped)
		{
			unsafe {
				if (fn__getJackTarget == null) fn__getJackTarget = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getJackTarget");
				var result = fn__getJackTarget(_ped);
				return result;
			}
		}

		public bool IsPedFleeing(int _ped)
		{
			unsafe {
				if (fn__isPedFleeing == null) fn__isPedFleeing = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedFleeing");
				var result = fn__isPedFleeing(_ped);
				return result;
			}
		}

		public bool IsPedInCover(int _ped, bool _exceptUseWeapon)
		{
			unsafe {
				if (fn__isPedInCover == null) fn__isPedInCover = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isPedInCover");
				var result = fn__isPedInCover(_ped, _exceptUseWeapon);
				return result;
			}
		}

		public bool IsPedInCoverFacingLeft(int _ped)
		{
			unsafe {
				if (fn__isPedInCoverFacingLeft == null) fn__isPedInCoverFacingLeft = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInCoverFacingLeft");
				var result = fn__isPedInCoverFacingLeft(_ped);
				return result;
			}
		}

		public bool IsPedInHighCover(int _ped)
		{
			unsafe {
				if (fn__isPedInHighCover == null) fn__isPedInHighCover = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInHighCover");
				var result = fn__isPedInHighCover(_ped);
				return result;
			}
		}

		public bool IsPedGoingIntoCover(int _ped)
		{
			unsafe {
				if (fn__isPedGoingIntoCover == null) fn__isPedGoingIntoCover = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedGoingIntoCover");
				var result = fn__isPedGoingIntoCover(_ped);
				return result;
			}
		}

		public int SetPedPinnedDown(int _ped, bool _pinned, int _i)
		{
			unsafe {
				if (fn__setPedPinnedDown == null) fn__setPedPinnedDown = (delegate* unmanaged[Cdecl]<int, bool, int, int>) NativeLibrary.GetExport(handle, "Native_setPedPinnedDown");
				var result = fn__setPedPinnedDown(_ped, _pinned, _i);
				return result;
			}
		}

		public int GetSeatPedIsTryingToEnter(int _ped)
		{
			unsafe {
				if (fn__getSeatPedIsTryingToEnter == null) fn__getSeatPedIsTryingToEnter = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getSeatPedIsTryingToEnter");
				var result = fn__getSeatPedIsTryingToEnter(_ped);
				return result;
			}
		}

		public int GetVehiclePedIsTryingToEnter(int _ped)
		{
			unsafe {
				if (fn__getVehiclePedIsTryingToEnter == null) fn__getVehiclePedIsTryingToEnter = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehiclePedIsTryingToEnter");
				var result = fn__getVehiclePedIsTryingToEnter(_ped);
				return result;
			}
		}

		public int GetPedSourceOfDeath(int _ped)
		{
			unsafe {
				if (fn__getPedSourceOfDeath == null) fn__getPedSourceOfDeath = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedSourceOfDeath");
				var result = fn__getPedSourceOfDeath(_ped);
				return result;
			}
		}

		public int GetPedCauseOfDeath(int _ped)
		{
			unsafe {
				if (fn__getPedCauseOfDeath == null) fn__getPedCauseOfDeath = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedCauseOfDeath");
				var result = fn__getPedCauseOfDeath(_ped);
				return result;
			}
		}

		public int GetPedTimeOfDeath(int _ped)
		{
			unsafe {
				if (fn__getPedTimeOfDeath == null) fn__getPedTimeOfDeath = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedTimeOfDeath");
				var result = fn__getPedTimeOfDeath(_ped);
				return result;
			}
		}

		public int _0x5407B7288D0478B7(int _p0)
		{
			unsafe {
				if (fn__0x5407B7288D0478B7 == null) fn__0x5407B7288D0478B7 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x5407B7288D0478B7");
				var result = fn__0x5407B7288D0478B7(_p0);
				return result;
			}
		}

		public int _0x336B3D200AB007CB(int _p0, float _p1, float _p2, float _p3, float _p4)
		{
			unsafe {
				if (fn__0x336B3D200AB007CB == null) fn__0x336B3D200AB007CB = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native__0x336B3D200AB007CB");
				var result = fn__0x336B3D200AB007CB(_p0, _p1, _p2, _p3, _p4);
				return result;
			}
		}

		public void SetPedRelationshipGroupDefaultHash(int _ped, int _hash)
		{
			unsafe {
				if (fn__setPedRelationshipGroupDefaultHash == null) fn__setPedRelationshipGroupDefaultHash = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedRelationshipGroupDefaultHash");
				fn__setPedRelationshipGroupDefaultHash(_ped, _hash);
			}
		}

		public void SetPedRelationshipGroupHash(int _ped, int _hash)
		{
			unsafe {
				if (fn__setPedRelationshipGroupHash == null) fn__setPedRelationshipGroupHash = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedRelationshipGroupHash");
				fn__setPedRelationshipGroupHash(_ped, _hash);
			}
		}

		public void SetRelationshipBetweenGroups(int _relationship, int _group1, int _group2)
		{
			unsafe {
				if (fn__setRelationshipBetweenGroups == null) fn__setRelationshipBetweenGroups = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setRelationshipBetweenGroups");
				fn__setRelationshipBetweenGroups(_relationship, _group1, _group2);
			}
		}

		public void ClearRelationshipBetweenGroups(int _relationship, int _group1, int _group2)
		{
			unsafe {
				if (fn__clearRelationshipBetweenGroups == null) fn__clearRelationshipBetweenGroups = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_clearRelationshipBetweenGroups");
				fn__clearRelationshipBetweenGroups(_relationship, _group1, _group2);
			}
		}

		public int AddRelationshipGroup(string _name, ref int _groupHash)
		{
			unsafe {
				if (fn__addRelationshipGroup == null) fn__addRelationshipGroup = (delegate* unmanaged[Cdecl]<nint, int*, int>) NativeLibrary.GetExport(handle, "Native_addRelationshipGroup");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var ref_groupHash = _groupHash;
				var result = fn__addRelationshipGroup(ptr_name, &ref_groupHash);
				Marshal.FreeHGlobal(ptr_name);
				_groupHash = ref_groupHash;
				return result;
			}
		}

		public void RemoveRelationshipGroup(int _groupHash)
		{
			unsafe {
				if (fn__removeRelationshipGroup == null) fn__removeRelationshipGroup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeRelationshipGroup");
				fn__removeRelationshipGroup(_groupHash);
			}
		}

		public bool DoesRelationshipGroupExist(int _groupHash)
		{
			unsafe {
				if (fn__doesRelationshipGroupExist == null) fn__doesRelationshipGroupExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesRelationshipGroupExist");
				var result = fn__doesRelationshipGroupExist(_groupHash);
				return result;
			}
		}

		public int GetRelationshipBetweenPeds(int _ped1, int _ped2)
		{
			unsafe {
				if (fn__getRelationshipBetweenPeds == null) fn__getRelationshipBetweenPeds = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getRelationshipBetweenPeds");
				var result = fn__getRelationshipBetweenPeds(_ped1, _ped2);
				return result;
			}
		}

		public int GetPedRelationshipGroupDefaultHash(int _ped)
		{
			unsafe {
				if (fn__getPedRelationshipGroupDefaultHash == null) fn__getPedRelationshipGroupDefaultHash = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedRelationshipGroupDefaultHash");
				var result = fn__getPedRelationshipGroupDefaultHash(_ped);
				return result;
			}
		}

		public int GetPedRelationshipGroupHash(int _ped)
		{
			unsafe {
				if (fn__getPedRelationshipGroupHash == null) fn__getPedRelationshipGroupHash = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedRelationshipGroupHash");
				var result = fn__getPedRelationshipGroupHash(_ped);
				return result;
			}
		}

		public int GetRelationshipBetweenGroups(int _group1, int _group2)
		{
			unsafe {
				if (fn__getRelationshipBetweenGroups == null) fn__getRelationshipBetweenGroups = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getRelationshipBetweenGroups");
				var result = fn__getRelationshipBetweenGroups(_group1, _group2);
				return result;
			}
		}

		public void SetRelationshipGroupDontAffectWantedLevel(int _group, bool _p1)
		{
			unsafe {
				if (fn__setRelationshipGroupDontAffectWantedLevel == null) fn__setRelationshipGroupDontAffectWantedLevel = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setRelationshipGroupDontAffectWantedLevel");
				fn__setRelationshipGroupDontAffectWantedLevel(_group, _p1);
			}
		}

		public void _0xAD27D957598E49E9(int _ped, int _p1, float _p2, int _hash, int _p4, int _p5)
		{
			unsafe {
				if (fn__0xAD27D957598E49E9 == null) fn__0xAD27D957598E49E9 = (delegate* unmanaged[Cdecl]<int, int, float, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xAD27D957598E49E9");
				fn__0xAD27D957598E49E9(_ped, _p1, _p2, _hash, _p4, _p5);
			}
		}

		public void SetPedCanBeTargetedWithoutLos(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanBeTargetedWithoutLos == null) fn__setPedCanBeTargetedWithoutLos = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanBeTargetedWithoutLos");
				fn__setPedCanBeTargetedWithoutLos(_ped, _toggle);
			}
		}

		public void SetPedToInformRespectedFriends(int _ped, float _radius, int _maxFriends)
		{
			unsafe {
				if (fn__setPedToInformRespectedFriends == null) fn__setPedToInformRespectedFriends = (delegate* unmanaged[Cdecl]<int, float, int, void>) NativeLibrary.GetExport(handle, "Native_setPedToInformRespectedFriends");
				fn__setPedToInformRespectedFriends(_ped, _radius, _maxFriends);
			}
		}

		public bool IsPedRespondingToEvent(int _ped, int _event)
		{
			unsafe {
				if (fn__isPedRespondingToEvent == null) fn__isPedRespondingToEvent = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedRespondingToEvent");
				var result = fn__isPedRespondingToEvent(_ped, _event);
				return result;
			}
		}

		public bool GetPedEventData(int _ped, int _eventType, ref int _outData)
		{
			unsafe {
				if (fn__getPedEventData == null) fn__getPedEventData = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getPedEventData");
				var ref_outData = _outData;
				var result = fn__getPedEventData(_ped, _eventType, &ref_outData);
				_outData = ref_outData;
				return result;
			}
		}

		public void SetPedFiringPattern(int _ped, int _patternHash)
		{
			unsafe {
				if (fn__setPedFiringPattern == null) fn__setPedFiringPattern = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedFiringPattern");
				fn__setPedFiringPattern(_ped, _patternHash);
			}
		}

		public void SetPedShootRate(int _ped, int _shootRate)
		{
			unsafe {
				if (fn__setPedShootRate == null) fn__setPedShootRate = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedShootRate");
				fn__setPedShootRate(_ped, _shootRate);
			}
		}

		public void SetCombatFloat(int _ped, int _combatType, float _p2)
		{
			unsafe {
				if (fn__setCombatFloat == null) fn__setCombatFloat = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setCombatFloat");
				fn__setCombatFloat(_ped, _combatType, _p2);
			}
		}

		public float GetCombatFloat(int _ped, int _p1)
		{
			unsafe {
				if (fn__getCombatFloat == null) fn__getCombatFloat = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getCombatFloat");
				var result = fn__getCombatFloat(_ped, _p1);
				return result;
			}
		}

		public void GetGroupSize(int _groupID, ref int _unknown, ref int _sizeInMembers)
		{
			unsafe {
				if (fn__getGroupSize == null) fn__getGroupSize = (delegate* unmanaged[Cdecl]<int, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getGroupSize");
				var ref_unknown = _unknown;
				var ref_sizeInMembers = _sizeInMembers;
				fn__getGroupSize(_groupID, &ref_unknown, &ref_sizeInMembers);
				_unknown = ref_unknown;
				_sizeInMembers = ref_sizeInMembers;
			}
		}

		public bool DoesGroupExist(int _groupId)
		{
			unsafe {
				if (fn__doesGroupExist == null) fn__doesGroupExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesGroupExist");
				var result = fn__doesGroupExist(_groupId);
				return result;
			}
		}

		public int GetPedGroupIndex(int _ped)
		{
			unsafe {
				if (fn__getPedGroupIndex == null) fn__getPedGroupIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedGroupIndex");
				var result = fn__getPedGroupIndex(_ped);
				return result;
			}
		}

		public bool IsPedInGroup(int _ped)
		{
			unsafe {
				if (fn__isPedInGroup == null) fn__isPedInGroup = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInGroup");
				var result = fn__isPedInGroup(_ped);
				return result;
			}
		}

		public int GetPlayerPedIsFollowing(int _ped)
		{
			unsafe {
				if (fn__getPlayerPedIsFollowing == null) fn__getPlayerPedIsFollowing = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerPedIsFollowing");
				var result = fn__getPlayerPedIsFollowing(_ped);
				return result;
			}
		}

		public void SetGroupFormation(int _groupId, int _formationType)
		{
			unsafe {
				if (fn__setGroupFormation == null) fn__setGroupFormation = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setGroupFormation");
				fn__setGroupFormation(_groupId, _formationType);
			}
		}

		public void SetGroupFormationSpacing(int _groupId, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__setGroupFormationSpacing == null) fn__setGroupFormationSpacing = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setGroupFormationSpacing");
				fn__setGroupFormationSpacing(_groupId, _p1, _p2, _p3);
			}
		}

		public void ResetGroupFormationDefaultSpacing(int _groupHandle)
		{
			unsafe {
				if (fn__resetGroupFormationDefaultSpacing == null) fn__resetGroupFormationDefaultSpacing = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetGroupFormationDefaultSpacing");
				fn__resetGroupFormationDefaultSpacing(_groupHandle);
			}
		}

		public int GetVehiclePedIsUsing(int _ped)
		{
			unsafe {
				if (fn__getVehiclePedIsUsing == null) fn__getVehiclePedIsUsing = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehiclePedIsUsing");
				var result = fn__getVehiclePedIsUsing(_ped);
				return result;
			}
		}

		public int GetVehiclePedIsEntering(int _ped)
		{
			unsafe {
				if (fn__getVehiclePedIsEntering == null) fn__getVehiclePedIsEntering = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehiclePedIsEntering");
				var result = fn__getVehiclePedIsEntering(_ped);
				return result;
			}
		}

		public void SetPedGravity(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedGravity == null) fn__setPedGravity = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedGravity");
				fn__setPedGravity(_ped, _toggle);
			}
		}

		public void ApplyDamageToPed(int _ped, int _damageAmount, bool _p2, int _p3)
		{
			unsafe {
				if (fn__applyDamageToPed == null) fn__applyDamageToPed = (delegate* unmanaged[Cdecl]<int, int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_applyDamageToPed");
				fn__applyDamageToPed(_ped, _damageAmount, _p2, _p3);
			}
		}

		public int GetTimeOfLastPedWeaponDamage(int _ped, int _weaponHash)
		{
			unsafe {
				if (fn__getTimeOfLastPedWeaponDamage == null) fn__getTimeOfLastPedWeaponDamage = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getTimeOfLastPedWeaponDamage");
				var result = fn__getTimeOfLastPedWeaponDamage(_ped, _weaponHash);
				return result;
			}
		}

		public void SetPedAllowedToDuck(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedAllowedToDuck == null) fn__setPedAllowedToDuck = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAllowedToDuck");
				fn__setPedAllowedToDuck(_ped, _toggle);
			}
		}

		public void SetPedNeverLeavesGroup(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedNeverLeavesGroup == null) fn__setPedNeverLeavesGroup = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedNeverLeavesGroup");
				fn__setPedNeverLeavesGroup(_ped, _toggle);
			}
		}

		public int GetPedType(int _ped)
		{
			unsafe {
				if (fn__getPedType == null) fn__getPedType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedType");
				var result = fn__getPedType(_ped);
				return result;
			}
		}

		public void SetPedAsCop(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedAsCop == null) fn__setPedAsCop = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAsCop");
				fn__setPedAsCop(_ped, _toggle);
			}
		}

		public void SetPedMaxHealth(int _ped, int _value)
		{
			unsafe {
				if (fn__setPedMaxHealth == null) fn__setPedMaxHealth = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedMaxHealth");
				fn__setPedMaxHealth(_ped, _value);
			}
		}

		public int GetPedMaxHealth(int _ped)
		{
			unsafe {
				if (fn__getPedMaxHealth == null) fn__getPedMaxHealth = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedMaxHealth");
				var result = fn__getPedMaxHealth(_ped);
				return result;
			}
		}

		public void SetPedMaxTimeInWater(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedMaxTimeInWater == null) fn__setPedMaxTimeInWater = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedMaxTimeInWater");
				fn__setPedMaxTimeInWater(_ped, _value);
			}
		}

		public void SetPedMaxTimeUnderwater(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedMaxTimeUnderwater == null) fn__setPedMaxTimeUnderwater = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedMaxTimeUnderwater");
				fn__setPedMaxTimeUnderwater(_ped, _value);
			}
		}

		public void _0x2735233A786B1BEF(int _ped, float _p1)
		{
			unsafe {
				if (fn__0x2735233A786B1BEF == null) fn__0x2735233A786B1BEF = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x2735233A786B1BEF");
				fn__0x2735233A786B1BEF(_ped, _p1);
			}
		}

		public void SetPedVehicleForcedSeatUsage(int _ped, int _vehicle, int _seatIndex, int _flags, int _p4)
		{
			unsafe {
				if (fn__setPedVehicleForcedSeatUsage == null) fn__setPedVehicleForcedSeatUsage = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedVehicleForcedSeatUsage");
				fn__setPedVehicleForcedSeatUsage(_ped, _vehicle, _seatIndex, _flags, _p4);
			}
		}

		public void ClearAllPedVehicleForcedSeatUsage(int _ped)
		{
			unsafe {
				if (fn__clearAllPedVehicleForcedSeatUsage == null) fn__clearAllPedVehicleForcedSeatUsage = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearAllPedVehicleForcedSeatUsage");
				fn__clearAllPedVehicleForcedSeatUsage(_ped);
			}
		}

		public void _0xB282749D5E028163(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xB282749D5E028163 == null) fn__0xB282749D5E028163 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xB282749D5E028163");
				fn__0xB282749D5E028163(_p0, _p1);
			}
		}

		public void SetPedCanBeKnockedOffVehicle(int _ped, int _state)
		{
			unsafe {
				if (fn__setPedCanBeKnockedOffVehicle == null) fn__setPedCanBeKnockedOffVehicle = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedCanBeKnockedOffVehicle");
				fn__setPedCanBeKnockedOffVehicle(_ped, _state);
			}
		}

		public bool CanKnockPedOffVehicle(int _ped)
		{
			unsafe {
				if (fn__canKnockPedOffVehicle == null) fn__canKnockPedOffVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canKnockPedOffVehicle");
				var result = fn__canKnockPedOffVehicle(_ped);
				return result;
			}
		}

		public void KnockPedOffVehicle(int _ped)
		{
			unsafe {
				if (fn__knockPedOffVehicle == null) fn__knockPedOffVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_knockPedOffVehicle");
				fn__knockPedOffVehicle(_ped);
			}
		}

		public void SetPedCoordsNoGang(int _ped, float _posX, float _posY, float _posZ)
		{
			unsafe {
				if (fn__setPedCoordsNoGang == null) fn__setPedCoordsNoGang = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setPedCoordsNoGang");
				fn__setPedCoordsNoGang(_ped, _posX, _posY, _posZ);
			}
		}

		public int GetPedAsGroupMember(int _groupID, int _memberNumber)
		{
			unsafe {
				if (fn__getPedAsGroupMember == null) fn__getPedAsGroupMember = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedAsGroupMember");
				var result = fn__getPedAsGroupMember(_groupID, _memberNumber);
				return result;
			}
		}

		public int GetPedAsGroupLeader(int _groupID)
		{
			unsafe {
				if (fn__getPedAsGroupLeader == null) fn__getPedAsGroupLeader = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedAsGroupLeader");
				var result = fn__getPedAsGroupLeader(_groupID);
				return result;
			}
		}

		public void SetPedKeepTask(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedKeepTask == null) fn__setPedKeepTask = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedKeepTask");
				fn__setPedKeepTask(_ped, _toggle);
			}
		}

		public void _0x49E50BDB8BA4DAB2(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__0x49E50BDB8BA4DAB2 == null) fn__0x49E50BDB8BA4DAB2 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x49E50BDB8BA4DAB2");
				fn__0x49E50BDB8BA4DAB2(_ped, _toggle);
			}
		}

		public bool IsPedSwimming(int _ped)
		{
			unsafe {
				if (fn__isPedSwimming == null) fn__isPedSwimming = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedSwimming");
				var result = fn__isPedSwimming(_ped);
				return result;
			}
		}

		public bool IsPedSwimmingUnderWater(int _ped)
		{
			unsafe {
				if (fn__isPedSwimmingUnderWater == null) fn__isPedSwimmingUnderWater = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedSwimmingUnderWater");
				var result = fn__isPedSwimmingUnderWater(_ped);
				return result;
			}
		}

		public void SetPedCoordsKeepVehicle(int _ped, float _posX, float _posY, float _posZ)
		{
			unsafe {
				if (fn__setPedCoordsKeepVehicle == null) fn__setPedCoordsKeepVehicle = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setPedCoordsKeepVehicle");
				fn__setPedCoordsKeepVehicle(_ped, _posX, _posY, _posZ);
			}
		}

		public void SetPedDiesInVehicle(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedDiesInVehicle == null) fn__setPedDiesInVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDiesInVehicle");
				fn__setPedDiesInVehicle(_ped, _toggle);
			}
		}

		public void SetCreateRandomCops(bool _toggle)
		{
			unsafe {
				if (fn__setCreateRandomCops == null) fn__setCreateRandomCops = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setCreateRandomCops");
				fn__setCreateRandomCops(_toggle);
			}
		}

		public void SetCreateRandomCopsNotOnScenarios(bool _toggle)
		{
			unsafe {
				if (fn__setCreateRandomCopsNotOnScenarios == null) fn__setCreateRandomCopsNotOnScenarios = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setCreateRandomCopsNotOnScenarios");
				fn__setCreateRandomCopsNotOnScenarios(_toggle);
			}
		}

		public void SetCreateRandomCopsOnScenarios(bool _toggle)
		{
			unsafe {
				if (fn__setCreateRandomCopsOnScenarios == null) fn__setCreateRandomCopsOnScenarios = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setCreateRandomCopsOnScenarios");
				fn__setCreateRandomCopsOnScenarios(_toggle);
			}
		}

		public bool CanCreateRandomCops()
		{
			unsafe {
				if (fn__canCreateRandomCops == null) fn__canCreateRandomCops = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_canCreateRandomCops");
				var result = fn__canCreateRandomCops();
				return result;
			}
		}

		public void SetPedAsEnemy(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedAsEnemy == null) fn__setPedAsEnemy = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAsEnemy");
				fn__setPedAsEnemy(_ped, _toggle);
			}
		}

		public void SetPedCanSmashGlass(int _ped, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setPedCanSmashGlass == null) fn__setPedCanSmashGlass = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanSmashGlass");
				fn__setPedCanSmashGlass(_ped, _p1, _p2);
			}
		}

		public bool IsPedInAnyTrain(int _ped)
		{
			unsafe {
				if (fn__isPedInAnyTrain == null) fn__isPedInAnyTrain = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInAnyTrain");
				var result = fn__isPedInAnyTrain(_ped);
				return result;
			}
		}

		public bool IsPedGettingIntoAVehicle(int _ped)
		{
			unsafe {
				if (fn__isPedGettingIntoAVehicle == null) fn__isPedGettingIntoAVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedGettingIntoAVehicle");
				var result = fn__isPedGettingIntoAVehicle(_ped);
				return result;
			}
		}

		public bool IsPedTryingToEnterALockedVehicle(int _ped)
		{
			unsafe {
				if (fn__isPedTryingToEnterALockedVehicle == null) fn__isPedTryingToEnterALockedVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedTryingToEnterALockedVehicle");
				var result = fn__isPedTryingToEnterALockedVehicle(_ped);
				return result;
			}
		}

		public void SetEnableHandcuffs(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setEnableHandcuffs == null) fn__setEnableHandcuffs = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEnableHandcuffs");
				fn__setEnableHandcuffs(_ped, _toggle);
			}
		}

		public void SetEnableBoundAnkles(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setEnableBoundAnkles == null) fn__setEnableBoundAnkles = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEnableBoundAnkles");
				fn__setEnableBoundAnkles(_ped, _toggle);
			}
		}

		public void SetEnableScuba(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setEnableScuba == null) fn__setEnableScuba = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEnableScuba");
				fn__setEnableScuba(_ped, _toggle);
			}
		}

		public void SetCanAttackFriendly(int _ped, bool _toggle, bool _p2)
		{
			unsafe {
				if (fn__setCanAttackFriendly == null) fn__setCanAttackFriendly = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setCanAttackFriendly");
				fn__setCanAttackFriendly(_ped, _toggle, _p2);
			}
		}

		public int GetPedAlertness(int _ped)
		{
			unsafe {
				if (fn__getPedAlertness == null) fn__getPedAlertness = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedAlertness");
				var result = fn__getPedAlertness(_ped);
				return result;
			}
		}

		public void SetPedAlertness(int _ped, int _value)
		{
			unsafe {
				if (fn__setPedAlertness == null) fn__setPedAlertness = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedAlertness");
				fn__setPedAlertness(_ped, _value);
			}
		}

		public void SetPedGetOutUpsideDownVehicle(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedGetOutUpsideDownVehicle == null) fn__setPedGetOutUpsideDownVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedGetOutUpsideDownVehicle");
				fn__setPedGetOutUpsideDownVehicle(_ped, _toggle);
			}
		}

		public void SetPedMovementClipset(int _ped, string _clipSet, float _transitionSpeed)
		{
			unsafe {
				if (fn__setPedMovementClipset == null) fn__setPedMovementClipset = (delegate* unmanaged[Cdecl]<int, nint, float, void>) NativeLibrary.GetExport(handle, "Native_setPedMovementClipset");
				var ptr_clipSet = MemoryUtils.StringToHGlobalUtf8(_clipSet);
				fn__setPedMovementClipset(_ped, ptr_clipSet, _transitionSpeed);
				Marshal.FreeHGlobal(ptr_clipSet);
			}
		}

		public void ResetPedMovementClipset(int _ped, float _p1)
		{
			unsafe {
				if (fn__resetPedMovementClipset == null) fn__resetPedMovementClipset = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_resetPedMovementClipset");
				fn__resetPedMovementClipset(_ped, _p1);
			}
		}

		public void SetPedStrafeClipset(int _ped, string _clipSet)
		{
			unsafe {
				if (fn__setPedStrafeClipset == null) fn__setPedStrafeClipset = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setPedStrafeClipset");
				var ptr_clipSet = MemoryUtils.StringToHGlobalUtf8(_clipSet);
				fn__setPedStrafeClipset(_ped, ptr_clipSet);
				Marshal.FreeHGlobal(ptr_clipSet);
			}
		}

		public void ResetPedStrafeClipset(int _ped)
		{
			unsafe {
				if (fn__resetPedStrafeClipset == null) fn__resetPedStrafeClipset = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPedStrafeClipset");
				fn__resetPedStrafeClipset(_ped);
			}
		}

		public void SetPedWeaponMovementClipset(int _ped, string _clipSet)
		{
			unsafe {
				if (fn__setPedWeaponMovementClipset == null) fn__setPedWeaponMovementClipset = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setPedWeaponMovementClipset");
				var ptr_clipSet = MemoryUtils.StringToHGlobalUtf8(_clipSet);
				fn__setPedWeaponMovementClipset(_ped, ptr_clipSet);
				Marshal.FreeHGlobal(ptr_clipSet);
			}
		}

		public void ResetPedWeaponMovementClipset(int _ped)
		{
			unsafe {
				if (fn__resetPedWeaponMovementClipset == null) fn__resetPedWeaponMovementClipset = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPedWeaponMovementClipset");
				fn__resetPedWeaponMovementClipset(_ped);
			}
		}

		public void SetPedDriveByClipsetOverride(int _ped, string _clipset)
		{
			unsafe {
				if (fn__setPedDriveByClipsetOverride == null) fn__setPedDriveByClipsetOverride = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setPedDriveByClipsetOverride");
				var ptr_clipset = MemoryUtils.StringToHGlobalUtf8(_clipset);
				fn__setPedDriveByClipsetOverride(_ped, ptr_clipset);
				Marshal.FreeHGlobal(ptr_clipset);
			}
		}

		public void ClearPedDriveByClipsetOverride(int _ped)
		{
			unsafe {
				if (fn__clearPedDriveByClipsetOverride == null) fn__clearPedDriveByClipsetOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedDriveByClipsetOverride");
				fn__clearPedDriveByClipsetOverride(_ped);
			}
		}

		public void SetPedCoverClipsetOverride(int _ped, string _p1)
		{
			unsafe {
				if (fn__setPedCoverClipsetOverride == null) fn__setPedCoverClipsetOverride = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setPedCoverClipsetOverride");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__setPedCoverClipsetOverride(_ped, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void ClearPedCoverClipsetOverride(int _ped)
		{
			unsafe {
				if (fn__clearPedCoverClipsetOverride == null) fn__clearPedCoverClipsetOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedCoverClipsetOverride");
				fn__clearPedCoverClipsetOverride(_ped);
			}
		}

		public void _0x80054D7FCC70EEC6(int _ped)
		{
			unsafe {
				if (fn__0x80054D7FCC70EEC6 == null) fn__0x80054D7FCC70EEC6 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x80054D7FCC70EEC6");
				fn__0x80054D7FCC70EEC6(_ped);
			}
		}

		public void SetPedInVehicleContext(int _ped, int _context)
		{
			unsafe {
				if (fn__setPedInVehicleContext == null) fn__setPedInVehicleContext = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedInVehicleContext");
				fn__setPedInVehicleContext(_ped, _context);
			}
		}

		public void ResetPedInVehicleContext(int _ped)
		{
			unsafe {
				if (fn__resetPedInVehicleContext == null) fn__resetPedInVehicleContext = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPedInVehicleContext");
				fn__resetPedInVehicleContext(_ped);
			}
		}

		public bool IsScriptedScenarioPedUsingConditionalAnim(int _ped, string _animDict, string _anim)
		{
			unsafe {
				if (fn__isScriptedScenarioPedUsingConditionalAnim == null) fn__isScriptedScenarioPedUsingConditionalAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_isScriptedScenarioPedUsingConditionalAnim");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_anim = MemoryUtils.StringToHGlobalUtf8(_anim);
				var result = fn__isScriptedScenarioPedUsingConditionalAnim(_ped, ptr_animDict, ptr_anim);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_anim);
				return result;
			}
		}

		public void SetPedAlternateWalkAnim(int _ped, string _animDict, string _animName, float _p3, bool _p4)
		{
			unsafe {
				if (fn__setPedAlternateWalkAnim == null) fn__setPedAlternateWalkAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAlternateWalkAnim");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				fn__setPedAlternateWalkAnim(_ped, ptr_animDict, ptr_animName, _p3, _p4);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
			}
		}

		public void ClearPedAlternateWalkAnim(int _ped, float _p1)
		{
			unsafe {
				if (fn__clearPedAlternateWalkAnim == null) fn__clearPedAlternateWalkAnim = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_clearPedAlternateWalkAnim");
				fn__clearPedAlternateWalkAnim(_ped, _p1);
			}
		}

		public void SetPedAlternateMovementAnim(int _ped, int _stance, string _animDictionary, string _animationName, float _p4, bool _p5)
		{
			unsafe {
				if (fn__setPedAlternateMovementAnim == null) fn__setPedAlternateMovementAnim = (delegate* unmanaged[Cdecl]<int, int, nint, nint, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAlternateMovementAnim");
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var ptr_animationName = MemoryUtils.StringToHGlobalUtf8(_animationName);
				fn__setPedAlternateMovementAnim(_ped, _stance, ptr_animDictionary, ptr_animationName, _p4, _p5);
				Marshal.FreeHGlobal(ptr_animDictionary);
				Marshal.FreeHGlobal(ptr_animationName);
			}
		}

		public void ClearPedAlternateMovementAnim(int _ped, int _stance, float _p2)
		{
			unsafe {
				if (fn__clearPedAlternateMovementAnim == null) fn__clearPedAlternateMovementAnim = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_clearPedAlternateMovementAnim");
				fn__clearPedAlternateMovementAnim(_ped, _stance, _p2);
			}
		}

		public void SetPedGestureGroup(int _ped, string _animGroupGesture)
		{
			unsafe {
				if (fn__setPedGestureGroup == null) fn__setPedGestureGroup = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setPedGestureGroup");
				var ptr_animGroupGesture = MemoryUtils.StringToHGlobalUtf8(_animGroupGesture);
				fn__setPedGestureGroup(_ped, ptr_animGroupGesture);
				Marshal.FreeHGlobal(ptr_animGroupGesture);
			}
		}

		public Vector3 GetAnimInitialOffsetPosition(string _animDict, string _animName, float _x, float _y, float _z, float _xRot, float _yRot, float _zRot, float _p8, int _p9)
		{
			unsafe {
				if (fn__getAnimInitialOffsetPosition == null) fn__getAnimInitialOffsetPosition = (delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, float, float, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getAnimInitialOffsetPosition");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var result = fn__getAnimInitialOffsetPosition(ptr_animDict, ptr_animName, _x, _y, _z, _xRot, _yRot, _zRot, _p8, _p9);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				return result;
			}
		}

		public Vector3 GetAnimInitialOffsetRotation(string _animDict, string _animName, float _x, float _y, float _z, float _xRot, float _yRot, float _zRot, float _p8, int _p9)
		{
			unsafe {
				if (fn__getAnimInitialOffsetRotation == null) fn__getAnimInitialOffsetRotation = (delegate* unmanaged[Cdecl]<nint, nint, float, float, float, float, float, float, float, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getAnimInitialOffsetRotation");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var result = fn__getAnimInitialOffsetRotation(ptr_animDict, ptr_animName, _x, _y, _z, _xRot, _yRot, _zRot, _p8, _p9);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				return result;
			}
		}

		public int GetPedDrawableVariation(int _ped, int _componentId)
		{
			unsafe {
				if (fn__getPedDrawableVariation == null) fn__getPedDrawableVariation = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedDrawableVariation");
				var result = fn__getPedDrawableVariation(_ped, _componentId);
				return result;
			}
		}

		public int GetNumberOfPedDrawableVariations(int _ped, int _componentId)
		{
			unsafe {
				if (fn__getNumberOfPedDrawableVariations == null) fn__getNumberOfPedDrawableVariations = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfPedDrawableVariations");
				var result = fn__getNumberOfPedDrawableVariations(_ped, _componentId);
				return result;
			}
		}

		public int GetPedTextureVariation(int _ped, int _componentId)
		{
			unsafe {
				if (fn__getPedTextureVariation == null) fn__getPedTextureVariation = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedTextureVariation");
				var result = fn__getPedTextureVariation(_ped, _componentId);
				return result;
			}
		}

		public int GetNumberOfPedTextureVariations(int _ped, int _componentId, int _drawableId)
		{
			unsafe {
				if (fn__getNumberOfPedTextureVariations == null) fn__getNumberOfPedTextureVariations = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfPedTextureVariations");
				var result = fn__getNumberOfPedTextureVariations(_ped, _componentId, _drawableId);
				return result;
			}
		}

		public int GetNumberOfPedPropDrawableVariations(int _ped, int _propId)
		{
			unsafe {
				if (fn__getNumberOfPedPropDrawableVariations == null) fn__getNumberOfPedPropDrawableVariations = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfPedPropDrawableVariations");
				var result = fn__getNumberOfPedPropDrawableVariations(_ped, _propId);
				return result;
			}
		}

		public int GetNumberOfPedPropTextureVariations(int _ped, int _propId, int _drawableId)
		{
			unsafe {
				if (fn__getNumberOfPedPropTextureVariations == null) fn__getNumberOfPedPropTextureVariations = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfPedPropTextureVariations");
				var result = fn__getNumberOfPedPropTextureVariations(_ped, _propId, _drawableId);
				return result;
			}
		}

		public int GetPedPaletteVariation(int _ped, int _componentId)
		{
			unsafe {
				if (fn__getPedPaletteVariation == null) fn__getPedPaletteVariation = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedPaletteVariation");
				var result = fn__getPedPaletteVariation(_ped, _componentId);
				return result;
			}
		}

		public bool _0x9E30E91FB03A2CAF(ref int _p0, ref int _p1)
		{
			unsafe {
				if (fn__0x9E30E91FB03A2CAF == null) fn__0x9E30E91FB03A2CAF = (delegate* unmanaged[Cdecl]<int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x9E30E91FB03A2CAF");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__0x9E30E91FB03A2CAF(&ref_p0, &ref_p1);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public int _0x1E77FA7A62EE6C4C(int _p0)
		{
			unsafe {
				if (fn__0x1E77FA7A62EE6C4C == null) fn__0x1E77FA7A62EE6C4C = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x1E77FA7A62EE6C4C");
				var result = fn__0x1E77FA7A62EE6C4C(_p0);
				return result;
			}
		}

		public int _0xF033419D1B81FAE8(int _p0)
		{
			unsafe {
				if (fn__0xF033419D1B81FAE8 == null) fn__0xF033419D1B81FAE8 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xF033419D1B81FAE8");
				var result = fn__0xF033419D1B81FAE8(_p0);
				return result;
			}
		}

		public bool IsPedComponentVariationValid(int _ped, int _componentId, int _drawableId, int _textureId)
		{
			unsafe {
				if (fn__isPedComponentVariationValid == null) fn__isPedComponentVariationValid = (delegate* unmanaged[Cdecl]<int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedComponentVariationValid");
				var result = fn__isPedComponentVariationValid(_ped, _componentId, _drawableId, _textureId);
				return result;
			}
		}

		public void SetPedComponentVariation(int _ped, int _componentId, int _drawableId, int _textureId, int _paletteId)
		{
			unsafe {
				if (fn__setPedComponentVariation == null) fn__setPedComponentVariation = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedComponentVariation");
				fn__setPedComponentVariation(_ped, _componentId, _drawableId, _textureId, _paletteId);
			}
		}

		public void SetPedRandomComponentVariation(int _ped, int _p1)
		{
			unsafe {
				if (fn__setPedRandomComponentVariation == null) fn__setPedRandomComponentVariation = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedRandomComponentVariation");
				fn__setPedRandomComponentVariation(_ped, _p1);
			}
		}

		public void SetPedRandomProps(int _ped)
		{
			unsafe {
				if (fn__setPedRandomProps == null) fn__setPedRandomProps = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedRandomProps");
				fn__setPedRandomProps(_ped);
			}
		}

		public void SetPedDefaultComponentVariation(int _ped)
		{
			unsafe {
				if (fn__setPedDefaultComponentVariation == null) fn__setPedDefaultComponentVariation = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedDefaultComponentVariation");
				fn__setPedDefaultComponentVariation(_ped);
			}
		}

		public void SetPedBlendFromParents(int _ped, int _p1, int _p2, float _p3, float _p4)
		{
			unsafe {
				if (fn__setPedBlendFromParents == null) fn__setPedBlendFromParents = (delegate* unmanaged[Cdecl]<int, int, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_setPedBlendFromParents");
				fn__setPedBlendFromParents(_ped, _p1, _p2, _p3, _p4);
			}
		}

		public void SetPedHeadBlendData(int _ped, int _shapeFirstID, int _shapeSecondID, int _shapeThirdID, int _skinFirstID, int _skinSecondID, int _skinThirdID, float _shapeMix, float _skinMix, float _thirdMix, bool _isParent)
		{
			unsafe {
				if (fn__setPedHeadBlendData == null) fn__setPedHeadBlendData = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedHeadBlendData");
				fn__setPedHeadBlendData(_ped, _shapeFirstID, _shapeSecondID, _shapeThirdID, _skinFirstID, _skinSecondID, _skinThirdID, _shapeMix, _skinMix, _thirdMix, _isParent);
			}
		}

		public bool GetPedHeadBlendData(int _ped, ref int _headBlendData)
		{
			unsafe {
				if (fn__getPedHeadBlendData == null) fn__getPedHeadBlendData = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getPedHeadBlendData");
				var ref_headBlendData = _headBlendData;
				var result = fn__getPedHeadBlendData(_ped, &ref_headBlendData);
				_headBlendData = ref_headBlendData;
				return result;
			}
		}

		public void UpdatePedHeadBlendData(int _ped, float _shapeMix, float _skinMix, float _thirdMix)
		{
			unsafe {
				if (fn__updatePedHeadBlendData == null) fn__updatePedHeadBlendData = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_updatePedHeadBlendData");
				fn__updatePedHeadBlendData(_ped, _shapeMix, _skinMix, _thirdMix);
			}
		}

		public void SetPedEyeColor(int _ped, int _index)
		{
			unsafe {
				if (fn__setPedEyeColor == null) fn__setPedEyeColor = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedEyeColor");
				fn__setPedEyeColor(_ped, _index);
			}
		}

		public int GetPedEyeColor(int _ped)
		{
			unsafe {
				if (fn__getPedEyeColor == null) fn__getPedEyeColor = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedEyeColor");
				var result = fn__getPedEyeColor(_ped);
				return result;
			}
		}

		public void SetPedHeadOverlay(int _ped, int _overlayID, int _index, float _opacity)
		{
			unsafe {
				if (fn__setPedHeadOverlay == null) fn__setPedHeadOverlay = (delegate* unmanaged[Cdecl]<int, int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedHeadOverlay");
				fn__setPedHeadOverlay(_ped, _overlayID, _index, _opacity);
			}
		}

		public int GetPedHeadOverlayValue(int _ped, int _overlayID)
		{
			unsafe {
				if (fn__getPedHeadOverlayValue == null) fn__getPedHeadOverlayValue = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedHeadOverlayValue");
				var result = fn__getPedHeadOverlayValue(_ped, _overlayID);
				return result;
			}
		}

		public int GetPedHeadOverlayNum(int _overlayID)
		{
			unsafe {
				if (fn__getPedHeadOverlayNum == null) fn__getPedHeadOverlayNum = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedHeadOverlayNum");
				var result = fn__getPedHeadOverlayNum(_overlayID);
				return result;
			}
		}

		public void SetPedHeadOverlayColor(int _ped, int _overlayID, int _colorType, int _colorID, int _secondColorID)
		{
			unsafe {
				if (fn__setPedHeadOverlayColor == null) fn__setPedHeadOverlayColor = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedHeadOverlayColor");
				fn__setPedHeadOverlayColor(_ped, _overlayID, _colorType, _colorID, _secondColorID);
			}
		}

		public void SetPedHairColor(int _ped, int _colorID, int _highlightColorID)
		{
			unsafe {
				if (fn__setPedHairColor == null) fn__setPedHairColor = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedHairColor");
				fn__setPedHairColor(_ped, _colorID, _highlightColorID);
			}
		}

		public int GetNumHairColors()
		{
			unsafe {
				if (fn__getNumHairColors == null) fn__getNumHairColors = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumHairColors");
				var result = fn__getNumHairColors();
				return result;
			}
		}

		public int GetNumMakeupColors()
		{
			unsafe {
				if (fn__getNumMakeupColors == null) fn__getNumMakeupColors = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumMakeupColors");
				var result = fn__getNumMakeupColors();
				return result;
			}
		}

		public void GetPedHairRgbColor(int _hairColorIndex, ref int _outR, ref int _outG, ref int _outB)
		{
			unsafe {
				if (fn__getPedHairRgbColor == null) fn__getPedHairRgbColor = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getPedHairRgbColor");
				var ref_outR = _outR;
				var ref_outG = _outG;
				var ref_outB = _outB;
				fn__getPedHairRgbColor(_hairColorIndex, &ref_outR, &ref_outG, &ref_outB);
				_outR = ref_outR;
				_outG = ref_outG;
				_outB = ref_outB;
			}
		}

		public void GetPedMakeupRgbColor(int _makeupColorIndex, ref int _outR, ref int _outG, ref int _outB)
		{
			unsafe {
				if (fn__getPedMakeupRgbColor == null) fn__getPedMakeupRgbColor = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getPedMakeupRgbColor");
				var ref_outR = _outR;
				var ref_outG = _outG;
				var ref_outB = _outB;
				fn__getPedMakeupRgbColor(_makeupColorIndex, &ref_outR, &ref_outG, &ref_outB);
				_outR = ref_outR;
				_outG = ref_outG;
				_outB = ref_outB;
			}
		}

		public bool IsPedHairColorValid2(int _colorId)
		{
			unsafe {
				if (fn__isPedHairColorValid2 == null) fn__isPedHairColorValid2 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedHairColorValid2");
				var result = fn__isPedHairColorValid2(_colorId);
				return result;
			}
		}

		public int _0xEA9960D07DADCF10(int _p0)
		{
			unsafe {
				if (fn__0xEA9960D07DADCF10 == null) fn__0xEA9960D07DADCF10 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xEA9960D07DADCF10");
				var result = fn__0xEA9960D07DADCF10(_p0);
				return result;
			}
		}

		public bool IsPedLipstickColorValid2(int _colorId)
		{
			unsafe {
				if (fn__isPedLipstickColorValid2 == null) fn__isPedLipstickColorValid2 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedLipstickColorValid2");
				var result = fn__isPedLipstickColorValid2(_colorId);
				return result;
			}
		}

		public bool IsPedBlushColorValid2(int _colorId)
		{
			unsafe {
				if (fn__isPedBlushColorValid2 == null) fn__isPedBlushColorValid2 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedBlushColorValid2");
				var result = fn__isPedBlushColorValid2(_colorId);
				return result;
			}
		}

		public bool IsPedHairColorValid(int _colorID)
		{
			unsafe {
				if (fn__isPedHairColorValid == null) fn__isPedHairColorValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedHairColorValid");
				var result = fn__isPedHairColorValid(_colorID);
				return result;
			}
		}

		public int _0xAAA6A3698A69E048(int _p0)
		{
			unsafe {
				if (fn__0xAAA6A3698A69E048 == null) fn__0xAAA6A3698A69E048 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xAAA6A3698A69E048");
				var result = fn__0xAAA6A3698A69E048(_p0);
				return result;
			}
		}

		public bool IsPedLipstickColorValid(int _colorID)
		{
			unsafe {
				if (fn__isPedLipstickColorValid == null) fn__isPedLipstickColorValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedLipstickColorValid");
				var result = fn__isPedLipstickColorValid(_colorID);
				return result;
			}
		}

		public bool IsPedBlushColorValid(int _colorID)
		{
			unsafe {
				if (fn__isPedBlushColorValid == null) fn__isPedBlushColorValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedBlushColorValid");
				var result = fn__isPedBlushColorValid(_colorID);
				return result;
			}
		}

		public bool IsPedBodyBlemishValid(int _colorId)
		{
			unsafe {
				if (fn__isPedBodyBlemishValid == null) fn__isPedBodyBlemishValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedBodyBlemishValid");
				var result = fn__isPedBodyBlemishValid(_colorId);
				return result;
			}
		}

		public int _0xC56FBF2F228E1DAC(int _modelHash, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xC56FBF2F228E1DAC == null) fn__0xC56FBF2F228E1DAC = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0xC56FBF2F228E1DAC");
				var result = fn__0xC56FBF2F228E1DAC(_modelHash, _p1, _p2);
				return result;
			}
		}

		public void SetPedFaceFeature(int _ped, int _index, float _scale)
		{
			unsafe {
				if (fn__setPedFaceFeature == null) fn__setPedFaceFeature = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedFaceFeature");
				fn__setPedFaceFeature(_ped, _index, _scale);
			}
		}

		public bool HasPedHeadBlendFinished(int _ped)
		{
			unsafe {
				if (fn__hasPedHeadBlendFinished == null) fn__hasPedHeadBlendFinished = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasPedHeadBlendFinished");
				var result = fn__hasPedHeadBlendFinished(_ped);
				return result;
			}
		}

		public void FinalizeHeadBlend(int _ped)
		{
			unsafe {
				if (fn__finalizeHeadBlend == null) fn__finalizeHeadBlend = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_finalizeHeadBlend");
				fn__finalizeHeadBlend(_ped);
			}
		}

		public void SetHeadBlendPaletteColor(int _ped, int _r, int _g, int _b, int _id)
		{
			unsafe {
				if (fn__setHeadBlendPaletteColor == null) fn__setHeadBlendPaletteColor = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setHeadBlendPaletteColor");
				fn__setHeadBlendPaletteColor(_ped, _r, _g, _b, _id);
			}
		}

		public void DisableHeadBlendPaletteColor(int _ped)
		{
			unsafe {
				if (fn__disableHeadBlendPaletteColor == null) fn__disableHeadBlendPaletteColor = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableHeadBlendPaletteColor");
				fn__disableHeadBlendPaletteColor(_ped);
			}
		}

		public int GetPedHeadBlendFirstIndex(int _type)
		{
			unsafe {
				if (fn__getPedHeadBlendFirstIndex == null) fn__getPedHeadBlendFirstIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedHeadBlendFirstIndex");
				var result = fn__getPedHeadBlendFirstIndex(_type);
				return result;
			}
		}

		public int GetPedHeadBlendNumHeads(int _type)
		{
			unsafe {
				if (fn__getPedHeadBlendNumHeads == null) fn__getPedHeadBlendNumHeads = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedHeadBlendNumHeads");
				var result = fn__getPedHeadBlendNumHeads(_type);
				return result;
			}
		}

		public int SetPedPreloadVariationData(int _ped, int _slot, int _drawableId, int _textureId)
		{
			unsafe {
				if (fn__setPedPreloadVariationData == null) fn__setPedPreloadVariationData = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_setPedPreloadVariationData");
				var result = fn__setPedPreloadVariationData(_ped, _slot, _drawableId, _textureId);
				return result;
			}
		}

		public bool HasPedPreloadVariationDataFinished(int _ped)
		{
			unsafe {
				if (fn__hasPedPreloadVariationDataFinished == null) fn__hasPedPreloadVariationDataFinished = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasPedPreloadVariationDataFinished");
				var result = fn__hasPedPreloadVariationDataFinished(_ped);
				return result;
			}
		}

		public void ReleasePedPreloadVariationData(int _ped)
		{
			unsafe {
				if (fn__releasePedPreloadVariationData == null) fn__releasePedPreloadVariationData = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_releasePedPreloadVariationData");
				fn__releasePedPreloadVariationData(_ped);
			}
		}

		public bool SetPedPreloadPropData(int _ped, int _componentId, int _drawableId, int _TextureId)
		{
			unsafe {
				if (fn__setPedPreloadPropData == null) fn__setPedPreloadPropData = (delegate* unmanaged[Cdecl]<int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_setPedPreloadPropData");
				var result = fn__setPedPreloadPropData(_ped, _componentId, _drawableId, _TextureId);
				return result;
			}
		}

		public bool HasPedPreloadPropDataFinished(int _ped)
		{
			unsafe {
				if (fn__hasPedPreloadPropDataFinished == null) fn__hasPedPreloadPropDataFinished = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasPedPreloadPropDataFinished");
				var result = fn__hasPedPreloadPropDataFinished(_ped);
				return result;
			}
		}

		public void ReleasePedPreloadPropData(int _ped)
		{
			unsafe {
				if (fn__releasePedPreloadPropData == null) fn__releasePedPreloadPropData = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_releasePedPreloadPropData");
				fn__releasePedPreloadPropData(_ped);
			}
		}

		public int GetPedPropIndex(int _ped, int _componentId)
		{
			unsafe {
				if (fn__getPedPropIndex == null) fn__getPedPropIndex = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedPropIndex");
				var result = fn__getPedPropIndex(_ped, _componentId);
				return result;
			}
		}

		public void SetPedPropIndex(int _ped, int _componentId, int _drawableId, int _TextureId, bool _attach)
		{
			unsafe {
				if (fn__setPedPropIndex == null) fn__setPedPropIndex = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedPropIndex");
				fn__setPedPropIndex(_ped, _componentId, _drawableId, _TextureId, _attach);
			}
		}

		public void KnockOffPedProp(int _ped, bool _p1, bool _p2, bool _p3, bool _p4)
		{
			unsafe {
				if (fn__knockOffPedProp == null) fn__knockOffPedProp = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_knockOffPedProp");
				fn__knockOffPedProp(_ped, _p1, _p2, _p3, _p4);
			}
		}

		public void ClearPedProp(int _ped, int _propId)
		{
			unsafe {
				if (fn__clearPedProp == null) fn__clearPedProp = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_clearPedProp");
				fn__clearPedProp(_ped, _propId);
			}
		}

		public void ClearAllPedProps(int _ped)
		{
			unsafe {
				if (fn__clearAllPedProps == null) fn__clearAllPedProps = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearAllPedProps");
				fn__clearAllPedProps(_ped);
			}
		}

		public void DropAmbientProp(int _ped)
		{
			unsafe {
				if (fn__dropAmbientProp == null) fn__dropAmbientProp = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_dropAmbientProp");
				fn__dropAmbientProp(_ped);
			}
		}

		public int GetPedPropTextureIndex(int _ped, int _componentId)
		{
			unsafe {
				if (fn__getPedPropTextureIndex == null) fn__getPedPropTextureIndex = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedPropTextureIndex");
				var result = fn__getPedPropTextureIndex(_ped, _componentId);
				return result;
			}
		}

		public void ClearPedParachutePackVariation(int _ped)
		{
			unsafe {
				if (fn__clearPedParachutePackVariation == null) fn__clearPedParachutePackVariation = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedParachutePackVariation");
				fn__clearPedParachutePackVariation(_ped);
			}
		}

		public void SetPedScubaGearVariation(int _ped)
		{
			unsafe {
				if (fn__setPedScubaGearVariation == null) fn__setPedScubaGearVariation = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedScubaGearVariation");
				fn__setPedScubaGearVariation(_ped);
			}
		}

		public void ClearPedScubaGearVariation(int _ped)
		{
			unsafe {
				if (fn__clearPedScubaGearVariation == null) fn__clearPedScubaGearVariation = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedScubaGearVariation");
				fn__clearPedScubaGearVariation(_ped);
			}
		}

		public bool _0xFEC9A3B1820F3331(int _p0)
		{
			unsafe {
				if (fn__0xFEC9A3B1820F3331 == null) fn__0xFEC9A3B1820F3331 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xFEC9A3B1820F3331");
				var result = fn__0xFEC9A3B1820F3331(_p0);
				return result;
			}
		}

		public void SetBlockingOfNonTemporaryEvents(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setBlockingOfNonTemporaryEvents == null) fn__setBlockingOfNonTemporaryEvents = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBlockingOfNonTemporaryEvents");
				fn__setBlockingOfNonTemporaryEvents(_ped, _toggle);
			}
		}

		public void SetPedBoundsOrientation(int _ped, float _p1, float _p2, float _p3, float _p4, float _p5)
		{
			unsafe {
				if (fn__setPedBoundsOrientation == null) fn__setPedBoundsOrientation = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setPedBoundsOrientation");
				fn__setPedBoundsOrientation(_ped, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void RegisterTarget(int _ped, int _target)
		{
			unsafe {
				if (fn__registerTarget == null) fn__registerTarget = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_registerTarget");
				fn__registerTarget(_ped, _target);
			}
		}

		public void RegisterHatedTargetsAroundPed(int _ped, float _radius)
		{
			unsafe {
				if (fn__registerHatedTargetsAroundPed == null) fn__registerHatedTargetsAroundPed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_registerHatedTargetsAroundPed");
				fn__registerHatedTargetsAroundPed(_ped, _radius);
			}
		}

		public int GetRandomPedAtCoord(float _x, float _y, float _z, float _xRadius, float _yRadius, float _zRadius, int _pedType)
		{
			unsafe {
				if (fn__getRandomPedAtCoord == null) fn__getRandomPedAtCoord = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int>) NativeLibrary.GetExport(handle, "Native_getRandomPedAtCoord");
				var result = fn__getRandomPedAtCoord(_x, _y, _z, _xRadius, _yRadius, _zRadius, _pedType);
				return result;
			}
		}

		public bool GetClosestPed(float _x, float _y, float _z, float _radius, bool _p4, bool _p5, ref int _outPed, bool _p7, bool _p8, int _pedType)
		{
			unsafe {
				if (fn__getClosestPed == null) fn__getClosestPed = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool, int*, bool, bool, int, bool>) NativeLibrary.GetExport(handle, "Native_getClosestPed");
				var ref_outPed = _outPed;
				var result = fn__getClosestPed(_x, _y, _z, _radius, _p4, _p5, &ref_outPed, _p7, _p8, _pedType);
				_outPed = ref_outPed;
				return result;
			}
		}

		public void SetScenarioPedsToBeReturnedByNextCommand(bool _value)
		{
			unsafe {
				if (fn__setScenarioPedsToBeReturnedByNextCommand == null) fn__setScenarioPedsToBeReturnedByNextCommand = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setScenarioPedsToBeReturnedByNextCommand");
				fn__setScenarioPedsToBeReturnedByNextCommand(_value);
			}
		}

		public bool _0x03EA03AF85A85CB7(int _ped, bool _p1, bool _p2, bool _p3, bool _p4, bool _p5, bool _p6, bool _p7, int _p8)
		{
			unsafe {
				if (fn__0x03EA03AF85A85CB7 == null) fn__0x03EA03AF85A85CB7 = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, bool, bool, bool, int, bool>) NativeLibrary.GetExport(handle, "Native__0x03EA03AF85A85CB7");
				var result = fn__0x03EA03AF85A85CB7(_ped, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
				return result;
			}
		}

		public void SetDriverRacingModifier(int _driver, float _modifier)
		{
			unsafe {
				if (fn__setDriverRacingModifier == null) fn__setDriverRacingModifier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setDriverRacingModifier");
				fn__setDriverRacingModifier(_driver, _modifier);
			}
		}

		public void SetDriverAbility(int _driver, float _ability)
		{
			unsafe {
				if (fn__setDriverAbility == null) fn__setDriverAbility = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setDriverAbility");
				fn__setDriverAbility(_driver, _ability);
			}
		}

		public void SetDriverAggressiveness(int _driver, float _aggressiveness)
		{
			unsafe {
				if (fn__setDriverAggressiveness == null) fn__setDriverAggressiveness = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setDriverAggressiveness");
				fn__setDriverAggressiveness(_driver, _aggressiveness);
			}
		}

		public bool CanPedRagdoll(int _ped)
		{
			unsafe {
				if (fn__canPedRagdoll == null) fn__canPedRagdoll = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canPedRagdoll");
				var result = fn__canPedRagdoll(_ped);
				return result;
			}
		}

		public bool SetPedToRagdoll(int _ped, int _time1, int _time2, int _ragdollType, bool _p4, bool _p5, bool _p6)
		{
			unsafe {
				if (fn__setPedToRagdoll == null) fn__setPedToRagdoll = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_setPedToRagdoll");
				var result = fn__setPedToRagdoll(_ped, _time1, _time2, _ragdollType, _p4, _p5, _p6);
				return result;
			}
		}

		public bool SetPedToRagdollWithFall(int _ped, int _time, int _p2, int _ragdollType, float _x, float _y, float _z, float _p7, float _p8, float _p9, float _p10, float _p11, float _p12, float _p13)
		{
			unsafe {
				if (fn__setPedToRagdollWithFall == null) fn__setPedToRagdollWithFall = (delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, float, float, float, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_setPedToRagdollWithFall");
				var result = fn__setPedToRagdollWithFall(_ped, _time, _p2, _ragdollType, _x, _y, _z, _p7, _p8, _p9, _p10, _p11, _p12, _p13);
				return result;
			}
		}

		public void SetPedRagdollOnCollision(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedRagdollOnCollision == null) fn__setPedRagdollOnCollision = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedRagdollOnCollision");
				fn__setPedRagdollOnCollision(_ped, _toggle);
			}
		}

		public bool IsPedRagdoll(int _ped)
		{
			unsafe {
				if (fn__isPedRagdoll == null) fn__isPedRagdoll = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedRagdoll");
				var result = fn__isPedRagdoll(_ped);
				return result;
			}
		}

		public bool IsPedRunningRagdollTask(int _ped)
		{
			unsafe {
				if (fn__isPedRunningRagdollTask == null) fn__isPedRunningRagdollTask = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedRunningRagdollTask");
				var result = fn__isPedRunningRagdollTask(_ped);
				return result;
			}
		}

		public void SetPedRagdollForceFall(int _ped)
		{
			unsafe {
				if (fn__setPedRagdollForceFall == null) fn__setPedRagdollForceFall = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedRagdollForceFall");
				fn__setPedRagdollForceFall(_ped);
			}
		}

		public void ResetPedRagdollTimer(int _ped)
		{
			unsafe {
				if (fn__resetPedRagdollTimer == null) fn__resetPedRagdollTimer = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPedRagdollTimer");
				fn__resetPedRagdollTimer(_ped);
			}
		}

		public void SetPedCanRagdoll(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanRagdoll == null) fn__setPedCanRagdoll = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanRagdoll");
				fn__setPedCanRagdoll(_ped, _toggle);
			}
		}

		public bool IsPedRunningMeleeTask(int _ped)
		{
			unsafe {
				if (fn__isPedRunningMeleeTask == null) fn__isPedRunningMeleeTask = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedRunningMeleeTask");
				var result = fn__isPedRunningMeleeTask(_ped);
				return result;
			}
		}

		public bool IsPedRunningMobilePhoneTask(int _ped)
		{
			unsafe {
				if (fn__isPedRunningMobilePhoneTask == null) fn__isPedRunningMobilePhoneTask = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedRunningMobilePhoneTask");
				var result = fn__isPedRunningMobilePhoneTask(_ped);
				return result;
			}
		}

		public bool IsMobilePhoneToPedEar(int _ped)
		{
			unsafe {
				if (fn__isMobilePhoneToPedEar == null) fn__isMobilePhoneToPedEar = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMobilePhoneToPedEar");
				var result = fn__isMobilePhoneToPedEar(_ped);
				return result;
			}
		}

		public void SetRagdollBlockingFlags(int _ped, int _flags)
		{
			unsafe {
				if (fn__setRagdollBlockingFlags == null) fn__setRagdollBlockingFlags = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setRagdollBlockingFlags");
				fn__setRagdollBlockingFlags(_ped, _flags);
			}
		}

		public void ClearRagdollBlockingFlags(int _ped, int _flags)
		{
			unsafe {
				if (fn__clearRagdollBlockingFlags == null) fn__clearRagdollBlockingFlags = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_clearRagdollBlockingFlags");
				fn__clearRagdollBlockingFlags(_ped, _flags);
			}
		}

		public void SetPedAngledDefensiveArea(int _ped, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, bool _p8, bool _p9)
		{
			unsafe {
				if (fn__setPedAngledDefensiveArea == null) fn__setPedAngledDefensiveArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAngledDefensiveArea");
				fn__setPedAngledDefensiveArea(_ped, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void SetPedSphereDefensiveArea(int _ped, float _x, float _y, float _z, float _radius, bool _p5, bool _p6)
		{
			unsafe {
				if (fn__setPedSphereDefensiveArea == null) fn__setPedSphereDefensiveArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedSphereDefensiveArea");
				fn__setPedSphereDefensiveArea(_ped, _x, _y, _z, _radius, _p5, _p6);
			}
		}

		public void SetPedDefensiveSphereAttachedToPed(int _ped, int _target, float _xOffset, float _yOffset, float _zOffset, float _radius, bool _p6)
		{
			unsafe {
				if (fn__setPedDefensiveSphereAttachedToPed == null) fn__setPedDefensiveSphereAttachedToPed = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDefensiveSphereAttachedToPed");
				fn__setPedDefensiveSphereAttachedToPed(_ped, _target, _xOffset, _yOffset, _zOffset, _radius, _p6);
			}
		}

		public void SetPedDefensiveSphereAttachedToVehicle(int _ped, int _target, float _xOffset, float _yOffset, float _zOffset, float _radius, bool _p6)
		{
			unsafe {
				if (fn__setPedDefensiveSphereAttachedToVehicle == null) fn__setPedDefensiveSphereAttachedToVehicle = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDefensiveSphereAttachedToVehicle");
				fn__setPedDefensiveSphereAttachedToVehicle(_ped, _target, _xOffset, _yOffset, _zOffset, _radius, _p6);
			}
		}

		public void SetPedDefensiveAreaAttachedToPed(int _ped, int _attachPed, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, float _p8, bool _p9, bool _p10)
		{
			unsafe {
				if (fn__setPedDefensiveAreaAttachedToPed == null) fn__setPedDefensiveAreaAttachedToPed = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDefensiveAreaAttachedToPed");
				fn__setPedDefensiveAreaAttachedToPed(_ped, _attachPed, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10);
			}
		}

		public void SetPedDefensiveAreaDirection(int _ped, float _p1, float _p2, float _p3, bool _p4)
		{
			unsafe {
				if (fn__setPedDefensiveAreaDirection == null) fn__setPedDefensiveAreaDirection = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDefensiveAreaDirection");
				fn__setPedDefensiveAreaDirection(_ped, _p1, _p2, _p3, _p4);
			}
		}

		public void RemovePedDefensiveArea(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__removePedDefensiveArea == null) fn__removePedDefensiveArea = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removePedDefensiveArea");
				fn__removePedDefensiveArea(_ped, _toggle);
			}
		}

		public Vector3 GetPedDefensiveAreaPosition(int _ped, bool _p1)
		{
			unsafe {
				if (fn__getPedDefensiveAreaPosition == null) fn__getPedDefensiveAreaPosition = (delegate* unmanaged[Cdecl]<int, bool, Vector3>) NativeLibrary.GetExport(handle, "Native_getPedDefensiveAreaPosition");
				var result = fn__getPedDefensiveAreaPosition(_ped, _p1);
				return result;
			}
		}

		public bool IsPedDefensiveAreaActive(int _ped, bool _p1)
		{
			unsafe {
				if (fn__isPedDefensiveAreaActive == null) fn__isPedDefensiveAreaActive = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isPedDefensiveAreaActive");
				var result = fn__isPedDefensiveAreaActive(_ped, _p1);
				return result;
			}
		}

		public void SetPedPreferredCoverSet(int _ped, int _itemSet)
		{
			unsafe {
				if (fn__setPedPreferredCoverSet == null) fn__setPedPreferredCoverSet = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedPreferredCoverSet");
				fn__setPedPreferredCoverSet(_ped, _itemSet);
			}
		}

		public void RemovePedPreferredCoverSet(int _ped)
		{
			unsafe {
				if (fn__removePedPreferredCoverSet == null) fn__removePedPreferredCoverSet = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removePedPreferredCoverSet");
				fn__removePedPreferredCoverSet(_ped);
			}
		}

		public void ReviveInjuredPed(int _ped)
		{
			unsafe {
				if (fn__reviveInjuredPed == null) fn__reviveInjuredPed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_reviveInjuredPed");
				fn__reviveInjuredPed(_ped);
			}
		}

		public void ResurrectPed(int _ped)
		{
			unsafe {
				if (fn__resurrectPed == null) fn__resurrectPed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resurrectPed");
				fn__resurrectPed(_ped);
			}
		}

		public void SetPedNameDebug(int _ped, string _name)
		{
			unsafe {
				if (fn__setPedNameDebug == null) fn__setPedNameDebug = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setPedNameDebug");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setPedNameDebug(_ped, ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public Vector3 GetPedExtractedDisplacement(int _ped, bool _worldSpace)
		{
			unsafe {
				if (fn__getPedExtractedDisplacement == null) fn__getPedExtractedDisplacement = (delegate* unmanaged[Cdecl]<int, bool, Vector3>) NativeLibrary.GetExport(handle, "Native_getPedExtractedDisplacement");
				var result = fn__getPedExtractedDisplacement(_ped, _worldSpace);
				return result;
			}
		}

		public void SetPedDiesWhenInjured(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedDiesWhenInjured == null) fn__setPedDiesWhenInjured = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDiesWhenInjured");
				fn__setPedDiesWhenInjured(_ped, _toggle);
			}
		}

		public void SetPedEnableWeaponBlocking(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedEnableWeaponBlocking == null) fn__setPedEnableWeaponBlocking = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedEnableWeaponBlocking");
				fn__setPedEnableWeaponBlocking(_ped, _toggle);
			}
		}

		public void _0xF9ACF4A08098EA25(int _ped, bool _p1)
		{
			unsafe {
				if (fn__0xF9ACF4A08098EA25 == null) fn__0xF9ACF4A08098EA25 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xF9ACF4A08098EA25");
				fn__0xF9ACF4A08098EA25(_ped, _p1);
			}
		}

		public void ResetPedVisibleDamage(int _ped)
		{
			unsafe {
				if (fn__resetPedVisibleDamage == null) fn__resetPedVisibleDamage = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPedVisibleDamage");
				fn__resetPedVisibleDamage(_ped);
			}
		}

		public void ApplyPedBloodDamageByZone(int _ped, int _p1, float _p2, float _p3, int _p4)
		{
			unsafe {
				if (fn__applyPedBloodDamageByZone == null) fn__applyPedBloodDamageByZone = (delegate* unmanaged[Cdecl]<int, int, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_applyPedBloodDamageByZone");
				fn__applyPedBloodDamageByZone(_ped, _p1, _p2, _p3, _p4);
			}
		}

		public void ApplyPedBlood(int _ped, int _boneIndex, float _xRot, float _yRot, float _zRot, string _woundType)
		{
			unsafe {
				if (fn__applyPedBlood == null) fn__applyPedBlood = (delegate* unmanaged[Cdecl]<int, int, float, float, float, nint, void>) NativeLibrary.GetExport(handle, "Native_applyPedBlood");
				var ptr_woundType = MemoryUtils.StringToHGlobalUtf8(_woundType);
				fn__applyPedBlood(_ped, _boneIndex, _xRot, _yRot, _zRot, ptr_woundType);
				Marshal.FreeHGlobal(ptr_woundType);
			}
		}

		public void ApplyPedBloodByZone(int _ped, int _p1, float _p2, float _p3, string _p4)
		{
			unsafe {
				if (fn__applyPedBloodByZone == null) fn__applyPedBloodByZone = (delegate* unmanaged[Cdecl]<int, int, float, float, nint, void>) NativeLibrary.GetExport(handle, "Native_applyPedBloodByZone");
				var ptr_p4 = MemoryUtils.StringToHGlobalUtf8(_p4);
				fn__applyPedBloodByZone(_ped, _p1, _p2, _p3, ptr_p4);
				Marshal.FreeHGlobal(ptr_p4);
			}
		}

		public void ApplyPedBloodSpecific(int _ped, int _p1, float _p2, float _p3, float _p4, float _p5, int _p6, float _p7, string _p8)
		{
			unsafe {
				if (fn__applyPedBloodSpecific == null) fn__applyPedBloodSpecific = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, nint, void>) NativeLibrary.GetExport(handle, "Native_applyPedBloodSpecific");
				var ptr_p8 = MemoryUtils.StringToHGlobalUtf8(_p8);
				fn__applyPedBloodSpecific(_ped, _p1, _p2, _p3, _p4, _p5, _p6, _p7, ptr_p8);
				Marshal.FreeHGlobal(ptr_p8);
			}
		}

		public void ApplyPedDamageDecal(int _ped, int _damageZone, float _xOffset, float _yOffset, float _heading, float _scale, float _alpha, int _unkVariation, bool _fadeIn, string _decalName)
		{
			unsafe {
				if (fn__applyPedDamageDecal == null) fn__applyPedDamageDecal = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, int, bool, nint, void>) NativeLibrary.GetExport(handle, "Native_applyPedDamageDecal");
				var ptr_decalName = MemoryUtils.StringToHGlobalUtf8(_decalName);
				fn__applyPedDamageDecal(_ped, _damageZone, _xOffset, _yOffset, _heading, _scale, _alpha, _unkVariation, _fadeIn, ptr_decalName);
				Marshal.FreeHGlobal(ptr_decalName);
			}
		}

		public void ApplyPedDamagePack(int _ped, string _damagePack, float _damage, float _mult)
		{
			unsafe {
				if (fn__applyPedDamagePack == null) fn__applyPedDamagePack = (delegate* unmanaged[Cdecl]<int, nint, float, float, void>) NativeLibrary.GetExport(handle, "Native_applyPedDamagePack");
				var ptr_damagePack = MemoryUtils.StringToHGlobalUtf8(_damagePack);
				fn__applyPedDamagePack(_ped, ptr_damagePack, _damage, _mult);
				Marshal.FreeHGlobal(ptr_damagePack);
			}
		}

		public void ClearPedBloodDamage(int _ped)
		{
			unsafe {
				if (fn__clearPedBloodDamage == null) fn__clearPedBloodDamage = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedBloodDamage");
				fn__clearPedBloodDamage(_ped);
			}
		}

		public void ClearPedBloodDamageByZone(int _ped, int _p1)
		{
			unsafe {
				if (fn__clearPedBloodDamageByZone == null) fn__clearPedBloodDamageByZone = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_clearPedBloodDamageByZone");
				fn__clearPedBloodDamageByZone(_ped, _p1);
			}
		}

		public void HidePedBloodDamageByZone(int _ped, int _p1, bool _p2)
		{
			unsafe {
				if (fn__hidePedBloodDamageByZone == null) fn__hidePedBloodDamageByZone = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_hidePedBloodDamageByZone");
				fn__hidePedBloodDamageByZone(_ped, _p1, _p2);
			}
		}

		public void ClearPedDamageDecalByZone(int _ped, int _p1, string _p2)
		{
			unsafe {
				if (fn__clearPedDamageDecalByZone == null) fn__clearPedDamageDecalByZone = (delegate* unmanaged[Cdecl]<int, int, nint, void>) NativeLibrary.GetExport(handle, "Native_clearPedDamageDecalByZone");
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				fn__clearPedDamageDecalByZone(_ped, _p1, ptr_p2);
				Marshal.FreeHGlobal(ptr_p2);
			}
		}

		public int GetPedDecorationsState(int _ped)
		{
			unsafe {
				if (fn__getPedDecorationsState == null) fn__getPedDecorationsState = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedDecorationsState");
				var result = fn__getPedDecorationsState(_ped);
				return result;
			}
		}

		public void _0x2B694AFCF64E6994(int _ped, bool _p1)
		{
			unsafe {
				if (fn__0x2B694AFCF64E6994 == null) fn__0x2B694AFCF64E6994 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x2B694AFCF64E6994");
				fn__0x2B694AFCF64E6994(_ped, _p1);
			}
		}

		public void ClearPedWetness(int _ped)
		{
			unsafe {
				if (fn__clearPedWetness == null) fn__clearPedWetness = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedWetness");
				fn__clearPedWetness(_ped);
			}
		}

		public void SetPedWetnessHeight(int _ped, float _height)
		{
			unsafe {
				if (fn__setPedWetnessHeight == null) fn__setPedWetnessHeight = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedWetnessHeight");
				fn__setPedWetnessHeight(_ped, _height);
			}
		}

		public void SetPedWetnessEnabledThisFrame(int _ped)
		{
			unsafe {
				if (fn__setPedWetnessEnabledThisFrame == null) fn__setPedWetnessEnabledThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedWetnessEnabledThisFrame");
				fn__setPedWetnessEnabledThisFrame(_ped);
			}
		}

		public void ClearPedEnvDirt(int _ped)
		{
			unsafe {
				if (fn__clearPedEnvDirt == null) fn__clearPedEnvDirt = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedEnvDirt");
				fn__clearPedEnvDirt(_ped);
			}
		}

		public void SetPedSweat(int _ped, float _sweat)
		{
			unsafe {
				if (fn__setPedSweat == null) fn__setPedSweat = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedSweat");
				fn__setPedSweat(_ped, _sweat);
			}
		}

		public void AddPedDecorationFromHashes(int _ped, int _collection, int _overlay)
		{
			unsafe {
				if (fn__addPedDecorationFromHashes == null) fn__addPedDecorationFromHashes = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_addPedDecorationFromHashes");
				fn__addPedDecorationFromHashes(_ped, _collection, _overlay);
			}
		}

		public void AddPedDecorationFromHashesInCorona(int _ped, int _collection, int _overlay)
		{
			unsafe {
				if (fn__addPedDecorationFromHashesInCorona == null) fn__addPedDecorationFromHashesInCorona = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_addPedDecorationFromHashesInCorona");
				fn__addPedDecorationFromHashesInCorona(_ped, _collection, _overlay);
			}
		}

		public int GetPedDecorationZoneFromHashes(int _collection, int _overlay)
		{
			unsafe {
				if (fn__getPedDecorationZoneFromHashes == null) fn__getPedDecorationZoneFromHashes = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedDecorationZoneFromHashes");
				var result = fn__getPedDecorationZoneFromHashes(_collection, _overlay);
				return result;
			}
		}

		public void ClearPedDecorations(int _ped)
		{
			unsafe {
				if (fn__clearPedDecorations == null) fn__clearPedDecorations = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedDecorations");
				fn__clearPedDecorations(_ped);
			}
		}

		public void ClearPedDecorationsLeaveScars(int _ped)
		{
			unsafe {
				if (fn__clearPedDecorationsLeaveScars == null) fn__clearPedDecorationsLeaveScars = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedDecorationsLeaveScars");
				fn__clearPedDecorationsLeaveScars(_ped);
			}
		}

		public bool WasPedSkeletonUpdated(int _ped)
		{
			unsafe {
				if (fn__wasPedSkeletonUpdated == null) fn__wasPedSkeletonUpdated = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_wasPedSkeletonUpdated");
				var result = fn__wasPedSkeletonUpdated(_ped);
				return result;
			}
		}

		public Vector3 GetPedBoneCoords(int _ped, int _boneId, float _offsetX, float _offsetY, float _offsetZ)
		{
			unsafe {
				if (fn__getPedBoneCoords == null) fn__getPedBoneCoords = (delegate* unmanaged[Cdecl]<int, int, float, float, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getPedBoneCoords");
				var result = fn__getPedBoneCoords(_ped, _boneId, _offsetX, _offsetY, _offsetZ);
				return result;
			}
		}

		public void CreateNmMessage(bool _startImmediately, int _messageId)
		{
			unsafe {
				if (fn__createNmMessage == null) fn__createNmMessage = (delegate* unmanaged[Cdecl]<bool, int, void>) NativeLibrary.GetExport(handle, "Native_createNmMessage");
				fn__createNmMessage(_startImmediately, _messageId);
			}
		}

		public void GivePedNmMessage(int _ped)
		{
			unsafe {
				if (fn__givePedNmMessage == null) fn__givePedNmMessage = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_givePedNmMessage");
				fn__givePedNmMessage(_ped);
			}
		}

		public int AddScenarioBlockingArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _p6, bool _p7, bool _p8, bool _p9)
		{
			unsafe {
				if (fn__addScenarioBlockingArea == null) fn__addScenarioBlockingArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_addScenarioBlockingArea");
				var result = fn__addScenarioBlockingArea(_x1, _y1, _z1, _x2, _y2, _z2, _p6, _p7, _p8, _p9);
				return result;
			}
		}

		public void RemoveScenarioBlockingAreas()
		{
			unsafe {
				if (fn__removeScenarioBlockingAreas == null) fn__removeScenarioBlockingAreas = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeScenarioBlockingAreas");
				fn__removeScenarioBlockingAreas();
			}
		}

		public void RemoveScenarioBlockingArea(int _p0, bool _p1)
		{
			unsafe {
				if (fn__removeScenarioBlockingArea == null) fn__removeScenarioBlockingArea = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removeScenarioBlockingArea");
				fn__removeScenarioBlockingArea(_p0, _p1);
			}
		}

		public void SetScenarioPedsSpawnInSphereArea(float _x, float _y, float _z, float _range, int _p4)
		{
			unsafe {
				if (fn__setScenarioPedsSpawnInSphereArea == null) fn__setScenarioPedsSpawnInSphereArea = (delegate* unmanaged[Cdecl]<float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setScenarioPedsSpawnInSphereArea");
				fn__setScenarioPedsSpawnInSphereArea(_x, _y, _z, _range, _p4);
			}
		}

		public bool DoesScenarioBlockingAreaExist(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__doesScenarioBlockingAreaExist == null) fn__doesScenarioBlockingAreaExist = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_doesScenarioBlockingAreaExist");
				var result = fn__doesScenarioBlockingAreaExist(_x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public bool IsPedUsingScenario(int _ped, string _scenario)
		{
			unsafe {
				if (fn__isPedUsingScenario == null) fn__isPedUsingScenario = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_isPedUsingScenario");
				var ptr_scenario = MemoryUtils.StringToHGlobalUtf8(_scenario);
				var result = fn__isPedUsingScenario(_ped, ptr_scenario);
				Marshal.FreeHGlobal(ptr_scenario);
				return result;
			}
		}

		public bool IsPedUsingAnyScenario(int _ped)
		{
			unsafe {
				if (fn__isPedUsingAnyScenario == null) fn__isPedUsingAnyScenario = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedUsingAnyScenario");
				var result = fn__isPedUsingAnyScenario(_ped);
				return result;
			}
		}

		public int SetPedPanicExitScenario(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__setPedPanicExitScenario == null) fn__setPedPanicExitScenario = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_setPedPanicExitScenario");
				var result = fn__setPedPanicExitScenario(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public void _0x9A77DFD295E29B09(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0x9A77DFD295E29B09 == null) fn__0x9A77DFD295E29B09 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x9A77DFD295E29B09");
				fn__0x9A77DFD295E29B09(_p0, _p1);
			}
		}

		public int _0x25361A96E0F7E419(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x25361A96E0F7E419 == null) fn__0x25361A96E0F7E419 = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native__0x25361A96E0F7E419");
				var result = fn__0x25361A96E0F7E419(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public int SetPedShouldPlayDirectedScenarioExit(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__setPedShouldPlayDirectedScenarioExit == null) fn__setPedShouldPlayDirectedScenarioExit = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_setPedShouldPlayDirectedScenarioExit");
				var result = fn__setPedShouldPlayDirectedScenarioExit(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public void SetPedShouldPlayNormalScenarioExit(int _ped)
		{
			unsafe {
				if (fn__setPedShouldPlayNormalScenarioExit == null) fn__setPedShouldPlayNormalScenarioExit = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedShouldPlayNormalScenarioExit");
				fn__setPedShouldPlayNormalScenarioExit(_ped);
			}
		}

		public void SetPedShouldPlayImmediateScenarioExit(int _ped)
		{
			unsafe {
				if (fn__setPedShouldPlayImmediateScenarioExit == null) fn__setPedShouldPlayImmediateScenarioExit = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedShouldPlayImmediateScenarioExit");
				fn__setPedShouldPlayImmediateScenarioExit(_ped);
			}
		}

		public int SetPedShouldPlayFleeScenarioExit(int _ped, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__setPedShouldPlayFleeScenarioExit == null) fn__setPedShouldPlayFleeScenarioExit = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_setPedShouldPlayFleeScenarioExit");
				var result = fn__setPedShouldPlayFleeScenarioExit(_ped, _p1, _p2, _p3);
				return result;
			}
		}

		public void _0x425AECF167663F48(int _ped, bool _p1)
		{
			unsafe {
				if (fn__0x425AECF167663F48 == null) fn__0x425AECF167663F48 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x425AECF167663F48");
				fn__0x425AECF167663F48(_ped, _p1);
			}
		}

		public void _0x5B6010B3CBC29095(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0x5B6010B3CBC29095 == null) fn__0x5B6010B3CBC29095 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x5B6010B3CBC29095");
				fn__0x5B6010B3CBC29095(_p0, _p1);
			}
		}

		public void _0xCEDA60A74219D064(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0xCEDA60A74219D064 == null) fn__0xCEDA60A74219D064 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xCEDA60A74219D064");
				fn__0xCEDA60A74219D064(_p0, _p1);
			}
		}

		public int _0xC30BDAEE47256C13(int _p0)
		{
			unsafe {
				if (fn__0xC30BDAEE47256C13 == null) fn__0xC30BDAEE47256C13 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xC30BDAEE47256C13");
				var result = fn__0xC30BDAEE47256C13(_p0);
				return result;
			}
		}

		public void PlayFacialAnim(int _ped, string _animName, string _animDict)
		{
			unsafe {
				if (fn__playFacialAnim == null) fn__playFacialAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_playFacialAnim");
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				fn__playFacialAnim(_ped, ptr_animName, ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				Marshal.FreeHGlobal(ptr_animDict);
			}
		}

		public void SetFacialClipsetOverride(int _ped, string _animDict)
		{
			unsafe {
				if (fn__setFacialClipsetOverride == null) fn__setFacialClipsetOverride = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setFacialClipsetOverride");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				fn__setFacialClipsetOverride(_ped, ptr_animDict);
				Marshal.FreeHGlobal(ptr_animDict);
			}
		}

		public void SetFacialIdleAnimOverride(int _ped, string _animName, string _animDict)
		{
			unsafe {
				if (fn__setFacialIdleAnimOverride == null) fn__setFacialIdleAnimOverride = (delegate* unmanaged[Cdecl]<int, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_setFacialIdleAnimOverride");
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				fn__setFacialIdleAnimOverride(_ped, ptr_animName, ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
				Marshal.FreeHGlobal(ptr_animDict);
			}
		}

		public void ClearFacialIdleAnimOverride(int _ped)
		{
			unsafe {
				if (fn__clearFacialIdleAnimOverride == null) fn__clearFacialIdleAnimOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearFacialIdleAnimOverride");
				fn__clearFacialIdleAnimOverride(_ped);
			}
		}

		public void SetPedCanPlayGestureAnims(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanPlayGestureAnims == null) fn__setPedCanPlayGestureAnims = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanPlayGestureAnims");
				fn__setPedCanPlayGestureAnims(_ped, _toggle);
			}
		}

		public void SetPedCanPlayVisemeAnims(int _ped, bool _toggle, bool _p2)
		{
			unsafe {
				if (fn__setPedCanPlayVisemeAnims == null) fn__setPedCanPlayVisemeAnims = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanPlayVisemeAnims");
				fn__setPedCanPlayVisemeAnims(_ped, _toggle, _p2);
			}
		}

		public void SetPedCanPlayInjuredAnims(int _ped, bool _p1)
		{
			unsafe {
				if (fn__setPedCanPlayInjuredAnims == null) fn__setPedCanPlayInjuredAnims = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanPlayInjuredAnims");
				fn__setPedCanPlayInjuredAnims(_ped, _p1);
			}
		}

		public void SetPedCanPlayAmbientAnims(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanPlayAmbientAnims == null) fn__setPedCanPlayAmbientAnims = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanPlayAmbientAnims");
				fn__setPedCanPlayAmbientAnims(_ped, _toggle);
			}
		}

		public void SetPedCanPlayAmbientBaseAnims(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanPlayAmbientBaseAnims == null) fn__setPedCanPlayAmbientBaseAnims = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanPlayAmbientBaseAnims");
				fn__setPedCanPlayAmbientBaseAnims(_ped, _toggle);
			}
		}

		public void _0xC2EE020F5FB4DB53(int _ped)
		{
			unsafe {
				if (fn__0xC2EE020F5FB4DB53 == null) fn__0xC2EE020F5FB4DB53 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC2EE020F5FB4DB53");
				fn__0xC2EE020F5FB4DB53(_ped);
			}
		}

		public void SetPedCanArmIk(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanArmIk == null) fn__setPedCanArmIk = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanArmIk");
				fn__setPedCanArmIk(_ped, _toggle);
			}
		}

		public void SetPedCanHeadIk(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanHeadIk == null) fn__setPedCanHeadIk = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanHeadIk");
				fn__setPedCanHeadIk(_ped, _toggle);
			}
		}

		public void SetPedCanLegIk(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanLegIk == null) fn__setPedCanLegIk = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanLegIk");
				fn__setPedCanLegIk(_ped, _toggle);
			}
		}

		public void SetPedCanTorsoIk(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanTorsoIk == null) fn__setPedCanTorsoIk = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanTorsoIk");
				fn__setPedCanTorsoIk(_ped, _toggle);
			}
		}

		public void SetPedCanTorsoReactIk(int _ped, bool _p1)
		{
			unsafe {
				if (fn__setPedCanTorsoReactIk == null) fn__setPedCanTorsoReactIk = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanTorsoReactIk");
				fn__setPedCanTorsoReactIk(_ped, _p1);
			}
		}

		public void _0x6647C5F6F5792496(int _ped, bool _p1)
		{
			unsafe {
				if (fn__0x6647C5F6F5792496 == null) fn__0x6647C5F6F5792496 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x6647C5F6F5792496");
				fn__0x6647C5F6F5792496(_ped, _p1);
			}
		}

		public void SetPedCanUseAutoConversationLookat(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanUseAutoConversationLookat == null) fn__setPedCanUseAutoConversationLookat = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanUseAutoConversationLookat");
				fn__setPedCanUseAutoConversationLookat(_ped, _toggle);
			}
		}

		public bool IsPedHeadtrackingPed(int _ped1, int _ped2)
		{
			unsafe {
				if (fn__isPedHeadtrackingPed == null) fn__isPedHeadtrackingPed = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedHeadtrackingPed");
				var result = fn__isPedHeadtrackingPed(_ped1, _ped2);
				return result;
			}
		}

		public bool IsPedHeadtrackingEntity(int _ped, int _entity)
		{
			unsafe {
				if (fn__isPedHeadtrackingEntity == null) fn__isPedHeadtrackingEntity = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedHeadtrackingEntity");
				var result = fn__isPedHeadtrackingEntity(_ped, _entity);
				return result;
			}
		}

		public void SetPedPrimaryLookat(int _ped, int _lookAt)
		{
			unsafe {
				if (fn__setPedPrimaryLookat == null) fn__setPedPrimaryLookat = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedPrimaryLookat");
				fn__setPedPrimaryLookat(_ped, _lookAt);
			}
		}

		public void SetPedClothPackageIndex(int _p0, int _p1)
		{
			unsafe {
				if (fn__setPedClothPackageIndex == null) fn__setPedClothPackageIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedClothPackageIndex");
				fn__setPedClothPackageIndex(_p0, _p1);
			}
		}

		public void SetPedClothProne(int _p0, int _p1)
		{
			unsafe {
				if (fn__setPedClothProne == null) fn__setPedClothProne = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedClothProne");
				fn__setPedClothProne(_p0, _p1);
			}
		}

		public void _0xA660FAF550EB37E5(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0xA660FAF550EB37E5 == null) fn__0xA660FAF550EB37E5 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xA660FAF550EB37E5");
				fn__0xA660FAF550EB37E5(_p0, _p1);
			}
		}

		public void SetPedConfigFlag(int _ped, int _flagId, bool _value)
		{
			unsafe {
				if (fn__setPedConfigFlag == null) fn__setPedConfigFlag = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedConfigFlag");
				fn__setPedConfigFlag(_ped, _flagId, _value);
			}
		}

		public void SetPedResetFlag(int _ped, int _flagId, bool _doReset)
		{
			unsafe {
				if (fn__setPedResetFlag == null) fn__setPedResetFlag = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedResetFlag");
				fn__setPedResetFlag(_ped, _flagId, _doReset);
			}
		}

		public bool GetPedConfigFlag(int _ped, int _flagId, bool _p2)
		{
			unsafe {
				if (fn__getPedConfigFlag == null) fn__getPedConfigFlag = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_getPedConfigFlag");
				var result = fn__getPedConfigFlag(_ped, _flagId, _p2);
				return result;
			}
		}

		public bool GetPedResetFlag(int _ped, int _flagId)
		{
			unsafe {
				if (fn__getPedResetFlag == null) fn__getPedResetFlag = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_getPedResetFlag");
				var result = fn__getPedResetFlag(_ped, _flagId);
				return result;
			}
		}

		public void SetPedGroupMemberPassengerIndex(int _ped, int _index)
		{
			unsafe {
				if (fn__setPedGroupMemberPassengerIndex == null) fn__setPedGroupMemberPassengerIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedGroupMemberPassengerIndex");
				fn__setPedGroupMemberPassengerIndex(_ped, _index);
			}
		}

		public void SetPedCanEvasiveDive(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanEvasiveDive == null) fn__setPedCanEvasiveDive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanEvasiveDive");
				fn__setPedCanEvasiveDive(_ped, _toggle);
			}
		}

		public bool IsPedEvasiveDiving(int _ped, ref int _evadingEntity)
		{
			unsafe {
				if (fn__isPedEvasiveDiving == null) fn__isPedEvasiveDiving = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_isPedEvasiveDiving");
				var ref_evadingEntity = _evadingEntity;
				var result = fn__isPedEvasiveDiving(_ped, &ref_evadingEntity);
				_evadingEntity = ref_evadingEntity;
				return result;
			}
		}

		public void SetPedShootsAtCoord(int _ped, float _x, float _y, float _z, bool _toggle)
		{
			unsafe {
				if (fn__setPedShootsAtCoord == null) fn__setPedShootsAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedShootsAtCoord");
				fn__setPedShootsAtCoord(_ped, _x, _y, _z, _toggle);
			}
		}

		public void SetPedModelIsSuppressed(int _modelHash, bool _toggle)
		{
			unsafe {
				if (fn__setPedModelIsSuppressed == null) fn__setPedModelIsSuppressed = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedModelIsSuppressed");
				fn__setPedModelIsSuppressed(_modelHash, _toggle);
			}
		}

		public void StopAnyPedModelBeingSuppressed()
		{
			unsafe {
				if (fn__stopAnyPedModelBeingSuppressed == null) fn__stopAnyPedModelBeingSuppressed = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopAnyPedModelBeingSuppressed");
				fn__stopAnyPedModelBeingSuppressed();
			}
		}

		public void SetPedCanBeTargetedWhenInjured(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanBeTargetedWhenInjured == null) fn__setPedCanBeTargetedWhenInjured = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanBeTargetedWhenInjured");
				fn__setPedCanBeTargetedWhenInjured(_ped, _toggle);
			}
		}

		public void SetPedGeneratesDeadBodyEvents(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedGeneratesDeadBodyEvents == null) fn__setPedGeneratesDeadBodyEvents = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedGeneratesDeadBodyEvents");
				fn__setPedGeneratesDeadBodyEvents(_ped, _toggle);
			}
		}

		public void BlockPedDeadBodyShockingEvents(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__blockPedDeadBodyShockingEvents == null) fn__blockPedDeadBodyShockingEvents = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_blockPedDeadBodyShockingEvents");
				fn__blockPedDeadBodyShockingEvents(_ped, _toggle);
			}
		}

		public void _0x3E9679C1DFCF422C(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x3E9679C1DFCF422C == null) fn__0x3E9679C1DFCF422C = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x3E9679C1DFCF422C");
				fn__0x3E9679C1DFCF422C(_p0, _p1);
			}
		}

		public void SetPedCanRagdollFromPlayerImpact(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanRagdollFromPlayerImpact == null) fn__setPedCanRagdollFromPlayerImpact = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanRagdollFromPlayerImpact");
				fn__setPedCanRagdollFromPlayerImpact(_ped, _toggle);
			}
		}

		public void GivePedHelmet(int _ped, bool _cannotRemove, int _helmetFlag, int _textureIndex)
		{
			unsafe {
				if (fn__givePedHelmet == null) fn__givePedHelmet = (delegate* unmanaged[Cdecl]<int, bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_givePedHelmet");
				fn__givePedHelmet(_ped, _cannotRemove, _helmetFlag, _textureIndex);
			}
		}

		public void RemovePedHelmet(int _ped, bool _instantly)
		{
			unsafe {
				if (fn__removePedHelmet == null) fn__removePedHelmet = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removePedHelmet");
				fn__removePedHelmet(_ped, _instantly);
			}
		}

		public bool IsPedTakingOffHelmet(int _ped)
		{
			unsafe {
				if (fn__isPedTakingOffHelmet == null) fn__isPedTakingOffHelmet = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedTakingOffHelmet");
				var result = fn__isPedTakingOffHelmet(_ped);
				return result;
			}
		}

		public void SetPedHelmet(int _ped, bool _canWearHelmet)
		{
			unsafe {
				if (fn__setPedHelmet == null) fn__setPedHelmet = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedHelmet");
				fn__setPedHelmet(_ped, _canWearHelmet);
			}
		}

		public void SetPedHelmetFlag(int _ped, int _helmetFlag)
		{
			unsafe {
				if (fn__setPedHelmetFlag == null) fn__setPedHelmetFlag = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedHelmetFlag");
				fn__setPedHelmetFlag(_ped, _helmetFlag);
			}
		}

		public void SetPedHelmetPropIndex(int _ped, int _propIndex, bool _p2)
		{
			unsafe {
				if (fn__setPedHelmetPropIndex == null) fn__setPedHelmetPropIndex = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedHelmetPropIndex");
				fn__setPedHelmetPropIndex(_ped, _propIndex, _p2);
			}
		}

		public void SetPedHelmetUnk(int _ped, bool _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__setPedHelmetUnk == null) fn__setPedHelmetUnk = (delegate* unmanaged[Cdecl]<int, bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedHelmetUnk");
				fn__setPedHelmetUnk(_ped, _p1, _p2, _p3);
			}
		}

		public bool IsPedHelmetUnk(int _ped)
		{
			unsafe {
				if (fn__isPedHelmetUnk == null) fn__isPedHelmetUnk = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedHelmetUnk");
				var result = fn__isPedHelmetUnk(_ped);
				return result;
			}
		}

		public void SetPedHelmetTextureIndex(int _ped, int _textureIndex)
		{
			unsafe {
				if (fn__setPedHelmetTextureIndex == null) fn__setPedHelmetTextureIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedHelmetTextureIndex");
				fn__setPedHelmetTextureIndex(_ped, _textureIndex);
			}
		}

		public bool IsPedWearingHelmet(int _ped)
		{
			unsafe {
				if (fn__isPedWearingHelmet == null) fn__isPedWearingHelmet = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedWearingHelmet");
				var result = fn__isPedWearingHelmet(_ped);
				return result;
			}
		}

		public void ClearPedStoredHatProp(int _ped)
		{
			unsafe {
				if (fn__clearPedStoredHatProp == null) fn__clearPedStoredHatProp = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedStoredHatProp");
				fn__clearPedStoredHatProp(_ped);
			}
		}

		public int GetPedHelmetStoredHatPropIndex(int _ped)
		{
			unsafe {
				if (fn__getPedHelmetStoredHatPropIndex == null) fn__getPedHelmetStoredHatPropIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedHelmetStoredHatPropIndex");
				var result = fn__getPedHelmetStoredHatPropIndex(_ped);
				return result;
			}
		}

		public int GetPedHelmetStoredHatTexIndex(int _ped)
		{
			unsafe {
				if (fn__getPedHelmetStoredHatTexIndex == null) fn__getPedHelmetStoredHatTexIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedHelmetStoredHatTexIndex");
				var result = fn__getPedHelmetStoredHatTexIndex(_ped);
				return result;
			}
		}

		public bool _0xF2385935BFFD4D92(int _p0)
		{
			unsafe {
				if (fn__0xF2385935BFFD4D92 == null) fn__0xF2385935BFFD4D92 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xF2385935BFFD4D92");
				var result = fn__0xF2385935BFFD4D92(_p0);
				return result;
			}
		}

		public void SetPedToLoadCover(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedToLoadCover == null) fn__setPedToLoadCover = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedToLoadCover");
				fn__setPedToLoadCover(_ped, _toggle);
			}
		}

		public void SetPedCanCowerInCover(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanCowerInCover == null) fn__setPedCanCowerInCover = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanCowerInCover");
				fn__setPedCanCowerInCover(_ped, _toggle);
			}
		}

		public void SetPedCanPeekInCover(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanPeekInCover == null) fn__setPedCanPeekInCover = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanPeekInCover");
				fn__setPedCanPeekInCover(_ped, _toggle);
			}
		}

		public void SetPedPlaysHeadOnHornAnimWhenDiesInVehicle(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedPlaysHeadOnHornAnimWhenDiesInVehicle == null) fn__setPedPlaysHeadOnHornAnimWhenDiesInVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedPlaysHeadOnHornAnimWhenDiesInVehicle");
				fn__setPedPlaysHeadOnHornAnimWhenDiesInVehicle(_ped, _toggle);
			}
		}

		public void SetPedLegIkMode(int _ped, int _mode)
		{
			unsafe {
				if (fn__setPedLegIkMode == null) fn__setPedLegIkMode = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedLegIkMode");
				fn__setPedLegIkMode(_ped, _mode);
			}
		}

		public void SetPedMotionBlur(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedMotionBlur == null) fn__setPedMotionBlur = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedMotionBlur");
				fn__setPedMotionBlur(_ped, _toggle);
			}
		}

		public void SetPedCanSwitchWeapon(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanSwitchWeapon == null) fn__setPedCanSwitchWeapon = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanSwitchWeapon");
				fn__setPedCanSwitchWeapon(_ped, _toggle);
			}
		}

		public void SetPedDiesInstantlyInWater(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedDiesInstantlyInWater == null) fn__setPedDiesInstantlyInWater = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDiesInstantlyInWater");
				fn__setPedDiesInstantlyInWater(_ped, _toggle);
			}
		}

		public void _0x1A330D297AAC6BC1(int _ped, int _p1)
		{
			unsafe {
				if (fn__0x1A330D297AAC6BC1 == null) fn__0x1A330D297AAC6BC1 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1A330D297AAC6BC1");
				fn__0x1A330D297AAC6BC1(_ped, _p1);
			}
		}

		public void StopPedWeaponFiringWhenDropped(int _ped)
		{
			unsafe {
				if (fn__stopPedWeaponFiringWhenDropped == null) fn__stopPedWeaponFiringWhenDropped = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopPedWeaponFiringWhenDropped");
				fn__stopPedWeaponFiringWhenDropped(_ped);
			}
		}

		public void SetScriptedAnimSeatOffset(int _ped, float _p1)
		{
			unsafe {
				if (fn__setScriptedAnimSeatOffset == null) fn__setScriptedAnimSeatOffset = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setScriptedAnimSeatOffset");
				fn__setScriptedAnimSeatOffset(_ped, _p1);
			}
		}

		public void SetPedCombatMovement(int _ped, int _combatMovement)
		{
			unsafe {
				if (fn__setPedCombatMovement == null) fn__setPedCombatMovement = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedCombatMovement");
				fn__setPedCombatMovement(_ped, _combatMovement);
			}
		}

		public int GetPedCombatMovement(int _ped)
		{
			unsafe {
				if (fn__getPedCombatMovement == null) fn__getPedCombatMovement = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedCombatMovement");
				var result = fn__getPedCombatMovement(_ped);
				return result;
			}
		}

		public void SetPedCombatAbility(int _ped, int _abilityLevel)
		{
			unsafe {
				if (fn__setPedCombatAbility == null) fn__setPedCombatAbility = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedCombatAbility");
				fn__setPedCombatAbility(_ped, _abilityLevel);
			}
		}

		public void SetPedCombatRange(int _ped, int _combatRange)
		{
			unsafe {
				if (fn__setPedCombatRange == null) fn__setPedCombatRange = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedCombatRange");
				fn__setPedCombatRange(_ped, _combatRange);
			}
		}

		public int GetPedCombatRange(int _ped)
		{
			unsafe {
				if (fn__getPedCombatRange == null) fn__getPedCombatRange = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedCombatRange");
				var result = fn__getPedCombatRange(_ped);
				return result;
			}
		}

		public void SetPedCombatAttributes(int _ped, int _attributeId, bool _enabled)
		{
			unsafe {
				if (fn__setPedCombatAttributes == null) fn__setPedCombatAttributes = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCombatAttributes");
				fn__setPedCombatAttributes(_ped, _attributeId, _enabled);
			}
		}

		public void SetPedTargetLossResponse(int _ped, int _responseType)
		{
			unsafe {
				if (fn__setPedTargetLossResponse == null) fn__setPedTargetLossResponse = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedTargetLossResponse");
				fn__setPedTargetLossResponse(_ped, _responseType);
			}
		}

		public bool IsPedPerformingMeleeAction(int _ped)
		{
			unsafe {
				if (fn__isPedPerformingMeleeAction == null) fn__isPedPerformingMeleeAction = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedPerformingMeleeAction");
				var result = fn__isPedPerformingMeleeAction(_ped);
				return result;
			}
		}

		public bool IsPedPerformingStealthKill(int _ped)
		{
			unsafe {
				if (fn__isPedPerformingStealthKill == null) fn__isPedPerformingStealthKill = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedPerformingStealthKill");
				var result = fn__isPedPerformingStealthKill(_ped);
				return result;
			}
		}

		public bool IsPedPerformingDependentComboLimit(int _ped)
		{
			unsafe {
				if (fn__isPedPerformingDependentComboLimit == null) fn__isPedPerformingDependentComboLimit = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedPerformingDependentComboLimit");
				var result = fn__isPedPerformingDependentComboLimit(_ped);
				return result;
			}
		}

		public bool IsPedBeingStealthKilled(int _ped)
		{
			unsafe {
				if (fn__isPedBeingStealthKilled == null) fn__isPedBeingStealthKilled = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedBeingStealthKilled");
				var result = fn__isPedBeingStealthKilled(_ped);
				return result;
			}
		}

		public int GetMeleeTargetForPed(int _ped)
		{
			unsafe {
				if (fn__getMeleeTargetForPed == null) fn__getMeleeTargetForPed = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getMeleeTargetForPed");
				var result = fn__getMeleeTargetForPed(_ped);
				return result;
			}
		}

		public bool WasPedKilledByStealth(int _ped)
		{
			unsafe {
				if (fn__wasPedKilledByStealth == null) fn__wasPedKilledByStealth = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_wasPedKilledByStealth");
				var result = fn__wasPedKilledByStealth(_ped);
				return result;
			}
		}

		public bool WasPedKilledByTakedown(int _ped)
		{
			unsafe {
				if (fn__wasPedKilledByTakedown == null) fn__wasPedKilledByTakedown = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_wasPedKilledByTakedown");
				var result = fn__wasPedKilledByTakedown(_ped);
				return result;
			}
		}

		public bool WasPedKnockedOut(int _ped)
		{
			unsafe {
				if (fn__wasPedKnockedOut == null) fn__wasPedKnockedOut = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_wasPedKnockedOut");
				var result = fn__wasPedKnockedOut(_ped);
				return result;
			}
		}

		public void SetPedFleeAttributes(int _ped, int _attributeFlags, bool _enable)
		{
			unsafe {
				if (fn__setPedFleeAttributes == null) fn__setPedFleeAttributes = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedFleeAttributes");
				fn__setPedFleeAttributes(_ped, _attributeFlags, _enable);
			}
		}

		public void SetPedCowerHash(int _ped, string _p1)
		{
			unsafe {
				if (fn__setPedCowerHash == null) fn__setPedCowerHash = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setPedCowerHash");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__setPedCowerHash(_ped, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void _0x2016C603D6B8987C(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__0x2016C603D6B8987C == null) fn__0x2016C603D6B8987C = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x2016C603D6B8987C");
				fn__0x2016C603D6B8987C(_ped, _toggle);
			}
		}

		public void SetPedSteersAroundPeds(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedSteersAroundPeds == null) fn__setPedSteersAroundPeds = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedSteersAroundPeds");
				fn__setPedSteersAroundPeds(_ped, _toggle);
			}
		}

		public void SetPedSteersAroundObjects(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedSteersAroundObjects == null) fn__setPedSteersAroundObjects = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedSteersAroundObjects");
				fn__setPedSteersAroundObjects(_ped, _toggle);
			}
		}

		public void SetPedSteersAroundVehicles(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedSteersAroundVehicles == null) fn__setPedSteersAroundVehicles = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedSteersAroundVehicles");
				fn__setPedSteersAroundVehicles(_ped, _toggle);
			}
		}

		public void _0xA9B61A329BFDCBEA(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0xA9B61A329BFDCBEA == null) fn__0xA9B61A329BFDCBEA = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xA9B61A329BFDCBEA");
				fn__0xA9B61A329BFDCBEA(_p0, _p1);
			}
		}

		public void SetPedIncreasedAvoidanceRadius(int _ped)
		{
			unsafe {
				if (fn__setPedIncreasedAvoidanceRadius == null) fn__setPedIncreasedAvoidanceRadius = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedIncreasedAvoidanceRadius");
				fn__setPedIncreasedAvoidanceRadius(_ped);
			}
		}

		public void SetPedBlocksPathingWhenDead(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedBlocksPathingWhenDead == null) fn__setPedBlocksPathingWhenDead = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedBlocksPathingWhenDead");
				fn__setPedBlocksPathingWhenDead(_ped, _toggle);
			}
		}

		public void _0xA52D5247A4227E14(int _p0)
		{
			unsafe {
				if (fn__0xA52D5247A4227E14 == null) fn__0xA52D5247A4227E14 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xA52D5247A4227E14");
				fn__0xA52D5247A4227E14(_p0);
			}
		}

		public bool IsAnyPedNearPoint(float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__isAnyPedNearPoint == null) fn__isAnyPedNearPoint = (delegate* unmanaged[Cdecl]<float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isAnyPedNearPoint");
				var result = fn__isAnyPedNearPoint(_x, _y, _z, _radius);
				return result;
			}
		}

		public void ForcePedAiAndAnimationUpdate(int _ped, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__forcePedAiAndAnimationUpdate == null) fn__forcePedAiAndAnimationUpdate = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_forcePedAiAndAnimationUpdate");
				fn__forcePedAiAndAnimationUpdate(_ped, _p1, _p2);
			}
		}

		public bool IsPedHeadingTowardsPosition(int _ped, float _x, float _y, float _z, float _p4)
		{
			unsafe {
				if (fn__isPedHeadingTowardsPosition == null) fn__isPedHeadingTowardsPosition = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isPedHeadingTowardsPosition");
				var result = fn__isPedHeadingTowardsPosition(_ped, _x, _y, _z, _p4);
				return result;
			}
		}

		public void RequestPedVisibilityTracking(int _ped)
		{
			unsafe {
				if (fn__requestPedVisibilityTracking == null) fn__requestPedVisibilityTracking = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestPedVisibilityTracking");
				fn__requestPedVisibilityTracking(_ped);
			}
		}

		public void RequestPedVehicleVisibilityTracking(int _ped, bool _p1)
		{
			unsafe {
				if (fn__requestPedVehicleVisibilityTracking == null) fn__requestPedVehicleVisibilityTracking = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_requestPedVehicleVisibilityTracking");
				fn__requestPedVehicleVisibilityTracking(_ped, _p1);
			}
		}

		public void _0xCD018C591F94CB43(int _ped, bool _p1)
		{
			unsafe {
				if (fn__0xCD018C591F94CB43 == null) fn__0xCD018C591F94CB43 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xCD018C591F94CB43");
				fn__0xCD018C591F94CB43(_ped, _p1);
			}
		}

		public void _0x75BA1CB3B7D40CAF(int _ped, bool _p1)
		{
			unsafe {
				if (fn__0x75BA1CB3B7D40CAF == null) fn__0x75BA1CB3B7D40CAF = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x75BA1CB3B7D40CAF");
				fn__0x75BA1CB3B7D40CAF(_ped, _p1);
			}
		}

		public bool IsTrackedPedVisible(int _ped)
		{
			unsafe {
				if (fn__isTrackedPedVisible == null) fn__isTrackedPedVisible = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isTrackedPedVisible");
				var result = fn__isTrackedPedVisible(_ped);
				return result;
			}
		}

		public int _0x511F1A683387C7E2(int _ped)
		{
			unsafe {
				if (fn__0x511F1A683387C7E2 == null) fn__0x511F1A683387C7E2 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x511F1A683387C7E2");
				var result = fn__0x511F1A683387C7E2(_ped);
				return result;
			}
		}

		public bool IsPedTracked(int _ped)
		{
			unsafe {
				if (fn__isPedTracked == null) fn__isPedTracked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedTracked");
				var result = fn__isPedTracked(_ped);
				return result;
			}
		}

		public bool HasPedReceivedEvent(int _ped, int _eventId)
		{
			unsafe {
				if (fn__hasPedReceivedEvent == null) fn__hasPedReceivedEvent = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasPedReceivedEvent");
				var result = fn__hasPedReceivedEvent(_ped, _eventId);
				return result;
			}
		}

		public bool CanPedSeeHatedPed(int _ped1, int _ped2)
		{
			unsafe {
				if (fn__canPedSeeHatedPed == null) fn__canPedSeeHatedPed = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_canPedSeeHatedPed");
				var result = fn__canPedSeeHatedPed(_ped1, _ped2);
				return result;
			}
		}

		public bool _0x9C6A6C19B6C0C496(int _ped, ref int _p1)
		{
			unsafe {
				if (fn__0x9C6A6C19B6C0C496 == null) fn__0x9C6A6C19B6C0C496 = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x9C6A6C19B6C0C496");
				var ref_p1 = _p1;
				var result = fn__0x9C6A6C19B6C0C496(_ped, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool _0x2DFC81C9B9608549(int _ped, ref int _p1)
		{
			unsafe {
				if (fn__0x2DFC81C9B9608549 == null) fn__0x2DFC81C9B9608549 = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x2DFC81C9B9608549");
				var ref_p1 = _p1;
				var result = fn__0x2DFC81C9B9608549(_ped, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public int GetPedBoneIndex(int _ped, int _boneId)
		{
			unsafe {
				if (fn__getPedBoneIndex == null) fn__getPedBoneIndex = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedBoneIndex");
				var result = fn__getPedBoneIndex(_ped, _boneId);
				return result;
			}
		}

		public int GetPedRagdollBoneIndex(int _ped, int _bone)
		{
			unsafe {
				if (fn__getPedRagdollBoneIndex == null) fn__getPedRagdollBoneIndex = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedRagdollBoneIndex");
				var result = fn__getPedRagdollBoneIndex(_ped, _bone);
				return result;
			}
		}

		public void SetPedEnveffScale(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedEnveffScale == null) fn__setPedEnveffScale = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedEnveffScale");
				fn__setPedEnveffScale(_ped, _value);
			}
		}

		public float GetPedEnveffScale(int _ped)
		{
			unsafe {
				if (fn__getPedEnveffScale == null) fn__getPedEnveffScale = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPedEnveffScale");
				var result = fn__getPedEnveffScale(_ped);
				return result;
			}
		}

		public void SetEnablePedEnveffScale(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setEnablePedEnveffScale == null) fn__setEnablePedEnveffScale = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEnablePedEnveffScale");
				fn__setEnablePedEnveffScale(_ped, _toggle);
			}
		}

		public void _0x110F526AB784111F(int _ped, float _p1)
		{
			unsafe {
				if (fn__0x110F526AB784111F == null) fn__0x110F526AB784111F = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x110F526AB784111F");
				fn__0x110F526AB784111F(_ped, _p1);
			}
		}

		public void SetPedEnveffColorModulator(int _ped, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__setPedEnveffColorModulator == null) fn__setPedEnveffColorModulator = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedEnveffColorModulator");
				fn__setPedEnveffColorModulator(_ped, _p1, _p2, _p3);
			}
		}

		public void SetPedEmissiveIntensity(int _ped, float _intensity)
		{
			unsafe {
				if (fn__setPedEmissiveIntensity == null) fn__setPedEmissiveIntensity = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedEmissiveIntensity");
				fn__setPedEmissiveIntensity(_ped, _intensity);
			}
		}

		public float GetPedEmissiveIntensity(int _ped)
		{
			unsafe {
				if (fn__getPedEmissiveIntensity == null) fn__getPedEmissiveIntensity = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPedEmissiveIntensity");
				var result = fn__getPedEmissiveIntensity(_ped);
				return result;
			}
		}

		public bool IsPedShaderEffectValid(int _ped)
		{
			unsafe {
				if (fn__isPedShaderEffectValid == null) fn__isPedShaderEffectValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedShaderEffectValid");
				var result = fn__isPedShaderEffectValid(_ped);
				return result;
			}
		}

		public void _0xE906EC930F5FE7C8(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xE906EC930F5FE7C8 == null) fn__0xE906EC930F5FE7C8 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xE906EC930F5FE7C8");
				fn__0xE906EC930F5FE7C8(_p0, _p1);
			}
		}

		public void _0x1216E0BFA72CC703(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x1216E0BFA72CC703 == null) fn__0x1216E0BFA72CC703 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1216E0BFA72CC703");
				fn__0x1216E0BFA72CC703(_p0, _p1);
			}
		}

		public void SetPedAoBlobRendering(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedAoBlobRendering == null) fn__setPedAoBlobRendering = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAoBlobRendering");
				fn__setPedAoBlobRendering(_ped, _toggle);
			}
		}

		public bool _0xB8B52E498014F5B0(int _ped)
		{
			unsafe {
				if (fn__0xB8B52E498014F5B0 == null) fn__0xB8B52E498014F5B0 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xB8B52E498014F5B0");
				var result = fn__0xB8B52E498014F5B0(_ped);
				return result;
			}
		}

		public int CreateSynchronizedScene(float _x, float _y, float _z, float _roll, float _pitch, float _yaw, int _p6)
		{
			unsafe {
				if (fn__createSynchronizedScene == null) fn__createSynchronizedScene = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int>) NativeLibrary.GetExport(handle, "Native_createSynchronizedScene");
				var result = fn__createSynchronizedScene(_x, _y, _z, _roll, _pitch, _yaw, _p6);
				return result;
			}
		}

		public int CreateSynchronizedScene2(float _x, float _y, float _z, float _radius, int _object)
		{
			unsafe {
				if (fn__createSynchronizedScene2 == null) fn__createSynchronizedScene2 = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int>) NativeLibrary.GetExport(handle, "Native_createSynchronizedScene2");
				var result = fn__createSynchronizedScene2(_x, _y, _z, _radius, _object);
				return result;
			}
		}

		public bool IsSynchronizedSceneRunning(int _sceneId)
		{
			unsafe {
				if (fn__isSynchronizedSceneRunning == null) fn__isSynchronizedSceneRunning = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isSynchronizedSceneRunning");
				var result = fn__isSynchronizedSceneRunning(_sceneId);
				return result;
			}
		}

		public void SetSynchronizedSceneOrigin(int _sceneID, float _x, float _y, float _z, float _roll, float _pitch, float _yaw, bool _p7)
		{
			unsafe {
				if (fn__setSynchronizedSceneOrigin == null) fn__setSynchronizedSceneOrigin = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setSynchronizedSceneOrigin");
				fn__setSynchronizedSceneOrigin(_sceneID, _x, _y, _z, _roll, _pitch, _yaw, _p7);
			}
		}

		public void SetSynchronizedScenePhase(int _sceneID, float _phase)
		{
			unsafe {
				if (fn__setSynchronizedScenePhase == null) fn__setSynchronizedScenePhase = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setSynchronizedScenePhase");
				fn__setSynchronizedScenePhase(_sceneID, _phase);
			}
		}

		public float GetSynchronizedScenePhase(int _sceneID)
		{
			unsafe {
				if (fn__getSynchronizedScenePhase == null) fn__getSynchronizedScenePhase = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getSynchronizedScenePhase");
				var result = fn__getSynchronizedScenePhase(_sceneID);
				return result;
			}
		}

		public void SetSynchronizedSceneRate(int _sceneID, float _rate)
		{
			unsafe {
				if (fn__setSynchronizedSceneRate == null) fn__setSynchronizedSceneRate = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setSynchronizedSceneRate");
				fn__setSynchronizedSceneRate(_sceneID, _rate);
			}
		}

		public float GetSynchronizedSceneRate(int _sceneID)
		{
			unsafe {
				if (fn__getSynchronizedSceneRate == null) fn__getSynchronizedSceneRate = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getSynchronizedSceneRate");
				var result = fn__getSynchronizedSceneRate(_sceneID);
				return result;
			}
		}

		public void SetSynchronizedSceneLooped(int _sceneID, bool _toggle)
		{
			unsafe {
				if (fn__setSynchronizedSceneLooped == null) fn__setSynchronizedSceneLooped = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setSynchronizedSceneLooped");
				fn__setSynchronizedSceneLooped(_sceneID, _toggle);
			}
		}

		public bool IsSynchronizedSceneLooped(int _sceneID)
		{
			unsafe {
				if (fn__isSynchronizedSceneLooped == null) fn__isSynchronizedSceneLooped = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isSynchronizedSceneLooped");
				var result = fn__isSynchronizedSceneLooped(_sceneID);
				return result;
			}
		}

		public void SetSynchronizedSceneHoldLastFrame(int _sceneID, bool _toggle)
		{
			unsafe {
				if (fn__setSynchronizedSceneHoldLastFrame == null) fn__setSynchronizedSceneHoldLastFrame = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setSynchronizedSceneHoldLastFrame");
				fn__setSynchronizedSceneHoldLastFrame(_sceneID, _toggle);
			}
		}

		public bool IsSynchronizedSceneHoldLastFrame(int _sceneID)
		{
			unsafe {
				if (fn__isSynchronizedSceneHoldLastFrame == null) fn__isSynchronizedSceneHoldLastFrame = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isSynchronizedSceneHoldLastFrame");
				var result = fn__isSynchronizedSceneHoldLastFrame(_sceneID);
				return result;
			}
		}

		public void AttachSynchronizedSceneToEntity(int _sceneID, int _entity, int _boneIndex)
		{
			unsafe {
				if (fn__attachSynchronizedSceneToEntity == null) fn__attachSynchronizedSceneToEntity = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_attachSynchronizedSceneToEntity");
				fn__attachSynchronizedSceneToEntity(_sceneID, _entity, _boneIndex);
			}
		}

		public void DetachSynchronizedScene(int _sceneID)
		{
			unsafe {
				if (fn__detachSynchronizedScene == null) fn__detachSynchronizedScene = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_detachSynchronizedScene");
				fn__detachSynchronizedScene(_sceneID);
			}
		}

		public void DisposeSynchronizedScene(int _scene)
		{
			unsafe {
				if (fn__disposeSynchronizedScene == null) fn__disposeSynchronizedScene = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disposeSynchronizedScene");
				fn__disposeSynchronizedScene(_scene);
			}
		}

		public bool ForcePedMotionState(int _ped, int _motionStateHash, bool _p2, int _p3, bool _p4)
		{
			unsafe {
				if (fn__forcePedMotionState == null) fn__forcePedMotionState = (delegate* unmanaged[Cdecl]<int, int, bool, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_forcePedMotionState");
				var result = fn__forcePedMotionState(_ped, _motionStateHash, _p2, _p3, _p4);
				return result;
			}
		}

		public bool GetPedCurrentMovementSpeed(int _ped, ref float _speedX, ref float _speedY)
		{
			unsafe {
				if (fn__getPedCurrentMovementSpeed == null) fn__getPedCurrentMovementSpeed = (delegate* unmanaged[Cdecl]<int, float*, float*, bool>) NativeLibrary.GetExport(handle, "Native_getPedCurrentMovementSpeed");
				var ref_speedX = _speedX;
				var ref_speedY = _speedY;
				var result = fn__getPedCurrentMovementSpeed(_ped, &ref_speedX, &ref_speedY);
				_speedX = ref_speedX;
				_speedY = ref_speedY;
				return result;
			}
		}

		public void SetPedMaxMoveBlendRatio(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedMaxMoveBlendRatio == null) fn__setPedMaxMoveBlendRatio = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedMaxMoveBlendRatio");
				fn__setPedMaxMoveBlendRatio(_ped, _value);
			}
		}

		public void SetPedMinMoveBlendRatio(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedMinMoveBlendRatio == null) fn__setPedMinMoveBlendRatio = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedMinMoveBlendRatio");
				fn__setPedMinMoveBlendRatio(_ped, _value);
			}
		}

		public void SetPedMoveRateOverride(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedMoveRateOverride == null) fn__setPedMoveRateOverride = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedMoveRateOverride");
				fn__setPedMoveRateOverride(_ped, _value);
			}
		}

		public void _0x0B3E35AC043707D9(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x0B3E35AC043707D9 == null) fn__0x0B3E35AC043707D9 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0B3E35AC043707D9");
				fn__0x0B3E35AC043707D9(_p0, _p1);
			}
		}

		public bool _0x46B05BCAE43856B0(int _ped, int _flag)
		{
			unsafe {
				if (fn__0x46B05BCAE43856B0 == null) fn__0x46B05BCAE43856B0 = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native__0x46B05BCAE43856B0");
				var result = fn__0x46B05BCAE43856B0(_ped, _flag);
				return result;
			}
		}

		public int GetPedNearbyVehicles(int _ped, ref int _sizeAndVehs)
		{
			unsafe {
				if (fn__getPedNearbyVehicles == null) fn__getPedNearbyVehicles = (delegate* unmanaged[Cdecl]<int, int*, int>) NativeLibrary.GetExport(handle, "Native_getPedNearbyVehicles");
				var ref_sizeAndVehs = _sizeAndVehs;
				var result = fn__getPedNearbyVehicles(_ped, &ref_sizeAndVehs);
				_sizeAndVehs = ref_sizeAndVehs;
				return result;
			}
		}

		public int GetPedNearbyPeds(int _ped, ref int _sizeAndPeds, int _ignore)
		{
			unsafe {
				if (fn__getPedNearbyPeds == null) fn__getPedNearbyPeds = (delegate* unmanaged[Cdecl]<int, int*, int, int>) NativeLibrary.GetExport(handle, "Native_getPedNearbyPeds");
				var ref_sizeAndPeds = _sizeAndPeds;
				var result = fn__getPedNearbyPeds(_ped, &ref_sizeAndPeds, _ignore);
				_sizeAndPeds = ref_sizeAndPeds;
				return result;
			}
		}

		public bool HaveAllStreamingRequestsCompleted(int _ped)
		{
			unsafe {
				if (fn__haveAllStreamingRequestsCompleted == null) fn__haveAllStreamingRequestsCompleted = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_haveAllStreamingRequestsCompleted");
				var result = fn__haveAllStreamingRequestsCompleted(_ped);
				return result;
			}
		}

		public bool IsPedUsingActionMode(int _ped)
		{
			unsafe {
				if (fn__isPedUsingActionMode == null) fn__isPedUsingActionMode = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedUsingActionMode");
				var result = fn__isPedUsingActionMode(_ped);
				return result;
			}
		}

		public void SetPedUsingActionMode(int _ped, bool _p1, int _p2, string _action)
		{
			unsafe {
				if (fn__setPedUsingActionMode == null) fn__setPedUsingActionMode = (delegate* unmanaged[Cdecl]<int, bool, int, nint, void>) NativeLibrary.GetExport(handle, "Native_setPedUsingActionMode");
				var ptr_action = MemoryUtils.StringToHGlobalUtf8(_action);
				fn__setPedUsingActionMode(_ped, _p1, _p2, ptr_action);
				Marshal.FreeHGlobal(ptr_action);
			}
		}

		public void SetMovementModeOverride(int _ped, string _name)
		{
			unsafe {
				if (fn__setMovementModeOverride == null) fn__setMovementModeOverride = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setMovementModeOverride");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setMovementModeOverride(_ped, ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void SetPedCapsule(int _ped, float _value)
		{
			unsafe {
				if (fn__setPedCapsule == null) fn__setPedCapsule = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedCapsule");
				fn__setPedCapsule(_ped, _value);
			}
		}

		public int RegisterPedheadshot(int _ped)
		{
			unsafe {
				if (fn__registerPedheadshot == null) fn__registerPedheadshot = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_registerPedheadshot");
				var result = fn__registerPedheadshot(_ped);
				return result;
			}
		}

		public int RegisterPedheadshot3(int _ped)
		{
			unsafe {
				if (fn__registerPedheadshot3 == null) fn__registerPedheadshot3 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_registerPedheadshot3");
				var result = fn__registerPedheadshot3(_ped);
				return result;
			}
		}

		public int RegisterPedheadshotTransparent(int _ped)
		{
			unsafe {
				if (fn__registerPedheadshotTransparent == null) fn__registerPedheadshotTransparent = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_registerPedheadshotTransparent");
				var result = fn__registerPedheadshotTransparent(_ped);
				return result;
			}
		}

		public void UnregisterPedheadshot(int _id)
		{
			unsafe {
				if (fn__unregisterPedheadshot == null) fn__unregisterPedheadshot = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_unregisterPedheadshot");
				fn__unregisterPedheadshot(_id);
			}
		}

		public bool IsPedheadshotValid(int _id)
		{
			unsafe {
				if (fn__isPedheadshotValid == null) fn__isPedheadshotValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedheadshotValid");
				var result = fn__isPedheadshotValid(_id);
				return result;
			}
		}

		public bool IsPedheadshotReady(int _id)
		{
			unsafe {
				if (fn__isPedheadshotReady == null) fn__isPedheadshotReady = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedheadshotReady");
				var result = fn__isPedheadshotReady(_id);
				return result;
			}
		}

		public string GetPedheadshotTxdString(int _id)
		{
			unsafe {
				if (fn__getPedheadshotTxdString == null) fn__getPedheadshotTxdString = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getPedheadshotTxdString");
				var result = fn__getPedheadshotTxdString(_id);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool RequestPedheadshotImgUpload(int _id)
		{
			unsafe {
				if (fn__requestPedheadshotImgUpload == null) fn__requestPedheadshotImgUpload = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_requestPedheadshotImgUpload");
				var result = fn__requestPedheadshotImgUpload(_id);
				return result;
			}
		}

		public void ReleasePedheadshotImgUpload(int _id)
		{
			unsafe {
				if (fn__releasePedheadshotImgUpload == null) fn__releasePedheadshotImgUpload = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_releasePedheadshotImgUpload");
				fn__releasePedheadshotImgUpload(_id);
			}
		}

		public bool IsPedheadshotImgUploadAvailable()
		{
			unsafe {
				if (fn__isPedheadshotImgUploadAvailable == null) fn__isPedheadshotImgUploadAvailable = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPedheadshotImgUploadAvailable");
				var result = fn__isPedheadshotImgUploadAvailable();
				return result;
			}
		}

		public bool HasPedheadshotImgUploadFailed()
		{
			unsafe {
				if (fn__hasPedheadshotImgUploadFailed == null) fn__hasPedheadshotImgUploadFailed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasPedheadshotImgUploadFailed");
				var result = fn__hasPedheadshotImgUploadFailed();
				return result;
			}
		}

		public bool HasPedheadshotImgUploadSucceeded()
		{
			unsafe {
				if (fn__hasPedheadshotImgUploadSucceeded == null) fn__hasPedheadshotImgUploadSucceeded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasPedheadshotImgUploadSucceeded");
				var result = fn__hasPedheadshotImgUploadSucceeded();
				return result;
			}
		}

		public void SetPedHeatscaleOverride(int _ped, float _heatScale)
		{
			unsafe {
				if (fn__setPedHeatscaleOverride == null) fn__setPedHeatscaleOverride = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedHeatscaleOverride");
				fn__setPedHeatscaleOverride(_ped, _heatScale);
			}
		}

		public void DisablePedHeatscaleOverride(int _ped)
		{
			unsafe {
				if (fn__disablePedHeatscaleOverride == null) fn__disablePedHeatscaleOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disablePedHeatscaleOverride");
				fn__disablePedHeatscaleOverride(_ped);
			}
		}

		public void SpawnpointsStartSearch(float _p0, float _p1, float _p2, float _p3, float _p4, int _interiorFlags, float _scale, int _duration)
		{
			unsafe {
				if (fn__spawnpointsStartSearch == null) fn__spawnpointsStartSearch = (delegate* unmanaged[Cdecl]<float, float, float, float, float, int, float, int, void>) NativeLibrary.GetExport(handle, "Native_spawnpointsStartSearch");
				fn__spawnpointsStartSearch(_p0, _p1, _p2, _p3, _p4, _interiorFlags, _scale, _duration);
			}
		}

		public void SpawnpointsStartSearchInAngledArea(float _x, float _y, float _z, float _p3, float _p4, float _p5, float _p6, int _interiorFlags, float _scale, int _duration)
		{
			unsafe {
				if (fn__spawnpointsStartSearchInAngledArea == null) fn__spawnpointsStartSearchInAngledArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, float, int, void>) NativeLibrary.GetExport(handle, "Native_spawnpointsStartSearchInAngledArea");
				fn__spawnpointsStartSearchInAngledArea(_x, _y, _z, _p3, _p4, _p5, _p6, _interiorFlags, _scale, _duration);
			}
		}

		public void SpawnpointsCancelSearch()
		{
			unsafe {
				if (fn__spawnpointsCancelSearch == null) fn__spawnpointsCancelSearch = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_spawnpointsCancelSearch");
				fn__spawnpointsCancelSearch();
			}
		}

		public bool SpawnpointsIsSearchActive()
		{
			unsafe {
				if (fn__spawnpointsIsSearchActive == null) fn__spawnpointsIsSearchActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_spawnpointsIsSearchActive");
				var result = fn__spawnpointsIsSearchActive();
				return result;
			}
		}

		public bool SpawnpointsIsSearchComplete()
		{
			unsafe {
				if (fn__spawnpointsIsSearchComplete == null) fn__spawnpointsIsSearchComplete = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_spawnpointsIsSearchComplete");
				var result = fn__spawnpointsIsSearchComplete();
				return result;
			}
		}

		public bool SpawnpointsIsSearchFailed()
		{
			unsafe {
				if (fn__spawnpointsIsSearchFailed == null) fn__spawnpointsIsSearchFailed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_spawnpointsIsSearchFailed");
				var result = fn__spawnpointsIsSearchFailed();
				return result;
			}
		}

		public int SpawnpointsGetNumSearchResults()
		{
			unsafe {
				if (fn__spawnpointsGetNumSearchResults == null) fn__spawnpointsGetNumSearchResults = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_spawnpointsGetNumSearchResults");
				var result = fn__spawnpointsGetNumSearchResults();
				return result;
			}
		}

		public void SpawnpointsGetSearchResult(int _randomInt, ref float _x, ref float _y, ref float _z)
		{
			unsafe {
				if (fn__spawnpointsGetSearchResult == null) fn__spawnpointsGetSearchResult = (delegate* unmanaged[Cdecl]<int, float*, float*, float*, void>) NativeLibrary.GetExport(handle, "Native_spawnpointsGetSearchResult");
				var ref_x = _x;
				var ref_y = _y;
				var ref_z = _z;
				fn__spawnpointsGetSearchResult(_randomInt, &ref_x, &ref_y, &ref_z);
				_x = ref_x;
				_y = ref_y;
				_z = ref_z;
			}
		}

		public void SpawnpointsGetSearchResultFlags(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__spawnpointsGetSearchResultFlags == null) fn__spawnpointsGetSearchResultFlags = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_spawnpointsGetSearchResultFlags");
				var ref_p1 = _p1;
				fn__spawnpointsGetSearchResultFlags(_p0, &ref_p1);
				_p1 = ref_p1;
			}
		}

		public void SetIkTarget(int _ped, int _ikIndex, int _entityLookAt, int _boneLookAt, float _offsetX, float _offsetY, float _offsetZ, int _p7, int _blendInDuration, int _blendOutDuration)
		{
			unsafe {
				if (fn__setIkTarget == null) fn__setIkTarget = (delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setIkTarget");
				fn__setIkTarget(_ped, _ikIndex, _entityLookAt, _boneLookAt, _offsetX, _offsetY, _offsetZ, _p7, _blendInDuration, _blendOutDuration);
			}
		}

		public void _0xED3C76ADFA6D07C4(int _ped)
		{
			unsafe {
				if (fn__0xED3C76ADFA6D07C4 == null) fn__0xED3C76ADFA6D07C4 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xED3C76ADFA6D07C4");
				fn__0xED3C76ADFA6D07C4(_ped);
			}
		}

		public void RequestActionModeAsset(string _asset)
		{
			unsafe {
				if (fn__requestActionModeAsset == null) fn__requestActionModeAsset = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestActionModeAsset");
				var ptr_asset = MemoryUtils.StringToHGlobalUtf8(_asset);
				fn__requestActionModeAsset(ptr_asset);
				Marshal.FreeHGlobal(ptr_asset);
			}
		}

		public bool HasActionModeAssetLoaded(string _asset)
		{
			unsafe {
				if (fn__hasActionModeAssetLoaded == null) fn__hasActionModeAssetLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasActionModeAssetLoaded");
				var ptr_asset = MemoryUtils.StringToHGlobalUtf8(_asset);
				var result = fn__hasActionModeAssetLoaded(ptr_asset);
				Marshal.FreeHGlobal(ptr_asset);
				return result;
			}
		}

		public void RemoveActionModeAsset(string _asset)
		{
			unsafe {
				if (fn__removeActionModeAsset == null) fn__removeActionModeAsset = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeActionModeAsset");
				var ptr_asset = MemoryUtils.StringToHGlobalUtf8(_asset);
				fn__removeActionModeAsset(ptr_asset);
				Marshal.FreeHGlobal(ptr_asset);
			}
		}

		public void RequestStealthModeAsset(string _asset)
		{
			unsafe {
				if (fn__requestStealthModeAsset == null) fn__requestStealthModeAsset = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestStealthModeAsset");
				var ptr_asset = MemoryUtils.StringToHGlobalUtf8(_asset);
				fn__requestStealthModeAsset(ptr_asset);
				Marshal.FreeHGlobal(ptr_asset);
			}
		}

		public bool HasStealthModeAssetLoaded(string _asset)
		{
			unsafe {
				if (fn__hasStealthModeAssetLoaded == null) fn__hasStealthModeAssetLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasStealthModeAssetLoaded");
				var ptr_asset = MemoryUtils.StringToHGlobalUtf8(_asset);
				var result = fn__hasStealthModeAssetLoaded(ptr_asset);
				Marshal.FreeHGlobal(ptr_asset);
				return result;
			}
		}

		public void RemoveStealthModeAsset(string _asset)
		{
			unsafe {
				if (fn__removeStealthModeAsset == null) fn__removeStealthModeAsset = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeStealthModeAsset");
				var ptr_asset = MemoryUtils.StringToHGlobalUtf8(_asset);
				fn__removeStealthModeAsset(ptr_asset);
				Marshal.FreeHGlobal(ptr_asset);
			}
		}

		public void SetPedLodMultiplier(int _ped, float _multiplier)
		{
			unsafe {
				if (fn__setPedLodMultiplier == null) fn__setPedLodMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedLodMultiplier");
				fn__setPedLodMultiplier(_ped, _multiplier);
			}
		}

		public void SetPedCanLosePropsOnDamage(int _ped, bool _toggle, int _p2)
		{
			unsafe {
				if (fn__setPedCanLosePropsOnDamage == null) fn__setPedCanLosePropsOnDamage = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setPedCanLosePropsOnDamage");
				fn__setPedCanLosePropsOnDamage(_ped, _toggle, _p2);
			}
		}

		public void SetForceFootstepUpdate(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setForceFootstepUpdate == null) fn__setForceFootstepUpdate = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setForceFootstepUpdate");
				fn__setForceFootstepUpdate(_ped, _toggle);
			}
		}

		public void SetForceStepType(int _ped, bool _p1, int _type, int _p3)
		{
			unsafe {
				if (fn__setForceStepType == null) fn__setForceStepType = (delegate* unmanaged[Cdecl]<int, bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_setForceStepType");
				fn__setForceStepType(_ped, _p1, _type, _p3);
			}
		}

		public bool IsAnyHostilePedNearPoint(int _ped, float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__isAnyHostilePedNearPoint == null) fn__isAnyHostilePedNearPoint = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isAnyHostilePedNearPoint");
				var result = fn__isAnyHostilePedNearPoint(_ped, _x, _y, _z, _radius);
				return result;
			}
		}

		public void SetPedCanPlayInCarIdles(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedCanPlayInCarIdles == null) fn__setPedCanPlayInCarIdles = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanPlayInCarIdles");
				fn__setPedCanPlayInCarIdles(_ped, _toggle);
			}
		}

		public bool IsTargetPedInPerceptionArea(int _ped, int _targetPed, float _p2, float _p3, float _p4, float _p5)
		{
			unsafe {
				if (fn__isTargetPedInPerceptionArea == null) fn__isTargetPedInPerceptionArea = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isTargetPedInPerceptionArea");
				var result = fn__isTargetPedInPerceptionArea(_ped, _targetPed, _p2, _p3, _p4, _p5);
				return result;
			}
		}

		public void SetPopControlSphereThisFrame(float _x, float _y, float _z, float _min, float _max)
		{
			unsafe {
				if (fn__setPopControlSphereThisFrame == null) fn__setPopControlSphereThisFrame = (delegate* unmanaged[Cdecl]<float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setPopControlSphereThisFrame");
				fn__setPopControlSphereThisFrame(_x, _y, _z, _min, _max);
			}
		}

		public void _0xD33DAA36272177C4(int _ped)
		{
			unsafe {
				if (fn__0xD33DAA36272177C4 == null) fn__0xD33DAA36272177C4 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xD33DAA36272177C4");
				fn__0xD33DAA36272177C4(_ped);
			}
		}

		public void _0x711794453CFD692B(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x711794453CFD692B == null) fn__0x711794453CFD692B = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x711794453CFD692B");
				fn__0x711794453CFD692B(_p0, _p1);
			}
		}

		public void _0x83A169EABCDB10A2(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x83A169EABCDB10A2 == null) fn__0x83A169EABCDB10A2 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x83A169EABCDB10A2");
				fn__0x83A169EABCDB10A2(_p0, _p1);
			}
		}

		public void _0x288DF530C92DAD6F(int _p0, float _p1)
		{
			unsafe {
				if (fn__0x288DF530C92DAD6F == null) fn__0x288DF530C92DAD6F = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x288DF530C92DAD6F");
				fn__0x288DF530C92DAD6F(_p0, _p1);
			}
		}

		public bool IsPedSwappingWeapon(int _Ped)
		{
			unsafe {
				if (fn__isPedSwappingWeapon == null) fn__isPedSwappingWeapon = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedSwappingWeapon");
				var result = fn__isPedSwappingWeapon(_Ped);
				return result;
			}
		}

		public void _0x0F62619393661D6E(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x0F62619393661D6E == null) fn__0x0F62619393661D6E = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0F62619393661D6E");
				fn__0x0F62619393661D6E(_p0, _p1, _p2);
			}
		}

		public void _0xDFE68C4B787E1BFB(int _ped)
		{
			unsafe {
				if (fn__0xDFE68C4B787E1BFB == null) fn__0xDFE68C4B787E1BFB = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xDFE68C4B787E1BFB");
				fn__0xDFE68C4B787E1BFB(_ped);
			}
		}

		public void SetEnableScubaGearLight(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setEnableScubaGearLight == null) fn__setEnableScubaGearLight = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEnableScubaGearLight");
				fn__setEnableScubaGearLight(_ped, _toggle);
			}
		}

		public bool IsScubaGearLightEnabled(int _ped)
		{
			unsafe {
				if (fn__isScubaGearLightEnabled == null) fn__isScubaGearLightEnabled = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isScubaGearLightEnabled");
				var result = fn__isScubaGearLightEnabled(_ped);
				return result;
			}
		}

		public void ClearFacialClipsetOverride(int _ped)
		{
			unsafe {
				if (fn__clearFacialClipsetOverride == null) fn__clearFacialClipsetOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearFacialClipsetOverride");
				fn__clearFacialClipsetOverride(_ped);
			}
		}

		public void _0xFAB944D4D481ACCB(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__0xFAB944D4D481ACCB == null) fn__0xFAB944D4D481ACCB = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xFAB944D4D481ACCB");
				fn__0xFAB944D4D481ACCB(_ped, _toggle);
			}
		}

		public int AddRope(float _x, float _y, float _z, float _rotX, float _rotY, float _rotZ, float _length, int _ropeType, float _maxLength, float _minLength, float _windingSpeed, bool _p11, bool _p12, bool _rigid, float _p14, bool _breakWhenShot, ref int _unkPtr)
		{
			unsafe {
				if (fn__addRope == null) fn__addRope = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, float, float, float, bool, bool, bool, float, bool, int*, int>) NativeLibrary.GetExport(handle, "Native_addRope");
				var ref_unkPtr = _unkPtr;
				var result = fn__addRope(_x, _y, _z, _rotX, _rotY, _rotZ, _length, _ropeType, _maxLength, _minLength, _windingSpeed, _p11, _p12, _rigid, _p14, _breakWhenShot, &ref_unkPtr);
				_unkPtr = ref_unkPtr;
				return result;
			}
		}

		public void DeleteRope(ref int _ropeId)
		{
			unsafe {
				if (fn__deleteRope == null) fn__deleteRope = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_deleteRope");
				var ref_ropeId = _ropeId;
				fn__deleteRope(&ref_ropeId);
				_ropeId = ref_ropeId;
			}
		}

		public void DeleteChildRope(int _ropeId)
		{
			unsafe {
				if (fn__deleteChildRope == null) fn__deleteChildRope = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_deleteChildRope");
				fn__deleteChildRope(_ropeId);
			}
		}

		public bool DoesRopeExist(ref int _ropeId)
		{
			unsafe {
				if (fn__doesRopeExist == null) fn__doesRopeExist = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_doesRopeExist");
				var ref_ropeId = _ropeId;
				var result = fn__doesRopeExist(&ref_ropeId);
				_ropeId = ref_ropeId;
				return result;
			}
		}

		public void _0xA1AE736541B0FCA3(ref int _ropeId, bool _p1)
		{
			unsafe {
				if (fn__0xA1AE736541B0FCA3 == null) fn__0xA1AE736541B0FCA3 = (delegate* unmanaged[Cdecl]<int*, bool, void>) NativeLibrary.GetExport(handle, "Native__0xA1AE736541B0FCA3");
				var ref_ropeId = _ropeId;
				fn__0xA1AE736541B0FCA3(&ref_ropeId, _p1);
				_ropeId = ref_ropeId;
			}
		}

		public void RopeDrawShadowEnabled(ref int _ropeId, bool _toggle)
		{
			unsafe {
				if (fn__ropeDrawShadowEnabled == null) fn__ropeDrawShadowEnabled = (delegate* unmanaged[Cdecl]<int*, bool, void>) NativeLibrary.GetExport(handle, "Native_ropeDrawShadowEnabled");
				var ref_ropeId = _ropeId;
				fn__ropeDrawShadowEnabled(&ref_ropeId, _toggle);
				_ropeId = ref_ropeId;
			}
		}

		public void LoadRopeData(int _ropeId, string _rope_preset)
		{
			unsafe {
				if (fn__loadRopeData == null) fn__loadRopeData = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_loadRopeData");
				var ptr_rope_preset = MemoryUtils.StringToHGlobalUtf8(_rope_preset);
				fn__loadRopeData(_ropeId, ptr_rope_preset);
				Marshal.FreeHGlobal(ptr_rope_preset);
			}
		}

		public void PinRopeVertex(int _ropeId, int _vertex, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__pinRopeVertex == null) fn__pinRopeVertex = (delegate* unmanaged[Cdecl]<int, int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_pinRopeVertex");
				fn__pinRopeVertex(_ropeId, _vertex, _x, _y, _z);
			}
		}

		public void UnpinRopeVertex(int _ropeId, int _vertex)
		{
			unsafe {
				if (fn__unpinRopeVertex == null) fn__unpinRopeVertex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_unpinRopeVertex");
				fn__unpinRopeVertex(_ropeId, _vertex);
			}
		}

		public int GetRopeVertexCount(int _ropeId)
		{
			unsafe {
				if (fn__getRopeVertexCount == null) fn__getRopeVertexCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getRopeVertexCount");
				var result = fn__getRopeVertexCount(_ropeId);
				return result;
			}
		}

		public void AttachEntitiesToRope(int _ropeId, int _ent1, int _ent2, float _ent1_x, float _ent1_y, float _ent1_z, float _ent2_x, float _ent2_y, float _ent2_z, float _length, bool _p10, bool _p11, ref int _p12, ref int _p13)
		{
			unsafe {
				if (fn__attachEntitiesToRope == null) fn__attachEntitiesToRope = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, float, float, bool, bool, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_attachEntitiesToRope");
				var ref_p12 = _p12;
				var ref_p13 = _p13;
				fn__attachEntitiesToRope(_ropeId, _ent1, _ent2, _ent1_x, _ent1_y, _ent1_z, _ent2_x, _ent2_y, _ent2_z, _length, _p10, _p11, &ref_p12, &ref_p13);
				_p12 = ref_p12;
				_p13 = ref_p13;
			}
		}

		public void AttachRopeToEntity(int _ropeId, int _entity, float _x, float _y, float _z, bool _p5)
		{
			unsafe {
				if (fn__attachRopeToEntity == null) fn__attachRopeToEntity = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_attachRopeToEntity");
				fn__attachRopeToEntity(_ropeId, _entity, _x, _y, _z, _p5);
			}
		}

		public void DetachRopeFromEntity(int _ropeId, int _entity)
		{
			unsafe {
				if (fn__detachRopeFromEntity == null) fn__detachRopeFromEntity = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_detachRopeFromEntity");
				fn__detachRopeFromEntity(_ropeId, _entity);
			}
		}

		public void RopeSetUpdatePinverts(int _ropeId)
		{
			unsafe {
				if (fn__ropeSetUpdatePinverts == null) fn__ropeSetUpdatePinverts = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_ropeSetUpdatePinverts");
				fn__ropeSetUpdatePinverts(_ropeId);
			}
		}

		public void RopeSetUpdateOrder(int _ropeId, int _p1)
		{
			unsafe {
				if (fn__ropeSetUpdateOrder == null) fn__ropeSetUpdateOrder = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_ropeSetUpdateOrder");
				fn__ropeSetUpdateOrder(_ropeId, _p1);
			}
		}

		public void _0x36CCB9BE67B970FD(int _ropeId, bool _p1)
		{
			unsafe {
				if (fn__0x36CCB9BE67B970FD == null) fn__0x36CCB9BE67B970FD = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x36CCB9BE67B970FD");
				fn__0x36CCB9BE67B970FD(_ropeId, _p1);
			}
		}

		public bool _0x84DE3B5FB3E666F0(ref int _ropeId)
		{
			unsafe {
				if (fn__0x84DE3B5FB3E666F0 == null) fn__0x84DE3B5FB3E666F0 = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native__0x84DE3B5FB3E666F0");
				var ref_ropeId = _ropeId;
				var result = fn__0x84DE3B5FB3E666F0(&ref_ropeId);
				_ropeId = ref_ropeId;
				return result;
			}
		}

		public Vector3 GetRopeLastVertexCoord(int _ropeId)
		{
			unsafe {
				if (fn__getRopeLastVertexCoord == null) fn__getRopeLastVertexCoord = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getRopeLastVertexCoord");
				var result = fn__getRopeLastVertexCoord(_ropeId);
				return result;
			}
		}

		public Vector3 GetRopeVertexCoord(int _ropeId, int _vertex)
		{
			unsafe {
				if (fn__getRopeVertexCoord == null) fn__getRopeVertexCoord = (delegate* unmanaged[Cdecl]<int, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getRopeVertexCoord");
				var result = fn__getRopeVertexCoord(_ropeId, _vertex);
				return result;
			}
		}

		public void StartRopeWinding(int _ropeId)
		{
			unsafe {
				if (fn__startRopeWinding == null) fn__startRopeWinding = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_startRopeWinding");
				fn__startRopeWinding(_ropeId);
			}
		}

		public void StopRopeWinding(int _ropeId)
		{
			unsafe {
				if (fn__stopRopeWinding == null) fn__stopRopeWinding = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopRopeWinding");
				fn__stopRopeWinding(_ropeId);
			}
		}

		public void StartRopeUnwindingFront(int _ropeId)
		{
			unsafe {
				if (fn__startRopeUnwindingFront == null) fn__startRopeUnwindingFront = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_startRopeUnwindingFront");
				fn__startRopeUnwindingFront(_ropeId);
			}
		}

		public void StopRopeUnwindingFront(int _ropeId)
		{
			unsafe {
				if (fn__stopRopeUnwindingFront == null) fn__stopRopeUnwindingFront = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopRopeUnwindingFront");
				fn__stopRopeUnwindingFront(_ropeId);
			}
		}

		public void RopeConvertToSimple(int _ropeId)
		{
			unsafe {
				if (fn__ropeConvertToSimple == null) fn__ropeConvertToSimple = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_ropeConvertToSimple");
				fn__ropeConvertToSimple(_ropeId);
			}
		}

		public void RopeLoadTextures()
		{
			unsafe {
				if (fn__ropeLoadTextures == null) fn__ropeLoadTextures = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_ropeLoadTextures");
				fn__ropeLoadTextures();
			}
		}

		public bool RopeAreTexturesLoaded()
		{
			unsafe {
				if (fn__ropeAreTexturesLoaded == null) fn__ropeAreTexturesLoaded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_ropeAreTexturesLoaded");
				var result = fn__ropeAreTexturesLoaded();
				return result;
			}
		}

		public void RopeUnloadTextures()
		{
			unsafe {
				if (fn__ropeUnloadTextures == null) fn__ropeUnloadTextures = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_ropeUnloadTextures");
				fn__ropeUnloadTextures();
			}
		}

		public bool DoesRopeBelongToThisScript(int _ropeId)
		{
			unsafe {
				if (fn__doesRopeBelongToThisScript == null) fn__doesRopeBelongToThisScript = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesRopeBelongToThisScript");
				var result = fn__doesRopeBelongToThisScript(_ropeId);
				return result;
			}
		}

		public void _0xBC0CE682D4D05650(int _ropeId, int _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, float _p8, float _p9, float _p10, float _p11, float _p12, float _p13)
		{
			unsafe {
				if (fn__0xBC0CE682D4D05650 == null) fn__0xBC0CE682D4D05650 = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0xBC0CE682D4D05650");
				fn__0xBC0CE682D4D05650(_ropeId, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12, _p13);
			}
		}

		public void _0xB1B6216CA2E7B55E(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__0xB1B6216CA2E7B55E == null) fn__0xB1B6216CA2E7B55E = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native__0xB1B6216CA2E7B55E");
				fn__0xB1B6216CA2E7B55E(_p0, _p1, _p2);
			}
		}

		public void _0xB743F735C03D7810(int _ropeId, int _p1)
		{
			unsafe {
				if (fn__0xB743F735C03D7810 == null) fn__0xB743F735C03D7810 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xB743F735C03D7810");
				fn__0xB743F735C03D7810(_ropeId, _p1);
			}
		}

		public float RopeGetDistanceBetweenEnds(int _ropeId)
		{
			unsafe {
				if (fn__ropeGetDistanceBetweenEnds == null) fn__ropeGetDistanceBetweenEnds = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_ropeGetDistanceBetweenEnds");
				var result = fn__ropeGetDistanceBetweenEnds(_ropeId);
				return result;
			}
		}

		public void RopeForceLength(int _ropeId, float _length)
		{
			unsafe {
				if (fn__ropeForceLength == null) fn__ropeForceLength = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_ropeForceLength");
				fn__ropeForceLength(_ropeId, _length);
			}
		}

		public void RopeResetLength(int _ropeId, float _length)
		{
			unsafe {
				if (fn__ropeResetLength == null) fn__ropeResetLength = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_ropeResetLength");
				fn__ropeResetLength(_ropeId, _length);
			}
		}

		public void ApplyImpulseToCloth(float _posX, float _posY, float _posZ, float _vecX, float _vecY, float _vecZ, float _impulse)
		{
			unsafe {
				if (fn__applyImpulseToCloth == null) fn__applyImpulseToCloth = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_applyImpulseToCloth");
				fn__applyImpulseToCloth(_posX, _posY, _posZ, _vecX, _vecY, _vecZ, _impulse);
			}
		}

		public void SetDamping(int _entity, int _vertex, float _value)
		{
			unsafe {
				if (fn__setDamping == null) fn__setDamping = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setDamping");
				fn__setDamping(_entity, _vertex, _value);
			}
		}

		public void ActivatePhysics(int _entity)
		{
			unsafe {
				if (fn__activatePhysics == null) fn__activatePhysics = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_activatePhysics");
				fn__activatePhysics(_entity);
			}
		}

		public void SetCgoffset(int _entity, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setCgoffset == null) fn__setCgoffset = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setCgoffset");
				fn__setCgoffset(_entity, _x, _y, _z);
			}
		}

		public Vector3 GetCgoffset(int _entity)
		{
			unsafe {
				if (fn__getCgoffset == null) fn__getCgoffset = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getCgoffset");
				var result = fn__getCgoffset(_entity);
				return result;
			}
		}

		public void SetCgAtBoundcenter(int _entity)
		{
			unsafe {
				if (fn__setCgAtBoundcenter == null) fn__setCgAtBoundcenter = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setCgAtBoundcenter");
				fn__setCgAtBoundcenter(_entity);
			}
		}

		public void BreakEntityGlass(int _entity, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, float _p8, int _p9, bool _p10)
		{
			unsafe {
				if (fn__breakEntityGlass == null) fn__breakEntityGlass = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_breakEntityGlass");
				fn__breakEntityGlass(_entity, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10);
			}
		}

		public bool GetHasObjectFragInst(int _object)
		{
			unsafe {
				if (fn__getHasObjectFragInst == null) fn__getHasObjectFragInst = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getHasObjectFragInst");
				var result = fn__getHasObjectFragInst(_object);
				return result;
			}
		}

		public void SetDisableBreaking(int _object, bool _toggle)
		{
			unsafe {
				if (fn__setDisableBreaking == null) fn__setDisableBreaking = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableBreaking");
				fn__setDisableBreaking(_object, _toggle);
			}
		}

		public void _0xCC6E963682533882(int _object)
		{
			unsafe {
				if (fn__0xCC6E963682533882 == null) fn__0xCC6E963682533882 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xCC6E963682533882");
				fn__0xCC6E963682533882(_object);
			}
		}

		public void SetDisableFragDamage(int _object, bool _toggle)
		{
			unsafe {
				if (fn__setDisableFragDamage == null) fn__setDisableFragDamage = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableFragDamage");
				fn__setDisableFragDamage(_object, _toggle);
			}
		}

		public void SetEntityProofUnk(int _entity, bool _toggle)
		{
			unsafe {
				if (fn__setEntityProofUnk == null) fn__setEntityProofUnk = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEntityProofUnk");
				fn__setEntityProofUnk(_entity, _toggle);
			}
		}

		public void _0x9EBD751E5787BAF2(bool _p0)
		{
			unsafe {
				if (fn__0x9EBD751E5787BAF2 == null) fn__0x9EBD751E5787BAF2 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x9EBD751E5787BAF2");
				fn__0x9EBD751E5787BAF2(_p0);
			}
		}

		public void SetLaunchControlEnabled(bool _toggle)
		{
			unsafe {
				if (fn__setLaunchControlEnabled == null) fn__setLaunchControlEnabled = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setLaunchControlEnabled");
				fn__setLaunchControlEnabled(_toggle);
			}
		}

		public int GetPlayerPed(int _player)
		{
			unsafe {
				if (fn__getPlayerPed == null) fn__getPlayerPed = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerPed");
				var result = fn__getPlayerPed(_player);
				return result;
			}
		}

		public int GetPlayerPedScriptIndex(int _player)
		{
			unsafe {
				if (fn__getPlayerPedScriptIndex == null) fn__getPlayerPedScriptIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerPedScriptIndex");
				var result = fn__getPlayerPedScriptIndex(_player);
				return result;
			}
		}

		public void SetPlayerModel(int _player, int _model)
		{
			unsafe {
				if (fn__setPlayerModel == null) fn__setPlayerModel = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerModel");
				fn__setPlayerModel(_player, _model);
			}
		}

		public void ChangePlayerPed(int _player, int _ped, bool _p2, bool _resetDamage)
		{
			unsafe {
				if (fn__changePlayerPed == null) fn__changePlayerPed = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_changePlayerPed");
				fn__changePlayerPed(_player, _ped, _p2, _resetDamage);
			}
		}

		public void GetPlayerRgbColour(int _player, ref int _r, ref int _g, ref int _b)
		{
			unsafe {
				if (fn__getPlayerRgbColour == null) fn__getPlayerRgbColour = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getPlayerRgbColour");
				var ref_r = _r;
				var ref_g = _g;
				var ref_b = _b;
				fn__getPlayerRgbColour(_player, &ref_r, &ref_g, &ref_b);
				_r = ref_r;
				_g = ref_g;
				_b = ref_b;
			}
		}

		public int GetNumberOfPlayers()
		{
			unsafe {
				if (fn__getNumberOfPlayers == null) fn__getNumberOfPlayers = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumberOfPlayers");
				var result = fn__getNumberOfPlayers();
				return result;
			}
		}

		public int GetPlayerTeam(int _player)
		{
			unsafe {
				if (fn__getPlayerTeam == null) fn__getPlayerTeam = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerTeam");
				var result = fn__getPlayerTeam(_player);
				return result;
			}
		}

		public void SetPlayerTeam(int _player, int _team)
		{
			unsafe {
				if (fn__setPlayerTeam == null) fn__setPlayerTeam = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerTeam");
				fn__setPlayerTeam(_player, _team);
			}
		}

		public int GetNumberOfPlayersInTeam(int _team)
		{
			unsafe {
				if (fn__getNumberOfPlayersInTeam == null) fn__getNumberOfPlayersInTeam = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfPlayersInTeam");
				var result = fn__getNumberOfPlayersInTeam(_team);
				return result;
			}
		}

		public string GetPlayerName(int _player)
		{
			unsafe {
				if (fn__getPlayerName == null) fn__getPlayerName = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getPlayerName");
				var result = fn__getPlayerName(_player);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public float GetWantedLevelRadius(int _player)
		{
			unsafe {
				if (fn__getWantedLevelRadius == null) fn__getWantedLevelRadius = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getWantedLevelRadius");
				var result = fn__getWantedLevelRadius(_player);
				return result;
			}
		}

		public Vector3 GetPlayerWantedCentrePosition(int _player)
		{
			unsafe {
				if (fn__getPlayerWantedCentrePosition == null) fn__getPlayerWantedCentrePosition = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getPlayerWantedCentrePosition");
				var result = fn__getPlayerWantedCentrePosition(_player);
				return result;
			}
		}

		public void SetPlayerWantedCentrePosition(int _player, ref Vector3 _position, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__setPlayerWantedCentrePosition == null) fn__setPlayerWantedCentrePosition = (delegate* unmanaged[Cdecl]<int, Vector3*, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerWantedCentrePosition");
				var ref_position = _position;
				fn__setPlayerWantedCentrePosition(_player, &ref_position, _p2, _p3);
				_position = ref_position;
			}
		}

		public int GetWantedLevelThreshold(int _wantedLevel)
		{
			unsafe {
				if (fn__getWantedLevelThreshold == null) fn__getWantedLevelThreshold = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWantedLevelThreshold");
				var result = fn__getWantedLevelThreshold(_wantedLevel);
				return result;
			}
		}

		public void SetPlayerWantedLevel(int _player, int _wantedLevel, bool _disableNoMission)
		{
			unsafe {
				if (fn__setPlayerWantedLevel == null) fn__setPlayerWantedLevel = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerWantedLevel");
				fn__setPlayerWantedLevel(_player, _wantedLevel, _disableNoMission);
			}
		}

		public void SetPlayerWantedLevelNoDrop(int _player, int _wantedLevel, bool _p2)
		{
			unsafe {
				if (fn__setPlayerWantedLevelNoDrop == null) fn__setPlayerWantedLevelNoDrop = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerWantedLevelNoDrop");
				fn__setPlayerWantedLevelNoDrop(_player, _wantedLevel, _p2);
			}
		}

		public void SetPlayerWantedLevelNow(int _player, bool _p1)
		{
			unsafe {
				if (fn__setPlayerWantedLevelNow == null) fn__setPlayerWantedLevelNow = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerWantedLevelNow");
				fn__setPlayerWantedLevelNow(_player, _p1);
			}
		}

		public bool ArePlayerFlashingStarsAboutToDrop(int _player)
		{
			unsafe {
				if (fn__arePlayerFlashingStarsAboutToDrop == null) fn__arePlayerFlashingStarsAboutToDrop = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_arePlayerFlashingStarsAboutToDrop");
				var result = fn__arePlayerFlashingStarsAboutToDrop(_player);
				return result;
			}
		}

		public bool ArePlayerStarsGreyedOut(int _player)
		{
			unsafe {
				if (fn__arePlayerStarsGreyedOut == null) fn__arePlayerStarsGreyedOut = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_arePlayerStarsGreyedOut");
				var result = fn__arePlayerStarsGreyedOut(_player);
				return result;
			}
		}

		public int _0x7E07C78925D5FD96(int _p0)
		{
			unsafe {
				if (fn__0x7E07C78925D5FD96 == null) fn__0x7E07C78925D5FD96 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x7E07C78925D5FD96");
				var result = fn__0x7E07C78925D5FD96(_p0);
				return result;
			}
		}

		public void SetDispatchCopsForPlayer(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setDispatchCopsForPlayer == null) fn__setDispatchCopsForPlayer = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDispatchCopsForPlayer");
				fn__setDispatchCopsForPlayer(_player, _toggle);
			}
		}

		public bool IsPlayerWantedLevelGreater(int _player, int _wantedLevel)
		{
			unsafe {
				if (fn__isPlayerWantedLevelGreater == null) fn__isPlayerWantedLevelGreater = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerWantedLevelGreater");
				var result = fn__isPlayerWantedLevelGreater(_player, _wantedLevel);
				return result;
			}
		}

		public void ClearPlayerWantedLevel(int _player)
		{
			unsafe {
				if (fn__clearPlayerWantedLevel == null) fn__clearPlayerWantedLevel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPlayerWantedLevel");
				fn__clearPlayerWantedLevel(_player);
			}
		}

		public bool IsPlayerDead(int _player)
		{
			unsafe {
				if (fn__isPlayerDead == null) fn__isPlayerDead = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerDead");
				var result = fn__isPlayerDead(_player);
				return result;
			}
		}

		public bool IsPlayerPressingHorn(int _player)
		{
			unsafe {
				if (fn__isPlayerPressingHorn == null) fn__isPlayerPressingHorn = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerPressingHorn");
				var result = fn__isPlayerPressingHorn(_player);
				return result;
			}
		}

		public void SetPlayerControl(int _player, bool _bHasControl, int _flags)
		{
			unsafe {
				if (fn__setPlayerControl == null) fn__setPlayerControl = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerControl");
				fn__setPlayerControl(_player, _bHasControl, _flags);
			}
		}

		public int GetPlayerWantedLevel(int _player)
		{
			unsafe {
				if (fn__getPlayerWantedLevel == null) fn__getPlayerWantedLevel = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerWantedLevel");
				var result = fn__getPlayerWantedLevel(_player);
				return result;
			}
		}

		public void SetMaxWantedLevel(int _maxWantedLevel)
		{
			unsafe {
				if (fn__setMaxWantedLevel == null) fn__setMaxWantedLevel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setMaxWantedLevel");
				fn__setMaxWantedLevel(_maxWantedLevel);
			}
		}

		public void SetPoliceRadarBlips(bool _toggle)
		{
			unsafe {
				if (fn__setPoliceRadarBlips == null) fn__setPoliceRadarBlips = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setPoliceRadarBlips");
				fn__setPoliceRadarBlips(_toggle);
			}
		}

		public void SetPoliceIgnorePlayer(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPoliceIgnorePlayer == null) fn__setPoliceIgnorePlayer = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPoliceIgnorePlayer");
				fn__setPoliceIgnorePlayer(_player, _toggle);
			}
		}

		public bool IsPlayerPlaying(int _player)
		{
			unsafe {
				if (fn__isPlayerPlaying == null) fn__isPlayerPlaying = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerPlaying");
				var result = fn__isPlayerPlaying(_player);
				return result;
			}
		}

		public void SetEveryoneIgnorePlayer(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setEveryoneIgnorePlayer == null) fn__setEveryoneIgnorePlayer = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setEveryoneIgnorePlayer");
				fn__setEveryoneIgnorePlayer(_player, _toggle);
			}
		}

		public void SetAllRandomPedsFlee(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setAllRandomPedsFlee == null) fn__setAllRandomPedsFlee = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setAllRandomPedsFlee");
				fn__setAllRandomPedsFlee(_player, _toggle);
			}
		}

		public void SetAllRandomPedsFleeThisFrame(int _player)
		{
			unsafe {
				if (fn__setAllRandomPedsFleeThisFrame == null) fn__setAllRandomPedsFleeThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setAllRandomPedsFleeThisFrame");
				fn__setAllRandomPedsFleeThisFrame(_player);
			}
		}

		public void _0xDE45D1A1EF45EE61(int _player, bool _toggle)
		{
			unsafe {
				if (fn__0xDE45D1A1EF45EE61 == null) fn__0xDE45D1A1EF45EE61 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xDE45D1A1EF45EE61");
				fn__0xDE45D1A1EF45EE61(_player, _toggle);
			}
		}

		public void _0xC3376F42B1FACCC6(int _player)
		{
			unsafe {
				if (fn__0xC3376F42B1FACCC6 == null) fn__0xC3376F42B1FACCC6 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC3376F42B1FACCC6");
				fn__0xC3376F42B1FACCC6(_player);
			}
		}

		public void _0xFAC75988A7D078D3(int _player)
		{
			unsafe {
				if (fn__0xFAC75988A7D078D3 == null) fn__0xFAC75988A7D078D3 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xFAC75988A7D078D3");
				fn__0xFAC75988A7D078D3(_player);
			}
		}

		public void SetIgnoreLowPriorityShockingEvents(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setIgnoreLowPriorityShockingEvents == null) fn__setIgnoreLowPriorityShockingEvents = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setIgnoreLowPriorityShockingEvents");
				fn__setIgnoreLowPriorityShockingEvents(_player, _toggle);
			}
		}

		public void SetWantedLevelMultiplier(float _multiplier)
		{
			unsafe {
				if (fn__setWantedLevelMultiplier == null) fn__setWantedLevelMultiplier = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setWantedLevelMultiplier");
				fn__setWantedLevelMultiplier(_multiplier);
			}
		}

		public void SetWantedLevelDifficulty(int _player, float _difficulty)
		{
			unsafe {
				if (fn__setWantedLevelDifficulty == null) fn__setWantedLevelDifficulty = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setWantedLevelDifficulty");
				fn__setWantedLevelDifficulty(_player, _difficulty);
			}
		}

		public void ResetWantedLevelDifficulty(int _player)
		{
			unsafe {
				if (fn__resetWantedLevelDifficulty == null) fn__resetWantedLevelDifficulty = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetWantedLevelDifficulty");
				fn__resetWantedLevelDifficulty(_player);
			}
		}

		public int GetWantedLevelParoleDuration()
		{
			unsafe {
				if (fn__getWantedLevelParoleDuration == null) fn__getWantedLevelParoleDuration = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getWantedLevelParoleDuration");
				var result = fn__getWantedLevelParoleDuration();
				return result;
			}
		}

		public void SetWantedLevelHiddenEvasionTime(int _player, int _wantedLevel, int _lossTime)
		{
			unsafe {
				if (fn__setWantedLevelHiddenEvasionTime == null) fn__setWantedLevelHiddenEvasionTime = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setWantedLevelHiddenEvasionTime");
				fn__setWantedLevelHiddenEvasionTime(_player, _wantedLevel, _lossTime);
			}
		}

		public void _0x823EC8E82BA45986(int _p0)
		{
			unsafe {
				if (fn__0x823EC8E82BA45986 == null) fn__0x823EC8E82BA45986 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x823EC8E82BA45986");
				fn__0x823EC8E82BA45986(_p0);
			}
		}

		public void StartFiringAmnesty(int _duration)
		{
			unsafe {
				if (fn__startFiringAmnesty == null) fn__startFiringAmnesty = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_startFiringAmnesty");
				fn__startFiringAmnesty(_duration);
			}
		}

		public void ReportCrime(int _player, int _crimeType, int _wantedLvlThresh)
		{
			unsafe {
				if (fn__reportCrime == null) fn__reportCrime = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_reportCrime");
				fn__reportCrime(_player, _crimeType, _wantedLvlThresh);
			}
		}

		public void SwitchCrimeType(int _player, int _p1)
		{
			unsafe {
				if (fn__switchCrimeType == null) fn__switchCrimeType = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_switchCrimeType");
				fn__switchCrimeType(_player, _p1);
			}
		}

		public void _0xBC9490CA15AEA8FB(int _player)
		{
			unsafe {
				if (fn__0xBC9490CA15AEA8FB == null) fn__0xBC9490CA15AEA8FB = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xBC9490CA15AEA8FB");
				fn__0xBC9490CA15AEA8FB(_player);
			}
		}

		public void _0x4669B3ED80F24B4E(int _player)
		{
			unsafe {
				if (fn__0x4669B3ED80F24B4E == null) fn__0x4669B3ED80F24B4E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x4669B3ED80F24B4E");
				fn__0x4669B3ED80F24B4E(_player);
			}
		}

		public void _0x2F41A3BAE005E5FA(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x2F41A3BAE005E5FA == null) fn__0x2F41A3BAE005E5FA = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2F41A3BAE005E5FA");
				fn__0x2F41A3BAE005E5FA(_p0, _p1);
			}
		}

		public void _0xAD73CE5A09E42D12(int _player)
		{
			unsafe {
				if (fn__0xAD73CE5A09E42D12 == null) fn__0xAD73CE5A09E42D12 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xAD73CE5A09E42D12");
				fn__0xAD73CE5A09E42D12(_player);
			}
		}

		public void _0x36F1B38855F2A8DF(int _player)
		{
			unsafe {
				if (fn__0x36F1B38855F2A8DF == null) fn__0x36F1B38855F2A8DF = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x36F1B38855F2A8DF");
				fn__0x36F1B38855F2A8DF(_player);
			}
		}

		public void ReportPoliceSpottedPlayer(int _player)
		{
			unsafe {
				if (fn__reportPoliceSpottedPlayer == null) fn__reportPoliceSpottedPlayer = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_reportPoliceSpottedPlayer");
				fn__reportPoliceSpottedPlayer(_player);
			}
		}

		public void _0xB45EFF719D8427A6(float _p0)
		{
			unsafe {
				if (fn__0xB45EFF719D8427A6 == null) fn__0xB45EFF719D8427A6 = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0xB45EFF719D8427A6");
				fn__0xB45EFF719D8427A6(_p0);
			}
		}

		public void _0x0032A6DBA562C518()
		{
			unsafe {
				if (fn__0x0032A6DBA562C518 == null) fn__0x0032A6DBA562C518 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x0032A6DBA562C518");
				fn__0x0032A6DBA562C518();
			}
		}

		public bool CanPlayerStartMission(int _player)
		{
			unsafe {
				if (fn__canPlayerStartMission == null) fn__canPlayerStartMission = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canPlayerStartMission");
				var result = fn__canPlayerStartMission(_player);
				return result;
			}
		}

		public bool IsPlayerReadyForCutscene(int _player)
		{
			unsafe {
				if (fn__isPlayerReadyForCutscene == null) fn__isPlayerReadyForCutscene = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerReadyForCutscene");
				var result = fn__isPlayerReadyForCutscene(_player);
				return result;
			}
		}

		public bool IsPlayerTargettingEntity(int _player, int _entity)
		{
			unsafe {
				if (fn__isPlayerTargettingEntity == null) fn__isPlayerTargettingEntity = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerTargettingEntity");
				var result = fn__isPlayerTargettingEntity(_player, _entity);
				return result;
			}
		}

		public bool GetPlayerTargetEntity(int _player, ref int _entity)
		{
			unsafe {
				if (fn__getPlayerTargetEntity == null) fn__getPlayerTargetEntity = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getPlayerTargetEntity");
				var ref_entity = _entity;
				var result = fn__getPlayerTargetEntity(_player, &ref_entity);
				_entity = ref_entity;
				return result;
			}
		}

		public bool IsPlayerFreeAiming(int _player)
		{
			unsafe {
				if (fn__isPlayerFreeAiming == null) fn__isPlayerFreeAiming = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerFreeAiming");
				var result = fn__isPlayerFreeAiming(_player);
				return result;
			}
		}

		public bool IsPlayerFreeAimingAtEntity(int _player, int _entity)
		{
			unsafe {
				if (fn__isPlayerFreeAimingAtEntity == null) fn__isPlayerFreeAimingAtEntity = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerFreeAimingAtEntity");
				var result = fn__isPlayerFreeAimingAtEntity(_player, _entity);
				return result;
			}
		}

		public bool GetEntityPlayerIsFreeAimingAt(int _player, ref int _entity)
		{
			unsafe {
				if (fn__getEntityPlayerIsFreeAimingAt == null) fn__getEntityPlayerIsFreeAimingAt = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getEntityPlayerIsFreeAimingAt");
				var ref_entity = _entity;
				var result = fn__getEntityPlayerIsFreeAimingAt(_player, &ref_entity);
				_entity = ref_entity;
				return result;
			}
		}

		public void SetPlayerLockonRangeOverride(int _player, float _range)
		{
			unsafe {
				if (fn__setPlayerLockonRangeOverride == null) fn__setPlayerLockonRangeOverride = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerLockonRangeOverride");
				fn__setPlayerLockonRangeOverride(_player, _range);
			}
		}

		public void SetPlayerCanDoDriveBy(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerCanDoDriveBy == null) fn__setPlayerCanDoDriveBy = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerCanDoDriveBy");
				fn__setPlayerCanDoDriveBy(_player, _toggle);
			}
		}

		public void SetPlayerCanBeHassledByGangs(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerCanBeHassledByGangs == null) fn__setPlayerCanBeHassledByGangs = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerCanBeHassledByGangs");
				fn__setPlayerCanBeHassledByGangs(_player, _toggle);
			}
		}

		public void SetPlayerCanUseCover(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerCanUseCover == null) fn__setPlayerCanUseCover = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerCanUseCover");
				fn__setPlayerCanUseCover(_player, _toggle);
			}
		}

		public int GetMaxWantedLevel()
		{
			unsafe {
				if (fn__getMaxWantedLevel == null) fn__getMaxWantedLevel = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getMaxWantedLevel");
				var result = fn__getMaxWantedLevel();
				return result;
			}
		}

		public bool IsPlayerTargettingAnything(int _player)
		{
			unsafe {
				if (fn__isPlayerTargettingAnything == null) fn__isPlayerTargettingAnything = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerTargettingAnything");
				var result = fn__isPlayerTargettingAnything(_player);
				return result;
			}
		}

		public void SetPlayerSprint(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerSprint == null) fn__setPlayerSprint = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerSprint");
				fn__setPlayerSprint(_player, _toggle);
			}
		}

		public void ResetPlayerStamina(int _player)
		{
			unsafe {
				if (fn__resetPlayerStamina == null) fn__resetPlayerStamina = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPlayerStamina");
				fn__resetPlayerStamina(_player);
			}
		}

		public void RestorePlayerStamina(int _player, float _p1)
		{
			unsafe {
				if (fn__restorePlayerStamina == null) fn__restorePlayerStamina = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_restorePlayerStamina");
				fn__restorePlayerStamina(_player, _p1);
			}
		}

		public float GetPlayerSprintStaminaRemaining(int _player)
		{
			unsafe {
				if (fn__getPlayerSprintStaminaRemaining == null) fn__getPlayerSprintStaminaRemaining = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPlayerSprintStaminaRemaining");
				var result = fn__getPlayerSprintStaminaRemaining(_player);
				return result;
			}
		}

		public float GetPlayerSprintTimeRemaining(int _player)
		{
			unsafe {
				if (fn__getPlayerSprintTimeRemaining == null) fn__getPlayerSprintTimeRemaining = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPlayerSprintTimeRemaining");
				var result = fn__getPlayerSprintTimeRemaining(_player);
				return result;
			}
		}

		public float GetPlayerUnderwaterTimeRemaining(int _player)
		{
			unsafe {
				if (fn__getPlayerUnderwaterTimeRemaining == null) fn__getPlayerUnderwaterTimeRemaining = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPlayerUnderwaterTimeRemaining");
				var result = fn__getPlayerUnderwaterTimeRemaining(_player);
				return result;
			}
		}

		public int SetPlayerUnderwaterTimeRemaining(int _player, float _time)
		{
			unsafe {
				if (fn__setPlayerUnderwaterTimeRemaining == null) fn__setPlayerUnderwaterTimeRemaining = (delegate* unmanaged[Cdecl]<int, float, int>) NativeLibrary.GetExport(handle, "Native_setPlayerUnderwaterTimeRemaining");
				var result = fn__setPlayerUnderwaterTimeRemaining(_player, _time);
				return result;
			}
		}

		public int GetPlayerGroup(int _player)
		{
			unsafe {
				if (fn__getPlayerGroup == null) fn__getPlayerGroup = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerGroup");
				var result = fn__getPlayerGroup(_player);
				return result;
			}
		}

		public int GetPlayerMaxArmour(int _player)
		{
			unsafe {
				if (fn__getPlayerMaxArmour == null) fn__getPlayerMaxArmour = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerMaxArmour");
				var result = fn__getPlayerMaxArmour(_player);
				return result;
			}
		}

		public bool IsPlayerControlOn(int _player)
		{
			unsafe {
				if (fn__isPlayerControlOn == null) fn__isPlayerControlOn = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerControlOn");
				var result = fn__isPlayerControlOn(_player);
				return result;
			}
		}

		public bool IsPlayerCamControlDisabled()
		{
			unsafe {
				if (fn__isPlayerCamControlDisabled == null) fn__isPlayerCamControlDisabled = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPlayerCamControlDisabled");
				var result = fn__isPlayerCamControlDisabled();
				return result;
			}
		}

		public bool IsPlayerScriptControlOn(int _player)
		{
			unsafe {
				if (fn__isPlayerScriptControlOn == null) fn__isPlayerScriptControlOn = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerScriptControlOn");
				var result = fn__isPlayerScriptControlOn(_player);
				return result;
			}
		}

		public bool IsPlayerClimbing(int _player)
		{
			unsafe {
				if (fn__isPlayerClimbing == null) fn__isPlayerClimbing = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerClimbing");
				var result = fn__isPlayerClimbing(_player);
				return result;
			}
		}

		public bool IsPlayerBeingArrested(int _player, bool _atArresting)
		{
			unsafe {
				if (fn__isPlayerBeingArrested == null) fn__isPlayerBeingArrested = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerBeingArrested");
				var result = fn__isPlayerBeingArrested(_player, _atArresting);
				return result;
			}
		}

		public void ResetPlayerArrestState(int _player)
		{
			unsafe {
				if (fn__resetPlayerArrestState == null) fn__resetPlayerArrestState = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPlayerArrestState");
				fn__resetPlayerArrestState(_player);
			}
		}

		public int GetPlayersLastVehicle()
		{
			unsafe {
				if (fn__getPlayersLastVehicle == null) fn__getPlayersLastVehicle = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayersLastVehicle");
				var result = fn__getPlayersLastVehicle();
				return result;
			}
		}

		public int GetPlayerIndex()
		{
			unsafe {
				if (fn__getPlayerIndex == null) fn__getPlayerIndex = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayerIndex");
				var result = fn__getPlayerIndex();
				return result;
			}
		}

		public int IntToPlayerindex(int _value)
		{
			unsafe {
				if (fn__intToPlayerindex == null) fn__intToPlayerindex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_intToPlayerindex");
				var result = fn__intToPlayerindex(_value);
				return result;
			}
		}

		public int IntToParticipantindex(int _value)
		{
			unsafe {
				if (fn__intToParticipantindex == null) fn__intToParticipantindex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_intToParticipantindex");
				var result = fn__intToParticipantindex(_value);
				return result;
			}
		}

		public int GetTimeSincePlayerHitVehicle(int _player)
		{
			unsafe {
				if (fn__getTimeSincePlayerHitVehicle == null) fn__getTimeSincePlayerHitVehicle = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getTimeSincePlayerHitVehicle");
				var result = fn__getTimeSincePlayerHitVehicle(_player);
				return result;
			}
		}

		public int GetTimeSincePlayerHitPed(int _player)
		{
			unsafe {
				if (fn__getTimeSincePlayerHitPed == null) fn__getTimeSincePlayerHitPed = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getTimeSincePlayerHitPed");
				var result = fn__getTimeSincePlayerHitPed(_player);
				return result;
			}
		}

		public int GetTimeSincePlayerDroveOnPavement(int _player)
		{
			unsafe {
				if (fn__getTimeSincePlayerDroveOnPavement == null) fn__getTimeSincePlayerDroveOnPavement = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getTimeSincePlayerDroveOnPavement");
				var result = fn__getTimeSincePlayerDroveOnPavement(_player);
				return result;
			}
		}

		public int GetTimeSincePlayerDroveAgainstTraffic(int _player)
		{
			unsafe {
				if (fn__getTimeSincePlayerDroveAgainstTraffic == null) fn__getTimeSincePlayerDroveAgainstTraffic = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getTimeSincePlayerDroveAgainstTraffic");
				var result = fn__getTimeSincePlayerDroveAgainstTraffic(_player);
				return result;
			}
		}

		public bool IsPlayerFreeForAmbientTask(int _player)
		{
			unsafe {
				if (fn__isPlayerFreeForAmbientTask == null) fn__isPlayerFreeForAmbientTask = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerFreeForAmbientTask");
				var result = fn__isPlayerFreeForAmbientTask(_player);
				return result;
			}
		}

		public int PlayerId()
		{
			unsafe {
				if (fn__playerId == null) fn__playerId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_playerId");
				var result = fn__playerId();
				return result;
			}
		}

		public int PlayerPedId()
		{
			unsafe {
				if (fn__playerPedId == null) fn__playerPedId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_playerPedId");
				var result = fn__playerPedId();
				return result;
			}
		}

		public int NetworkPlayerIdToInt()
		{
			unsafe {
				if (fn__networkPlayerIdToInt == null) fn__networkPlayerIdToInt = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_networkPlayerIdToInt");
				var result = fn__networkPlayerIdToInt();
				return result;
			}
		}

		public bool HasForceCleanupOccurred(int _cleanupFlags)
		{
			unsafe {
				if (fn__hasForceCleanupOccurred == null) fn__hasForceCleanupOccurred = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasForceCleanupOccurred");
				var result = fn__hasForceCleanupOccurred(_cleanupFlags);
				return result;
			}
		}

		public void ForceCleanup(int _cleanupFlags)
		{
			unsafe {
				if (fn__forceCleanup == null) fn__forceCleanup = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_forceCleanup");
				fn__forceCleanup(_cleanupFlags);
			}
		}

		public void ForceCleanupForAllThreadsWithThisName(string _name, int _cleanupFlags)
		{
			unsafe {
				if (fn__forceCleanupForAllThreadsWithThisName == null) fn__forceCleanupForAllThreadsWithThisName = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_forceCleanupForAllThreadsWithThisName");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__forceCleanupForAllThreadsWithThisName(ptr_name, _cleanupFlags);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void ForceCleanupForThreadWithThisId(int _id, int _cleanupFlags)
		{
			unsafe {
				if (fn__forceCleanupForThreadWithThisId == null) fn__forceCleanupForThreadWithThisId = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_forceCleanupForThreadWithThisId");
				fn__forceCleanupForThreadWithThisId(_id, _cleanupFlags);
			}
		}

		public int GetCauseOfMostRecentForceCleanup()
		{
			unsafe {
				if (fn__getCauseOfMostRecentForceCleanup == null) fn__getCauseOfMostRecentForceCleanup = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getCauseOfMostRecentForceCleanup");
				var result = fn__getCauseOfMostRecentForceCleanup();
				return result;
			}
		}

		public void SetPlayerMayOnlyEnterThisVehicle(int _player, int _vehicle)
		{
			unsafe {
				if (fn__setPlayerMayOnlyEnterThisVehicle == null) fn__setPlayerMayOnlyEnterThisVehicle = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerMayOnlyEnterThisVehicle");
				fn__setPlayerMayOnlyEnterThisVehicle(_player, _vehicle);
			}
		}

		public void SetPlayerMayNotEnterAnyVehicle(int _player)
		{
			unsafe {
				if (fn__setPlayerMayNotEnterAnyVehicle == null) fn__setPlayerMayNotEnterAnyVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerMayNotEnterAnyVehicle");
				fn__setPlayerMayNotEnterAnyVehicle(_player);
			}
		}

		public bool GiveAchievementToPlayer(int _achievementId)
		{
			unsafe {
				if (fn__giveAchievementToPlayer == null) fn__giveAchievementToPlayer = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_giveAchievementToPlayer");
				var result = fn__giveAchievementToPlayer(_achievementId);
				return result;
			}
		}

		public bool SetAchievementProgress(int _achievementId, int _progress)
		{
			unsafe {
				if (fn__setAchievementProgress == null) fn__setAchievementProgress = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_setAchievementProgress");
				var result = fn__setAchievementProgress(_achievementId, _progress);
				return result;
			}
		}

		public int GetAchievementProgress(int _achievementId)
		{
			unsafe {
				if (fn__getAchievementProgress == null) fn__getAchievementProgress = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getAchievementProgress");
				var result = fn__getAchievementProgress(_achievementId);
				return result;
			}
		}

		public bool HasAchievementBeenPassed(int _achievementId)
		{
			unsafe {
				if (fn__hasAchievementBeenPassed == null) fn__hasAchievementBeenPassed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasAchievementBeenPassed");
				var result = fn__hasAchievementBeenPassed(_achievementId);
				return result;
			}
		}

		public bool IsPlayerOnline()
		{
			unsafe {
				if (fn__isPlayerOnline == null) fn__isPlayerOnline = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPlayerOnline");
				var result = fn__isPlayerOnline();
				return result;
			}
		}

		public bool IsPlayerLoggingInNp()
		{
			unsafe {
				if (fn__isPlayerLoggingInNp == null) fn__isPlayerLoggingInNp = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPlayerLoggingInNp");
				var result = fn__isPlayerLoggingInNp();
				return result;
			}
		}

		public void DisplaySystemSigninUi(bool _unk)
		{
			unsafe {
				if (fn__displaySystemSigninUi == null) fn__displaySystemSigninUi = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_displaySystemSigninUi");
				fn__displaySystemSigninUi(_unk);
			}
		}

		public bool IsSystemUiBeingDisplayed()
		{
			unsafe {
				if (fn__isSystemUiBeingDisplayed == null) fn__isSystemUiBeingDisplayed = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isSystemUiBeingDisplayed");
				var result = fn__isSystemUiBeingDisplayed();
				return result;
			}
		}

		public void SetPlayerInvincible(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerInvincible == null) fn__setPlayerInvincible = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerInvincible");
				fn__setPlayerInvincible(_player, _toggle);
			}
		}

		public bool GetPlayerInvincible(int _player)
		{
			unsafe {
				if (fn__getPlayerInvincible == null) fn__getPlayerInvincible = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getPlayerInvincible");
				var result = fn__getPlayerInvincible(_player);
				return result;
			}
		}

		public bool _0xDCC07526B8EC45AF(int _player)
		{
			unsafe {
				if (fn__0xDCC07526B8EC45AF == null) fn__0xDCC07526B8EC45AF = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xDCC07526B8EC45AF");
				var result = fn__0xDCC07526B8EC45AF(_player);
				return result;
			}
		}

		public void SetPlayerInvincibleKeepRagdollEnabled(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerInvincibleKeepRagdollEnabled == null) fn__setPlayerInvincibleKeepRagdollEnabled = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerInvincibleKeepRagdollEnabled");
				fn__setPlayerInvincibleKeepRagdollEnabled(_player, _toggle);
			}
		}

		public void _0xCAC57395B151135F(int _player, bool _p1)
		{
			unsafe {
				if (fn__0xCAC57395B151135F == null) fn__0xCAC57395B151135F = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xCAC57395B151135F");
				fn__0xCAC57395B151135F(_player, _p1);
			}
		}

		public void RemovePlayerHelmet(int _player, bool _p2)
		{
			unsafe {
				if (fn__removePlayerHelmet == null) fn__removePlayerHelmet = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removePlayerHelmet");
				fn__removePlayerHelmet(_player, _p2);
			}
		}

		public void GivePlayerRagdollControl(int _player, bool _toggle)
		{
			unsafe {
				if (fn__givePlayerRagdollControl == null) fn__givePlayerRagdollControl = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_givePlayerRagdollControl");
				fn__givePlayerRagdollControl(_player, _toggle);
			}
		}

		public void SetPlayerLockon(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerLockon == null) fn__setPlayerLockon = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerLockon");
				fn__setPlayerLockon(_player, _toggle);
			}
		}

		public void SetPlayerTargetingMode(int _targetMode)
		{
			unsafe {
				if (fn__setPlayerTargetingMode == null) fn__setPlayerTargetingMode = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerTargetingMode");
				fn__setPlayerTargetingMode(_targetMode);
			}
		}

		public void SetPlayerTargetLevel(int _targetLevel)
		{
			unsafe {
				if (fn__setPlayerTargetLevel == null) fn__setPlayerTargetLevel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerTargetLevel");
				fn__setPlayerTargetLevel(_targetLevel);
			}
		}

		public bool _0xB9CF1F793A9F1BF1()
		{
			unsafe {
				if (fn__0xB9CF1F793A9F1BF1 == null) fn__0xB9CF1F793A9F1BF1 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xB9CF1F793A9F1BF1");
				var result = fn__0xB9CF1F793A9F1BF1();
				return result;
			}
		}

		public bool _0xCB645E85E97EA48B()
		{
			unsafe {
				if (fn__0xCB645E85E97EA48B == null) fn__0xCB645E85E97EA48B = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xCB645E85E97EA48B");
				var result = fn__0xCB645E85E97EA48B();
				return result;
			}
		}

		public void ClearPlayerHasDamagedAtLeastOnePed(int _player)
		{
			unsafe {
				if (fn__clearPlayerHasDamagedAtLeastOnePed == null) fn__clearPlayerHasDamagedAtLeastOnePed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPlayerHasDamagedAtLeastOnePed");
				fn__clearPlayerHasDamagedAtLeastOnePed(_player);
			}
		}

		public bool HasPlayerDamagedAtLeastOnePed(int _player)
		{
			unsafe {
				if (fn__hasPlayerDamagedAtLeastOnePed == null) fn__hasPlayerDamagedAtLeastOnePed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasPlayerDamagedAtLeastOnePed");
				var result = fn__hasPlayerDamagedAtLeastOnePed(_player);
				return result;
			}
		}

		public void ClearPlayerHasDamagedAtLeastOneNonAnimalPed(int _player)
		{
			unsafe {
				if (fn__clearPlayerHasDamagedAtLeastOneNonAnimalPed == null) fn__clearPlayerHasDamagedAtLeastOneNonAnimalPed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPlayerHasDamagedAtLeastOneNonAnimalPed");
				fn__clearPlayerHasDamagedAtLeastOneNonAnimalPed(_player);
			}
		}

		public bool HasPlayerDamagedAtLeastOneNonAnimalPed(int _player)
		{
			unsafe {
				if (fn__hasPlayerDamagedAtLeastOneNonAnimalPed == null) fn__hasPlayerDamagedAtLeastOneNonAnimalPed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasPlayerDamagedAtLeastOneNonAnimalPed");
				var result = fn__hasPlayerDamagedAtLeastOneNonAnimalPed(_player);
				return result;
			}
		}

		public void SetAirDragMultiplierForPlayersVehicle(int _player, float _multiplier)
		{
			unsafe {
				if (fn__setAirDragMultiplierForPlayersVehicle == null) fn__setAirDragMultiplierForPlayersVehicle = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setAirDragMultiplierForPlayersVehicle");
				fn__setAirDragMultiplierForPlayersVehicle(_player, _multiplier);
			}
		}

		public void SetSwimMultiplierForPlayer(int _player, float _multiplier)
		{
			unsafe {
				if (fn__setSwimMultiplierForPlayer == null) fn__setSwimMultiplierForPlayer = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setSwimMultiplierForPlayer");
				fn__setSwimMultiplierForPlayer(_player, _multiplier);
			}
		}

		public void SetRunSprintMultiplierForPlayer(int _player, float _multiplier)
		{
			unsafe {
				if (fn__setRunSprintMultiplierForPlayer == null) fn__setRunSprintMultiplierForPlayer = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setRunSprintMultiplierForPlayer");
				fn__setRunSprintMultiplierForPlayer(_player, _multiplier);
			}
		}

		public int GetTimeSinceLastArrest()
		{
			unsafe {
				if (fn__getTimeSinceLastArrest == null) fn__getTimeSinceLastArrest = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getTimeSinceLastArrest");
				var result = fn__getTimeSinceLastArrest();
				return result;
			}
		}

		public int GetTimeSinceLastDeath()
		{
			unsafe {
				if (fn__getTimeSinceLastDeath == null) fn__getTimeSinceLastDeath = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getTimeSinceLastDeath");
				var result = fn__getTimeSinceLastDeath();
				return result;
			}
		}

		public void AssistedMovementCloseRoute()
		{
			unsafe {
				if (fn__assistedMovementCloseRoute == null) fn__assistedMovementCloseRoute = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_assistedMovementCloseRoute");
				fn__assistedMovementCloseRoute();
			}
		}

		public void AssistedMovementFlushRoute()
		{
			unsafe {
				if (fn__assistedMovementFlushRoute == null) fn__assistedMovementFlushRoute = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_assistedMovementFlushRoute");
				fn__assistedMovementFlushRoute();
			}
		}

		public void SetPlayerForcedAim(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerForcedAim == null) fn__setPlayerForcedAim = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerForcedAim");
				fn__setPlayerForcedAim(_player, _toggle);
			}
		}

		public void SetPlayerForcedZoom(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerForcedZoom == null) fn__setPlayerForcedZoom = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerForcedZoom");
				fn__setPlayerForcedZoom(_player, _toggle);
			}
		}

		public void SetPlayerForceSkipAimIntro(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerForceSkipAimIntro == null) fn__setPlayerForceSkipAimIntro = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerForceSkipAimIntro");
				fn__setPlayerForceSkipAimIntro(_player, _toggle);
			}
		}

		public void DisablePlayerFiring(int _player, bool _toggle)
		{
			unsafe {
				if (fn__disablePlayerFiring == null) fn__disablePlayerFiring = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_disablePlayerFiring");
				fn__disablePlayerFiring(_player, _toggle);
			}
		}

		public void _0xB885852C39CC265D()
		{
			unsafe {
				if (fn__0xB885852C39CC265D == null) fn__0xB885852C39CC265D = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xB885852C39CC265D");
				fn__0xB885852C39CC265D();
			}
		}

		public void SetDisableAmbientMeleeMove(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setDisableAmbientMeleeMove == null) fn__setDisableAmbientMeleeMove = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableAmbientMeleeMove");
				fn__setDisableAmbientMeleeMove(_player, _toggle);
			}
		}

		public void SetPlayerMaxArmour(int _player, int _value)
		{
			unsafe {
				if (fn__setPlayerMaxArmour == null) fn__setPlayerMaxArmour = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerMaxArmour");
				fn__setPlayerMaxArmour(_player, _value);
			}
		}

		public void SpecialAbilityActivate(int _player, int _p1)
		{
			unsafe {
				if (fn__specialAbilityActivate == null) fn__specialAbilityActivate = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityActivate");
				fn__specialAbilityActivate(_player, _p1);
			}
		}

		public void SetSpecialAbility(int _player, int _p1, int _p2)
		{
			unsafe {
				if (fn__setSpecialAbility == null) fn__setSpecialAbility = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setSpecialAbility");
				fn__setSpecialAbility(_player, _p1, _p2);
			}
		}

		public void SpecialAbilityDeplete(int _player, int _p1)
		{
			unsafe {
				if (fn__specialAbilityDeplete == null) fn__specialAbilityDeplete = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityDeplete");
				fn__specialAbilityDeplete(_player, _p1);
			}
		}

		public void SpecialAbilityDeactivate(int _player, int _p1)
		{
			unsafe {
				if (fn__specialAbilityDeactivate == null) fn__specialAbilityDeactivate = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityDeactivate");
				fn__specialAbilityDeactivate(_player, _p1);
			}
		}

		public void SpecialAbilityDeactivateFast(int _player, int _p1)
		{
			unsafe {
				if (fn__specialAbilityDeactivateFast == null) fn__specialAbilityDeactivateFast = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityDeactivateFast");
				fn__specialAbilityDeactivateFast(_player, _p1);
			}
		}

		public void SpecialAbilityReset(int _player, int _p1)
		{
			unsafe {
				if (fn__specialAbilityReset == null) fn__specialAbilityReset = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityReset");
				fn__specialAbilityReset(_player, _p1);
			}
		}

		public void SpecialAbilityChargeOnMissionFailed(int _player, int _p1)
		{
			unsafe {
				if (fn__specialAbilityChargeOnMissionFailed == null) fn__specialAbilityChargeOnMissionFailed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityChargeOnMissionFailed");
				fn__specialAbilityChargeOnMissionFailed(_player, _p1);
			}
		}

		public void SpecialAbilityChargeSmall(int _player, bool _p1, bool _p2, int _p3)
		{
			unsafe {
				if (fn__specialAbilityChargeSmall == null) fn__specialAbilityChargeSmall = (delegate* unmanaged[Cdecl]<int, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityChargeSmall");
				fn__specialAbilityChargeSmall(_player, _p1, _p2, _p3);
			}
		}

		public void SpecialAbilityChargeMedium(int _player, bool _p1, bool _p2, int _p3)
		{
			unsafe {
				if (fn__specialAbilityChargeMedium == null) fn__specialAbilityChargeMedium = (delegate* unmanaged[Cdecl]<int, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityChargeMedium");
				fn__specialAbilityChargeMedium(_player, _p1, _p2, _p3);
			}
		}

		public void SpecialAbilityChargeLarge(int _player, bool _p1, bool _p2, int _p3)
		{
			unsafe {
				if (fn__specialAbilityChargeLarge == null) fn__specialAbilityChargeLarge = (delegate* unmanaged[Cdecl]<int, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityChargeLarge");
				fn__specialAbilityChargeLarge(_player, _p1, _p2, _p3);
			}
		}

		public void SpecialAbilityChargeContinuous(int _player, int _p1, int _p2)
		{
			unsafe {
				if (fn__specialAbilityChargeContinuous == null) fn__specialAbilityChargeContinuous = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityChargeContinuous");
				fn__specialAbilityChargeContinuous(_player, _p1, _p2);
			}
		}

		public void SpecialAbilityChargeAbsolute(int _player, int _p1, bool _p2, int _p3)
		{
			unsafe {
				if (fn__specialAbilityChargeAbsolute == null) fn__specialAbilityChargeAbsolute = (delegate* unmanaged[Cdecl]<int, int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityChargeAbsolute");
				fn__specialAbilityChargeAbsolute(_player, _p1, _p2, _p3);
			}
		}

		public void SpecialAbilityChargeNormalized(int _player, float _normalizedValue, bool _p2, int _p3)
		{
			unsafe {
				if (fn__specialAbilityChargeNormalized == null) fn__specialAbilityChargeNormalized = (delegate* unmanaged[Cdecl]<int, float, bool, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityChargeNormalized");
				fn__specialAbilityChargeNormalized(_player, _normalizedValue, _p2, _p3);
			}
		}

		public void SpecialAbilityFillMeter(int _player, bool _p1, int _p2)
		{
			unsafe {
				if (fn__specialAbilityFillMeter == null) fn__specialAbilityFillMeter = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityFillMeter");
				fn__specialAbilityFillMeter(_player, _p1, _p2);
			}
		}

		public void SpecialAbilityDepleteMeter(int _player, bool _p1, int _p2)
		{
			unsafe {
				if (fn__specialAbilityDepleteMeter == null) fn__specialAbilityDepleteMeter = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityDepleteMeter");
				fn__specialAbilityDepleteMeter(_player, _p1, _p2);
			}
		}

		public void SpecialAbilityLock(int _playerModel, int _p1)
		{
			unsafe {
				if (fn__specialAbilityLock == null) fn__specialAbilityLock = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityLock");
				fn__specialAbilityLock(_playerModel, _p1);
			}
		}

		public void SpecialAbilityUnlock(int _playerModel, int _p1)
		{
			unsafe {
				if (fn__specialAbilityUnlock == null) fn__specialAbilityUnlock = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_specialAbilityUnlock");
				fn__specialAbilityUnlock(_playerModel, _p1);
			}
		}

		public bool IsSpecialAbilityUnlocked(int _playerModel)
		{
			unsafe {
				if (fn__isSpecialAbilityUnlocked == null) fn__isSpecialAbilityUnlocked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isSpecialAbilityUnlocked");
				var result = fn__isSpecialAbilityUnlocked(_playerModel);
				return result;
			}
		}

		public bool IsSpecialAbilityActive(int _player, int _p1)
		{
			unsafe {
				if (fn__isSpecialAbilityActive == null) fn__isSpecialAbilityActive = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isSpecialAbilityActive");
				var result = fn__isSpecialAbilityActive(_player, _p1);
				return result;
			}
		}

		public bool IsSpecialAbilityMeterFull(int _player, int _p1)
		{
			unsafe {
				if (fn__isSpecialAbilityMeterFull == null) fn__isSpecialAbilityMeterFull = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isSpecialAbilityMeterFull");
				var result = fn__isSpecialAbilityMeterFull(_player, _p1);
				return result;
			}
		}

		public void EnableSpecialAbility(int _player, bool _toggle, int _p2)
		{
			unsafe {
				if (fn__enableSpecialAbility == null) fn__enableSpecialAbility = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_enableSpecialAbility");
				fn__enableSpecialAbility(_player, _toggle, _p2);
			}
		}

		public bool IsSpecialAbilityEnabled(int _player, int _p1)
		{
			unsafe {
				if (fn__isSpecialAbilityEnabled == null) fn__isSpecialAbilityEnabled = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isSpecialAbilityEnabled");
				var result = fn__isSpecialAbilityEnabled(_player, _p1);
				return result;
			}
		}

		public void SetSpecialAbilityMultiplier(float _multiplier)
		{
			unsafe {
				if (fn__setSpecialAbilityMultiplier == null) fn__setSpecialAbilityMultiplier = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setSpecialAbilityMultiplier");
				fn__setSpecialAbilityMultiplier(_multiplier);
			}
		}

		public void _0xFFEE8FA29AB9A18E(int _player, int _p1)
		{
			unsafe {
				if (fn__0xFFEE8FA29AB9A18E == null) fn__0xFFEE8FA29AB9A18E = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xFFEE8FA29AB9A18E");
				fn__0xFFEE8FA29AB9A18E(_player, _p1);
			}
		}

		public bool _0x5FC472C501CCADB3(int _player)
		{
			unsafe {
				if (fn__0x5FC472C501CCADB3 == null) fn__0x5FC472C501CCADB3 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x5FC472C501CCADB3");
				var result = fn__0x5FC472C501CCADB3(_player);
				return result;
			}
		}

		public bool _0xF10B44FD479D69F3(int _player, int _p1)
		{
			unsafe {
				if (fn__0xF10B44FD479D69F3 == null) fn__0xF10B44FD479D69F3 = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native__0xF10B44FD479D69F3");
				var result = fn__0xF10B44FD479D69F3(_player, _p1);
				return result;
			}
		}

		public bool _0xDD2620B7B9D16FF1(int _player, float _p1)
		{
			unsafe {
				if (fn__0xDD2620B7B9D16FF1 == null) fn__0xDD2620B7B9D16FF1 = (delegate* unmanaged[Cdecl]<int, float, bool>) NativeLibrary.GetExport(handle, "Native__0xDD2620B7B9D16FF1");
				var result = fn__0xDD2620B7B9D16FF1(_player, _p1);
				return result;
			}
		}

		public void StartPlayerTeleport(int _player, float _x, float _y, float _z, float _heading, bool _p5, bool _findCollisionLand, bool _p7)
		{
			unsafe {
				if (fn__startPlayerTeleport == null) fn__startPlayerTeleport = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_startPlayerTeleport");
				fn__startPlayerTeleport(_player, _x, _y, _z, _heading, _p5, _findCollisionLand, _p7);
			}
		}

		public bool UpdatePlayerTeleport(int _player)
		{
			unsafe {
				if (fn__updatePlayerTeleport == null) fn__updatePlayerTeleport = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_updatePlayerTeleport");
				var result = fn__updatePlayerTeleport(_player);
				return result;
			}
		}

		public void StopPlayerTeleport()
		{
			unsafe {
				if (fn__stopPlayerTeleport == null) fn__stopPlayerTeleport = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopPlayerTeleport");
				fn__stopPlayerTeleport();
			}
		}

		public bool IsPlayerTeleportActive()
		{
			unsafe {
				if (fn__isPlayerTeleportActive == null) fn__isPlayerTeleportActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPlayerTeleportActive");
				var result = fn__isPlayerTeleportActive();
				return result;
			}
		}

		public float GetPlayerCurrentStealthNoise(int _player)
		{
			unsafe {
				if (fn__getPlayerCurrentStealthNoise == null) fn__getPlayerCurrentStealthNoise = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPlayerCurrentStealthNoise");
				var result = fn__getPlayerCurrentStealthNoise(_player);
				return result;
			}
		}

		public void SetPlayerHealthRechargeMultiplier(int _player, float _regenRate)
		{
			unsafe {
				if (fn__setPlayerHealthRechargeMultiplier == null) fn__setPlayerHealthRechargeMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerHealthRechargeMultiplier");
				fn__setPlayerHealthRechargeMultiplier(_player, _regenRate);
			}
		}

		public float GetPlayerHealthRechargeLimit(int _player)
		{
			unsafe {
				if (fn__getPlayerHealthRechargeLimit == null) fn__getPlayerHealthRechargeLimit = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPlayerHealthRechargeLimit");
				var result = fn__getPlayerHealthRechargeLimit(_player);
				return result;
			}
		}

		public void SetPlayerHealthRechargeLimit(int _player, float _limit)
		{
			unsafe {
				if (fn__setPlayerHealthRechargeLimit == null) fn__setPlayerHealthRechargeLimit = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerHealthRechargeLimit");
				fn__setPlayerHealthRechargeLimit(_player, _limit);
			}
		}

		public void SetPlayerFallDistance(int _player, float _p1)
		{
			unsafe {
				if (fn__setPlayerFallDistance == null) fn__setPlayerFallDistance = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerFallDistance");
				fn__setPlayerFallDistance(_player, _p1);
			}
		}

		public void SetPlayerWeaponDamageModifier(int _player, float _modifier)
		{
			unsafe {
				if (fn__setPlayerWeaponDamageModifier == null) fn__setPlayerWeaponDamageModifier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerWeaponDamageModifier");
				fn__setPlayerWeaponDamageModifier(_player, _modifier);
			}
		}

		public void SetPlayerWeaponDefenseModifier(int _player, float _modifier)
		{
			unsafe {
				if (fn__setPlayerWeaponDefenseModifier == null) fn__setPlayerWeaponDefenseModifier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerWeaponDefenseModifier");
				fn__setPlayerWeaponDefenseModifier(_player, _modifier);
			}
		}

		public void SetPlayerWeaponDefenseModifier2(int _player, float _modifier)
		{
			unsafe {
				if (fn__setPlayerWeaponDefenseModifier2 == null) fn__setPlayerWeaponDefenseModifier2 = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerWeaponDefenseModifier2");
				fn__setPlayerWeaponDefenseModifier2(_player, _modifier);
			}
		}

		public void SetPlayerMeleeWeaponDamageModifier(int _player, float _modifier, bool _p2)
		{
			unsafe {
				if (fn__setPlayerMeleeWeaponDamageModifier == null) fn__setPlayerMeleeWeaponDamageModifier = (delegate* unmanaged[Cdecl]<int, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerMeleeWeaponDamageModifier");
				fn__setPlayerMeleeWeaponDamageModifier(_player, _modifier, _p2);
			}
		}

		public void SetPlayerMeleeWeaponDefenseModifier(int _player, float _modifier)
		{
			unsafe {
				if (fn__setPlayerMeleeWeaponDefenseModifier == null) fn__setPlayerMeleeWeaponDefenseModifier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerMeleeWeaponDefenseModifier");
				fn__setPlayerMeleeWeaponDefenseModifier(_player, _modifier);
			}
		}

		public void SetPlayerVehicleDamageModifier(int _player, float _modifier)
		{
			unsafe {
				if (fn__setPlayerVehicleDamageModifier == null) fn__setPlayerVehicleDamageModifier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerVehicleDamageModifier");
				fn__setPlayerVehicleDamageModifier(_player, _modifier);
			}
		}

		public void SetPlayerVehicleDefenseModifier(int _player, float _modifier)
		{
			unsafe {
				if (fn__setPlayerVehicleDefenseModifier == null) fn__setPlayerVehicleDefenseModifier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerVehicleDefenseModifier");
				fn__setPlayerVehicleDefenseModifier(_player, _modifier);
			}
		}

		public void _0x8D768602ADEF2245(int _player, float _p1)
		{
			unsafe {
				if (fn__0x8D768602ADEF2245 == null) fn__0x8D768602ADEF2245 = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x8D768602ADEF2245");
				fn__0x8D768602ADEF2245(_player, _p1);
			}
		}

		public void _0xD821056B9ACF8052(int _player, int _p1)
		{
			unsafe {
				if (fn__0xD821056B9ACF8052 == null) fn__0xD821056B9ACF8052 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xD821056B9ACF8052");
				fn__0xD821056B9ACF8052(_player, _p1);
			}
		}

		public void _0x31E90B8873A4CD3B(int _player, float _p1)
		{
			unsafe {
				if (fn__0x31E90B8873A4CD3B == null) fn__0x31E90B8873A4CD3B = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x31E90B8873A4CD3B");
				fn__0x31E90B8873A4CD3B(_player, _p1);
			}
		}

		public void SetPlayerParachuteTintIndex(int _player, int _tintIndex)
		{
			unsafe {
				if (fn__setPlayerParachuteTintIndex == null) fn__setPlayerParachuteTintIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerParachuteTintIndex");
				fn__setPlayerParachuteTintIndex(_player, _tintIndex);
			}
		}

		public void GetPlayerParachuteTintIndex(int _player, ref int _tintIndex)
		{
			unsafe {
				if (fn__getPlayerParachuteTintIndex == null) fn__getPlayerParachuteTintIndex = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getPlayerParachuteTintIndex");
				var ref_tintIndex = _tintIndex;
				fn__getPlayerParachuteTintIndex(_player, &ref_tintIndex);
				_tintIndex = ref_tintIndex;
			}
		}

		public void SetPlayerReserveParachuteTintIndex(int _player, int _index)
		{
			unsafe {
				if (fn__setPlayerReserveParachuteTintIndex == null) fn__setPlayerReserveParachuteTintIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerReserveParachuteTintIndex");
				fn__setPlayerReserveParachuteTintIndex(_player, _index);
			}
		}

		public void GetPlayerReserveParachuteTintIndex(int _player, ref int _index)
		{
			unsafe {
				if (fn__getPlayerReserveParachuteTintIndex == null) fn__getPlayerReserveParachuteTintIndex = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getPlayerReserveParachuteTintIndex");
				var ref_index = _index;
				fn__getPlayerReserveParachuteTintIndex(_player, &ref_index);
				_index = ref_index;
			}
		}

		public void SetPlayerParachutePackTintIndex(int _player, int _tintIndex)
		{
			unsafe {
				if (fn__setPlayerParachutePackTintIndex == null) fn__setPlayerParachutePackTintIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerParachutePackTintIndex");
				fn__setPlayerParachutePackTintIndex(_player, _tintIndex);
			}
		}

		public void GetPlayerParachutePackTintIndex(int _player, ref int _tintIndex)
		{
			unsafe {
				if (fn__getPlayerParachutePackTintIndex == null) fn__getPlayerParachutePackTintIndex = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getPlayerParachutePackTintIndex");
				var ref_tintIndex = _tintIndex;
				fn__getPlayerParachutePackTintIndex(_player, &ref_tintIndex);
				_tintIndex = ref_tintIndex;
			}
		}

		public void SetPlayerHasReserveParachute(int _player)
		{
			unsafe {
				if (fn__setPlayerHasReserveParachute == null) fn__setPlayerHasReserveParachute = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerHasReserveParachute");
				fn__setPlayerHasReserveParachute(_player);
			}
		}

		public bool GetPlayerHasReserveParachute(int _player)
		{
			unsafe {
				if (fn__getPlayerHasReserveParachute == null) fn__getPlayerHasReserveParachute = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getPlayerHasReserveParachute");
				var result = fn__getPlayerHasReserveParachute(_player);
				return result;
			}
		}

		public void SetPlayerCanLeaveParachuteSmokeTrail(int _player, bool _enabled)
		{
			unsafe {
				if (fn__setPlayerCanLeaveParachuteSmokeTrail == null) fn__setPlayerCanLeaveParachuteSmokeTrail = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerCanLeaveParachuteSmokeTrail");
				fn__setPlayerCanLeaveParachuteSmokeTrail(_player, _enabled);
			}
		}

		public void SetPlayerParachuteSmokeTrailColor(int _player, int _r, int _g, int _b)
		{
			unsafe {
				if (fn__setPlayerParachuteSmokeTrailColor == null) fn__setPlayerParachuteSmokeTrailColor = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerParachuteSmokeTrailColor");
				fn__setPlayerParachuteSmokeTrailColor(_player, _r, _g, _b);
			}
		}

		public void GetPlayerParachuteSmokeTrailColor(int _player, ref int _r, ref int _g, ref int _b)
		{
			unsafe {
				if (fn__getPlayerParachuteSmokeTrailColor == null) fn__getPlayerParachuteSmokeTrailColor = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getPlayerParachuteSmokeTrailColor");
				var ref_r = _r;
				var ref_g = _g;
				var ref_b = _b;
				fn__getPlayerParachuteSmokeTrailColor(_player, &ref_r, &ref_g, &ref_b);
				_r = ref_r;
				_g = ref_g;
				_b = ref_b;
			}
		}

		public void SetPlayerResetFlagPreferRearSeats(int _player, int _flags)
		{
			unsafe {
				if (fn__setPlayerResetFlagPreferRearSeats == null) fn__setPlayerResetFlagPreferRearSeats = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerResetFlagPreferRearSeats");
				fn__setPlayerResetFlagPreferRearSeats(_player, _flags);
			}
		}

		public void SetPlayerNoiseMultiplier(int _player, float _multiplier)
		{
			unsafe {
				if (fn__setPlayerNoiseMultiplier == null) fn__setPlayerNoiseMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerNoiseMultiplier");
				fn__setPlayerNoiseMultiplier(_player, _multiplier);
			}
		}

		public void SetPlayerSneakingNoiseMultiplier(int _player, float _multiplier)
		{
			unsafe {
				if (fn__setPlayerSneakingNoiseMultiplier == null) fn__setPlayerSneakingNoiseMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerSneakingNoiseMultiplier");
				fn__setPlayerSneakingNoiseMultiplier(_player, _multiplier);
			}
		}

		public bool CanPedHearPlayer(int _player, int _ped)
		{
			unsafe {
				if (fn__canPedHearPlayer == null) fn__canPedHearPlayer = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_canPedHearPlayer");
				var result = fn__canPedHearPlayer(_player, _ped);
				return result;
			}
		}

		public void SimulatePlayerInputGait(int _player, float _amount, int _gaitType, float _speed, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__simulatePlayerInputGait == null) fn__simulatePlayerInputGait = (delegate* unmanaged[Cdecl]<int, float, int, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_simulatePlayerInputGait");
				fn__simulatePlayerInputGait(_player, _amount, _gaitType, _speed, _p4, _p5);
			}
		}

		public void ResetPlayerInputGait(int _player)
		{
			unsafe {
				if (fn__resetPlayerInputGait == null) fn__resetPlayerInputGait = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_resetPlayerInputGait");
				fn__resetPlayerInputGait(_player);
			}
		}

		public void SetAutoGiveParachuteWhenEnterPlane(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setAutoGiveParachuteWhenEnterPlane == null) fn__setAutoGiveParachuteWhenEnterPlane = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setAutoGiveParachuteWhenEnterPlane");
				fn__setAutoGiveParachuteWhenEnterPlane(_player, _toggle);
			}
		}

		public void SetAutoGiveScubaGearWhenExitVehicle(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setAutoGiveScubaGearWhenExitVehicle == null) fn__setAutoGiveScubaGearWhenExitVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setAutoGiveScubaGearWhenExitVehicle");
				fn__setAutoGiveScubaGearWhenExitVehicle(_player, _toggle);
			}
		}

		public void SetPlayerStealthPerceptionModifier(int _player, float _value)
		{
			unsafe {
				if (fn__setPlayerStealthPerceptionModifier == null) fn__setPlayerStealthPerceptionModifier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlayerStealthPerceptionModifier");
				fn__setPlayerStealthPerceptionModifier(_player, _value);
			}
		}

		public bool _0x690A61A6D13583F6(int _player)
		{
			unsafe {
				if (fn__0x690A61A6D13583F6 == null) fn__0x690A61A6D13583F6 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x690A61A6D13583F6");
				var result = fn__0x690A61A6D13583F6(_player);
				return result;
			}
		}

		public void _0x9EDD76E87D5D51BA(int _player)
		{
			unsafe {
				if (fn__0x9EDD76E87D5D51BA == null) fn__0x9EDD76E87D5D51BA = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x9EDD76E87D5D51BA");
				fn__0x9EDD76E87D5D51BA(_player);
			}
		}

		public void SetPlayerSimulateAiming(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerSimulateAiming == null) fn__setPlayerSimulateAiming = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerSimulateAiming");
				fn__setPlayerSimulateAiming(_player, _toggle);
			}
		}

		public void SetPlayerClothPinFrames(int _player, int _p1)
		{
			unsafe {
				if (fn__setPlayerClothPinFrames == null) fn__setPlayerClothPinFrames = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerClothPinFrames");
				fn__setPlayerClothPinFrames(_player, _p1);
			}
		}

		public void SetPlayerClothPackageIndex(int _index)
		{
			unsafe {
				if (fn__setPlayerClothPackageIndex == null) fn__setPlayerClothPackageIndex = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerClothPackageIndex");
				fn__setPlayerClothPackageIndex(_index);
			}
		}

		public void SetPlayerClothLockCounter(int _value)
		{
			unsafe {
				if (fn__setPlayerClothLockCounter == null) fn__setPlayerClothLockCounter = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerClothLockCounter");
				fn__setPlayerClothLockCounter(_value);
			}
		}

		public void PlayerAttachVirtualBound(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7)
		{
			unsafe {
				if (fn__playerAttachVirtualBound == null) fn__playerAttachVirtualBound = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_playerAttachVirtualBound");
				fn__playerAttachVirtualBound(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
			}
		}

		public void PlayerDetachVirtualBound()
		{
			unsafe {
				if (fn__playerDetachVirtualBound == null) fn__playerDetachVirtualBound = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_playerDetachVirtualBound");
				fn__playerDetachVirtualBound();
			}
		}

		public bool HasPlayerBeenSpottedInStolenVehicle(int _player)
		{
			unsafe {
				if (fn__hasPlayerBeenSpottedInStolenVehicle == null) fn__hasPlayerBeenSpottedInStolenVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasPlayerBeenSpottedInStolenVehicle");
				var result = fn__hasPlayerBeenSpottedInStolenVehicle(_player);
				return result;
			}
		}

		public bool IsPlayerBattleAware(int _player)
		{
			unsafe {
				if (fn__isPlayerBattleAware == null) fn__isPlayerBattleAware = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerBattleAware");
				var result = fn__isPlayerBattleAware(_player);
				return result;
			}
		}

		public bool _0xBC0753C9CA14B506(int _player, int _p1, bool _p2)
		{
			unsafe {
				if (fn__0xBC0753C9CA14B506 == null) fn__0xBC0753C9CA14B506 = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native__0xBC0753C9CA14B506");
				var result = fn__0xBC0753C9CA14B506(_player, _p1, _p2);
				return result;
			}
		}

		public void ExtendWorldBoundaryForPlayer(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__extendWorldBoundaryForPlayer == null) fn__extendWorldBoundaryForPlayer = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_extendWorldBoundaryForPlayer");
				fn__extendWorldBoundaryForPlayer(_x, _y, _z);
			}
		}

		public void ResetWorldBoundaryForPlayer()
		{
			unsafe {
				if (fn__resetWorldBoundaryForPlayer == null) fn__resetWorldBoundaryForPlayer = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetWorldBoundaryForPlayer");
				fn__resetWorldBoundaryForPlayer();
			}
		}

		public bool IsPlayerRidingTrain(int _player)
		{
			unsafe {
				if (fn__isPlayerRidingTrain == null) fn__isPlayerRidingTrain = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerRidingTrain");
				var result = fn__isPlayerRidingTrain(_player);
				return result;
			}
		}

		public bool HasPlayerLeftTheWorld(int _player)
		{
			unsafe {
				if (fn__hasPlayerLeftTheWorld == null) fn__hasPlayerLeftTheWorld = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasPlayerLeftTheWorld");
				var result = fn__hasPlayerLeftTheWorld(_player);
				return result;
			}
		}

		public void SetPlayerLeavePedBehind(int _player, bool _toggle)
		{
			unsafe {
				if (fn__setPlayerLeavePedBehind == null) fn__setPlayerLeavePedBehind = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerLeavePedBehind");
				fn__setPlayerLeavePedBehind(_player, _toggle);
			}
		}

		public void SetPlayerParachuteVariationOverride(int _player, int _p1, int _p2, int _p3, bool _p4)
		{
			unsafe {
				if (fn__setPlayerParachuteVariationOverride == null) fn__setPlayerParachuteVariationOverride = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerParachuteVariationOverride");
				fn__setPlayerParachuteVariationOverride(_player, _p1, _p2, _p3, _p4);
			}
		}

		public void ClearPlayerParachuteVariationOverride(int _player)
		{
			unsafe {
				if (fn__clearPlayerParachuteVariationOverride == null) fn__clearPlayerParachuteVariationOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPlayerParachuteVariationOverride");
				fn__clearPlayerParachuteVariationOverride(_player);
			}
		}

		public void SetPlayerParachuteModelOverride(int _player, int _model)
		{
			unsafe {
				if (fn__setPlayerParachuteModelOverride == null) fn__setPlayerParachuteModelOverride = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerParachuteModelOverride");
				fn__setPlayerParachuteModelOverride(_player, _model);
			}
		}

		public void SetPlayerReserveParachuteModelOverride(int _player, int _model)
		{
			unsafe {
				if (fn__setPlayerReserveParachuteModelOverride == null) fn__setPlayerReserveParachuteModelOverride = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerReserveParachuteModelOverride");
				fn__setPlayerReserveParachuteModelOverride(_player, _model);
			}
		}

		public int GetPlayerParachuteModelOverride(int _player)
		{
			unsafe {
				if (fn__getPlayerParachuteModelOverride == null) fn__getPlayerParachuteModelOverride = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerParachuteModelOverride");
				var result = fn__getPlayerParachuteModelOverride(_player);
				return result;
			}
		}

		public int GetPlayerReserveParachuteModelOverride(int _player)
		{
			unsafe {
				if (fn__getPlayerReserveParachuteModelOverride == null) fn__getPlayerReserveParachuteModelOverride = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerReserveParachuteModelOverride");
				var result = fn__getPlayerReserveParachuteModelOverride(_player);
				return result;
			}
		}

		public void ClearPlayerParachuteModelOverride(int _player)
		{
			unsafe {
				if (fn__clearPlayerParachuteModelOverride == null) fn__clearPlayerParachuteModelOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPlayerParachuteModelOverride");
				fn__clearPlayerParachuteModelOverride(_player);
			}
		}

		public void ClearPlayerReserveParachuteModelOverride(int _player)
		{
			unsafe {
				if (fn__clearPlayerReserveParachuteModelOverride == null) fn__clearPlayerReserveParachuteModelOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPlayerReserveParachuteModelOverride");
				fn__clearPlayerReserveParachuteModelOverride(_player);
			}
		}

		public void SetPlayerParachutePackModelOverride(int _player, int _model)
		{
			unsafe {
				if (fn__setPlayerParachutePackModelOverride == null) fn__setPlayerParachutePackModelOverride = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerParachutePackModelOverride");
				fn__setPlayerParachutePackModelOverride(_player, _model);
			}
		}

		public void ClearPlayerParachutePackModelOverride(int _player)
		{
			unsafe {
				if (fn__clearPlayerParachutePackModelOverride == null) fn__clearPlayerParachutePackModelOverride = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPlayerParachutePackModelOverride");
				fn__clearPlayerParachutePackModelOverride(_player);
			}
		}

		public void DisablePlayerVehicleRewards(int _player)
		{
			unsafe {
				if (fn__disablePlayerVehicleRewards == null) fn__disablePlayerVehicleRewards = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disablePlayerVehicleRewards");
				fn__disablePlayerVehicleRewards(_player);
			}
		}

		public void _0x2F7CEB6520288061(bool _p0)
		{
			unsafe {
				if (fn__0x2F7CEB6520288061 == null) fn__0x2F7CEB6520288061 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x2F7CEB6520288061");
				fn__0x2F7CEB6520288061(_p0);
			}
		}

		public void SetPlayerBluetoothState(int _player, bool _state)
		{
			unsafe {
				if (fn__setPlayerBluetoothState == null) fn__setPlayerBluetoothState = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerBluetoothState");
				fn__setPlayerBluetoothState(_player, _state);
			}
		}

		public bool IsPlayerBluetoothEnable(int _player)
		{
			unsafe {
				if (fn__isPlayerBluetoothEnable == null) fn__isPlayerBluetoothEnable = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayerBluetoothEnable");
				var result = fn__isPlayerBluetoothEnable(_player);
				return result;
			}
		}

		public void _0x5501B7A5CDB79D37(int _player)
		{
			unsafe {
				if (fn__0x5501B7A5CDB79D37 == null) fn__0x5501B7A5CDB79D37 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x5501B7A5CDB79D37");
				fn__0x5501B7A5CDB79D37(_player);
			}
		}

		public int GetPlayerFakeWantedLevel(int _player)
		{
			unsafe {
				if (fn__getPlayerFakeWantedLevel == null) fn__getPlayerFakeWantedLevel = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPlayerFakeWantedLevel");
				var result = fn__getPlayerFakeWantedLevel(_player);
				return result;
			}
		}

		public void _0x55FCC0C390620314(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x55FCC0C390620314 == null) fn__0x55FCC0C390620314 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x55FCC0C390620314");
				fn__0x55FCC0C390620314(_p0, _p1, _p2);
			}
		}

		public void _0x2382AB11450AE7BA(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x2382AB11450AE7BA == null) fn__0x2382AB11450AE7BA = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2382AB11450AE7BA");
				fn__0x2382AB11450AE7BA(_p0, _p1);
			}
		}

		public int _0x6E4361FF3E8CD7CA(int _p0)
		{
			unsafe {
				if (fn__0x6E4361FF3E8CD7CA == null) fn__0x6E4361FF3E8CD7CA = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x6E4361FF3E8CD7CA");
				var result = fn__0x6E4361FF3E8CD7CA(_p0);
				return result;
			}
		}

		public void _0x237440E46D918649(int _p0)
		{
			unsafe {
				if (fn__0x237440E46D918649 == null) fn__0x237440E46D918649 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x237440E46D918649");
				fn__0x237440E46D918649(_p0);
			}
		}

		public void SetPlayerHomingRocketDisabled(int _p0, int _p1)
		{
			unsafe {
				if (fn__setPlayerHomingRocketDisabled == null) fn__setPlayerHomingRocketDisabled = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerHomingRocketDisabled");
				fn__setPlayerHomingRocketDisabled(_p0, _p1);
			}
		}

		public void _0x9097EB6D4BB9A12A(int _player, int _entity)
		{
			unsafe {
				if (fn__0x9097EB6D4BB9A12A == null) fn__0x9097EB6D4BB9A12A = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x9097EB6D4BB9A12A");
				fn__0x9097EB6D4BB9A12A(_player, _entity);
			}
		}

		public void _0x9F260BFB59ADBCA3(int _player, int _entity)
		{
			unsafe {
				if (fn__0x9F260BFB59ADBCA3 == null) fn__0x9F260BFB59ADBCA3 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x9F260BFB59ADBCA3");
				fn__0x9F260BFB59ADBCA3(_player, _entity);
			}
		}

		public void _0x7BAE68775557AE0B(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__0x7BAE68775557AE0B == null) fn__0x7BAE68775557AE0B = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x7BAE68775557AE0B");
				fn__0x7BAE68775557AE0B(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void _0x7148E0F43D11F0D9()
		{
			unsafe {
				if (fn__0x7148E0F43D11F0D9 == null) fn__0x7148E0F43D11F0D9 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x7148E0F43D11F0D9");
				fn__0x7148E0F43D11F0D9();
			}
		}

		public void _0x70A382ADEC069DD3(float _coordX, float _coordY, float _coordZ)
		{
			unsafe {
				if (fn__0x70A382ADEC069DD3 == null) fn__0x70A382ADEC069DD3 = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0x70A382ADEC069DD3");
				fn__0x70A382ADEC069DD3(_coordX, _coordY, _coordZ);
			}
		}

		public void _0x48621C9FCA3EBD28(int _p0)
		{
			unsafe {
				if (fn__0x48621C9FCA3EBD28 == null) fn__0x48621C9FCA3EBD28 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x48621C9FCA3EBD28");
				fn__0x48621C9FCA3EBD28(_p0);
			}
		}

		public void _0x81CBAE94390F9F89()
		{
			unsafe {
				if (fn__0x81CBAE94390F9F89 == null) fn__0x81CBAE94390F9F89 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x81CBAE94390F9F89");
				fn__0x81CBAE94390F9F89();
			}
		}

		public void _0x13B350B8AD0EEE10()
		{
			unsafe {
				if (fn__0x13B350B8AD0EEE10 == null) fn__0x13B350B8AD0EEE10 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x13B350B8AD0EEE10");
				fn__0x13B350B8AD0EEE10();
			}
		}

		public void _0x293220DA1B46CEBC(float _p0, float _p1, int _p2)
		{
			unsafe {
				if (fn__0x293220DA1B46CEBC == null) fn__0x293220DA1B46CEBC = (delegate* unmanaged[Cdecl]<float, float, int, void>) NativeLibrary.GetExport(handle, "Native__0x293220DA1B46CEBC");
				fn__0x293220DA1B46CEBC(_p0, _p1, _p2);
			}
		}

		public void _0x208784099002BC30(string _missionNameLabel, int _p1)
		{
			unsafe {
				if (fn__0x208784099002BC30 == null) fn__0x208784099002BC30 = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native__0x208784099002BC30");
				var ptr_missionNameLabel = MemoryUtils.StringToHGlobalUtf8(_missionNameLabel);
				fn__0x208784099002BC30(ptr_missionNameLabel, _p1);
				Marshal.FreeHGlobal(ptr_missionNameLabel);
			}
		}

		public void StopRecordingThisFrame()
		{
			unsafe {
				if (fn__stopRecordingThisFrame == null) fn__stopRecordingThisFrame = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopRecordingThisFrame");
				fn__stopRecordingThisFrame();
			}
		}

		public void _0xF854439EFBB3B583()
		{
			unsafe {
				if (fn__0xF854439EFBB3B583 == null) fn__0xF854439EFBB3B583 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xF854439EFBB3B583");
				fn__0xF854439EFBB3B583();
			}
		}

		public void DisableRockstarEditorCameraChanges()
		{
			unsafe {
				if (fn__disableRockstarEditorCameraChanges == null) fn__disableRockstarEditorCameraChanges = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_disableRockstarEditorCameraChanges");
				fn__disableRockstarEditorCameraChanges();
			}
		}

		public void _0x66972397E0757E7A(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x66972397E0757E7A == null) fn__0x66972397E0757E7A = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x66972397E0757E7A");
				fn__0x66972397E0757E7A(_p0, _p1, _p2);
			}
		}

		public void StartRecording(int _mode)
		{
			unsafe {
				if (fn__startRecording == null) fn__startRecording = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_startRecording");
				fn__startRecording(_mode);
			}
		}

		public void StopRecordingAndSaveClip()
		{
			unsafe {
				if (fn__stopRecordingAndSaveClip == null) fn__stopRecordingAndSaveClip = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopRecordingAndSaveClip");
				fn__stopRecordingAndSaveClip();
			}
		}

		public void StopRecordingAndDiscardClip()
		{
			unsafe {
				if (fn__stopRecordingAndDiscardClip == null) fn__stopRecordingAndDiscardClip = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopRecordingAndDiscardClip");
				fn__stopRecordingAndDiscardClip();
			}
		}

		public bool SaveRecordingClip()
		{
			unsafe {
				if (fn__saveRecordingClip == null) fn__saveRecordingClip = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_saveRecordingClip");
				var result = fn__saveRecordingClip();
				return result;
			}
		}

		public bool IsRecording()
		{
			unsafe {
				if (fn__isRecording == null) fn__isRecording = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isRecording");
				var result = fn__isRecording();
				return result;
			}
		}

		public int _0xDF4B952F7D381B95()
		{
			unsafe {
				if (fn__0xDF4B952F7D381B95 == null) fn__0xDF4B952F7D381B95 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xDF4B952F7D381B95");
				var result = fn__0xDF4B952F7D381B95();
				return result;
			}
		}

		public int _0x4282E08174868BE3()
		{
			unsafe {
				if (fn__0x4282E08174868BE3 == null) fn__0x4282E08174868BE3 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x4282E08174868BE3");
				var result = fn__0x4282E08174868BE3();
				return result;
			}
		}

		public bool _0x33D47E85B476ABCD(bool _p0)
		{
			unsafe {
				if (fn__0x33D47E85B476ABCD == null) fn__0x33D47E85B476ABCD = (delegate* unmanaged[Cdecl]<bool, bool>) NativeLibrary.GetExport(handle, "Native__0x33D47E85B476ABCD");
				var result = fn__0x33D47E85B476ABCD(_p0);
				return result;
			}
		}

		public void _0x7E2BD3EF6C205F09(string _p0, bool _p1)
		{
			unsafe {
				if (fn__0x7E2BD3EF6C205F09 == null) fn__0x7E2BD3EF6C205F09 = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native__0x7E2BD3EF6C205F09");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0x7E2BD3EF6C205F09(ptr_p0, _p1);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public bool IsInteriorRenderingDisabled()
		{
			unsafe {
				if (fn__isInteriorRenderingDisabled == null) fn__isInteriorRenderingDisabled = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isInteriorRenderingDisabled");
				var result = fn__isInteriorRenderingDisabled();
				return result;
			}
		}

		public void _0x5AD3932DAEB1E5D3()
		{
			unsafe {
				if (fn__0x5AD3932DAEB1E5D3 == null) fn__0x5AD3932DAEB1E5D3 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x5AD3932DAEB1E5D3");
				fn__0x5AD3932DAEB1E5D3();
			}
		}

		public void _0xE058175F8EAFE79A(bool _p0)
		{
			unsafe {
				if (fn__0xE058175F8EAFE79A == null) fn__0xE058175F8EAFE79A = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0xE058175F8EAFE79A");
				fn__0xE058175F8EAFE79A(_p0);
			}
		}

		public void ResetEditorValues()
		{
			unsafe {
				if (fn__resetEditorValues == null) fn__resetEditorValues = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetEditorValues");
				fn__resetEditorValues();
			}
		}

		public void ActivateRockstarEditor(int _p0)
		{
			unsafe {
				if (fn__activateRockstarEditor == null) fn__activateRockstarEditor = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_activateRockstarEditor");
				fn__activateRockstarEditor(_p0);
			}
		}

		public void RequestScript(string _scriptName)
		{
			unsafe {
				if (fn__requestScript == null) fn__requestScript = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestScript");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				fn__requestScript(ptr_scriptName);
				Marshal.FreeHGlobal(ptr_scriptName);
			}
		}

		public void SetScriptAsNoLongerNeeded(string _scriptName)
		{
			unsafe {
				if (fn__setScriptAsNoLongerNeeded == null) fn__setScriptAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setScriptAsNoLongerNeeded");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				fn__setScriptAsNoLongerNeeded(ptr_scriptName);
				Marshal.FreeHGlobal(ptr_scriptName);
			}
		}

		public bool HasScriptLoaded(string _scriptName)
		{
			unsafe {
				if (fn__hasScriptLoaded == null) fn__hasScriptLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasScriptLoaded");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				var result = fn__hasScriptLoaded(ptr_scriptName);
				Marshal.FreeHGlobal(ptr_scriptName);
				return result;
			}
		}

		public bool DoesScriptExist(string _scriptName)
		{
			unsafe {
				if (fn__doesScriptExist == null) fn__doesScriptExist = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_doesScriptExist");
				var ptr_scriptName = MemoryUtils.StringToHGlobalUtf8(_scriptName);
				var result = fn__doesScriptExist(ptr_scriptName);
				Marshal.FreeHGlobal(ptr_scriptName);
				return result;
			}
		}

		public void RequestScriptWithNameHash(int _scriptHash)
		{
			unsafe {
				if (fn__requestScriptWithNameHash == null) fn__requestScriptWithNameHash = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestScriptWithNameHash");
				fn__requestScriptWithNameHash(_scriptHash);
			}
		}

		public void SetScriptWithNameHashAsNoLongerNeeded(int _scriptHash)
		{
			unsafe {
				if (fn__setScriptWithNameHashAsNoLongerNeeded == null) fn__setScriptWithNameHashAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setScriptWithNameHashAsNoLongerNeeded");
				fn__setScriptWithNameHashAsNoLongerNeeded(_scriptHash);
			}
		}

		public bool HasScriptWithNameHashLoaded(int _scriptHash)
		{
			unsafe {
				if (fn__hasScriptWithNameHashLoaded == null) fn__hasScriptWithNameHashLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasScriptWithNameHashLoaded");
				var result = fn__hasScriptWithNameHashLoaded(_scriptHash);
				return result;
			}
		}

		public bool DoesScriptWithNameHashExist(int _scriptHash)
		{
			unsafe {
				if (fn__doesScriptWithNameHashExist == null) fn__doesScriptWithNameHashExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesScriptWithNameHashExist");
				var result = fn__doesScriptWithNameHashExist(_scriptHash);
				return result;
			}
		}

		public void TerminateThread(int _threadId)
		{
			unsafe {
				if (fn__terminateThread == null) fn__terminateThread = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_terminateThread");
				fn__terminateThread(_threadId);
			}
		}

		public bool IsThreadActive(int _threadId)
		{
			unsafe {
				if (fn__isThreadActive == null) fn__isThreadActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThreadActive");
				var result = fn__isThreadActive(_threadId);
				return result;
			}
		}

		public string GetNameOfThread(int _threadId)
		{
			unsafe {
				if (fn__getNameOfThread == null) fn__getNameOfThread = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getNameOfThread");
				var result = fn__getNameOfThread(_threadId);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void ScriptThreadIteratorReset()
		{
			unsafe {
				if (fn__scriptThreadIteratorReset == null) fn__scriptThreadIteratorReset = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_scriptThreadIteratorReset");
				fn__scriptThreadIteratorReset();
			}
		}

		public int ScriptThreadIteratorGetNextThreadId()
		{
			unsafe {
				if (fn__scriptThreadIteratorGetNextThreadId == null) fn__scriptThreadIteratorGetNextThreadId = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_scriptThreadIteratorGetNextThreadId");
				var result = fn__scriptThreadIteratorGetNextThreadId();
				return result;
			}
		}

		public int GetIdOfThisThread()
		{
			unsafe {
				if (fn__getIdOfThisThread == null) fn__getIdOfThisThread = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getIdOfThisThread");
				var result = fn__getIdOfThisThread();
				return result;
			}
		}

		public void TerminateThisThread()
		{
			unsafe {
				if (fn__terminateThisThread == null) fn__terminateThisThread = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_terminateThisThread");
				fn__terminateThisThread();
			}
		}

		public int GetNumberOfReferencesOfScriptWithNameHash(int _scriptHash)
		{
			unsafe {
				if (fn__getNumberOfReferencesOfScriptWithNameHash == null) fn__getNumberOfReferencesOfScriptWithNameHash = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfReferencesOfScriptWithNameHash");
				var result = fn__getNumberOfReferencesOfScriptWithNameHash(_scriptHash);
				return result;
			}
		}

		public string GetThisScriptName()
		{
			unsafe {
				if (fn__getThisScriptName == null) fn__getThisScriptName = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_getThisScriptName");
				var result = fn__getThisScriptName();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int GetHashOfThisScriptName()
		{
			unsafe {
				if (fn__getHashOfThisScriptName == null) fn__getHashOfThisScriptName = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getHashOfThisScriptName");
				var result = fn__getHashOfThisScriptName();
				return result;
			}
		}

		public int GetNumberOfEvents(int _eventGroup)
		{
			unsafe {
				if (fn__getNumberOfEvents == null) fn__getNumberOfEvents = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfEvents");
				var result = fn__getNumberOfEvents(_eventGroup);
				return result;
			}
		}

		public bool GetEventExists(int _eventGroup, int _eventIndex)
		{
			unsafe {
				if (fn__getEventExists == null) fn__getEventExists = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_getEventExists");
				var result = fn__getEventExists(_eventGroup, _eventIndex);
				return result;
			}
		}

		public int GetEventAtIndex(int _eventGroup, int _eventIndex)
		{
			unsafe {
				if (fn__getEventAtIndex == null) fn__getEventAtIndex = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getEventAtIndex");
				var result = fn__getEventAtIndex(_eventGroup, _eventIndex);
				return result;
			}
		}

		public bool GetEventData(int _eventGroup, int _eventIndex, ref int _eventData, int _eventDataSize)
		{
			unsafe {
				if (fn__getEventData == null) fn__getEventData = (delegate* unmanaged[Cdecl]<int, int, int*, int, bool>) NativeLibrary.GetExport(handle, "Native_getEventData");
				var ref_eventData = _eventData;
				var result = fn__getEventData(_eventGroup, _eventIndex, &ref_eventData, _eventDataSize);
				_eventData = ref_eventData;
				return result;
			}
		}

		public void TriggerScriptEvent(int _eventGroup, ref int _eventData, int _eventDataSize, int _playerBits)
		{
			unsafe {
				if (fn__triggerScriptEvent == null) fn__triggerScriptEvent = (delegate* unmanaged[Cdecl]<int, int*, int, int, void>) NativeLibrary.GetExport(handle, "Native_triggerScriptEvent");
				var ref_eventData = _eventData;
				fn__triggerScriptEvent(_eventGroup, &ref_eventData, _eventDataSize, _playerBits);
				_eventData = ref_eventData;
			}
		}

		public void ShutdownLoadingScreen()
		{
			unsafe {
				if (fn__shutdownLoadingScreen == null) fn__shutdownLoadingScreen = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_shutdownLoadingScreen");
				fn__shutdownLoadingScreen();
			}
		}

		public void SetNoLoadingScreen(bool _toggle)
		{
			unsafe {
				if (fn__setNoLoadingScreen == null) fn__setNoLoadingScreen = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setNoLoadingScreen");
				fn__setNoLoadingScreen(_toggle);
			}
		}

		public bool GetNoLoadingScreen()
		{
			unsafe {
				if (fn__getNoLoadingScreen == null) fn__getNoLoadingScreen = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_getNoLoadingScreen");
				var result = fn__getNoLoadingScreen();
				return result;
			}
		}

		public void _0xB1577667C3708F9B()
		{
			unsafe {
				if (fn__0xB1577667C3708F9B == null) fn__0xB1577667C3708F9B = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xB1577667C3708F9B");
				fn__0xB1577667C3708F9B();
			}
		}

		public bool _0x836B62713E0534CA()
		{
			unsafe {
				if (fn__0x836B62713E0534CA == null) fn__0x836B62713E0534CA = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x836B62713E0534CA");
				var result = fn__0x836B62713E0534CA();
				return result;
			}
		}

		public void _0x760910B49D2B98EA()
		{
			unsafe {
				if (fn__0x760910B49D2B98EA == null) fn__0x760910B49D2B98EA = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x760910B49D2B98EA");
				fn__0x760910B49D2B98EA();
			}
		}

		public void BgStartContextHash(int _contextHash)
		{
			unsafe {
				if (fn__bgStartContextHash == null) fn__bgStartContextHash = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_bgStartContextHash");
				fn__bgStartContextHash(_contextHash);
			}
		}

		public void BgEndContextHash(int _contextHash)
		{
			unsafe {
				if (fn__bgEndContextHash == null) fn__bgEndContextHash = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_bgEndContextHash");
				fn__bgEndContextHash(_contextHash);
			}
		}

		public void BgStartContext(string _contextName)
		{
			unsafe {
				if (fn__bgStartContext == null) fn__bgStartContext = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_bgStartContext");
				var ptr_contextName = MemoryUtils.StringToHGlobalUtf8(_contextName);
				fn__bgStartContext(ptr_contextName);
				Marshal.FreeHGlobal(ptr_contextName);
			}
		}

		public void BgEndContext(string _contextName)
		{
			unsafe {
				if (fn__bgEndContext == null) fn__bgEndContext = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_bgEndContext");
				var ptr_contextName = MemoryUtils.StringToHGlobalUtf8(_contextName);
				fn__bgEndContext(ptr_contextName);
				Marshal.FreeHGlobal(ptr_contextName);
			}
		}

		public bool _0x0F6F1EBBC4E1D5E6(int _scriptIndex, string _p1)
		{
			unsafe {
				if (fn__0x0F6F1EBBC4E1D5E6 == null) fn__0x0F6F1EBBC4E1D5E6 = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native__0x0F6F1EBBC4E1D5E6");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var result = fn__0x0F6F1EBBC4E1D5E6(_scriptIndex, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
				return result;
			}
		}

		public int _0x22E21FBCFC88C149(int _scriptIndex, string _p1)
		{
			unsafe {
				if (fn__0x22E21FBCFC88C149 == null) fn__0x22E21FBCFC88C149 = (delegate* unmanaged[Cdecl]<int, nint, int>) NativeLibrary.GetExport(handle, "Native__0x22E21FBCFC88C149");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var result = fn__0x22E21FBCFC88C149(_scriptIndex, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
				return result;
			}
		}

		public int _0x829CD22E043A2577(int _p0)
		{
			unsafe {
				if (fn__0x829CD22E043A2577 == null) fn__0x829CD22E043A2577 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x829CD22E043A2577");
				var result = fn__0x829CD22E043A2577(_p0);
				return result;
			}
		}

		public int StartShapeTestLosProbe(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _flags, int _entity, int _p8)
		{
			unsafe {
				if (fn__startShapeTestLosProbe == null) fn__startShapeTestLosProbe = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startShapeTestLosProbe");
				var result = fn__startShapeTestLosProbe(_x1, _y1, _z1, _x2, _y2, _z2, _flags, _entity, _p8);
				return result;
			}
		}

		public int StartExpensiveSynchronousShapeTestLosProbe(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _flags, int _entity, int _p8)
		{
			unsafe {
				if (fn__startExpensiveSynchronousShapeTestLosProbe == null) fn__startExpensiveSynchronousShapeTestLosProbe = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startExpensiveSynchronousShapeTestLosProbe");
				var result = fn__startExpensiveSynchronousShapeTestLosProbe(_x1, _y1, _z1, _x2, _y2, _z2, _flags, _entity, _p8);
				return result;
			}
		}

		public int StartShapeTestBoundingBox(int _entity, int _flags1, int _flags2)
		{
			unsafe {
				if (fn__startShapeTestBoundingBox == null) fn__startShapeTestBoundingBox = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startShapeTestBoundingBox");
				var result = fn__startShapeTestBoundingBox(_entity, _flags1, _flags2);
				return result;
			}
		}

		public int StartShapeTestBox(float _x, float _y, float _z, float _x1, float _y2, float _z2, float _rotX, float _rotY, float _rotZ, int _p9, int _flags, int _entity, int _p12)
		{
			unsafe {
				if (fn__startShapeTestBox == null) fn__startShapeTestBox = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startShapeTestBox");
				var result = fn__startShapeTestBox(_x, _y, _z, _x1, _y2, _z2, _rotX, _rotY, _rotZ, _p9, _flags, _entity, _p12);
				return result;
			}
		}

		public int StartShapeTestBound(int _entity, int _flags1, int _flags2)
		{
			unsafe {
				if (fn__startShapeTestBound == null) fn__startShapeTestBound = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startShapeTestBound");
				var result = fn__startShapeTestBound(_entity, _flags1, _flags2);
				return result;
			}
		}

		public int StartShapeTestCapsule(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _radius, int _flags, int _entity, int _p9)
		{
			unsafe {
				if (fn__startShapeTestCapsule == null) fn__startShapeTestCapsule = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startShapeTestCapsule");
				var result = fn__startShapeTestCapsule(_x1, _y1, _z1, _x2, _y2, _z2, _radius, _flags, _entity, _p9);
				return result;
			}
		}

		public int StartShapeTestSweptSphere(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, float _radius, int _flags, int _entity, int _p9)
		{
			unsafe {
				if (fn__startShapeTestSweptSphere == null) fn__startShapeTestSweptSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startShapeTestSweptSphere");
				var result = fn__startShapeTestSweptSphere(_x1, _y1, _z1, _x2, _y2, _z2, _radius, _flags, _entity, _p9);
				return result;
			}
		}

		public int StartShapeTestSurroundingCoords(ref Vector3 _pVec1, ref Vector3 _pVec2, int _flag, int _entity, int _flag2)
		{
			unsafe {
				if (fn__startShapeTestSurroundingCoords == null) fn__startShapeTestSurroundingCoords = (delegate* unmanaged[Cdecl]<Vector3*, Vector3*, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_startShapeTestSurroundingCoords");
				var ref_pVec1 = _pVec1;
				var ref_pVec2 = _pVec2;
				var result = fn__startShapeTestSurroundingCoords(&ref_pVec1, &ref_pVec2, _flag, _entity, _flag2);
				_pVec1 = ref_pVec1;
				_pVec2 = ref_pVec2;
				return result;
			}
		}

		public int GetShapeTestResult(int _shapeTestHandle, ref bool _hit, ref Vector3 _endCoords, ref Vector3 _surfaceNormal, ref int _entityHit)
		{
			unsafe {
				if (fn__getShapeTestResult == null) fn__getShapeTestResult = (delegate* unmanaged[Cdecl]<int, bool*, Vector3*, Vector3*, int*, int>) NativeLibrary.GetExport(handle, "Native_getShapeTestResult");
				var ref_hit = _hit;
				var ref_endCoords = _endCoords;
				var ref_surfaceNormal = _surfaceNormal;
				var ref_entityHit = _entityHit;
				var result = fn__getShapeTestResult(_shapeTestHandle, &ref_hit, &ref_endCoords, &ref_surfaceNormal, &ref_entityHit);
				_hit = ref_hit;
				_endCoords = ref_endCoords;
				_surfaceNormal = ref_surfaceNormal;
				_entityHit = ref_entityHit;
				return result;
			}
		}

		public int GetShapeTestResultIncludingMaterial(int _shapeTestHandle, ref bool _hit, ref Vector3 _endCoords, ref Vector3 _surfaceNormal, ref int _materialHash, ref int _entityHit)
		{
			unsafe {
				if (fn__getShapeTestResultIncludingMaterial == null) fn__getShapeTestResultIncludingMaterial = (delegate* unmanaged[Cdecl]<int, bool*, Vector3*, Vector3*, int*, int*, int>) NativeLibrary.GetExport(handle, "Native_getShapeTestResultIncludingMaterial");
				var ref_hit = _hit;
				var ref_endCoords = _endCoords;
				var ref_surfaceNormal = _surfaceNormal;
				var ref_materialHash = _materialHash;
				var ref_entityHit = _entityHit;
				var result = fn__getShapeTestResultIncludingMaterial(_shapeTestHandle, &ref_hit, &ref_endCoords, &ref_surfaceNormal, &ref_materialHash, &ref_entityHit);
				_hit = ref_hit;
				_endCoords = ref_endCoords;
				_surfaceNormal = ref_surfaceNormal;
				_materialHash = ref_materialHash;
				_entityHit = ref_entityHit;
				return result;
			}
		}

		public void ReleaseScriptGuidFromEntity(int _entityHit)
		{
			unsafe {
				if (fn__releaseScriptGuidFromEntity == null) fn__releaseScriptGuidFromEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_releaseScriptGuidFromEntity");
				fn__releaseScriptGuidFromEntity(_entityHit);
			}
		}

		public int ScInboxGetTotalNumMessages()
		{
			unsafe {
				if (fn__scInboxGetTotalNumMessages == null) fn__scInboxGetTotalNumMessages = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_scInboxGetTotalNumMessages");
				var result = fn__scInboxGetTotalNumMessages();
				return result;
			}
		}

		public int ScInboxGetMessageTypeAtIndex(int _msgIndex)
		{
			unsafe {
				if (fn__scInboxGetMessageTypeAtIndex == null) fn__scInboxGetMessageTypeAtIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_scInboxGetMessageTypeAtIndex");
				var result = fn__scInboxGetMessageTypeAtIndex(_msgIndex);
				return result;
			}
		}

		public bool ScInboxGetMessageIsReadAtIndex(int _msgIndex)
		{
			unsafe {
				if (fn__scInboxGetMessageIsReadAtIndex == null) fn__scInboxGetMessageIsReadAtIndex = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_scInboxGetMessageIsReadAtIndex");
				var result = fn__scInboxGetMessageIsReadAtIndex(_msgIndex);
				return result;
			}
		}

		public bool ScInboxMessagePop(int _p0)
		{
			unsafe {
				if (fn__scInboxMessagePop == null) fn__scInboxMessagePop = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_scInboxMessagePop");
				var result = fn__scInboxMessagePop(_p0);
				return result;
			}
		}

		public bool ScInboxMessageGetDataInt(int _p0, string _context, ref int _out)
		{
			unsafe {
				if (fn__scInboxMessageGetDataInt == null) fn__scInboxMessageGetDataInt = (delegate* unmanaged[Cdecl]<int, nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_scInboxMessageGetDataInt");
				var ptr_context = MemoryUtils.StringToHGlobalUtf8(_context);
				var ref_out = _out;
				var result = fn__scInboxMessageGetDataInt(_p0, ptr_context, &ref_out);
				Marshal.FreeHGlobal(ptr_context);
				_out = ref_out;
				return result;
			}
		}

		public bool ScInboxMessageGetDataBool(int _p0, string _p1)
		{
			unsafe {
				if (fn__scInboxMessageGetDataBool == null) fn__scInboxMessageGetDataBool = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_scInboxMessageGetDataBool");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var result = fn__scInboxMessageGetDataBool(_p0, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
				return result;
			}
		}

		public bool ScInboxMessageGetDataString(int _p0, string _context, ref string _out)
		{
			unsafe {
				if (fn__scInboxMessageGetDataString == null) fn__scInboxMessageGetDataString = (delegate* unmanaged[Cdecl]<int, nint, nint*, bool>) NativeLibrary.GetExport(handle, "Native_scInboxMessageGetDataString");
				var ptr_context = MemoryUtils.StringToHGlobalUtf8(_context);
				var ptr_out = MemoryUtils.StringToHGlobalUtf8(_out);
				var ref_out = ptr_out;
				var result = fn__scInboxMessageGetDataString(_p0, ptr_context, &ref_out);
				Marshal.FreeHGlobal(ptr_context);
				_out = Marshal.PtrToStringUTF8(ref_out);
				freeString(ref_out);
				Marshal.FreeHGlobal(ptr_out);
				return result;
			}
		}

		public bool ScInboxMessageDoApply(int _p0)
		{
			unsafe {
				if (fn__scInboxMessageDoApply == null) fn__scInboxMessageDoApply = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_scInboxMessageDoApply");
				var result = fn__scInboxMessageDoApply(_p0);
				return result;
			}
		}

		public string ScInboxMessageGetString(int _p0)
		{
			unsafe {
				if (fn__scInboxMessageGetString == null) fn__scInboxMessageGetString = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_scInboxMessageGetString");
				var result = fn__scInboxMessageGetString(_p0);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void ScInboxMessagePushGamerToEventRecipList(ref int _gamerHandle)
		{
			unsafe {
				if (fn__scInboxMessagePushGamerToEventRecipList == null) fn__scInboxMessagePushGamerToEventRecipList = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_scInboxMessagePushGamerToEventRecipList");
				var ref_gamerHandle = _gamerHandle;
				fn__scInboxMessagePushGamerToEventRecipList(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public void ScInboxMessageSendUgcStatUpdateEvent(ref int _data)
		{
			unsafe {
				if (fn__scInboxMessageSendUgcStatUpdateEvent == null) fn__scInboxMessageSendUgcStatUpdateEvent = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_scInboxMessageSendUgcStatUpdateEvent");
				var ref_data = _data;
				fn__scInboxMessageSendUgcStatUpdateEvent(&ref_data);
				_data = ref_data;
			}
		}

		public bool ScInboxMessageGetUgcdata(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__scInboxMessageGetUgcdata == null) fn__scInboxMessageGetUgcdata = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_scInboxMessageGetUgcdata");
				var ref_p1 = _p1;
				var result = fn__scInboxMessageGetUgcdata(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool ScInboxMessageSendBountyPresenceEvent(ref int _data)
		{
			unsafe {
				if (fn__scInboxMessageSendBountyPresenceEvent == null) fn__scInboxMessageSendBountyPresenceEvent = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_scInboxMessageSendBountyPresenceEvent");
				var ref_data = _data;
				var result = fn__scInboxMessageSendBountyPresenceEvent(&ref_data);
				_data = ref_data;
				return result;
			}
		}

		public bool ScInboxMessageGetBountyData(int _index, ref int _outData)
		{
			unsafe {
				if (fn__scInboxMessageGetBountyData == null) fn__scInboxMessageGetBountyData = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_scInboxMessageGetBountyData");
				var ref_outData = _outData;
				var result = fn__scInboxMessageGetBountyData(_index, &ref_outData);
				_outData = ref_outData;
				return result;
			}
		}

		public void ScInboxGetEmails(int _offset, int _limit)
		{
			unsafe {
				if (fn__scInboxGetEmails == null) fn__scInboxGetEmails = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_scInboxGetEmails");
				fn__scInboxGetEmails(_offset, _limit);
			}
		}

		public int _0x16DA8172459434AA()
		{
			unsafe {
				if (fn__0x16DA8172459434AA == null) fn__0x16DA8172459434AA = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x16DA8172459434AA");
				var result = fn__0x16DA8172459434AA();
				return result;
			}
		}

		public int _0x7DB18CA8CAD5B098()
		{
			unsafe {
				if (fn__0x7DB18CA8CAD5B098 == null) fn__0x7DB18CA8CAD5B098 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x7DB18CA8CAD5B098");
				var result = fn__0x7DB18CA8CAD5B098();
				return result;
			}
		}

		public bool _0x4737980E8A283806(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__0x4737980E8A283806 == null) fn__0x4737980E8A283806 = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x4737980E8A283806");
				var ref_p1 = _p1;
				var result = fn__0x4737980E8A283806(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public void _0x44ACA259D67651DB(ref int _p0, int _p1)
		{
			unsafe {
				if (fn__0x44ACA259D67651DB == null) fn__0x44ACA259D67651DB = (delegate* unmanaged[Cdecl]<int*, int, void>) NativeLibrary.GetExport(handle, "Native__0x44ACA259D67651DB");
				var ref_p0 = _p0;
				fn__0x44ACA259D67651DB(&ref_p0, _p1);
				_p0 = ref_p0;
			}
		}

		public void ScEmailMessagePushGamerToRecipList(ref int _gamerHandle)
		{
			unsafe {
				if (fn__scEmailMessagePushGamerToRecipList == null) fn__scEmailMessagePushGamerToRecipList = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_scEmailMessagePushGamerToRecipList");
				var ref_gamerHandle = _gamerHandle;
				fn__scEmailMessagePushGamerToRecipList(&ref_gamerHandle);
				_gamerHandle = ref_gamerHandle;
			}
		}

		public void ScEmailMessageClearRecipList()
		{
			unsafe {
				if (fn__scEmailMessageClearRecipList == null) fn__scEmailMessageClearRecipList = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_scEmailMessageClearRecipList");
				fn__scEmailMessageClearRecipList();
			}
		}

		public void _0x116FB94DC4B79F17(string _p0)
		{
			unsafe {
				if (fn__0x116FB94DC4B79F17 == null) fn__0x116FB94DC4B79F17 = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native__0x116FB94DC4B79F17");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				fn__0x116FB94DC4B79F17(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
			}
		}

		public int _0x07DBD622D9533857(int _p0)
		{
			unsafe {
				if (fn__0x07DBD622D9533857 == null) fn__0x07DBD622D9533857 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x07DBD622D9533857");
				var result = fn__0x07DBD622D9533857(_p0);
				return result;
			}
		}

		public void SetHandleRockstarMessageViaScript(bool _toggle)
		{
			unsafe {
				if (fn__setHandleRockstarMessageViaScript == null) fn__setHandleRockstarMessageViaScript = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setHandleRockstarMessageViaScript");
				fn__setHandleRockstarMessageViaScript(_toggle);
			}
		}

		public bool IsRockstarMessageReadyForScript()
		{
			unsafe {
				if (fn__isRockstarMessageReadyForScript == null) fn__isRockstarMessageReadyForScript = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isRockstarMessageReadyForScript");
				var result = fn__isRockstarMessageReadyForScript();
				return result;
			}
		}

		public string RockstarMessageGetString()
		{
			unsafe {
				if (fn__rockstarMessageGetString == null) fn__rockstarMessageGetString = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_rockstarMessageGetString");
				var result = fn__rockstarMessageGetString();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool ScPresenceAttrSetInt(int _attrHash, int _value)
		{
			unsafe {
				if (fn__scPresenceAttrSetInt == null) fn__scPresenceAttrSetInt = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_scPresenceAttrSetInt");
				var result = fn__scPresenceAttrSetInt(_attrHash, _value);
				return result;
			}
		}

		public bool ScPresenceAttrSetFloat(int _attrHash, float _value)
		{
			unsafe {
				if (fn__scPresenceAttrSetFloat == null) fn__scPresenceAttrSetFloat = (delegate* unmanaged[Cdecl]<int, float, bool>) NativeLibrary.GetExport(handle, "Native_scPresenceAttrSetFloat");
				var result = fn__scPresenceAttrSetFloat(_attrHash, _value);
				return result;
			}
		}

		public bool ScPresenceAttrSetString(int _attrHash, string _value)
		{
			unsafe {
				if (fn__scPresenceAttrSetString == null) fn__scPresenceAttrSetString = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_scPresenceAttrSetString");
				var ptr_value = MemoryUtils.StringToHGlobalUtf8(_value);
				var result = fn__scPresenceAttrSetString(_attrHash, ptr_value);
				Marshal.FreeHGlobal(ptr_value);
				return result;
			}
		}

		public bool _0x487912FD248EFDDF(int _p0, float _p1)
		{
			unsafe {
				if (fn__0x487912FD248EFDDF == null) fn__0x487912FD248EFDDF = (delegate* unmanaged[Cdecl]<int, float, bool>) NativeLibrary.GetExport(handle, "Native__0x487912FD248EFDDF");
				var result = fn__0x487912FD248EFDDF(_p0, _p1);
				return result;
			}
		}

		public int _0xC85A7127E7AD02AA()
		{
			unsafe {
				if (fn__0xC85A7127E7AD02AA == null) fn__0xC85A7127E7AD02AA = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xC85A7127E7AD02AA");
				var result = fn__0xC85A7127E7AD02AA();
				return result;
			}
		}

		public int _0xA770C8EEC6FB2AC5()
		{
			unsafe {
				if (fn__0xA770C8EEC6FB2AC5 == null) fn__0xA770C8EEC6FB2AC5 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xA770C8EEC6FB2AC5");
				var result = fn__0xA770C8EEC6FB2AC5();
				return result;
			}
		}

		public bool ScGetIsProfileAttributeSet(string _name)
		{
			unsafe {
				if (fn__scGetIsProfileAttributeSet == null) fn__scGetIsProfileAttributeSet = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_scGetIsProfileAttributeSet");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__scGetIsProfileAttributeSet(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public int _0x7FFCBFEE44ECFABF()
		{
			unsafe {
				if (fn__0x7FFCBFEE44ECFABF == null) fn__0x7FFCBFEE44ECFABF = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x7FFCBFEE44ECFABF");
				var result = fn__0x7FFCBFEE44ECFABF();
				return result;
			}
		}

		public int _0x2D874D4AE612A65F()
		{
			unsafe {
				if (fn__0x2D874D4AE612A65F == null) fn__0x2D874D4AE612A65F = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x2D874D4AE612A65F");
				var result = fn__0x2D874D4AE612A65F();
				return result;
			}
		}

		public bool ScProfanityCheckString(string _string, ref int _token)
		{
			unsafe {
				if (fn__scProfanityCheckString == null) fn__scProfanityCheckString = (delegate* unmanaged[Cdecl]<nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_scProfanityCheckString");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				var ref_token = _token;
				var result = fn__scProfanityCheckString(ptr_string, &ref_token);
				Marshal.FreeHGlobal(ptr_string);
				_token = ref_token;
				return result;
			}
		}

		public bool ScProfanityCheckUgcString(string _string, ref int _token)
		{
			unsafe {
				if (fn__scProfanityCheckUgcString == null) fn__scProfanityCheckUgcString = (delegate* unmanaged[Cdecl]<nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_scProfanityCheckUgcString");
				var ptr_string = MemoryUtils.StringToHGlobalUtf8(_string);
				var ref_token = _token;
				var result = fn__scProfanityCheckUgcString(ptr_string, &ref_token);
				Marshal.FreeHGlobal(ptr_string);
				_token = ref_token;
				return result;
			}
		}

		public bool ScProfanityGetCheckIsValid(int _token)
		{
			unsafe {
				if (fn__scProfanityGetCheckIsValid == null) fn__scProfanityGetCheckIsValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_scProfanityGetCheckIsValid");
				var result = fn__scProfanityGetCheckIsValid(_token);
				return result;
			}
		}

		public bool ScProfanityGetCheckIsPending(int _token)
		{
			unsafe {
				if (fn__scProfanityGetCheckIsPending == null) fn__scProfanityGetCheckIsPending = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_scProfanityGetCheckIsPending");
				var result = fn__scProfanityGetCheckIsPending(_token);
				return result;
			}
		}

		public bool ScProfanityGetStringPassed(int _token)
		{
			unsafe {
				if (fn__scProfanityGetStringPassed == null) fn__scProfanityGetStringPassed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_scProfanityGetStringPassed");
				var result = fn__scProfanityGetStringPassed(_token);
				return result;
			}
		}

		public int ScProfanityGetStringStatus(int _token)
		{
			unsafe {
				if (fn__scProfanityGetStringStatus == null) fn__scProfanityGetStringStatus = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_scProfanityGetStringStatus");
				var result = fn__scProfanityGetStringStatus(_token);
				return result;
			}
		}

		public bool _0xF6BAAAF762E1BF40(string _p0, ref int _p1)
		{
			unsafe {
				if (fn__0xF6BAAAF762E1BF40 == null) fn__0xF6BAAAF762E1BF40 = (delegate* unmanaged[Cdecl]<nint, int*, bool>) NativeLibrary.GetExport(handle, "Native__0xF6BAAAF762E1BF40");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p1 = _p1;
				var result = fn__0xF6BAAAF762E1BF40(ptr_p0, &ref_p1);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool _0xF22CA0FD74B80E7A(int _p0)
		{
			unsafe {
				if (fn__0xF22CA0FD74B80E7A == null) fn__0xF22CA0FD74B80E7A = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xF22CA0FD74B80E7A");
				var result = fn__0xF22CA0FD74B80E7A(_p0);
				return result;
			}
		}

		public int _0x9237E334F6E43156(int _p0)
		{
			unsafe {
				if (fn__0x9237E334F6E43156 == null) fn__0x9237E334F6E43156 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x9237E334F6E43156");
				var result = fn__0x9237E334F6E43156(_p0);
				return result;
			}
		}

		public int _0x700569DBA175A77C(int _p0)
		{
			unsafe {
				if (fn__0x700569DBA175A77C == null) fn__0x700569DBA175A77C = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x700569DBA175A77C");
				var result = fn__0x700569DBA175A77C(_p0);
				return result;
			}
		}

		public int _0x1D4446A62D35B0D0(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x1D4446A62D35B0D0 == null) fn__0x1D4446A62D35B0D0 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x1D4446A62D35B0D0");
				var result = fn__0x1D4446A62D35B0D0(_p0, _p1);
				return result;
			}
		}

		public int _0x2E89990DDFF670C3(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x2E89990DDFF670C3 == null) fn__0x2E89990DDFF670C3 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x2E89990DDFF670C3");
				var result = fn__0x2E89990DDFF670C3(_p0, _p1);
				return result;
			}
		}

		public bool _0xD0EE05FE193646EA(string _p0, string _p1, ref int _p2)
		{
			unsafe {
				if (fn__0xD0EE05FE193646EA == null) fn__0xD0EE05FE193646EA = (delegate* unmanaged[Cdecl]<nint, nint, int*, bool>) NativeLibrary.GetExport(handle, "Native__0xD0EE05FE193646EA");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ref_p2 = _p2;
				var result = fn__0xD0EE05FE193646EA(ptr_p0, ptr_p1, &ref_p2);
				Marshal.FreeHGlobal(ptr_p0);
				Marshal.FreeHGlobal(ptr_p1);
				_p2 = ref_p2;
				return result;
			}
		}

		public bool _0x1989C6E6F67E76A8(string _p0, ref int _p1, ref int _p2)
		{
			unsafe {
				if (fn__0x1989C6E6F67E76A8 == null) fn__0x1989C6E6F67E76A8 = (delegate* unmanaged[Cdecl]<nint, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x1989C6E6F67E76A8");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var result = fn__0x1989C6E6F67E76A8(ptr_p0, &ref_p1, &ref_p2);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = ref_p1;
				_p2 = ref_p2;
				return result;
			}
		}

		public int _0x07C61676E5BB52CD(int _p0)
		{
			unsafe {
				if (fn__0x07C61676E5BB52CD == null) fn__0x07C61676E5BB52CD = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x07C61676E5BB52CD");
				var result = fn__0x07C61676E5BB52CD(_p0);
				return result;
			}
		}

		public int _0x8147FFF6A718E1AD(int _p0)
		{
			unsafe {
				if (fn__0x8147FFF6A718E1AD == null) fn__0x8147FFF6A718E1AD = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x8147FFF6A718E1AD");
				var result = fn__0x8147FFF6A718E1AD(_p0);
				return result;
			}
		}

		public bool _0x0F73393BAC7E6730(string _p0, ref int _p1)
		{
			unsafe {
				if (fn__0x0F73393BAC7E6730 == null) fn__0x0F73393BAC7E6730 = (delegate* unmanaged[Cdecl]<nint, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x0F73393BAC7E6730");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p1 = _p1;
				var result = fn__0x0F73393BAC7E6730(ptr_p0, &ref_p1);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = ref_p1;
				return result;
			}
		}

		public int _0xD302E99EDF0449CF(int _p0)
		{
			unsafe {
				if (fn__0xD302E99EDF0449CF == null) fn__0xD302E99EDF0449CF = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xD302E99EDF0449CF");
				var result = fn__0xD302E99EDF0449CF(_p0);
				return result;
			}
		}

		public int _0x5C4EBFFA98BDB41C(int _p0)
		{
			unsafe {
				if (fn__0x5C4EBFFA98BDB41C == null) fn__0x5C4EBFFA98BDB41C = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x5C4EBFFA98BDB41C");
				var result = fn__0x5C4EBFFA98BDB41C(_p0);
				return result;
			}
		}

		public bool _0xFF8F3A92B75ED67A()
		{
			unsafe {
				if (fn__0xFF8F3A92B75ED67A == null) fn__0xFF8F3A92B75ED67A = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xFF8F3A92B75ED67A");
				var result = fn__0xFF8F3A92B75ED67A();
				return result;
			}
		}

		public int _0x4ED9C8D6DA297639()
		{
			unsafe {
				if (fn__0x4ED9C8D6DA297639 == null) fn__0x4ED9C8D6DA297639 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x4ED9C8D6DA297639");
				var result = fn__0x4ED9C8D6DA297639();
				return result;
			}
		}

		public bool _0x710BCDA8071EDED1(string _p0, ref int _p1)
		{
			unsafe {
				if (fn__0x710BCDA8071EDED1 == null) fn__0x710BCDA8071EDED1 = (delegate* unmanaged[Cdecl]<nint, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x710BCDA8071EDED1");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p1 = _p1;
				var result = fn__0x710BCDA8071EDED1(ptr_p0, &ref_p1);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool _0x50A8A36201DBF83E(string _p0, ref float _p1)
		{
			unsafe {
				if (fn__0x50A8A36201DBF83E == null) fn__0x50A8A36201DBF83E = (delegate* unmanaged[Cdecl]<nint, float*, bool>) NativeLibrary.GetExport(handle, "Native__0x50A8A36201DBF83E");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p1 = _p1;
				var result = fn__0x50A8A36201DBF83E(ptr_p0, &ref_p1);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = ref_p1;
				return result;
			}
		}

		public bool _0x9DE5D2F723575ED0(string _p0, ref string _p1)
		{
			unsafe {
				if (fn__0x9DE5D2F723575ED0 == null) fn__0x9DE5D2F723575ED0 = (delegate* unmanaged[Cdecl]<nint, nint*, bool>) NativeLibrary.GetExport(handle, "Native__0x9DE5D2F723575ED0");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ref_p1 = ptr_p1;
				var result = fn__0x9DE5D2F723575ED0(ptr_p0, &ref_p1);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = Marshal.PtrToStringUTF8(ref_p1);
				freeString(ref_p1);
				Marshal.FreeHGlobal(ptr_p1);
				return result;
			}
		}

		public bool _0xC2C97EA97711D1AE(ref string _p0)
		{
			unsafe {
				if (fn__0xC2C97EA97711D1AE == null) fn__0xC2C97EA97711D1AE = (delegate* unmanaged[Cdecl]<nint*, bool>) NativeLibrary.GetExport(handle, "Native__0xC2C97EA97711D1AE");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p0 = ptr_p0;
				var result = fn__0xC2C97EA97711D1AE(&ref_p0);
				_p0 = Marshal.PtrToStringUTF8(ref_p0);
				freeString(ref_p0);
				Marshal.FreeHGlobal(ptr_p0);
				return result;
			}
		}

		public bool _0x450819D8CF90C416(string _p0)
		{
			unsafe {
				if (fn__0x450819D8CF90C416 == null) fn__0x450819D8CF90C416 = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native__0x450819D8CF90C416");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var result = fn__0x450819D8CF90C416(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
				return result;
			}
		}

		public int _0x4A7D6E727F941747(string _p0)
		{
			unsafe {
				if (fn__0x4A7D6E727F941747 == null) fn__0x4A7D6E727F941747 = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native__0x4A7D6E727F941747");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var result = fn__0x4A7D6E727F941747(ptr_p0);
				Marshal.FreeHGlobal(ptr_p0);
				return result;
			}
		}

		public bool _0xE75A4A2E5E316D86(string _p0, ref int _p1, string _p2)
		{
			unsafe {
				if (fn__0xE75A4A2E5E316D86 == null) fn__0xE75A4A2E5E316D86 = (delegate* unmanaged[Cdecl]<nint, int*, nint, bool>) NativeLibrary.GetExport(handle, "Native__0xE75A4A2E5E316D86");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p1 = _p1;
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var result = fn__0xE75A4A2E5E316D86(ptr_p0, &ref_p1, ptr_p2);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = ref_p1;
				Marshal.FreeHGlobal(ptr_p2);
				return result;
			}
		}

		public bool _0x2570E26BE63964E3(string _p0, ref float _p1, string _p2)
		{
			unsafe {
				if (fn__0x2570E26BE63964E3 == null) fn__0x2570E26BE63964E3 = (delegate* unmanaged[Cdecl]<nint, float*, nint, bool>) NativeLibrary.GetExport(handle, "Native__0x2570E26BE63964E3");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p1 = _p1;
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var result = fn__0x2570E26BE63964E3(ptr_p0, &ref_p1, ptr_p2);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = ref_p1;
				Marshal.FreeHGlobal(ptr_p2);
				return result;
			}
		}

		public bool _0x1D12A56FC95BE92E(string _p0, ref string _p1, string _p2)
		{
			unsafe {
				if (fn__0x1D12A56FC95BE92E == null) fn__0x1D12A56FC95BE92E = (delegate* unmanaged[Cdecl]<nint, nint*, nint, bool>) NativeLibrary.GetExport(handle, "Native__0x1D12A56FC95BE92E");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ref_p1 = ptr_p1;
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var result = fn__0x1D12A56FC95BE92E(ptr_p0, &ref_p1, ptr_p2);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = Marshal.PtrToStringUTF8(ref_p1);
				freeString(ref_p1);
				Marshal.FreeHGlobal(ptr_p1);
				Marshal.FreeHGlobal(ptr_p2);
				return result;
			}
		}

		public bool _0x33DF47CC0642061B(ref string _p0, string _p1)
		{
			unsafe {
				if (fn__0x33DF47CC0642061B == null) fn__0x33DF47CC0642061B = (delegate* unmanaged[Cdecl]<nint*, nint, bool>) NativeLibrary.GetExport(handle, "Native__0x33DF47CC0642061B");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p0 = ptr_p0;
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var result = fn__0x33DF47CC0642061B(&ref_p0, ptr_p1);
				_p0 = Marshal.PtrToStringUTF8(ref_p0);
				freeString(ref_p0);
				Marshal.FreeHGlobal(ptr_p0);
				Marshal.FreeHGlobal(ptr_p1);
				return result;
			}
		}

		public bool _0xA468E0BE12B12C70(int _p0)
		{
			unsafe {
				if (fn__0xA468E0BE12B12C70 == null) fn__0xA468E0BE12B12C70 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xA468E0BE12B12C70");
				var result = fn__0xA468E0BE12B12C70(_p0);
				return result;
			}
		}

		public bool _0x8CC469AB4D349B7C(int _p0, string _p1, ref int _p2)
		{
			unsafe {
				if (fn__0x8CC469AB4D349B7C == null) fn__0x8CC469AB4D349B7C = (delegate* unmanaged[Cdecl]<int, nint, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x8CC469AB4D349B7C");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ref_p2 = _p2;
				var result = fn__0x8CC469AB4D349B7C(_p0, ptr_p1, &ref_p2);
				Marshal.FreeHGlobal(ptr_p1);
				_p2 = ref_p2;
				return result;
			}
		}

		public bool _0xC5A35C73B68F3C49(int _p0, string _p1, ref float _p2)
		{
			unsafe {
				if (fn__0xC5A35C73B68F3C49 == null) fn__0xC5A35C73B68F3C49 = (delegate* unmanaged[Cdecl]<int, nint, float*, bool>) NativeLibrary.GetExport(handle, "Native__0xC5A35C73B68F3C49");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ref_p2 = _p2;
				var result = fn__0xC5A35C73B68F3C49(_p0, ptr_p1, &ref_p2);
				Marshal.FreeHGlobal(ptr_p1);
				_p2 = ref_p2;
				return result;
			}
		}

		public bool _0x699E4A5C8C893A18(int _p0, string _p1, ref string _p2)
		{
			unsafe {
				if (fn__0x699E4A5C8C893A18 == null) fn__0x699E4A5C8C893A18 = (delegate* unmanaged[Cdecl]<int, nint, nint*, bool>) NativeLibrary.GetExport(handle, "Native__0x699E4A5C8C893A18");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var ref_p2 = ptr_p2;
				var result = fn__0x699E4A5C8C893A18(_p0, ptr_p1, &ref_p2);
				Marshal.FreeHGlobal(ptr_p1);
				_p2 = Marshal.PtrToStringUTF8(ref_p2);
				freeString(ref_p2);
				Marshal.FreeHGlobal(ptr_p2);
				return result;
			}
		}

		public bool _0x19853B5B17D77BCA(int _p0, ref string _p1)
		{
			unsafe {
				if (fn__0x19853B5B17D77BCA == null) fn__0x19853B5B17D77BCA = (delegate* unmanaged[Cdecl]<int, nint*, bool>) NativeLibrary.GetExport(handle, "Native__0x19853B5B17D77BCA");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ref_p1 = ptr_p1;
				var result = fn__0x19853B5B17D77BCA(_p0, &ref_p1);
				_p1 = Marshal.PtrToStringUTF8(ref_p1);
				freeString(ref_p1);
				Marshal.FreeHGlobal(ptr_p1);
				return result;
			}
		}

		public bool _0x6BFB12CE158E3DD4(int _p0)
		{
			unsafe {
				if (fn__0x6BFB12CE158E3DD4 == null) fn__0x6BFB12CE158E3DD4 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x6BFB12CE158E3DD4");
				var result = fn__0x6BFB12CE158E3DD4(_p0);
				return result;
			}
		}

		public bool _0xFE4C1D0D3B9CC17E(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xFE4C1D0D3B9CC17E == null) fn__0xFE4C1D0D3B9CC17E = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native__0xFE4C1D0D3B9CC17E");
				var result = fn__0xFE4C1D0D3B9CC17E(_p0, _p1);
				return result;
			}
		}

		public int _0xD8122C407663B995()
		{
			unsafe {
				if (fn__0xD8122C407663B995 == null) fn__0xD8122C407663B995 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xD8122C407663B995");
				var result = fn__0xD8122C407663B995();
				return result;
			}
		}

		public bool _0x3001BEF2FECA3680()
		{
			unsafe {
				if (fn__0x3001BEF2FECA3680 == null) fn__0x3001BEF2FECA3680 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x3001BEF2FECA3680");
				var result = fn__0x3001BEF2FECA3680();
				return result;
			}
		}

		public bool _0x92DA6E70EF249BD1(string _p0, ref int _p1)
		{
			unsafe {
				if (fn__0x92DA6E70EF249BD1 == null) fn__0x92DA6E70EF249BD1 = (delegate* unmanaged[Cdecl]<nint, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x92DA6E70EF249BD1");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var ref_p1 = _p1;
				var result = fn__0x92DA6E70EF249BD1(ptr_p0, &ref_p1);
				Marshal.FreeHGlobal(ptr_p0);
				_p1 = ref_p1;
				return result;
			}
		}

		public void _0x675721C9F644D161()
		{
			unsafe {
				if (fn__0x675721C9F644D161 == null) fn__0x675721C9F644D161 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x675721C9F644D161");
				fn__0x675721C9F644D161();
			}
		}

		public int _0xE4F6E8D07A2F0F51(int _p0)
		{
			unsafe {
				if (fn__0xE4F6E8D07A2F0F51 == null) fn__0xE4F6E8D07A2F0F51 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xE4F6E8D07A2F0F51");
				var result = fn__0xE4F6E8D07A2F0F51(_p0);
				return result;
			}
		}

		public bool _0x8A4416C0DB05FA66(int _p0)
		{
			unsafe {
				if (fn__0x8A4416C0DB05FA66 == null) fn__0x8A4416C0DB05FA66 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x8A4416C0DB05FA66");
				var result = fn__0x8A4416C0DB05FA66(_p0);
				return result;
			}
		}

		public void _0xEA95C0853A27888E()
		{
			unsafe {
				if (fn__0xEA95C0853A27888E == null) fn__0xEA95C0853A27888E = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xEA95C0853A27888E");
				fn__0xEA95C0853A27888E();
			}
		}

		public string ScGetNickname()
		{
			unsafe {
				if (fn__scGetNickname == null) fn__scGetNickname = (delegate* unmanaged[Cdecl]<nint>) NativeLibrary.GetExport(handle, "Native_scGetNickname");
				var result = fn__scGetNickname();
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool _0x225798743970412B(ref int _p0)
		{
			unsafe {
				if (fn__0x225798743970412B == null) fn__0x225798743970412B = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native__0x225798743970412B");
				var ref_p0 = _p0;
				var result = fn__0x225798743970412B(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool ScGetHasAchievementBeenPassed(int _achievementId)
		{
			unsafe {
				if (fn__scGetHasAchievementBeenPassed == null) fn__scGetHasAchievementBeenPassed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_scGetHasAchievementBeenPassed");
				var result = fn__scGetHasAchievementBeenPassed(_achievementId);
				return result;
			}
		}

		public int StatClearSlotForReload(int _statSlot)
		{
			unsafe {
				if (fn__statClearSlotForReload == null) fn__statClearSlotForReload = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_statClearSlotForReload");
				var result = fn__statClearSlotForReload(_statSlot);
				return result;
			}
		}

		public bool StatLoad(int _p0)
		{
			unsafe {
				if (fn__statLoad == null) fn__statLoad = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_statLoad");
				var result = fn__statLoad(_p0);
				return result;
			}
		}

		public bool StatSave(int _p0, bool _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__statSave == null) fn__statSave = (delegate* unmanaged[Cdecl]<int, bool, int, int, bool>) NativeLibrary.GetExport(handle, "Native_statSave");
				var result = fn__statSave(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public void _0x5688585E6D563CD8(int _p0)
		{
			unsafe {
				if (fn__0x5688585E6D563CD8 == null) fn__0x5688585E6D563CD8 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x5688585E6D563CD8");
				fn__0x5688585E6D563CD8(_p0);
			}
		}

		public bool StatLoadPending(int _p0)
		{
			unsafe {
				if (fn__statLoadPending == null) fn__statLoadPending = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_statLoadPending");
				var result = fn__statLoadPending(_p0);
				return result;
			}
		}

		public bool StatSavePending()
		{
			unsafe {
				if (fn__statSavePending == null) fn__statSavePending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_statSavePending");
				var result = fn__statSavePending();
				return result;
			}
		}

		public bool StatSavePendingOrRequested()
		{
			unsafe {
				if (fn__statSavePendingOrRequested == null) fn__statSavePendingOrRequested = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_statSavePendingOrRequested");
				var result = fn__statSavePendingOrRequested();
				return result;
			}
		}

		public int StatDeleteSlot(int _p0)
		{
			unsafe {
				if (fn__statDeleteSlot == null) fn__statDeleteSlot = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_statDeleteSlot");
				var result = fn__statDeleteSlot(_p0);
				return result;
			}
		}

		public bool StatSlotIsLoaded(int _p0)
		{
			unsafe {
				if (fn__statSlotIsLoaded == null) fn__statSlotIsLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_statSlotIsLoaded");
				var result = fn__statSlotIsLoaded(_p0);
				return result;
			}
		}

		public bool _0x7F2C4CDF2E82DF4C(int _p0)
		{
			unsafe {
				if (fn__0x7F2C4CDF2E82DF4C == null) fn__0x7F2C4CDF2E82DF4C = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x7F2C4CDF2E82DF4C");
				var result = fn__0x7F2C4CDF2E82DF4C(_p0);
				return result;
			}
		}

		public int _0xE496A53BA5F50A56(int _p0)
		{
			unsafe {
				if (fn__0xE496A53BA5F50A56 == null) fn__0xE496A53BA5F50A56 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xE496A53BA5F50A56");
				var result = fn__0xE496A53BA5F50A56(_p0);
				return result;
			}
		}

		public void StatSetBlockSaves(bool _toggle)
		{
			unsafe {
				if (fn__statSetBlockSaves == null) fn__statSetBlockSaves = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_statSetBlockSaves");
				fn__statSetBlockSaves(_toggle);
			}
		}

		public bool _0x6A7F19756F1A9016()
		{
			unsafe {
				if (fn__0x6A7F19756F1A9016 == null) fn__0x6A7F19756F1A9016 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x6A7F19756F1A9016");
				var result = fn__0x6A7F19756F1A9016();
				return result;
			}
		}

		public bool _0x7E6946F68A38B74F(int _p0)
		{
			unsafe {
				if (fn__0x7E6946F68A38B74F == null) fn__0x7E6946F68A38B74F = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x7E6946F68A38B74F");
				var result = fn__0x7E6946F68A38B74F(_p0);
				return result;
			}
		}

		public void _0xA8733668D1047B51(int _p0)
		{
			unsafe {
				if (fn__0xA8733668D1047B51 == null) fn__0xA8733668D1047B51 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xA8733668D1047B51");
				fn__0xA8733668D1047B51(_p0);
			}
		}

		public bool _0xECB41AC6AB754401()
		{
			unsafe {
				if (fn__0xECB41AC6AB754401 == null) fn__0xECB41AC6AB754401 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xECB41AC6AB754401");
				var result = fn__0xECB41AC6AB754401();
				return result;
			}
		}

		public void _0x9B4BD21D69B1E609()
		{
			unsafe {
				if (fn__0x9B4BD21D69B1E609 == null) fn__0x9B4BD21D69B1E609 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x9B4BD21D69B1E609");
				fn__0x9B4BD21D69B1E609();
			}
		}

		public int _0xC0E0D686DDFC6EAE()
		{
			unsafe {
				if (fn__0xC0E0D686DDFC6EAE == null) fn__0xC0E0D686DDFC6EAE = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xC0E0D686DDFC6EAE");
				var result = fn__0xC0E0D686DDFC6EAE();
				return result;
			}
		}

		public bool StatSetInt(int _statName, int _value, bool _save)
		{
			unsafe {
				if (fn__statSetInt == null) fn__statSetInt = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetInt");
				var result = fn__statSetInt(_statName, _value, _save);
				return result;
			}
		}

		public bool StatSetFloat(int _statName, float _value, bool _save)
		{
			unsafe {
				if (fn__statSetFloat == null) fn__statSetFloat = (delegate* unmanaged[Cdecl]<int, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetFloat");
				var result = fn__statSetFloat(_statName, _value, _save);
				return result;
			}
		}

		public bool StatSetBool(int _statName, bool _value, bool _save)
		{
			unsafe {
				if (fn__statSetBool == null) fn__statSetBool = (delegate* unmanaged[Cdecl]<int, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetBool");
				var result = fn__statSetBool(_statName, _value, _save);
				return result;
			}
		}

		public bool StatSetGxtLabel(int _statName, string _value, bool _save)
		{
			unsafe {
				if (fn__statSetGxtLabel == null) fn__statSetGxtLabel = (delegate* unmanaged[Cdecl]<int, nint, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetGxtLabel");
				var ptr_value = MemoryUtils.StringToHGlobalUtf8(_value);
				var result = fn__statSetGxtLabel(_statName, ptr_value, _save);
				Marshal.FreeHGlobal(ptr_value);
				return result;
			}
		}

		public bool StatSetDate(int _statName, ref int _value, int _numFields, bool _save)
		{
			unsafe {
				if (fn__statSetDate == null) fn__statSetDate = (delegate* unmanaged[Cdecl]<int, int*, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetDate");
				var ref_value = _value;
				var result = fn__statSetDate(_statName, &ref_value, _numFields, _save);
				_value = ref_value;
				return result;
			}
		}

		public bool StatSetString(int _statName, string _value, bool _save)
		{
			unsafe {
				if (fn__statSetString == null) fn__statSetString = (delegate* unmanaged[Cdecl]<int, nint, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetString");
				var ptr_value = MemoryUtils.StringToHGlobalUtf8(_value);
				var result = fn__statSetString(_statName, ptr_value, _save);
				Marshal.FreeHGlobal(ptr_value);
				return result;
			}
		}

		public bool StatSetPos(int _statName, float _x, float _y, float _z, bool _save)
		{
			unsafe {
				if (fn__statSetPos == null) fn__statSetPos = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetPos");
				var result = fn__statSetPos(_statName, _x, _y, _z, _save);
				return result;
			}
		}

		public bool StatSetMaskedInt(int _statName, int _p1, int _p2, int _p3, bool _save)
		{
			unsafe {
				if (fn__statSetMaskedInt == null) fn__statSetMaskedInt = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetMaskedInt");
				var result = fn__statSetMaskedInt(_statName, _p1, _p2, _p3, _save);
				return result;
			}
		}

		public bool StatSetUserId(int _statName, string _value, bool _save)
		{
			unsafe {
				if (fn__statSetUserId == null) fn__statSetUserId = (delegate* unmanaged[Cdecl]<int, nint, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetUserId");
				var ptr_value = MemoryUtils.StringToHGlobalUtf8(_value);
				var result = fn__statSetUserId(_statName, ptr_value, _save);
				Marshal.FreeHGlobal(ptr_value);
				return result;
			}
		}

		public bool StatSetCurrentPosixTime(int _statName, bool _p1)
		{
			unsafe {
				if (fn__statSetCurrentPosixTime == null) fn__statSetCurrentPosixTime = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetCurrentPosixTime");
				var result = fn__statSetCurrentPosixTime(_statName, _p1);
				return result;
			}
		}

		public bool StatGetInt(int _statHash, ref int _outValue, int _p2)
		{
			unsafe {
				if (fn__statGetInt == null) fn__statGetInt = (delegate* unmanaged[Cdecl]<int, int*, int, bool>) NativeLibrary.GetExport(handle, "Native_statGetInt");
				var ref_outValue = _outValue;
				var result = fn__statGetInt(_statHash, &ref_outValue, _p2);
				_outValue = ref_outValue;
				return result;
			}
		}

		public bool StatGetFloat(int _statHash, ref float _outValue, int _p2)
		{
			unsafe {
				if (fn__statGetFloat == null) fn__statGetFloat = (delegate* unmanaged[Cdecl]<int, float*, int, bool>) NativeLibrary.GetExport(handle, "Native_statGetFloat");
				var ref_outValue = _outValue;
				var result = fn__statGetFloat(_statHash, &ref_outValue, _p2);
				_outValue = ref_outValue;
				return result;
			}
		}

		public bool StatGetBool(int _statHash, ref bool _outValue, int _p2)
		{
			unsafe {
				if (fn__statGetBool == null) fn__statGetBool = (delegate* unmanaged[Cdecl]<int, bool*, int, bool>) NativeLibrary.GetExport(handle, "Native_statGetBool");
				var ref_outValue = _outValue;
				var result = fn__statGetBool(_statHash, &ref_outValue, _p2);
				_outValue = ref_outValue;
				return result;
			}
		}

		public bool StatGetDate(int _statHash, ref int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__statGetDate == null) fn__statGetDate = (delegate* unmanaged[Cdecl]<int, int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_statGetDate");
				var ref_p1 = _p1;
				var result = fn__statGetDate(_statHash, &ref_p1, _p2, _p3);
				_p1 = ref_p1;
				return result;
			}
		}

		public string StatGetString(int _statHash, int _p1)
		{
			unsafe {
				if (fn__statGetString == null) fn__statGetString = (delegate* unmanaged[Cdecl]<int, int, nint>) NativeLibrary.GetExport(handle, "Native_statGetString");
				var result = fn__statGetString(_statHash, _p1);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool StatGetPos(int _p0, ref int _p1, ref int _p2, ref int _p3, int _p4)
		{
			unsafe {
				if (fn__statGetPos == null) fn__statGetPos = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, int, bool>) NativeLibrary.GetExport(handle, "Native_statGetPos");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				var result = fn__statGetPos(_p0, &ref_p1, &ref_p2, &ref_p3, _p4);
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
				return result;
			}
		}

		public bool StatGetMaskedInt(int _p0, ref int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__statGetMaskedInt == null) fn__statGetMaskedInt = (delegate* unmanaged[Cdecl]<int, int*, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_statGetMaskedInt");
				var ref_p1 = _p1;
				var result = fn__statGetMaskedInt(_p0, &ref_p1, _p2, _p3, _p4);
				_p1 = ref_p1;
				return result;
			}
		}

		public string StatGetUserId(int _p0)
		{
			unsafe {
				if (fn__statGetUserId == null) fn__statGetUserId = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_statGetUserId");
				var result = fn__statGetUserId(_p0);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string StatGetLicensePlate(int _statName)
		{
			unsafe {
				if (fn__statGetLicensePlate == null) fn__statGetLicensePlate = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_statGetLicensePlate");
				var result = fn__statGetLicensePlate(_statName);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool StatSetLicensePlate(int _statName, string _str)
		{
			unsafe {
				if (fn__statSetLicensePlate == null) fn__statSetLicensePlate = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_statSetLicensePlate");
				var ptr_str = MemoryUtils.StringToHGlobalUtf8(_str);
				var result = fn__statSetLicensePlate(_statName, ptr_str);
				Marshal.FreeHGlobal(ptr_str);
				return result;
			}
		}

		public void StatIncrement(int _statName, float _value)
		{
			unsafe {
				if (fn__statIncrement == null) fn__statIncrement = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_statIncrement");
				fn__statIncrement(_statName, _value);
			}
		}

		public bool _0x5A556B229A169402()
		{
			unsafe {
				if (fn__0x5A556B229A169402 == null) fn__0x5A556B229A169402 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x5A556B229A169402");
				var result = fn__0x5A556B229A169402();
				return result;
			}
		}

		public bool _0xB1D2BB1E1631F5B1()
		{
			unsafe {
				if (fn__0xB1D2BB1E1631F5B1 == null) fn__0xB1D2BB1E1631F5B1 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xB1D2BB1E1631F5B1");
				var result = fn__0xB1D2BB1E1631F5B1();
				return result;
			}
		}

		public bool _0xBED9F5693F34ED17(int _statName, int _p1, ref float _outValue)
		{
			unsafe {
				if (fn__0xBED9F5693F34ED17 == null) fn__0xBED9F5693F34ED17 = (delegate* unmanaged[Cdecl]<int, int, float*, bool>) NativeLibrary.GetExport(handle, "Native__0xBED9F5693F34ED17");
				var ref_outValue = _outValue;
				var result = fn__0xBED9F5693F34ED17(_statName, _p1, &ref_outValue);
				_outValue = ref_outValue;
				return result;
			}
		}

		public void _0x26D7399B9587FE89(int _p0)
		{
			unsafe {
				if (fn__0x26D7399B9587FE89 == null) fn__0x26D7399B9587FE89 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x26D7399B9587FE89");
				fn__0x26D7399B9587FE89(_p0);
			}
		}

		public void _0xA78B8FA58200DA56(int _p0)
		{
			unsafe {
				if (fn__0xA78B8FA58200DA56 == null) fn__0xA78B8FA58200DA56 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xA78B8FA58200DA56");
				fn__0xA78B8FA58200DA56(_p0);
			}
		}

		public int StatGetNumberOfDays(int _statName)
		{
			unsafe {
				if (fn__statGetNumberOfDays == null) fn__statGetNumberOfDays = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_statGetNumberOfDays");
				var result = fn__statGetNumberOfDays(_statName);
				return result;
			}
		}

		public int StatGetNumberOfHours(int _statName)
		{
			unsafe {
				if (fn__statGetNumberOfHours == null) fn__statGetNumberOfHours = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_statGetNumberOfHours");
				var result = fn__statGetNumberOfHours(_statName);
				return result;
			}
		}

		public int StatGetNumberOfMinutes(int _statName)
		{
			unsafe {
				if (fn__statGetNumberOfMinutes == null) fn__statGetNumberOfMinutes = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_statGetNumberOfMinutes");
				var result = fn__statGetNumberOfMinutes(_statName);
				return result;
			}
		}

		public int StatGetNumberOfSeconds(int _statName)
		{
			unsafe {
				if (fn__statGetNumberOfSeconds == null) fn__statGetNumberOfSeconds = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_statGetNumberOfSeconds");
				var result = fn__statGetNumberOfSeconds(_statName);
				return result;
			}
		}

		public void StatSetProfileSettingValue(int _profileSetting, int _value)
		{
			unsafe {
				if (fn__statSetProfileSettingValue == null) fn__statSetProfileSettingValue = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_statSetProfileSettingValue");
				fn__statSetProfileSettingValue(_profileSetting, _value);
			}
		}

		public void _0xC01D2470F22CDE5A()
		{
			unsafe {
				if (fn__0xC01D2470F22CDE5A == null) fn__0xC01D2470F22CDE5A = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xC01D2470F22CDE5A");
				fn__0xC01D2470F22CDE5A();
			}
		}

		public int StatGetPackedBoolMask(int _p0)
		{
			unsafe {
				if (fn__statGetPackedBoolMask == null) fn__statGetPackedBoolMask = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_statGetPackedBoolMask");
				var result = fn__statGetPackedBoolMask(_p0);
				return result;
			}
		}

		public int StatGetPackedIntMask(int _p0)
		{
			unsafe {
				if (fn__statGetPackedIntMask == null) fn__statGetPackedIntMask = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_statGetPackedIntMask");
				var result = fn__statGetPackedIntMask(_p0);
				return result;
			}
		}

		public int GetPackedBoolStatKey(int _index, bool _spStat, bool _charStat, int _character)
		{
			unsafe {
				if (fn__getPackedBoolStatKey == null) fn__getPackedBoolStatKey = (delegate* unmanaged[Cdecl]<int, bool, bool, int, int>) NativeLibrary.GetExport(handle, "Native_getPackedBoolStatKey");
				var result = fn__getPackedBoolStatKey(_index, _spStat, _charStat, _character);
				return result;
			}
		}

		public int GetPackedIntStatKey(int _index, bool _spStat, bool _charStat, int _character)
		{
			unsafe {
				if (fn__getPackedIntStatKey == null) fn__getPackedIntStatKey = (delegate* unmanaged[Cdecl]<int, bool, bool, int, int>) NativeLibrary.GetExport(handle, "Native_getPackedIntStatKey");
				var result = fn__getPackedIntStatKey(_index, _spStat, _charStat, _character);
				return result;
			}
		}

		public int GetPackedTuBoolStatKey(int _index, bool _spStat, bool _charStat, int _character)
		{
			unsafe {
				if (fn__getPackedTuBoolStatKey == null) fn__getPackedTuBoolStatKey = (delegate* unmanaged[Cdecl]<int, bool, bool, int, int>) NativeLibrary.GetExport(handle, "Native_getPackedTuBoolStatKey");
				var result = fn__getPackedTuBoolStatKey(_index, _spStat, _charStat, _character);
				return result;
			}
		}

		public int GetPackedTuIntStatKey(int _index, bool _spStat, bool _charStat, int _character)
		{
			unsafe {
				if (fn__getPackedTuIntStatKey == null) fn__getPackedTuIntStatKey = (delegate* unmanaged[Cdecl]<int, bool, bool, int, int>) NativeLibrary.GetExport(handle, "Native_getPackedTuIntStatKey");
				var result = fn__getPackedTuIntStatKey(_index, _spStat, _charStat, _character);
				return result;
			}
		}

		public int GetNgstatBoolHash(int _index, bool _spStat, bool _charStat, int _character, string _section)
		{
			unsafe {
				if (fn__getNgstatBoolHash == null) fn__getNgstatBoolHash = (delegate* unmanaged[Cdecl]<int, bool, bool, int, nint, int>) NativeLibrary.GetExport(handle, "Native_getNgstatBoolHash");
				var ptr_section = MemoryUtils.StringToHGlobalUtf8(_section);
				var result = fn__getNgstatBoolHash(_index, _spStat, _charStat, _character, ptr_section);
				Marshal.FreeHGlobal(ptr_section);
				return result;
			}
		}

		public int GetNgstatIntHash(int _index, bool _spStat, bool _charStat, int _character, string _section)
		{
			unsafe {
				if (fn__getNgstatIntHash == null) fn__getNgstatIntHash = (delegate* unmanaged[Cdecl]<int, bool, bool, int, nint, int>) NativeLibrary.GetExport(handle, "Native_getNgstatIntHash");
				var ptr_section = MemoryUtils.StringToHGlobalUtf8(_section);
				var result = fn__getNgstatIntHash(_index, _spStat, _charStat, _character, ptr_section);
				Marshal.FreeHGlobal(ptr_section);
				return result;
			}
		}

		public bool StatGetBoolMasked(int _statName, int _mask, int _p2)
		{
			unsafe {
				if (fn__statGetBoolMasked == null) fn__statGetBoolMasked = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_statGetBoolMasked");
				var result = fn__statGetBoolMasked(_statName, _mask, _p2);
				return result;
			}
		}

		public bool StatSetBoolMasked(int _statName, bool _value, int _mask, bool _save)
		{
			unsafe {
				if (fn__statSetBoolMasked == null) fn__statSetBoolMasked = (delegate* unmanaged[Cdecl]<int, bool, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_statSetBoolMasked");
				var result = fn__statSetBoolMasked(_statName, _value, _mask, _save);
				return result;
			}
		}

		public void PlaystatsBackgroundScriptAction(string _action, int _value)
		{
			unsafe {
				if (fn__playstatsBackgroundScriptAction == null) fn__playstatsBackgroundScriptAction = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsBackgroundScriptAction");
				var ptr_action = MemoryUtils.StringToHGlobalUtf8(_action);
				fn__playstatsBackgroundScriptAction(ptr_action, _value);
				Marshal.FreeHGlobal(ptr_action);
			}
		}

		public void PlaystatsNpcInvite(ref int _p0)
		{
			unsafe {
				if (fn__playstatsNpcInvite == null) fn__playstatsNpcInvite = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsNpcInvite");
				var ref_p0 = _p0;
				fn__playstatsNpcInvite(&ref_p0);
				_p0 = ref_p0;
			}
		}

		public void PlaystatsAwardXp(int _amount, int _type, int _category)
		{
			unsafe {
				if (fn__playstatsAwardXp == null) fn__playstatsAwardXp = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsAwardXp");
				fn__playstatsAwardXp(_amount, _type, _category);
			}
		}

		public void PlaystatsRankUp(int _rank)
		{
			unsafe {
				if (fn__playstatsRankUp == null) fn__playstatsRankUp = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsRankUp");
				fn__playstatsRankUp(_rank);
			}
		}

		public void PlaystatsStartOfflineMode()
		{
			unsafe {
				if (fn__playstatsStartOfflineMode == null) fn__playstatsStartOfflineMode = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_playstatsStartOfflineMode");
				fn__playstatsStartOfflineMode();
			}
		}

		public void PlaystatsActivityDone(int _p0, int _p1)
		{
			unsafe {
				if (fn__playstatsActivityDone == null) fn__playstatsActivityDone = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsActivityDone");
				fn__playstatsActivityDone(_p0, _p1);
			}
		}

		public void PlaystatsLeaveJobChain(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__playstatsLeaveJobChain == null) fn__playstatsLeaveJobChain = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsLeaveJobChain");
				fn__playstatsLeaveJobChain(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void PlaystatsMissionStarted(ref int _p0, int _p1, int _p2, bool _p3)
		{
			unsafe {
				if (fn__playstatsMissionStarted == null) fn__playstatsMissionStarted = (delegate* unmanaged[Cdecl]<int*, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_playstatsMissionStarted");
				var ref_p0 = _p0;
				fn__playstatsMissionStarted(&ref_p0, _p1, _p2, _p3);
				_p0 = ref_p0;
			}
		}

		public void PlaystatsMissionOver(ref int _p0, int _p1, int _p2, bool _p3, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__playstatsMissionOver == null) fn__playstatsMissionOver = (delegate* unmanaged[Cdecl]<int*, int, int, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_playstatsMissionOver");
				var ref_p0 = _p0;
				fn__playstatsMissionOver(&ref_p0, _p1, _p2, _p3, _p4, _p5);
				_p0 = ref_p0;
			}
		}

		public void PlaystatsMissionCheckpoint(ref int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsMissionCheckpoint == null) fn__playstatsMissionCheckpoint = (delegate* unmanaged[Cdecl]<int*, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsMissionCheckpoint");
				var ref_p0 = _p0;
				fn__playstatsMissionCheckpoint(&ref_p0, _p1, _p2, _p3);
				_p0 = ref_p0;
			}
		}

		public void PlaystatsRandomMissionDone(string _name, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsRandomMissionDone == null) fn__playstatsRandomMissionDone = (delegate* unmanaged[Cdecl]<nint, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsRandomMissionDone");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__playstatsRandomMissionDone(ptr_name, _p1, _p2, _p3);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void PlaystatsRosBet(int _amount, int _act, int _player, float _cm)
		{
			unsafe {
				if (fn__playstatsRosBet == null) fn__playstatsRosBet = (delegate* unmanaged[Cdecl]<int, int, int, float, void>) NativeLibrary.GetExport(handle, "Native_playstatsRosBet");
				fn__playstatsRosBet(_amount, _act, _player, _cm);
			}
		}

		public void PlaystatsRaceCheckpoint(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__playstatsRaceCheckpoint == null) fn__playstatsRaceCheckpoint = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsRaceCheckpoint");
				fn__playstatsRaceCheckpoint(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public bool _0x6DEE77AFF8C21BD1(ref int _playerAccountId, ref int _posixTime)
		{
			unsafe {
				if (fn__0x6DEE77AFF8C21BD1 == null) fn__0x6DEE77AFF8C21BD1 = (delegate* unmanaged[Cdecl]<int*, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x6DEE77AFF8C21BD1");
				var ref_playerAccountId = _playerAccountId;
				var ref_posixTime = _posixTime;
				var result = fn__0x6DEE77AFF8C21BD1(&ref_playerAccountId, &ref_posixTime);
				_playerAccountId = ref_playerAccountId;
				_posixTime = ref_posixTime;
				return result;
			}
		}

		public void PlaystatsMatchStarted(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__playstatsMatchStarted == null) fn__playstatsMatchStarted = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsMatchStarted");
				fn__playstatsMatchStarted(_p0, _p1, _p2);
			}
		}

		public void PlaystatsShopItem(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__playstatsShopItem == null) fn__playstatsShopItem = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsShopItem");
				fn__playstatsShopItem(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void PlaystatsCrateDropMissionDone(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7)
		{
			unsafe {
				if (fn__playstatsCrateDropMissionDone == null) fn__playstatsCrateDropMissionDone = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCrateDropMissionDone");
				fn__playstatsCrateDropMissionDone(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
			}
		}

		public void PlaystatsCrateCreatedMissionDone(float _p0, float _p1, float _p2)
		{
			unsafe {
				if (fn__playstatsCrateCreatedMissionDone == null) fn__playstatsCrateCreatedMissionDone = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_playstatsCrateCreatedMissionDone");
				fn__playstatsCrateCreatedMissionDone(_p0, _p1, _p2);
			}
		}

		public void PlaystatsHoldUpMissionDone(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsHoldUpMissionDone == null) fn__playstatsHoldUpMissionDone = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsHoldUpMissionDone");
				fn__playstatsHoldUpMissionDone(_p0, _p1, _p2, _p3);
			}
		}

		public void PlaystatsImportExportMissionDone(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsImportExportMissionDone == null) fn__playstatsImportExportMissionDone = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsImportExportMissionDone");
				fn__playstatsImportExportMissionDone(_p0, _p1, _p2, _p3);
			}
		}

		public void PlaystatsRaceToPointMissionDone(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsRaceToPointMissionDone == null) fn__playstatsRaceToPointMissionDone = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsRaceToPointMissionDone");
				fn__playstatsRaceToPointMissionDone(_p0, _p1, _p2, _p3);
			}
		}

		public void PlaystatsAcquiredHiddenPackage(int _p0)
		{
			unsafe {
				if (fn__playstatsAcquiredHiddenPackage == null) fn__playstatsAcquiredHiddenPackage = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsAcquiredHiddenPackage");
				fn__playstatsAcquiredHiddenPackage(_p0);
			}
		}

		public void PlaystatsWebsiteVisited(int _scaleformHash, int _p1)
		{
			unsafe {
				if (fn__playstatsWebsiteVisited == null) fn__playstatsWebsiteVisited = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsWebsiteVisited");
				fn__playstatsWebsiteVisited(_scaleformHash, _p1);
			}
		}

		public void PlaystatsFriendActivity(int _p0, int _p1)
		{
			unsafe {
				if (fn__playstatsFriendActivity == null) fn__playstatsFriendActivity = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsFriendActivity");
				fn__playstatsFriendActivity(_p0, _p1);
			}
		}

		public void PlaystatsOddjobDone(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__playstatsOddjobDone == null) fn__playstatsOddjobDone = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsOddjobDone");
				fn__playstatsOddjobDone(_p0, _p1, _p2);
			}
		}

		public void PlaystatsPropChange(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsPropChange == null) fn__playstatsPropChange = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsPropChange");
				fn__playstatsPropChange(_p0, _p1, _p2, _p3);
			}
		}

		public void PlaystatsClothChange(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__playstatsClothChange == null) fn__playstatsClothChange = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsClothChange");
				fn__playstatsClothChange(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void PlaystatsWeaponModeChange(int _weaponHash, int _componentHashTo, int _componentHashFrom)
		{
			unsafe {
				if (fn__playstatsWeaponModeChange == null) fn__playstatsWeaponModeChange = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsWeaponModeChange");
				fn__playstatsWeaponModeChange(_weaponHash, _componentHashTo, _componentHashFrom);
			}
		}

		public void PlaystatsCheatApplied(string _cheat)
		{
			unsafe {
				if (fn__playstatsCheatApplied == null) fn__playstatsCheatApplied = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_playstatsCheatApplied");
				var ptr_cheat = MemoryUtils.StringToHGlobalUtf8(_cheat);
				fn__playstatsCheatApplied(ptr_cheat);
				Marshal.FreeHGlobal(ptr_cheat);
			}
		}

		public void _0xF8C54A461C3E11DC(ref int _p0, ref int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__0xF8C54A461C3E11DC == null) fn__0xF8C54A461C3E11DC = (delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native__0xF8C54A461C3E11DC");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				fn__0xF8C54A461C3E11DC(&ref_p0, &ref_p1, &ref_p2, &ref_p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
			}
		}

		public void _0xF5BB8DAC426A52C0(ref int _p0, ref int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__0xF5BB8DAC426A52C0 == null) fn__0xF5BB8DAC426A52C0 = (delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native__0xF5BB8DAC426A52C0");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				fn__0xF5BB8DAC426A52C0(&ref_p0, &ref_p1, &ref_p2, &ref_p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
			}
		}

		public void _0xA736CF7FB7C5BFF4(ref int _p0, ref int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__0xA736CF7FB7C5BFF4 == null) fn__0xA736CF7FB7C5BFF4 = (delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native__0xA736CF7FB7C5BFF4");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				fn__0xA736CF7FB7C5BFF4(&ref_p0, &ref_p1, &ref_p2, &ref_p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
			}
		}

		public void _0x14E0B2D1AD1044E0(ref int _p0, ref int _p1, ref int _p2, ref int _p3)
		{
			unsafe {
				if (fn__0x14E0B2D1AD1044E0 == null) fn__0x14E0B2D1AD1044E0 = (delegate* unmanaged[Cdecl]<int*, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native__0x14E0B2D1AD1044E0");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				fn__0x14E0B2D1AD1044E0(&ref_p0, &ref_p1, &ref_p2, &ref_p3);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
			}
		}

		public void PlaystatsQuickfixTool(int _element, string _item)
		{
			unsafe {
				if (fn__playstatsQuickfixTool == null) fn__playstatsQuickfixTool = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_playstatsQuickfixTool");
				var ptr_item = MemoryUtils.StringToHGlobalUtf8(_item);
				fn__playstatsQuickfixTool(_element, ptr_item);
				Marshal.FreeHGlobal(ptr_item);
			}
		}

		public void PlaystatsIdleKick(int _time)
		{
			unsafe {
				if (fn__playstatsIdleKick == null) fn__playstatsIdleKick = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsIdleKick");
				fn__playstatsIdleKick(_time);
			}
		}

		public void _0xD1032E482629049E(int _p0)
		{
			unsafe {
				if (fn__0xD1032E482629049E == null) fn__0xD1032E482629049E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xD1032E482629049E");
				fn__0xD1032E482629049E(_p0);
			}
		}

		public void PlaystatsHeistSaveCheat(int _hash, int _p1)
		{
			unsafe {
				if (fn__playstatsHeistSaveCheat == null) fn__playstatsHeistSaveCheat = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsHeistSaveCheat");
				fn__playstatsHeistSaveCheat(_hash, _p1);
			}
		}

		public void PlaystatsDirectorMode(ref int _p0)
		{
			unsafe {
				if (fn__playstatsDirectorMode == null) fn__playstatsDirectorMode = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsDirectorMode");
				var ref_p0 = _p0;
				fn__playstatsDirectorMode(&ref_p0);
				_p0 = ref_p0;
			}
		}

		public void PlaystatsAwardBadsport(int _id)
		{
			unsafe {
				if (fn__playstatsAwardBadsport == null) fn__playstatsAwardBadsport = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsAwardBadsport");
				fn__playstatsAwardBadsport(_id);
			}
		}

		public void PlaystatsPegasaircraft(int _modelHash)
		{
			unsafe {
				if (fn__playstatsPegasaircraft == null) fn__playstatsPegasaircraft = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsPegasaircraft");
				fn__playstatsPegasaircraft(_modelHash);
			}
		}

		public void _0x6A60E43998228229(int _p0)
		{
			unsafe {
				if (fn__0x6A60E43998228229 == null) fn__0x6A60E43998228229 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x6A60E43998228229");
				fn__0x6A60E43998228229(_p0);
			}
		}

		public void _0xBFAFDB5FAAA5C5AB(int _p0)
		{
			unsafe {
				if (fn__0xBFAFDB5FAAA5C5AB == null) fn__0xBFAFDB5FAAA5C5AB = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xBFAFDB5FAAA5C5AB");
				fn__0xBFAFDB5FAAA5C5AB(_p0);
			}
		}

		public void _0x8C9D11605E59D955(int _p0)
		{
			unsafe {
				if (fn__0x8C9D11605E59D955 == null) fn__0x8C9D11605E59D955 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x8C9D11605E59D955");
				fn__0x8C9D11605E59D955(_p0);
			}
		}

		public void _0x3DE3AA516FB126A4(int _p0)
		{
			unsafe {
				if (fn__0x3DE3AA516FB126A4 == null) fn__0x3DE3AA516FB126A4 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x3DE3AA516FB126A4");
				fn__0x3DE3AA516FB126A4(_p0);
			}
		}

		public void _0xBAA2F0490E146BE8(int _p0)
		{
			unsafe {
				if (fn__0xBAA2F0490E146BE8 == null) fn__0xBAA2F0490E146BE8 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xBAA2F0490E146BE8");
				fn__0xBAA2F0490E146BE8(_p0);
			}
		}

		public void _0x1A7CE7CD3E653485(int _p0)
		{
			unsafe {
				if (fn__0x1A7CE7CD3E653485 == null) fn__0x1A7CE7CD3E653485 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x1A7CE7CD3E653485");
				fn__0x1A7CE7CD3E653485(_p0);
			}
		}

		public void _0x419615486BBF1956(int _p0)
		{
			unsafe {
				if (fn__0x419615486BBF1956 == null) fn__0x419615486BBF1956 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x419615486BBF1956");
				fn__0x419615486BBF1956(_p0);
			}
		}

		public void _0x84DFC579C2FC214C(int _p0)
		{
			unsafe {
				if (fn__0x84DFC579C2FC214C == null) fn__0x84DFC579C2FC214C = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x84DFC579C2FC214C");
				fn__0x84DFC579C2FC214C(_p0);
			}
		}

		public void _0x0A9C7F36E5D7B683(int _p0)
		{
			unsafe {
				if (fn__0x0A9C7F36E5D7B683 == null) fn__0x0A9C7F36E5D7B683 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x0A9C7F36E5D7B683");
				fn__0x0A9C7F36E5D7B683(_p0);
			}
		}

		public void _0x164C5FF663790845(int _p0)
		{
			unsafe {
				if (fn__0x164C5FF663790845 == null) fn__0x164C5FF663790845 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x164C5FF663790845");
				fn__0x164C5FF663790845(_p0);
			}
		}

		public void _0xEDBF6C9B0D2C65C8(int _p0)
		{
			unsafe {
				if (fn__0xEDBF6C9B0D2C65C8 == null) fn__0xEDBF6C9B0D2C65C8 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xEDBF6C9B0D2C65C8");
				fn__0xEDBF6C9B0D2C65C8(_p0);
			}
		}

		public void _0x6551B1F7F6CD46EA(int _p0)
		{
			unsafe {
				if (fn__0x6551B1F7F6CD46EA == null) fn__0x6551B1F7F6CD46EA = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x6551B1F7F6CD46EA");
				fn__0x6551B1F7F6CD46EA(_p0);
			}
		}

		public void _0x2CD90358F67D0AA8(int _p0)
		{
			unsafe {
				if (fn__0x2CD90358F67D0AA8 == null) fn__0x2CD90358F67D0AA8 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x2CD90358F67D0AA8");
				fn__0x2CD90358F67D0AA8(_p0);
			}
		}

		public void PlaystatsPiMenuHideSettings(ref int _data)
		{
			unsafe {
				if (fn__playstatsPiMenuHideSettings == null) fn__playstatsPiMenuHideSettings = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsPiMenuHideSettings");
				var ref_data = _data;
				fn__playstatsPiMenuHideSettings(&ref_data);
				_data = ref_data;
			}
		}

		public int LeaderboardsGetNumberOfColumns(int _p0, int _p1)
		{
			unsafe {
				if (fn__leaderboardsGetNumberOfColumns == null) fn__leaderboardsGetNumberOfColumns = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_leaderboardsGetNumberOfColumns");
				var result = fn__leaderboardsGetNumberOfColumns(_p0, _p1);
				return result;
			}
		}

		public int LeaderboardsGetColumnId(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__leaderboardsGetColumnId == null) fn__leaderboardsGetColumnId = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_leaderboardsGetColumnId");
				var result = fn__leaderboardsGetColumnId(_p0, _p1, _p2);
				return result;
			}
		}

		public int LeaderboardsGetColumnType(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__leaderboardsGetColumnType == null) fn__leaderboardsGetColumnType = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_leaderboardsGetColumnType");
				var result = fn__leaderboardsGetColumnType(_p0, _p1, _p2);
				return result;
			}
		}

		public int LeaderboardsReadClearAll()
		{
			unsafe {
				if (fn__leaderboardsReadClearAll == null) fn__leaderboardsReadClearAll = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_leaderboardsReadClearAll");
				var result = fn__leaderboardsReadClearAll();
				return result;
			}
		}

		public int LeaderboardsReadClear(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__leaderboardsReadClear == null) fn__leaderboardsReadClear = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_leaderboardsReadClear");
				var result = fn__leaderboardsReadClear(_p0, _p1, _p2);
				return result;
			}
		}

		public bool LeaderboardsReadPending(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__leaderboardsReadPending == null) fn__leaderboardsReadPending = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_leaderboardsReadPending");
				var result = fn__leaderboardsReadPending(_p0, _p1, _p2);
				return result;
			}
		}

		public bool LeaderboardsReadAnyPending()
		{
			unsafe {
				if (fn__leaderboardsReadAnyPending == null) fn__leaderboardsReadAnyPending = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_leaderboardsReadAnyPending");
				var result = fn__leaderboardsReadAnyPending();
				return result;
			}
		}

		public bool LeaderboardsReadSuccessful(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__leaderboardsReadSuccessful == null) fn__leaderboardsReadSuccessful = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_leaderboardsReadSuccessful");
				var result = fn__leaderboardsReadSuccessful(_p0, _p1, _p2);
				return result;
			}
		}

		public bool Leaderboards2ReadFriendsByRow(ref int _p0, ref int _p1, int _p2, bool _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__leaderboards2ReadFriendsByRow == null) fn__leaderboards2ReadFriendsByRow = (delegate* unmanaged[Cdecl]<int*, int*, int, bool, int, int, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2ReadFriendsByRow");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__leaderboards2ReadFriendsByRow(&ref_p0, &ref_p1, _p2, _p3, _p4, _p5);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public bool Leaderboards2ReadByHandle(ref int _p0, ref int _p1)
		{
			unsafe {
				if (fn__leaderboards2ReadByHandle == null) fn__leaderboards2ReadByHandle = (delegate* unmanaged[Cdecl]<int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2ReadByHandle");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__leaderboards2ReadByHandle(&ref_p0, &ref_p1);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public bool Leaderboards2ReadByRow(ref int _p0, ref int _p1, int _p2, ref int _p3, int _p4, ref int _p5, int _p6)
		{
			unsafe {
				if (fn__leaderboards2ReadByRow == null) fn__leaderboards2ReadByRow = (delegate* unmanaged[Cdecl]<int*, int*, int, int*, int, int*, int, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2ReadByRow");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p3 = _p3;
				var ref_p5 = _p5;
				var result = fn__leaderboards2ReadByRow(&ref_p0, &ref_p1, _p2, &ref_p3, _p4, &ref_p5, _p6);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p3 = ref_p3;
				_p5 = ref_p5;
				return result;
			}
		}

		public bool Leaderboards2ReadByRank(ref int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__leaderboards2ReadByRank == null) fn__leaderboards2ReadByRank = (delegate* unmanaged[Cdecl]<int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2ReadByRank");
				var ref_p0 = _p0;
				var result = fn__leaderboards2ReadByRank(&ref_p0, _p1, _p2);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool Leaderboards2ReadByRadius(ref int _p0, int _p1, ref int _p2)
		{
			unsafe {
				if (fn__leaderboards2ReadByRadius == null) fn__leaderboards2ReadByRadius = (delegate* unmanaged[Cdecl]<int*, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2ReadByRadius");
				var ref_p0 = _p0;
				var ref_p2 = _p2;
				var result = fn__leaderboards2ReadByRadius(&ref_p0, _p1, &ref_p2);
				_p0 = ref_p0;
				_p2 = ref_p2;
				return result;
			}
		}

		public bool Leaderboards2ReadByScoreInt(ref int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__leaderboards2ReadByScoreInt == null) fn__leaderboards2ReadByScoreInt = (delegate* unmanaged[Cdecl]<int*, int, int, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2ReadByScoreInt");
				var ref_p0 = _p0;
				var result = fn__leaderboards2ReadByScoreInt(&ref_p0, _p1, _p2);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool Leaderboards2ReadByScoreFloat(ref int _p0, float _p1, int _p2)
		{
			unsafe {
				if (fn__leaderboards2ReadByScoreFloat == null) fn__leaderboards2ReadByScoreFloat = (delegate* unmanaged[Cdecl]<int*, float, int, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2ReadByScoreFloat");
				var ref_p0 = _p0;
				var result = fn__leaderboards2ReadByScoreFloat(&ref_p0, _p1, _p2);
				_p0 = ref_p0;
				return result;
			}
		}

		public bool Leaderboards2ReadRankPrediction(ref int _p0, ref int _p1, ref int _p2)
		{
			unsafe {
				if (fn__leaderboards2ReadRankPrediction == null) fn__leaderboards2ReadRankPrediction = (delegate* unmanaged[Cdecl]<int*, int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2ReadRankPrediction");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var result = fn__leaderboards2ReadRankPrediction(&ref_p0, &ref_p1, &ref_p2);
				_p0 = ref_p0;
				_p1 = ref_p1;
				_p2 = ref_p2;
				return result;
			}
		}

		public bool Leaderboards2ReadByPlatform(ref int _p0, string _gamerHandleCsv, string _platformName)
		{
			unsafe {
				if (fn__leaderboards2ReadByPlatform == null) fn__leaderboards2ReadByPlatform = (delegate* unmanaged[Cdecl]<int*, nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2ReadByPlatform");
				var ref_p0 = _p0;
				var ptr_gamerHandleCsv = MemoryUtils.StringToHGlobalUtf8(_gamerHandleCsv);
				var ptr_platformName = MemoryUtils.StringToHGlobalUtf8(_platformName);
				var result = fn__leaderboards2ReadByPlatform(&ref_p0, ptr_gamerHandleCsv, ptr_platformName);
				_p0 = ref_p0;
				Marshal.FreeHGlobal(ptr_gamerHandleCsv);
				Marshal.FreeHGlobal(ptr_platformName);
				return result;
			}
		}

		public bool _0xA0F93D5465B3094D(ref int _p0)
		{
			unsafe {
				if (fn__0xA0F93D5465B3094D == null) fn__0xA0F93D5465B3094D = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native__0xA0F93D5465B3094D");
				var ref_p0 = _p0;
				var result = fn__0xA0F93D5465B3094D(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public void _0x71B008056E5692D6()
		{
			unsafe {
				if (fn__0x71B008056E5692D6 == null) fn__0x71B008056E5692D6 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x71B008056E5692D6");
				fn__0x71B008056E5692D6();
			}
		}

		public bool _0x34770B9CE0E03B91(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__0x34770B9CE0E03B91 == null) fn__0x34770B9CE0E03B91 = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native__0x34770B9CE0E03B91");
				var ref_p1 = _p1;
				var result = fn__0x34770B9CE0E03B91(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public int _0x88578F6EC36B4A3A(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x88578F6EC36B4A3A == null) fn__0x88578F6EC36B4A3A = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x88578F6EC36B4A3A");
				var result = fn__0x88578F6EC36B4A3A(_p0, _p1);
				return result;
			}
		}

		public float _0x38491439B6BA7F7D(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x38491439B6BA7F7D == null) fn__0x38491439B6BA7F7D = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native__0x38491439B6BA7F7D");
				var result = fn__0x38491439B6BA7F7D(_p0, _p1);
				return result;
			}
		}

		public bool Leaderboards2WriteData(ref int _p0)
		{
			unsafe {
				if (fn__leaderboards2WriteData == null) fn__leaderboards2WriteData = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2WriteData");
				var ref_p0 = _p0;
				var result = fn__leaderboards2WriteData(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public void LeaderboardsWriteAddColumn(int _p0, int _p1, float _p2)
		{
			unsafe {
				if (fn__leaderboardsWriteAddColumn == null) fn__leaderboardsWriteAddColumn = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_leaderboardsWriteAddColumn");
				fn__leaderboardsWriteAddColumn(_p0, _p1, _p2);
			}
		}

		public void LeaderboardsWriteAddColumnLong(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__leaderboardsWriteAddColumnLong == null) fn__leaderboardsWriteAddColumnLong = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_leaderboardsWriteAddColumnLong");
				fn__leaderboardsWriteAddColumnLong(_p0, _p1, _p2);
			}
		}

		public bool LeaderboardsCacheDataRow(ref int _p0)
		{
			unsafe {
				if (fn__leaderboardsCacheDataRow == null) fn__leaderboardsCacheDataRow = (delegate* unmanaged[Cdecl]<int*, bool>) NativeLibrary.GetExport(handle, "Native_leaderboardsCacheDataRow");
				var ref_p0 = _p0;
				var result = fn__leaderboardsCacheDataRow(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public void LeaderboardsClearCacheData()
		{
			unsafe {
				if (fn__leaderboardsClearCacheData == null) fn__leaderboardsClearCacheData = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_leaderboardsClearCacheData");
				fn__leaderboardsClearCacheData();
			}
		}

		public void _0x8EC74CEB042E7CFF(int _p0)
		{
			unsafe {
				if (fn__0x8EC74CEB042E7CFF == null) fn__0x8EC74CEB042E7CFF = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x8EC74CEB042E7CFF");
				fn__0x8EC74CEB042E7CFF(_p0);
			}
		}

		public bool LeaderboardsGetCacheExists(int _p0)
		{
			unsafe {
				if (fn__leaderboardsGetCacheExists == null) fn__leaderboardsGetCacheExists = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_leaderboardsGetCacheExists");
				var result = fn__leaderboardsGetCacheExists(_p0);
				return result;
			}
		}

		public int LeaderboardsGetCacheTime(int _p0)
		{
			unsafe {
				if (fn__leaderboardsGetCacheTime == null) fn__leaderboardsGetCacheTime = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_leaderboardsGetCacheTime");
				var result = fn__leaderboardsGetCacheTime(_p0);
				return result;
			}
		}

		public int LeaderboardsGetCacheNumberOfRows(int _p0)
		{
			unsafe {
				if (fn__leaderboardsGetCacheNumberOfRows == null) fn__leaderboardsGetCacheNumberOfRows = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_leaderboardsGetCacheNumberOfRows");
				var result = fn__leaderboardsGetCacheNumberOfRows(_p0);
				return result;
			}
		}

		public bool LeaderboardsGetCacheDataRow(int _p0, int _p1, ref int _p2)
		{
			unsafe {
				if (fn__leaderboardsGetCacheDataRow == null) fn__leaderboardsGetCacheDataRow = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_leaderboardsGetCacheDataRow");
				var ref_p2 = _p2;
				var result = fn__leaderboardsGetCacheDataRow(_p0, _p1, &ref_p2);
				_p2 = ref_p2;
				return result;
			}
		}

		public void UpdateStatInt(int _statHash, int _value, int _p2)
		{
			unsafe {
				if (fn__updateStatInt == null) fn__updateStatInt = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_updateStatInt");
				fn__updateStatInt(_statHash, _value, _p2);
			}
		}

		public void UpdateStatFloat(int _statHash, float _value, int _p2)
		{
			unsafe {
				if (fn__updateStatFloat == null) fn__updateStatFloat = (delegate* unmanaged[Cdecl]<int, float, int, void>) NativeLibrary.GetExport(handle, "Native_updateStatFloat");
				fn__updateStatFloat(_statHash, _value, _p2);
			}
		}

		public void _0x6483C25849031C4F(int _p0, int _p1, int _p2, ref int _p3)
		{
			unsafe {
				if (fn__0x6483C25849031C4F == null) fn__0x6483C25849031C4F = (delegate* unmanaged[Cdecl]<int, int, int, int*, void>) NativeLibrary.GetExport(handle, "Native__0x6483C25849031C4F");
				var ref_p3 = _p3;
				fn__0x6483C25849031C4F(_p0, _p1, _p2, &ref_p3);
				_p3 = ref_p3;
			}
		}

		public bool _0x5EAD2BF6484852E4()
		{
			unsafe {
				if (fn__0x5EAD2BF6484852E4 == null) fn__0x5EAD2BF6484852E4 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x5EAD2BF6484852E4");
				var result = fn__0x5EAD2BF6484852E4();
				return result;
			}
		}

		public void _0xC141B8917E0017EC()
		{
			unsafe {
				if (fn__0xC141B8917E0017EC == null) fn__0xC141B8917E0017EC = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xC141B8917E0017EC");
				fn__0xC141B8917E0017EC();
			}
		}

		public void SetProfileSettingPrologueComplete()
		{
			unsafe {
				if (fn__setProfileSettingPrologueComplete == null) fn__setProfileSettingPrologueComplete = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setProfileSettingPrologueComplete");
				fn__setProfileSettingPrologueComplete();
			}
		}

		public void _0xC67E2DA1CBE759E2()
		{
			unsafe {
				if (fn__0xC67E2DA1CBE759E2 == null) fn__0xC67E2DA1CBE759E2 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xC67E2DA1CBE759E2");
				fn__0xC67E2DA1CBE759E2();
			}
		}

		public void _0xF1A1803D3476F215(int _value)
		{
			unsafe {
				if (fn__0xF1A1803D3476F215 == null) fn__0xF1A1803D3476F215 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xF1A1803D3476F215");
				fn__0xF1A1803D3476F215(_value);
			}
		}

		public void _0x38BAAA5DD4C9D19F(int _value)
		{
			unsafe {
				if (fn__0x38BAAA5DD4C9D19F == null) fn__0x38BAAA5DD4C9D19F = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x38BAAA5DD4C9D19F");
				fn__0x38BAAA5DD4C9D19F(_value);
			}
		}

		public void _0x55384438FC55AD8E(int _value)
		{
			unsafe {
				if (fn__0x55384438FC55AD8E == null) fn__0x55384438FC55AD8E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x55384438FC55AD8E");
				fn__0x55384438FC55AD8E(_value);
			}
		}

		public void _0x723C1CE13FBFDB67(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x723C1CE13FBFDB67 == null) fn__0x723C1CE13FBFDB67 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x723C1CE13FBFDB67");
				fn__0x723C1CE13FBFDB67(_p0, _p1);
			}
		}

		public void _0x0D01D20616FC73FB(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x0D01D20616FC73FB == null) fn__0x0D01D20616FC73FB = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0D01D20616FC73FB");
				fn__0x0D01D20616FC73FB(_p0, _p1);
			}
		}

		public void _0x428EAF89E24F6C36(int _p0, float _p1)
		{
			unsafe {
				if (fn__0x428EAF89E24F6C36 == null) fn__0x428EAF89E24F6C36 = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x428EAF89E24F6C36");
				fn__0x428EAF89E24F6C36(_p0, _p1);
			}
		}

		public void StatSetCheatIsActive()
		{
			unsafe {
				if (fn__statSetCheatIsActive == null) fn__statSetCheatIsActive = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_statSetCheatIsActive");
				fn__statSetCheatIsActive();
			}
		}

		public bool Leaderboards2WriteDataForEventType(ref int _p0, ref int _p1)
		{
			unsafe {
				if (fn__leaderboards2WriteDataForEventType == null) fn__leaderboards2WriteDataForEventType = (delegate* unmanaged[Cdecl]<int*, int*, bool>) NativeLibrary.GetExport(handle, "Native_leaderboards2WriteDataForEventType");
				var ref_p0 = _p0;
				var ref_p1 = _p1;
				var result = fn__leaderboards2WriteDataForEventType(&ref_p0, &ref_p1);
				_p0 = ref_p0;
				_p1 = ref_p1;
				return result;
			}
		}

		public void _0x6F361B8889A792A3()
		{
			unsafe {
				if (fn__0x6F361B8889A792A3 == null) fn__0x6F361B8889A792A3 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x6F361B8889A792A3");
				fn__0x6F361B8889A792A3();
			}
		}

		public void _0xC847B43F369AC0B5()
		{
			unsafe {
				if (fn__0xC847B43F369AC0B5 == null) fn__0xC847B43F369AC0B5 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xC847B43F369AC0B5");
				fn__0xC847B43F369AC0B5();
			}
		}

		public bool StatMigrateSave(string _platformName)
		{
			unsafe {
				if (fn__statMigrateSave == null) fn__statMigrateSave = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_statMigrateSave");
				var ptr_platformName = MemoryUtils.StringToHGlobalUtf8(_platformName);
				var result = fn__statMigrateSave(ptr_platformName);
				Marshal.FreeHGlobal(ptr_platformName);
				return result;
			}
		}

		public int _0x9A62EC95AE10E011()
		{
			unsafe {
				if (fn__0x9A62EC95AE10E011 == null) fn__0x9A62EC95AE10E011 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x9A62EC95AE10E011");
				var result = fn__0x9A62EC95AE10E011();
				return result;
			}
		}

		public int _0x4C89FE2BDEB3F169()
		{
			unsafe {
				if (fn__0x4C89FE2BDEB3F169 == null) fn__0x4C89FE2BDEB3F169 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x4C89FE2BDEB3F169");
				var result = fn__0x4C89FE2BDEB3F169();
				return result;
			}
		}

		public int _0xC6E0E2616A7576BB()
		{
			unsafe {
				if (fn__0xC6E0E2616A7576BB == null) fn__0xC6E0E2616A7576BB = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xC6E0E2616A7576BB");
				var result = fn__0xC6E0E2616A7576BB();
				return result;
			}
		}

		public int _0x5BD5F255321C4AAF(int _p0)
		{
			unsafe {
				if (fn__0x5BD5F255321C4AAF == null) fn__0x5BD5F255321C4AAF = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x5BD5F255321C4AAF");
				var result = fn__0x5BD5F255321C4AAF(_p0);
				return result;
			}
		}

		public int _0xDEAAF77EB3687E97(int _p0, ref int _p1)
		{
			unsafe {
				if (fn__0xDEAAF77EB3687E97 == null) fn__0xDEAAF77EB3687E97 = (delegate* unmanaged[Cdecl]<int, int*, int>) NativeLibrary.GetExport(handle, "Native__0xDEAAF77EB3687E97");
				var ref_p1 = _p1;
				var result = fn__0xDEAAF77EB3687E97(_p0, &ref_p1);
				_p1 = ref_p1;
				return result;
			}
		}

		public int StatGetSaveMigrationStatus(ref int _data)
		{
			unsafe {
				if (fn__statGetSaveMigrationStatus == null) fn__statGetSaveMigrationStatus = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_statGetSaveMigrationStatus");
				var ref_data = _data;
				var result = fn__statGetSaveMigrationStatus(&ref_data);
				_data = ref_data;
				return result;
			}
		}

		public bool StatSaveMigrationCancel()
		{
			unsafe {
				if (fn__statSaveMigrationCancel == null) fn__statSaveMigrationCancel = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_statSaveMigrationCancel");
				var result = fn__statSaveMigrationCancel();
				return result;
			}
		}

		public int StatGetCancelSaveMigrationStatus()
		{
			unsafe {
				if (fn__statGetCancelSaveMigrationStatus == null) fn__statGetCancelSaveMigrationStatus = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_statGetCancelSaveMigrationStatus");
				var result = fn__statGetCancelSaveMigrationStatus();
				return result;
			}
		}

		public bool StatSaveMigrationConsumeContentUnlock(int _contentId, string _srcPlatform, string _srcGamerHandle)
		{
			unsafe {
				if (fn__statSaveMigrationConsumeContentUnlock == null) fn__statSaveMigrationConsumeContentUnlock = (delegate* unmanaged[Cdecl]<int, nint, nint, bool>) NativeLibrary.GetExport(handle, "Native_statSaveMigrationConsumeContentUnlock");
				var ptr_srcPlatform = MemoryUtils.StringToHGlobalUtf8(_srcPlatform);
				var ptr_srcGamerHandle = MemoryUtils.StringToHGlobalUtf8(_srcGamerHandle);
				var result = fn__statSaveMigrationConsumeContentUnlock(_contentId, ptr_srcPlatform, ptr_srcGamerHandle);
				Marshal.FreeHGlobal(ptr_srcPlatform);
				Marshal.FreeHGlobal(ptr_srcGamerHandle);
				return result;
			}
		}

		public int StatGetSaveMigrationConsumeContentUnlockStatus(ref int _p0)
		{
			unsafe {
				if (fn__statGetSaveMigrationConsumeContentUnlockStatus == null) fn__statGetSaveMigrationConsumeContentUnlockStatus = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_statGetSaveMigrationConsumeContentUnlockStatus");
				var ref_p0 = _p0;
				var result = fn__statGetSaveMigrationConsumeContentUnlockStatus(&ref_p0);
				_p0 = ref_p0;
				return result;
			}
		}

		public void _0x98E2BC1CA26287C3()
		{
			unsafe {
				if (fn__0x98E2BC1CA26287C3 == null) fn__0x98E2BC1CA26287C3 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x98E2BC1CA26287C3");
				fn__0x98E2BC1CA26287C3();
			}
		}

		public void _0x629526ABA383BCAA()
		{
			unsafe {
				if (fn__0x629526ABA383BCAA == null) fn__0x629526ABA383BCAA = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x629526ABA383BCAA");
				fn__0x629526ABA383BCAA();
			}
		}

		public int _0xBE3DB208333D9844()
		{
			unsafe {
				if (fn__0xBE3DB208333D9844 == null) fn__0xBE3DB208333D9844 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xBE3DB208333D9844");
				var result = fn__0xBE3DB208333D9844();
				return result;
			}
		}

		public int _0x33D72899E24C3365(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x33D72899E24C3365 == null) fn__0x33D72899E24C3365 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x33D72899E24C3365");
				var result = fn__0x33D72899E24C3365(_p0, _p1);
				return result;
			}
		}

		public int _0xA761D4AC6115623D()
		{
			unsafe {
				if (fn__0xA761D4AC6115623D == null) fn__0xA761D4AC6115623D = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xA761D4AC6115623D");
				var result = fn__0xA761D4AC6115623D();
				return result;
			}
		}

		public int _0xF11F01D98113536A(int _p0)
		{
			unsafe {
				if (fn__0xF11F01D98113536A == null) fn__0xF11F01D98113536A = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xF11F01D98113536A");
				var result = fn__0xF11F01D98113536A(_p0);
				return result;
			}
		}

		public int _0x8B9CDBD6C566C38C()
		{
			unsafe {
				if (fn__0x8B9CDBD6C566C38C == null) fn__0x8B9CDBD6C566C38C = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x8B9CDBD6C566C38C");
				var result = fn__0x8B9CDBD6C566C38C();
				return result;
			}
		}

		public int _0xE8853FBCE7D8D0D6()
		{
			unsafe {
				if (fn__0xE8853FBCE7D8D0D6 == null) fn__0xE8853FBCE7D8D0D6 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xE8853FBCE7D8D0D6");
				var result = fn__0xE8853FBCE7D8D0D6();
				return result;
			}
		}

		public int _0xA943FD1722E11EFD()
		{
			unsafe {
				if (fn__0xA943FD1722E11EFD == null) fn__0xA943FD1722E11EFD = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xA943FD1722E11EFD");
				var result = fn__0xA943FD1722E11EFD();
				return result;
			}
		}

		public int _0x84A810B375E69C0E()
		{
			unsafe {
				if (fn__0x84A810B375E69C0E == null) fn__0x84A810B375E69C0E = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x84A810B375E69C0E");
				var result = fn__0x84A810B375E69C0E();
				return result;
			}
		}

		public int _0x9EC8858184CD253A()
		{
			unsafe {
				if (fn__0x9EC8858184CD253A == null) fn__0x9EC8858184CD253A = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x9EC8858184CD253A");
				var result = fn__0x9EC8858184CD253A();
				return result;
			}
		}

		public int _0xBA9749CC94C1FD85()
		{
			unsafe {
				if (fn__0xBA9749CC94C1FD85 == null) fn__0xBA9749CC94C1FD85 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xBA9749CC94C1FD85");
				var result = fn__0xBA9749CC94C1FD85();
				return result;
			}
		}

		public int _0x55A8BECAF28A4EB7()
		{
			unsafe {
				if (fn__0x55A8BECAF28A4EB7 == null) fn__0x55A8BECAF28A4EB7 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x55A8BECAF28A4EB7");
				var result = fn__0x55A8BECAF28A4EB7();
				return result;
			}
		}

		public int _0x32CAC93C9DE73D32()
		{
			unsafe {
				if (fn__0x32CAC93C9DE73D32 == null) fn__0x32CAC93C9DE73D32 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x32CAC93C9DE73D32");
				var result = fn__0x32CAC93C9DE73D32();
				return result;
			}
		}

		public int _0xAFF47709F1D5DCCE()
		{
			unsafe {
				if (fn__0xAFF47709F1D5DCCE == null) fn__0xAFF47709F1D5DCCE = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xAFF47709F1D5DCCE");
				var result = fn__0xAFF47709F1D5DCCE();
				return result;
			}
		}

		public int _0x6E0A5253375C4584()
		{
			unsafe {
				if (fn__0x6E0A5253375C4584 == null) fn__0x6E0A5253375C4584 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x6E0A5253375C4584");
				var result = fn__0x6E0A5253375C4584();
				return result;
			}
		}

		public int _0x1A8EA222F9C67DBB(int _p0)
		{
			unsafe {
				if (fn__0x1A8EA222F9C67DBB == null) fn__0x1A8EA222F9C67DBB = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x1A8EA222F9C67DBB");
				var result = fn__0x1A8EA222F9C67DBB(_p0);
				return result;
			}
		}

		public int _0xF9F2922717B819EC()
		{
			unsafe {
				if (fn__0xF9F2922717B819EC == null) fn__0xF9F2922717B819EC = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0xF9F2922717B819EC");
				var result = fn__0xF9F2922717B819EC();
				return result;
			}
		}

		public int _0x0B8B7F74BF061C6D()
		{
			unsafe {
				if (fn__0x0B8B7F74BF061C6D == null) fn__0x0B8B7F74BF061C6D = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x0B8B7F74BF061C6D");
				var result = fn__0x0B8B7F74BF061C6D();
				return result;
			}
		}

		public bool _0xB3DA2606774A8E2D()
		{
			unsafe {
				if (fn__0xB3DA2606774A8E2D == null) fn__0xB3DA2606774A8E2D = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xB3DA2606774A8E2D");
				var result = fn__0xB3DA2606774A8E2D();
				return result;
			}
		}

		public void SetHasContentUnlocksFlags(int _value)
		{
			unsafe {
				if (fn__setHasContentUnlocksFlags == null) fn__setHasContentUnlocksFlags = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setHasContentUnlocksFlags");
				fn__setHasContentUnlocksFlags(_value);
			}
		}

		public void SetSaveMigrationTransactionId(int _transactionId)
		{
			unsafe {
				if (fn__setSaveMigrationTransactionId == null) fn__setSaveMigrationTransactionId = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setSaveMigrationTransactionId");
				fn__setSaveMigrationTransactionId(_transactionId);
			}
		}

		public void _0x6BC0ACD0673ACEBE(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x6BC0ACD0673ACEBE == null) fn__0x6BC0ACD0673ACEBE = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x6BC0ACD0673ACEBE");
				fn__0x6BC0ACD0673ACEBE(_p0, _p1, _p2);
			}
		}

		public void _0x8D8ADB562F09A245(int _p0)
		{
			unsafe {
				if (fn__0x8D8ADB562F09A245 == null) fn__0x8D8ADB562F09A245 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x8D8ADB562F09A245");
				fn__0x8D8ADB562F09A245(_p0);
			}
		}

		public void _0xD1A1EE3B4FA8E760(int _p0)
		{
			unsafe {
				if (fn__0xD1A1EE3B4FA8E760 == null) fn__0xD1A1EE3B4FA8E760 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xD1A1EE3B4FA8E760");
				fn__0xD1A1EE3B4FA8E760(_p0);
			}
		}

		public void _0x88087EE1F28024AE(int _p0)
		{
			unsafe {
				if (fn__0x88087EE1F28024AE == null) fn__0x88087EE1F28024AE = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x88087EE1F28024AE");
				fn__0x88087EE1F28024AE(_p0);
			}
		}

		public void _0xFCC228E07217FCAC(int _p0)
		{
			unsafe {
				if (fn__0xFCC228E07217FCAC == null) fn__0xFCC228E07217FCAC = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xFCC228E07217FCAC");
				fn__0xFCC228E07217FCAC(_p0);
			}
		}

		public void _0x678F86D8FC040BDB(int _p0)
		{
			unsafe {
				if (fn__0x678F86D8FC040BDB == null) fn__0x678F86D8FC040BDB = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x678F86D8FC040BDB");
				fn__0x678F86D8FC040BDB(_p0);
			}
		}

		public void _0xA6F54BB2FFCA35EA(int _p0)
		{
			unsafe {
				if (fn__0xA6F54BB2FFCA35EA == null) fn__0xA6F54BB2FFCA35EA = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xA6F54BB2FFCA35EA");
				fn__0xA6F54BB2FFCA35EA(_p0);
			}
		}

		public void _0x5FF2C33B13A02A11(int _p0)
		{
			unsafe {
				if (fn__0x5FF2C33B13A02A11 == null) fn__0x5FF2C33B13A02A11 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x5FF2C33B13A02A11");
				fn__0x5FF2C33B13A02A11(_p0);
			}
		}

		public void _0x282B6739644F4347(int _p0)
		{
			unsafe {
				if (fn__0x282B6739644F4347 == null) fn__0x282B6739644F4347 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x282B6739644F4347");
				fn__0x282B6739644F4347(_p0);
			}
		}

		public void _0xF06A6F41CB445443(int _p0)
		{
			unsafe {
				if (fn__0xF06A6F41CB445443 == null) fn__0xF06A6F41CB445443 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xF06A6F41CB445443");
				fn__0xF06A6F41CB445443(_p0);
			}
		}

		public void _0x7B18DA61F6BAE9D5(int _p0)
		{
			unsafe {
				if (fn__0x7B18DA61F6BAE9D5 == null) fn__0x7B18DA61F6BAE9D5 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x7B18DA61F6BAE9D5");
				fn__0x7B18DA61F6BAE9D5(_p0);
			}
		}

		public void _0x06EAF70AE066441E(int _p0)
		{
			unsafe {
				if (fn__0x06EAF70AE066441E == null) fn__0x06EAF70AE066441E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x06EAF70AE066441E");
				fn__0x06EAF70AE066441E(_p0);
			}
		}

		public void _0x14EDA9EE27BD1626(int _p0)
		{
			unsafe {
				if (fn__0x14EDA9EE27BD1626 == null) fn__0x14EDA9EE27BD1626 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x14EDA9EE27BD1626");
				fn__0x14EDA9EE27BD1626(_p0);
			}
		}

		public void _0x930F504203F561C9(int _p0)
		{
			unsafe {
				if (fn__0x930F504203F561C9 == null) fn__0x930F504203F561C9 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x930F504203F561C9");
				fn__0x930F504203F561C9(_p0);
			}
		}

		public void _0xE3261D791EB44ACB(int _p0)
		{
			unsafe {
				if (fn__0xE3261D791EB44ACB == null) fn__0xE3261D791EB44ACB = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xE3261D791EB44ACB");
				fn__0xE3261D791EB44ACB(_p0);
			}
		}

		public void _0x73001E34F85137F8(int _p0)
		{
			unsafe {
				if (fn__0x73001E34F85137F8 == null) fn__0x73001E34F85137F8 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x73001E34F85137F8");
				fn__0x73001E34F85137F8(_p0);
			}
		}

		public void _0x53CAE13E9B426993(int _p0)
		{
			unsafe {
				if (fn__0x53CAE13E9B426993 == null) fn__0x53CAE13E9B426993 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x53CAE13E9B426993");
				fn__0x53CAE13E9B426993(_p0);
			}
		}

		public void _0x7D36291161859389(int _p0)
		{
			unsafe {
				if (fn__0x7D36291161859389 == null) fn__0x7D36291161859389 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x7D36291161859389");
				fn__0x7D36291161859389(_p0);
			}
		}

		public void PlaystatsSpentPiCustomLoadout(int _amount)
		{
			unsafe {
				if (fn__playstatsSpentPiCustomLoadout == null) fn__playstatsSpentPiCustomLoadout = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsSpentPiCustomLoadout");
				fn__playstatsSpentPiCustomLoadout(_amount);
			}
		}

		public void PlaystatsBuyContraband(ref int _data)
		{
			unsafe {
				if (fn__playstatsBuyContraband == null) fn__playstatsBuyContraband = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsBuyContraband");
				var ref_data = _data;
				fn__playstatsBuyContraband(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsSellContraband(ref int _data)
		{
			unsafe {
				if (fn__playstatsSellContraband == null) fn__playstatsSellContraband = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsSellContraband");
				var ref_data = _data;
				fn__playstatsSellContraband(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsDefendContraband(ref int _data)
		{
			unsafe {
				if (fn__playstatsDefendContraband == null) fn__playstatsDefendContraband = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsDefendContraband");
				var ref_data = _data;
				fn__playstatsDefendContraband(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsRecoverContraband(ref int _data)
		{
			unsafe {
				if (fn__playstatsRecoverContraband == null) fn__playstatsRecoverContraband = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsRecoverContraband");
				var ref_data = _data;
				fn__playstatsRecoverContraband(&ref_data);
				_data = ref_data;
			}
		}

		public void _0x60EEDC12AF66E846(int _p0)
		{
			unsafe {
				if (fn__0x60EEDC12AF66E846 == null) fn__0x60EEDC12AF66E846 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x60EEDC12AF66E846");
				fn__0x60EEDC12AF66E846(_p0);
			}
		}

		public void _0x3EBEAC6C3F81F6BD(int _p0)
		{
			unsafe {
				if (fn__0x3EBEAC6C3F81F6BD == null) fn__0x3EBEAC6C3F81F6BD = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x3EBEAC6C3F81F6BD");
				fn__0x3EBEAC6C3F81F6BD(_p0);
			}
		}

		public void _0x96E6D5150DBF1C09(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x96E6D5150DBF1C09 == null) fn__0x96E6D5150DBF1C09 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x96E6D5150DBF1C09");
				fn__0x96E6D5150DBF1C09(_p0, _p1, _p2);
			}
		}

		public void _0xA3C53804BDB68ED2(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xA3C53804BDB68ED2 == null) fn__0xA3C53804BDB68ED2 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xA3C53804BDB68ED2");
				fn__0xA3C53804BDB68ED2(_p0, _p1);
			}
		}

		public void _0x6BCCF9948492FD85(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0x6BCCF9948492FD85 == null) fn__0x6BCCF9948492FD85 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x6BCCF9948492FD85");
				fn__0x6BCCF9948492FD85(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void HiredLimo(int _p0, int _p1)
		{
			unsafe {
				if (fn__hiredLimo == null) fn__hiredLimo = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_hiredLimo");
				fn__hiredLimo(_p0, _p1);
			}
		}

		public void OrderedBossVehicle(int _p0, int _p1, int _vehicleHash)
		{
			unsafe {
				if (fn__orderedBossVehicle == null) fn__orderedBossVehicle = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_orderedBossVehicle");
				fn__orderedBossVehicle(_p0, _p1, _vehicleHash);
			}
		}

		public void _0xD1C9B92BDD3F151D(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xD1C9B92BDD3F151D == null) fn__0xD1C9B92BDD3F151D = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xD1C9B92BDD3F151D");
				fn__0xD1C9B92BDD3F151D(_p0, _p1, _p2);
			}
		}

		public void _0x44919CC079BB60BF(int _p0)
		{
			unsafe {
				if (fn__0x44919CC079BB60BF == null) fn__0x44919CC079BB60BF = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x44919CC079BB60BF");
				fn__0x44919CC079BB60BF(_p0);
			}
		}

		public void _0x7033EEFD9B28088E(int _p0)
		{
			unsafe {
				if (fn__0x7033EEFD9B28088E == null) fn__0x7033EEFD9B28088E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x7033EEFD9B28088E");
				fn__0x7033EEFD9B28088E(_p0);
			}
		}

		public void _0xAA525DFF66BB82F5(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xAA525DFF66BB82F5 == null) fn__0xAA525DFF66BB82F5 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xAA525DFF66BB82F5");
				fn__0xAA525DFF66BB82F5(_p0, _p1, _p2);
			}
		}

		public void _0x015B03EE1C43E6EC(int _p0)
		{
			unsafe {
				if (fn__0x015B03EE1C43E6EC == null) fn__0x015B03EE1C43E6EC = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x015B03EE1C43E6EC");
				fn__0x015B03EE1C43E6EC(_p0);
			}
		}

		public void PlaystatsStuntPerformedEventAllowTrigger()
		{
			unsafe {
				if (fn__playstatsStuntPerformedEventAllowTrigger == null) fn__playstatsStuntPerformedEventAllowTrigger = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_playstatsStuntPerformedEventAllowTrigger");
				fn__playstatsStuntPerformedEventAllowTrigger();
			}
		}

		public void PlaystatsStuntPerformedEventDisallowTrigger()
		{
			unsafe {
				if (fn__playstatsStuntPerformedEventDisallowTrigger == null) fn__playstatsStuntPerformedEventDisallowTrigger = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_playstatsStuntPerformedEventDisallowTrigger");
				fn__playstatsStuntPerformedEventDisallowTrigger();
			}
		}

		public void _0xBF371CD2B64212FD(int _p0)
		{
			unsafe {
				if (fn__0xBF371CD2B64212FD == null) fn__0xBF371CD2B64212FD = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xBF371CD2B64212FD");
				fn__0xBF371CD2B64212FD(_p0);
			}
		}

		public void _0x7D8BA05688AD64C7(int _p0)
		{
			unsafe {
				if (fn__0x7D8BA05688AD64C7 == null) fn__0x7D8BA05688AD64C7 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x7D8BA05688AD64C7");
				fn__0x7D8BA05688AD64C7(_p0);
			}
		}

		public void _0x0B565B0AAE56A0E8(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__0x0B565B0AAE56A0E8 == null) fn__0x0B565B0AAE56A0E8 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0B565B0AAE56A0E8");
				fn__0x0B565B0AAE56A0E8(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void _0x28ECB8AC2F607DB2(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0x28ECB8AC2F607DB2 == null) fn__0x28ECB8AC2F607DB2 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x28ECB8AC2F607DB2");
				fn__0x28ECB8AC2F607DB2(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void PlaystatsChangeMcEmblem(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__playstatsChangeMcEmblem == null) fn__playstatsChangeMcEmblem = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsChangeMcEmblem");
				fn__playstatsChangeMcEmblem(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void _0xCC25A4553DFBF9EA(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0xCC25A4553DFBF9EA == null) fn__0xCC25A4553DFBF9EA = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xCC25A4553DFBF9EA");
				fn__0xCC25A4553DFBF9EA(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void _0xF534D94DFA2EAD26(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0xF534D94DFA2EAD26 == null) fn__0xF534D94DFA2EAD26 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xF534D94DFA2EAD26");
				fn__0xF534D94DFA2EAD26(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void _0xD558BEC0BBA7E8D2(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0xD558BEC0BBA7E8D2 == null) fn__0xD558BEC0BBA7E8D2 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xD558BEC0BBA7E8D2");
				fn__0xD558BEC0BBA7E8D2(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void PlaystatsEarnedMcPoints(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__playstatsEarnedMcPoints == null) fn__playstatsEarnedMcPoints = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsEarnedMcPoints");
				fn__playstatsEarnedMcPoints(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void _0x03C2EEBB04B3FB72(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__0x03C2EEBB04B3FB72 == null) fn__0x03C2EEBB04B3FB72 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x03C2EEBB04B3FB72");
				fn__0x03C2EEBB04B3FB72(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void _0x8989CBD7B4E82534(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__0x8989CBD7B4E82534 == null) fn__0x8989CBD7B4E82534 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x8989CBD7B4E82534");
				fn__0x8989CBD7B4E82534(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void _0x27AA1C973CACFE63(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__0x27AA1C973CACFE63 == null) fn__0x27AA1C973CACFE63 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x27AA1C973CACFE63");
				fn__0x27AA1C973CACFE63(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void PlaystatsCopyRankIntoNewSlot(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__playstatsCopyRankIntoNewSlot == null) fn__playstatsCopyRankIntoNewSlot = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCopyRankIntoNewSlot");
				fn__playstatsCopyRankIntoNewSlot(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void PlaystatsDupeDetection(ref int _data)
		{
			unsafe {
				if (fn__playstatsDupeDetection == null) fn__playstatsDupeDetection = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsDupeDetection");
				var ref_data = _data;
				fn__playstatsDupeDetection(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsBanAlert(int _p0)
		{
			unsafe {
				if (fn__playstatsBanAlert == null) fn__playstatsBanAlert = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsBanAlert");
				fn__playstatsBanAlert(_p0);
			}
		}

		public void PlaystatsGunrunMissionEnded(ref int _data)
		{
			unsafe {
				if (fn__playstatsGunrunMissionEnded == null) fn__playstatsGunrunMissionEnded = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsGunrunMissionEnded");
				var ref_data = _data;
				fn__playstatsGunrunMissionEnded(&ref_data);
				_data = ref_data;
			}
		}

		public void _0xDAF80797FC534BEC(int _p0)
		{
			unsafe {
				if (fn__0xDAF80797FC534BEC == null) fn__0xDAF80797FC534BEC = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xDAF80797FC534BEC");
				fn__0xDAF80797FC534BEC(_p0);
			}
		}

		public void _0x316DB59CD14C1774(int _p0)
		{
			unsafe {
				if (fn__0x316DB59CD14C1774 == null) fn__0x316DB59CD14C1774 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x316DB59CD14C1774");
				fn__0x316DB59CD14C1774(_p0);
			}
		}

		public void _0x2D7A9B577E72385E(int _p0)
		{
			unsafe {
				if (fn__0x2D7A9B577E72385E == null) fn__0x2D7A9B577E72385E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x2D7A9B577E72385E");
				fn__0x2D7A9B577E72385E(_p0);
			}
		}

		public void _0x830C3A44EB3F2CF9(int _p0)
		{
			unsafe {
				if (fn__0x830C3A44EB3F2CF9 == null) fn__0x830C3A44EB3F2CF9 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x830C3A44EB3F2CF9");
				fn__0x830C3A44EB3F2CF9(_p0);
			}
		}

		public void _0xB26F670685631727(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xB26F670685631727 == null) fn__0xB26F670685631727 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xB26F670685631727");
				fn__0xB26F670685631727(_p0, _p1);
			}
		}

		public void _0xC14BD9F5337219B2(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xC14BD9F5337219B2 == null) fn__0xC14BD9F5337219B2 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xC14BD9F5337219B2");
				fn__0xC14BD9F5337219B2(_p0, _p1);
			}
		}

		public void PlaystatsStoneHatchetEnd(ref int _data)
		{
			unsafe {
				if (fn__playstatsStoneHatchetEnd == null) fn__playstatsStoneHatchetEnd = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsStoneHatchetEnd");
				var ref_data = _data;
				fn__playstatsStoneHatchetEnd(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsSmugMissionEnded(ref int _data)
		{
			unsafe {
				if (fn__playstatsSmugMissionEnded == null) fn__playstatsSmugMissionEnded = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsSmugMissionEnded");
				var ref_data = _data;
				fn__playstatsSmugMissionEnded(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsH2FmprepEnd(ref int _data)
		{
			unsafe {
				if (fn__playstatsH2FmprepEnd == null) fn__playstatsH2FmprepEnd = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsH2FmprepEnd");
				var ref_data = _data;
				fn__playstatsH2FmprepEnd(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsH2InstanceEnd(ref int _data, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsH2InstanceEnd == null) fn__playstatsH2InstanceEnd = (delegate* unmanaged[Cdecl]<int*, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsH2InstanceEnd");
				var ref_data = _data;
				fn__playstatsH2InstanceEnd(&ref_data, _p1, _p2, _p3);
				_data = ref_data;
			}
		}

		public void PlaystatsDarMissionEnd(ref int _data)
		{
			unsafe {
				if (fn__playstatsDarMissionEnd == null) fn__playstatsDarMissionEnd = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsDarMissionEnd");
				var ref_data = _data;
				fn__playstatsDarMissionEnd(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsEnterSessionPack(ref int _data)
		{
			unsafe {
				if (fn__playstatsEnterSessionPack == null) fn__playstatsEnterSessionPack = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsEnterSessionPack");
				var ref_data = _data;
				fn__playstatsEnterSessionPack(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsDroneUsage(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__playstatsDroneUsage == null) fn__playstatsDroneUsage = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsDroneUsage");
				fn__playstatsDroneUsage(_p0, _p1, _p2);
			}
		}

		public void PlaystatsSpectatorWheelSpin(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsSpectatorWheelSpin == null) fn__playstatsSpectatorWheelSpin = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsSpectatorWheelSpin");
				fn__playstatsSpectatorWheelSpin(_p0, _p1, _p2, _p3);
			}
		}

		public void PlaystatsArenaWarSpectator(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__playstatsArenaWarSpectator == null) fn__playstatsArenaWarSpectator = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsArenaWarSpectator");
				fn__playstatsArenaWarSpectator(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void PlaystatsArenaWarsEnded(ref int _data)
		{
			unsafe {
				if (fn__playstatsArenaWarsEnded == null) fn__playstatsArenaWarsEnded = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsArenaWarsEnded");
				var ref_data = _data;
				fn__playstatsArenaWarsEnded(&ref_data);
				_data = ref_data;
			}
		}

		public void PlaystatsPassiveMode(bool _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsPassiveMode == null) fn__playstatsPassiveMode = (delegate* unmanaged[Cdecl]<bool, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsPassiveMode");
				fn__playstatsPassiveMode(_p0, _p1, _p2, _p3);
			}
		}

		public void PlaystatsCollectible(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__playstatsCollectible == null) fn__playstatsCollectible = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCollectible");
				fn__playstatsCollectible(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void PlaystatsCasinoStoryMissionEnded(int _p0, int _p1)
		{
			unsafe {
				if (fn__playstatsCasinoStoryMissionEnded == null) fn__playstatsCasinoStoryMissionEnded = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoStoryMissionEnded");
				fn__playstatsCasinoStoryMissionEnded(_p0, _p1);
			}
		}

		public void PlaystatsCasinoChip(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoChip == null) fn__playstatsCasinoChip = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoChip");
				fn__playstatsCasinoChip(_p0);
			}
		}

		public void PlaystatsCasinoRoulette(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoRoulette == null) fn__playstatsCasinoRoulette = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoRoulette");
				fn__playstatsCasinoRoulette(_p0);
			}
		}

		public void PlaystatsCasinoBlackjack(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoBlackjack == null) fn__playstatsCasinoBlackjack = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoBlackjack");
				fn__playstatsCasinoBlackjack(_p0);
			}
		}

		public void PlaystatsCasinoThreecardpoker(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoThreecardpoker == null) fn__playstatsCasinoThreecardpoker = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoThreecardpoker");
				fn__playstatsCasinoThreecardpoker(_p0);
			}
		}

		public void PlaystatsCasinoSlotmachine(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoSlotmachine == null) fn__playstatsCasinoSlotmachine = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoSlotmachine");
				fn__playstatsCasinoSlotmachine(_p0);
			}
		}

		public void PlaystatsCasinoInsidetrack(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoInsidetrack == null) fn__playstatsCasinoInsidetrack = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoInsidetrack");
				fn__playstatsCasinoInsidetrack(_p0);
			}
		}

		public void PlaystatsCasinoLuckyseven(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoLuckyseven == null) fn__playstatsCasinoLuckyseven = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoLuckyseven");
				fn__playstatsCasinoLuckyseven(_p0);
			}
		}

		public void PlaystatsCasinoRouletteLight(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoRouletteLight == null) fn__playstatsCasinoRouletteLight = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoRouletteLight");
				fn__playstatsCasinoRouletteLight(_p0);
			}
		}

		public void PlaystatsCasinoBlackjackLight(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoBlackjackLight == null) fn__playstatsCasinoBlackjackLight = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoBlackjackLight");
				fn__playstatsCasinoBlackjackLight(_p0);
			}
		}

		public void PlaystatsCasinoThreecardpokerLight(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoThreecardpokerLight == null) fn__playstatsCasinoThreecardpokerLight = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoThreecardpokerLight");
				fn__playstatsCasinoThreecardpokerLight(_p0);
			}
		}

		public void PlaystatsCasinoSlotmachineLight(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoSlotmachineLight == null) fn__playstatsCasinoSlotmachineLight = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoSlotmachineLight");
				fn__playstatsCasinoSlotmachineLight(_p0);
			}
		}

		public void PlaystatsCasinoInsidetrackLight(int _p0)
		{
			unsafe {
				if (fn__playstatsCasinoInsidetrackLight == null) fn__playstatsCasinoInsidetrackLight = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoInsidetrackLight");
				fn__playstatsCasinoInsidetrackLight(_p0);
			}
		}

		public void PlaystatsArcadegame(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__playstatsArcadegame == null) fn__playstatsArcadegame = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsArcadegame");
				fn__playstatsArcadegame(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void _0x4FCDBD3F0A813C25(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x4FCDBD3F0A813C25 == null) fn__0x4FCDBD3F0A813C25 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x4FCDBD3F0A813C25");
				fn__0x4FCDBD3F0A813C25(_p0, _p1);
			}
		}

		public void PlaystatsCasinoMissionEnded(ref int _data)
		{
			unsafe {
				if (fn__playstatsCasinoMissionEnded == null) fn__playstatsCasinoMissionEnded = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_playstatsCasinoMissionEnded");
				var ref_data = _data;
				fn__playstatsCasinoMissionEnded(&ref_data);
				_data = ref_data;
			}
		}

		public void _0xDFBD93BF2943E29B(int _p0)
		{
			unsafe {
				if (fn__0xDFBD93BF2943E29B == null) fn__0xDFBD93BF2943E29B = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xDFBD93BF2943E29B");
				fn__0xDFBD93BF2943E29B(_p0);
			}
		}

		public void _0x92FC0EEDFAC04A14(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__0x92FC0EEDFAC04A14 == null) fn__0x92FC0EEDFAC04A14 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x92FC0EEDFAC04A14");
				fn__0x92FC0EEDFAC04A14(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void _0x0077F15613D36993(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x0077F15613D36993 == null) fn__0x0077F15613D36993 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0077F15613D36993");
				fn__0x0077F15613D36993(_p0, _p1, _p2, _p3);
			}
		}

		public void _0xF9096193DF1F99D4(int _p0)
		{
			unsafe {
				if (fn__0xF9096193DF1F99D4 == null) fn__0xF9096193DF1F99D4 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xF9096193DF1F99D4");
				fn__0xF9096193DF1F99D4(_p0);
			}
		}

		public void _0x2E0259BABC27A327(int _p0)
		{
			unsafe {
				if (fn__0x2E0259BABC27A327 == null) fn__0x2E0259BABC27A327 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x2E0259BABC27A327");
				fn__0x2E0259BABC27A327(_p0);
			}
		}

		public void _0x53C31853EC9531FF(int _p0)
		{
			unsafe {
				if (fn__0x53C31853EC9531FF == null) fn__0x53C31853EC9531FF = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x53C31853EC9531FF");
				fn__0x53C31853EC9531FF(_p0);
			}
		}

		public void _0x810B5FCC52EC7FF0(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0x810B5FCC52EC7FF0 == null) fn__0x810B5FCC52EC7FF0 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x810B5FCC52EC7FF0");
				fn__0x810B5FCC52EC7FF0(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x5BF29846C6527C54(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0x5BF29846C6527C54 == null) fn__0x5BF29846C6527C54 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x5BF29846C6527C54");
				fn__0x5BF29846C6527C54(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void _0xC03FAB2C2F92289B(int _p0)
		{
			unsafe {
				if (fn__0xC03FAB2C2F92289B == null) fn__0xC03FAB2C2F92289B = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC03FAB2C2F92289B");
				fn__0xC03FAB2C2F92289B(_p0);
			}
		}

		public void _0x5CDAED54B34B0ED0(int _p0)
		{
			unsafe {
				if (fn__0x5CDAED54B34B0ED0 == null) fn__0x5CDAED54B34B0ED0 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x5CDAED54B34B0ED0");
				fn__0x5CDAED54B34B0ED0(_p0);
			}
		}

		public void _0x4AFF7E02E485E92B()
		{
			unsafe {
				if (fn__0x4AFF7E02E485E92B == null) fn__0x4AFF7E02E485E92B = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x4AFF7E02E485E92B");
				fn__0x4AFF7E02E485E92B();
			}
		}

		public void _0xDFCDB14317A9B361(int _p0)
		{
			unsafe {
				if (fn__0xDFCDB14317A9B361 == null) fn__0xDFCDB14317A9B361 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xDFCDB14317A9B361");
				fn__0xDFCDB14317A9B361(_p0);
			}
		}

		public void _0xC1E963C58664B556(int _p0)
		{
			unsafe {
				if (fn__0xC1E963C58664B556 == null) fn__0xC1E963C58664B556 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC1E963C58664B556");
				fn__0xC1E963C58664B556(_p0);
			}
		}

		public void _0x2FA3173480008493(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0x2FA3173480008493 == null) fn__0x2FA3173480008493 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2FA3173480008493");
				fn__0x2FA3173480008493(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void _0xD4367D310F079DB0(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xD4367D310F079DB0 == null) fn__0xD4367D310F079DB0 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xD4367D310F079DB0");
				fn__0xD4367D310F079DB0(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x4DC416F246A41FC8(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0x4DC416F246A41FC8 == null) fn__0x4DC416F246A41FC8 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x4DC416F246A41FC8");
				fn__0x4DC416F246A41FC8(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void _0x2818FF6638CB09DE(int _p0)
		{
			unsafe {
				if (fn__0x2818FF6638CB09DE == null) fn__0x2818FF6638CB09DE = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x2818FF6638CB09DE");
				fn__0x2818FF6638CB09DE(_p0);
			}
		}

		public void _0xD6CA58B3B53A0F22(int _p0)
		{
			unsafe {
				if (fn__0xD6CA58B3B53A0F22 == null) fn__0xD6CA58B3B53A0F22 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xD6CA58B3B53A0F22");
				fn__0xD6CA58B3B53A0F22(_p0);
			}
		}

		public void PlaystatsRobberyPrep(int _p0)
		{
			unsafe {
				if (fn__playstatsRobberyPrep == null) fn__playstatsRobberyPrep = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsRobberyPrep");
				fn__playstatsRobberyPrep(_p0);
			}
		}

		public void PlaystatsRobberyFinale(int _p0)
		{
			unsafe {
				if (fn__playstatsRobberyFinale == null) fn__playstatsRobberyFinale = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsRobberyFinale");
				fn__playstatsRobberyFinale(_p0);
			}
		}

		public void PlaystatsExtraEvent(int _p0)
		{
			unsafe {
				if (fn__playstatsExtraEvent == null) fn__playstatsExtraEvent = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsExtraEvent");
				fn__playstatsExtraEvent(_p0);
			}
		}

		public void PlaystatsCarclubPoints(int _p0)
		{
			unsafe {
				if (fn__playstatsCarclubPoints == null) fn__playstatsCarclubPoints = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCarclubPoints");
				fn__playstatsCarclubPoints(_p0);
			}
		}

		public void PlaystatsCarclubChallenge(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__playstatsCarclubChallenge == null) fn__playstatsCarclubChallenge = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCarclubChallenge");
				fn__playstatsCarclubChallenge(_p0, _p1, _p2, _p3);
			}
		}

		public void PlaystatsCarclubPrize(int _p0, int _p1)
		{
			unsafe {
				if (fn__playstatsCarclubPrize == null) fn__playstatsCarclubPrize = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_playstatsCarclubPrize");
				fn__playstatsCarclubPrize(_p0, _p1);
			}
		}

		public void LoadAllObjectsNow()
		{
			unsafe {
				if (fn__loadAllObjectsNow == null) fn__loadAllObjectsNow = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_loadAllObjectsNow");
				fn__loadAllObjectsNow();
			}
		}

		public void LoadScene(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__loadScene == null) fn__loadScene = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_loadScene");
				fn__loadScene(_x, _y, _z);
			}
		}

		public bool NetworkUpdateLoadScene()
		{
			unsafe {
				if (fn__networkUpdateLoadScene == null) fn__networkUpdateLoadScene = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_networkUpdateLoadScene");
				var result = fn__networkUpdateLoadScene();
				return result;
			}
		}

		public bool IsNetworkLoadingScene()
		{
			unsafe {
				if (fn__isNetworkLoadingScene == null) fn__isNetworkLoadingScene = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isNetworkLoadingScene");
				var result = fn__isNetworkLoadingScene();
				return result;
			}
		}

		public void SetInteriorActive(int _interiorID, bool _toggle)
		{
			unsafe {
				if (fn__setInteriorActive == null) fn__setInteriorActive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setInteriorActive");
				fn__setInteriorActive(_interiorID, _toggle);
			}
		}

		public void RequestModel(int _model)
		{
			unsafe {
				if (fn__requestModel == null) fn__requestModel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestModel");
				fn__requestModel(_model);
			}
		}

		public void RequestMenuPedModel(int _model)
		{
			unsafe {
				if (fn__requestMenuPedModel == null) fn__requestMenuPedModel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestMenuPedModel");
				fn__requestMenuPedModel(_model);
			}
		}

		public bool HasModelLoaded(int _model)
		{
			unsafe {
				if (fn__hasModelLoaded == null) fn__hasModelLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasModelLoaded");
				var result = fn__hasModelLoaded(_model);
				return result;
			}
		}

		public void RequestModelsInRoom(int _interior, string _roomName)
		{
			unsafe {
				if (fn__requestModelsInRoom == null) fn__requestModelsInRoom = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_requestModelsInRoom");
				var ptr_roomName = MemoryUtils.StringToHGlobalUtf8(_roomName);
				fn__requestModelsInRoom(_interior, ptr_roomName);
				Marshal.FreeHGlobal(ptr_roomName);
			}
		}

		public void SetModelAsNoLongerNeeded(int _model)
		{
			unsafe {
				if (fn__setModelAsNoLongerNeeded == null) fn__setModelAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setModelAsNoLongerNeeded");
				fn__setModelAsNoLongerNeeded(_model);
			}
		}

		public bool IsModelInCdimage(int _model)
		{
			unsafe {
				if (fn__isModelInCdimage == null) fn__isModelInCdimage = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isModelInCdimage");
				var result = fn__isModelInCdimage(_model);
				return result;
			}
		}

		public bool IsModelValid(int _model)
		{
			unsafe {
				if (fn__isModelValid == null) fn__isModelValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isModelValid");
				var result = fn__isModelValid(_model);
				return result;
			}
		}

		public bool IsModelAPed(int _model)
		{
			unsafe {
				if (fn__isModelAPed == null) fn__isModelAPed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isModelAPed");
				var result = fn__isModelAPed(_model);
				return result;
			}
		}

		public bool IsModelAVehicle(int _model)
		{
			unsafe {
				if (fn__isModelAVehicle == null) fn__isModelAVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isModelAVehicle");
				var result = fn__isModelAVehicle(_model);
				return result;
			}
		}

		public void RequestCollisionAtCoord(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__requestCollisionAtCoord == null) fn__requestCollisionAtCoord = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_requestCollisionAtCoord");
				fn__requestCollisionAtCoord(_x, _y, _z);
			}
		}

		public void RequestCollisionForModel(int _model)
		{
			unsafe {
				if (fn__requestCollisionForModel == null) fn__requestCollisionForModel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestCollisionForModel");
				fn__requestCollisionForModel(_model);
			}
		}

		public bool HasCollisionForModelLoaded(int _model)
		{
			unsafe {
				if (fn__hasCollisionForModelLoaded == null) fn__hasCollisionForModelLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasCollisionForModelLoaded");
				var result = fn__hasCollisionForModelLoaded(_model);
				return result;
			}
		}

		public void RequestAdditionalCollisionAtCoord(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__requestAdditionalCollisionAtCoord == null) fn__requestAdditionalCollisionAtCoord = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_requestAdditionalCollisionAtCoord");
				fn__requestAdditionalCollisionAtCoord(_x, _y, _z);
			}
		}

		public bool DoesAnimDictExist(string _animDict)
		{
			unsafe {
				if (fn__doesAnimDictExist == null) fn__doesAnimDictExist = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_doesAnimDictExist");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var result = fn__doesAnimDictExist(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animDict);
				return result;
			}
		}

		public void RequestAnimDict(string _animDict)
		{
			unsafe {
				if (fn__requestAnimDict == null) fn__requestAnimDict = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestAnimDict");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				fn__requestAnimDict(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animDict);
			}
		}

		public bool HasAnimDictLoaded(string _animDict)
		{
			unsafe {
				if (fn__hasAnimDictLoaded == null) fn__hasAnimDictLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasAnimDictLoaded");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var result = fn__hasAnimDictLoaded(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animDict);
				return result;
			}
		}

		public void RemoveAnimDict(string _animDict)
		{
			unsafe {
				if (fn__removeAnimDict == null) fn__removeAnimDict = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeAnimDict");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				fn__removeAnimDict(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animDict);
			}
		}

		public void RequestAnimSet(string _animSet)
		{
			unsafe {
				if (fn__requestAnimSet == null) fn__requestAnimSet = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestAnimSet");
				var ptr_animSet = MemoryUtils.StringToHGlobalUtf8(_animSet);
				fn__requestAnimSet(ptr_animSet);
				Marshal.FreeHGlobal(ptr_animSet);
			}
		}

		public bool HasAnimSetLoaded(string _animSet)
		{
			unsafe {
				if (fn__hasAnimSetLoaded == null) fn__hasAnimSetLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasAnimSetLoaded");
				var ptr_animSet = MemoryUtils.StringToHGlobalUtf8(_animSet);
				var result = fn__hasAnimSetLoaded(ptr_animSet);
				Marshal.FreeHGlobal(ptr_animSet);
				return result;
			}
		}

		public void RemoveAnimSet(string _animSet)
		{
			unsafe {
				if (fn__removeAnimSet == null) fn__removeAnimSet = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeAnimSet");
				var ptr_animSet = MemoryUtils.StringToHGlobalUtf8(_animSet);
				fn__removeAnimSet(ptr_animSet);
				Marshal.FreeHGlobal(ptr_animSet);
			}
		}

		public void RequestClipSet(string _clipSet)
		{
			unsafe {
				if (fn__requestClipSet == null) fn__requestClipSet = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestClipSet");
				var ptr_clipSet = MemoryUtils.StringToHGlobalUtf8(_clipSet);
				fn__requestClipSet(ptr_clipSet);
				Marshal.FreeHGlobal(ptr_clipSet);
			}
		}

		public bool HasClipSetLoaded(string _clipSet)
		{
			unsafe {
				if (fn__hasClipSetLoaded == null) fn__hasClipSetLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasClipSetLoaded");
				var ptr_clipSet = MemoryUtils.StringToHGlobalUtf8(_clipSet);
				var result = fn__hasClipSetLoaded(ptr_clipSet);
				Marshal.FreeHGlobal(ptr_clipSet);
				return result;
			}
		}

		public void RemoveClipSet(string _clipSet)
		{
			unsafe {
				if (fn__removeClipSet == null) fn__removeClipSet = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeClipSet");
				var ptr_clipSet = MemoryUtils.StringToHGlobalUtf8(_clipSet);
				fn__removeClipSet(ptr_clipSet);
				Marshal.FreeHGlobal(ptr_clipSet);
			}
		}

		public void RequestIpl(string _iplName)
		{
			unsafe {
				if (fn__requestIpl == null) fn__requestIpl = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestIpl");
				var ptr_iplName = MemoryUtils.StringToHGlobalUtf8(_iplName);
				fn__requestIpl(ptr_iplName);
				Marshal.FreeHGlobal(ptr_iplName);
			}
		}

		public void RemoveIpl(string _iplName)
		{
			unsafe {
				if (fn__removeIpl == null) fn__removeIpl = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeIpl");
				var ptr_iplName = MemoryUtils.StringToHGlobalUtf8(_iplName);
				fn__removeIpl(ptr_iplName);
				Marshal.FreeHGlobal(ptr_iplName);
			}
		}

		public bool IsIplActive(string _iplName)
		{
			unsafe {
				if (fn__isIplActive == null) fn__isIplActive = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isIplActive");
				var ptr_iplName = MemoryUtils.StringToHGlobalUtf8(_iplName);
				var result = fn__isIplActive(ptr_iplName);
				Marshal.FreeHGlobal(ptr_iplName);
				return result;
			}
		}

		public void SetStreaming(bool _toggle)
		{
			unsafe {
				if (fn__setStreaming == null) fn__setStreaming = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setStreaming");
				fn__setStreaming(_toggle);
			}
		}

		public void LoadGlobalWaterType(int _waterType)
		{
			unsafe {
				if (fn__loadGlobalWaterType == null) fn__loadGlobalWaterType = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_loadGlobalWaterType");
				fn__loadGlobalWaterType(_waterType);
			}
		}

		public int GetGlobalWaterType()
		{
			unsafe {
				if (fn__getGlobalWaterType == null) fn__getGlobalWaterType = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getGlobalWaterType");
				var result = fn__getGlobalWaterType();
				return result;
			}
		}

		public void SetGamePausesForStreaming(bool _toggle)
		{
			unsafe {
				if (fn__setGamePausesForStreaming == null) fn__setGamePausesForStreaming = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setGamePausesForStreaming");
				fn__setGamePausesForStreaming(_toggle);
			}
		}

		public void SetReducePedModelBudget(bool _toggle)
		{
			unsafe {
				if (fn__setReducePedModelBudget == null) fn__setReducePedModelBudget = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setReducePedModelBudget");
				fn__setReducePedModelBudget(_toggle);
			}
		}

		public void SetReduceVehicleModelBudget(bool _toggle)
		{
			unsafe {
				if (fn__setReduceVehicleModelBudget == null) fn__setReduceVehicleModelBudget = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setReduceVehicleModelBudget");
				fn__setReduceVehicleModelBudget(_toggle);
			}
		}

		public void SetDitchPoliceModels(bool _toggle)
		{
			unsafe {
				if (fn__setDitchPoliceModels == null) fn__setDitchPoliceModels = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setDitchPoliceModels");
				fn__setDitchPoliceModels(_toggle);
			}
		}

		public int GetNumberOfStreamingRequests()
		{
			unsafe {
				if (fn__getNumberOfStreamingRequests == null) fn__getNumberOfStreamingRequests = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumberOfStreamingRequests");
				var result = fn__getNumberOfStreamingRequests();
				return result;
			}
		}

		public void RequestPtfxAsset()
		{
			unsafe {
				if (fn__requestPtfxAsset == null) fn__requestPtfxAsset = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_requestPtfxAsset");
				fn__requestPtfxAsset();
			}
		}

		public bool HasPtfxAssetLoaded()
		{
			unsafe {
				if (fn__hasPtfxAssetLoaded == null) fn__hasPtfxAssetLoaded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasPtfxAssetLoaded");
				var result = fn__hasPtfxAssetLoaded();
				return result;
			}
		}

		public void RemovePtfxAsset()
		{
			unsafe {
				if (fn__removePtfxAsset == null) fn__removePtfxAsset = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removePtfxAsset");
				fn__removePtfxAsset();
			}
		}

		public void RequestNamedPtfxAsset(string _fxName)
		{
			unsafe {
				if (fn__requestNamedPtfxAsset == null) fn__requestNamedPtfxAsset = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestNamedPtfxAsset");
				var ptr_fxName = MemoryUtils.StringToHGlobalUtf8(_fxName);
				fn__requestNamedPtfxAsset(ptr_fxName);
				Marshal.FreeHGlobal(ptr_fxName);
			}
		}

		public bool HasNamedPtfxAssetLoaded(string _fxName)
		{
			unsafe {
				if (fn__hasNamedPtfxAssetLoaded == null) fn__hasNamedPtfxAssetLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_hasNamedPtfxAssetLoaded");
				var ptr_fxName = MemoryUtils.StringToHGlobalUtf8(_fxName);
				var result = fn__hasNamedPtfxAssetLoaded(ptr_fxName);
				Marshal.FreeHGlobal(ptr_fxName);
				return result;
			}
		}

		public void RemoveNamedPtfxAsset(string _fxName)
		{
			unsafe {
				if (fn__removeNamedPtfxAsset == null) fn__removeNamedPtfxAsset = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeNamedPtfxAsset");
				var ptr_fxName = MemoryUtils.StringToHGlobalUtf8(_fxName);
				fn__removeNamedPtfxAsset(ptr_fxName);
				Marshal.FreeHGlobal(ptr_fxName);
			}
		}

		public void SetVehiclePopulationBudget(int _p0)
		{
			unsafe {
				if (fn__setVehiclePopulationBudget == null) fn__setVehiclePopulationBudget = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setVehiclePopulationBudget");
				fn__setVehiclePopulationBudget(_p0);
			}
		}

		public void SetPedPopulationBudget(int _p0)
		{
			unsafe {
				if (fn__setPedPopulationBudget == null) fn__setPedPopulationBudget = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedPopulationBudget");
				fn__setPedPopulationBudget(_p0);
			}
		}

		public void ClearFocus()
		{
			unsafe {
				if (fn__clearFocus == null) fn__clearFocus = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearFocus");
				fn__clearFocus();
			}
		}

		public void SetFocusPosAndVel(float _x, float _y, float _z, float _offsetX, float _offsetY, float _offsetZ)
		{
			unsafe {
				if (fn__setFocusPosAndVel == null) fn__setFocusPosAndVel = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setFocusPosAndVel");
				fn__setFocusPosAndVel(_x, _y, _z, _offsetX, _offsetY, _offsetZ);
			}
		}

		public void SetFocusEntity(int _entity)
		{
			unsafe {
				if (fn__setFocusEntity == null) fn__setFocusEntity = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setFocusEntity");
				fn__setFocusEntity(_entity);
			}
		}

		public bool IsEntityFocus(int _entity)
		{
			unsafe {
				if (fn__isEntityFocus == null) fn__isEntityFocus = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityFocus");
				var result = fn__isEntityFocus(_entity);
				return result;
			}
		}

		public void _0x0811381EF5062FEC(int _p0)
		{
			unsafe {
				if (fn__0x0811381EF5062FEC == null) fn__0x0811381EF5062FEC = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x0811381EF5062FEC");
				fn__0x0811381EF5062FEC(_p0);
			}
		}

		public void SetMapdatacullboxEnabled(string _name, bool _toggle)
		{
			unsafe {
				if (fn__setMapdatacullboxEnabled == null) fn__setMapdatacullboxEnabled = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setMapdatacullboxEnabled");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setMapdatacullboxEnabled(ptr_name, _toggle);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void _0x4E52E752C76E7E7A(int _p0)
		{
			unsafe {
				if (fn__0x4E52E752C76E7E7A == null) fn__0x4E52E752C76E7E7A = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x4E52E752C76E7E7A");
				fn__0x4E52E752C76E7E7A(_p0);
			}
		}

		public int StreamvolCreateSphere(float _x, float _y, float _z, float _rad, int _p4, int _p5)
		{
			unsafe {
				if (fn__streamvolCreateSphere == null) fn__streamvolCreateSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int>) NativeLibrary.GetExport(handle, "Native_streamvolCreateSphere");
				var result = fn__streamvolCreateSphere(_x, _y, _z, _rad, _p4, _p5);
				return result;
			}
		}

		public int StreamvolCreateFrustum(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, int _p7, int _p8)
		{
			unsafe {
				if (fn__streamvolCreateFrustum == null) fn__streamvolCreateFrustum = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, int, int>) NativeLibrary.GetExport(handle, "Native_streamvolCreateFrustum");
				var result = fn__streamvolCreateFrustum(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8);
				return result;
			}
		}

		public int StreamvolCreateLine(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, int _p6)
		{
			unsafe {
				if (fn__streamvolCreateLine == null) fn__streamvolCreateLine = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int>) NativeLibrary.GetExport(handle, "Native_streamvolCreateLine");
				var result = fn__streamvolCreateLine(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
				return result;
			}
		}

		public void StreamvolDelete(int _unused)
		{
			unsafe {
				if (fn__streamvolDelete == null) fn__streamvolDelete = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_streamvolDelete");
				fn__streamvolDelete(_unused);
			}
		}

		public bool StreamvolHasLoaded(int _unused)
		{
			unsafe {
				if (fn__streamvolHasLoaded == null) fn__streamvolHasLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_streamvolHasLoaded");
				var result = fn__streamvolHasLoaded(_unused);
				return result;
			}
		}

		public bool StreamvolIsValid(int _unused)
		{
			unsafe {
				if (fn__streamvolIsValid == null) fn__streamvolIsValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_streamvolIsValid");
				var result = fn__streamvolIsValid(_unused);
				return result;
			}
		}

		public bool IsStreamvolActive()
		{
			unsafe {
				if (fn__isStreamvolActive == null) fn__isStreamvolActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isStreamvolActive");
				var result = fn__isStreamvolActive();
				return result;
			}
		}

		public bool NewLoadSceneStart(float _posX, float _posY, float _posZ, float _offsetX, float _offsetY, float _offsetZ, float _radius, int _p7)
		{
			unsafe {
				if (fn__newLoadSceneStart == null) fn__newLoadSceneStart = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, bool>) NativeLibrary.GetExport(handle, "Native_newLoadSceneStart");
				var result = fn__newLoadSceneStart(_posX, _posY, _posZ, _offsetX, _offsetY, _offsetZ, _radius, _p7);
				return result;
			}
		}

		public bool NewLoadSceneStartSphere(float _x, float _y, float _z, float _radius, int _p4)
		{
			unsafe {
				if (fn__newLoadSceneStartSphere == null) fn__newLoadSceneStartSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, int, bool>) NativeLibrary.GetExport(handle, "Native_newLoadSceneStartSphere");
				var result = fn__newLoadSceneStartSphere(_x, _y, _z, _radius, _p4);
				return result;
			}
		}

		public void NewLoadSceneStop()
		{
			unsafe {
				if (fn__newLoadSceneStop == null) fn__newLoadSceneStop = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_newLoadSceneStop");
				fn__newLoadSceneStop();
			}
		}

		public bool IsNewLoadSceneActive()
		{
			unsafe {
				if (fn__isNewLoadSceneActive == null) fn__isNewLoadSceneActive = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isNewLoadSceneActive");
				var result = fn__isNewLoadSceneActive();
				return result;
			}
		}

		public bool IsNewLoadSceneLoaded()
		{
			unsafe {
				if (fn__isNewLoadSceneLoaded == null) fn__isNewLoadSceneLoaded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isNewLoadSceneLoaded");
				var result = fn__isNewLoadSceneLoaded();
				return result;
			}
		}

		public int _0x71E7B2E657449AAD()
		{
			unsafe {
				if (fn__0x71E7B2E657449AAD == null) fn__0x71E7B2E657449AAD = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x71E7B2E657449AAD");
				var result = fn__0x71E7B2E657449AAD();
				return result;
			}
		}

		public void StartPlayerSwitch(int _from, int _to, int _flags, int _switchType)
		{
			unsafe {
				if (fn__startPlayerSwitch == null) fn__startPlayerSwitch = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_startPlayerSwitch");
				fn__startPlayerSwitch(_from, _to, _flags, _switchType);
			}
		}

		public void StopPlayerSwitch()
		{
			unsafe {
				if (fn__stopPlayerSwitch == null) fn__stopPlayerSwitch = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopPlayerSwitch");
				fn__stopPlayerSwitch();
			}
		}

		public bool IsPlayerSwitchInProgress()
		{
			unsafe {
				if (fn__isPlayerSwitchInProgress == null) fn__isPlayerSwitchInProgress = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isPlayerSwitchInProgress");
				var result = fn__isPlayerSwitchInProgress();
				return result;
			}
		}

		public int GetPlayerSwitchType()
		{
			unsafe {
				if (fn__getPlayerSwitchType == null) fn__getPlayerSwitchType = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayerSwitchType");
				var result = fn__getPlayerSwitchType();
				return result;
			}
		}

		public int GetIdealPlayerSwitchType(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2)
		{
			unsafe {
				if (fn__getIdealPlayerSwitchType == null) fn__getIdealPlayerSwitchType = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_getIdealPlayerSwitchType");
				var result = fn__getIdealPlayerSwitchType(_x1, _y1, _z1, _x2, _y2, _z2);
				return result;
			}
		}

		public int GetPlayerSwitchState()
		{
			unsafe {
				if (fn__getPlayerSwitchState == null) fn__getPlayerSwitchState = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayerSwitchState");
				var result = fn__getPlayerSwitchState();
				return result;
			}
		}

		public int GetPlayerShortSwitchState()
		{
			unsafe {
				if (fn__getPlayerShortSwitchState == null) fn__getPlayerShortSwitchState = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayerShortSwitchState");
				var result = fn__getPlayerShortSwitchState();
				return result;
			}
		}

		public void _0x5F2013F8BC24EE69(int _p0)
		{
			unsafe {
				if (fn__0x5F2013F8BC24EE69 == null) fn__0x5F2013F8BC24EE69 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x5F2013F8BC24EE69");
				fn__0x5F2013F8BC24EE69(_p0);
			}
		}

		public int GetPlayerSwitchJumpCutIndex()
		{
			unsafe {
				if (fn__getPlayerSwitchJumpCutIndex == null) fn__getPlayerSwitchJumpCutIndex = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayerSwitchJumpCutIndex");
				var result = fn__getPlayerSwitchJumpCutIndex();
				return result;
			}
		}

		public void SetPlayerSwitchOutro(float _cameraCoordX, float _cameraCoordY, float _cameraCoordZ, float _camRotationX, float _camRotationY, float _camRotationZ, float _camFov, float _camFarClip, int _rotationOrder)
		{
			unsafe {
				if (fn__setPlayerSwitchOutro == null) fn__setPlayerSwitchOutro = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setPlayerSwitchOutro");
				fn__setPlayerSwitchOutro(_cameraCoordX, _cameraCoordY, _cameraCoordZ, _camRotationX, _camRotationY, _camRotationZ, _camFov, _camFarClip, _rotationOrder);
			}
		}

		public void SetPlayerSwitchEstablishingShot(string _name)
		{
			unsafe {
				if (fn__setPlayerSwitchEstablishingShot == null) fn__setPlayerSwitchEstablishingShot = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setPlayerSwitchEstablishingShot");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setPlayerSwitchEstablishingShot(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void AllowPlayerSwitchPan()
		{
			unsafe {
				if (fn__allowPlayerSwitchPan == null) fn__allowPlayerSwitchPan = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_allowPlayerSwitchPan");
				fn__allowPlayerSwitchPan();
			}
		}

		public void AllowPlayerSwitchOutro()
		{
			unsafe {
				if (fn__allowPlayerSwitchOutro == null) fn__allowPlayerSwitchOutro = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_allowPlayerSwitchOutro");
				fn__allowPlayerSwitchOutro();
			}
		}

		public void AllowPlayerSwitchAscent()
		{
			unsafe {
				if (fn__allowPlayerSwitchAscent == null) fn__allowPlayerSwitchAscent = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_allowPlayerSwitchAscent");
				fn__allowPlayerSwitchAscent();
			}
		}

		public void AllowPlayerSwitchDescent()
		{
			unsafe {
				if (fn__allowPlayerSwitchDescent == null) fn__allowPlayerSwitchDescent = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_allowPlayerSwitchDescent");
				fn__allowPlayerSwitchDescent();
			}
		}

		public bool IsSwitchReadyForDescent()
		{
			unsafe {
				if (fn__isSwitchReadyForDescent == null) fn__isSwitchReadyForDescent = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isSwitchReadyForDescent");
				var result = fn__isSwitchReadyForDescent();
				return result;
			}
		}

		public void EnableSwitchPauseBeforeDescent()
		{
			unsafe {
				if (fn__enableSwitchPauseBeforeDescent == null) fn__enableSwitchPauseBeforeDescent = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_enableSwitchPauseBeforeDescent");
				fn__enableSwitchPauseBeforeDescent();
			}
		}

		public void DisableSwitchOutroFx()
		{
			unsafe {
				if (fn__disableSwitchOutroFx == null) fn__disableSwitchOutroFx = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_disableSwitchOutroFx");
				fn__disableSwitchOutroFx();
			}
		}

		public void SwitchOutPlayer(int _ped, int _flags, int _switchType)
		{
			unsafe {
				if (fn__switchOutPlayer == null) fn__switchOutPlayer = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_switchOutPlayer");
				fn__switchOutPlayer(_ped, _flags, _switchType);
			}
		}

		public void SwitchInPlayer(int _ped)
		{
			unsafe {
				if (fn__switchInPlayer == null) fn__switchInPlayer = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_switchInPlayer");
				fn__switchInPlayer(_ped);
			}
		}

		public bool _0x933BBEEB8C61B5F4()
		{
			unsafe {
				if (fn__0x933BBEEB8C61B5F4 == null) fn__0x933BBEEB8C61B5F4 = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0x933BBEEB8C61B5F4");
				var result = fn__0x933BBEEB8C61B5F4();
				return result;
			}
		}

		public int GetPlayerSwitchInterpOutDuration()
		{
			unsafe {
				if (fn__getPlayerSwitchInterpOutDuration == null) fn__getPlayerSwitchInterpOutDuration = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayerSwitchInterpOutDuration");
				var result = fn__getPlayerSwitchInterpOutDuration();
				return result;
			}
		}

		public int GetPlayerSwitchInterpOutCurrentTime()
		{
			unsafe {
				if (fn__getPlayerSwitchInterpOutCurrentTime == null) fn__getPlayerSwitchInterpOutCurrentTime = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getPlayerSwitchInterpOutCurrentTime");
				var result = fn__getPlayerSwitchInterpOutCurrentTime();
				return result;
			}
		}

		public bool IsSwitchSkippingDescent()
		{
			unsafe {
				if (fn__isSwitchSkippingDescent == null) fn__isSwitchSkippingDescent = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isSwitchSkippingDescent");
				var result = fn__isSwitchSkippingDescent();
				return result;
			}
		}

		public void _0x1E9057A74FD73E23()
		{
			unsafe {
				if (fn__0x1E9057A74FD73E23 == null) fn__0x1E9057A74FD73E23 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x1E9057A74FD73E23");
				fn__0x1E9057A74FD73E23();
			}
		}

		public float GetLodscale()
		{
			unsafe {
				if (fn__getLodscale == null) fn__getLodscale = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getLodscale");
				var result = fn__getLodscale();
				return result;
			}
		}

		public void OverrideLodscaleThisFrame(float _scaling)
		{
			unsafe {
				if (fn__overrideLodscaleThisFrame == null) fn__overrideLodscaleThisFrame = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_overrideLodscaleThisFrame");
				fn__overrideLodscaleThisFrame(_scaling);
			}
		}

		public void _0xBED8CA5FF5E04113(float _p0, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__0xBED8CA5FF5E04113 == null) fn__0xBED8CA5FF5E04113 = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0xBED8CA5FF5E04113");
				fn__0xBED8CA5FF5E04113(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x472397322E92A856()
		{
			unsafe {
				if (fn__0x472397322E92A856 == null) fn__0x472397322E92A856 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x472397322E92A856");
				fn__0x472397322E92A856();
			}
		}

		public void SetRenderHdOnly(bool _toggle)
		{
			unsafe {
				if (fn__setRenderHdOnly == null) fn__setRenderHdOnly = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setRenderHdOnly");
				fn__setRenderHdOnly(_toggle);
			}
		}

		public void _0x03F1A106BDA7DD3E()
		{
			unsafe {
				if (fn__0x03F1A106BDA7DD3E == null) fn__0x03F1A106BDA7DD3E = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x03F1A106BDA7DD3E");
				fn__0x03F1A106BDA7DD3E();
			}
		}

		public void _0x95A7DABDDBB78AE7(string _iplName1, string _iplName2)
		{
			unsafe {
				if (fn__0x95A7DABDDBB78AE7 == null) fn__0x95A7DABDDBB78AE7 = (delegate* unmanaged[Cdecl]<nint, nint, void>) NativeLibrary.GetExport(handle, "Native__0x95A7DABDDBB78AE7");
				var ptr_iplName1 = MemoryUtils.StringToHGlobalUtf8(_iplName1);
				var ptr_iplName2 = MemoryUtils.StringToHGlobalUtf8(_iplName2);
				fn__0x95A7DABDDBB78AE7(ptr_iplName1, ptr_iplName2);
				Marshal.FreeHGlobal(ptr_iplName1);
				Marshal.FreeHGlobal(ptr_iplName2);
			}
		}

		public void _0x63EB2B972A218CAC()
		{
			unsafe {
				if (fn__0x63EB2B972A218CAC == null) fn__0x63EB2B972A218CAC = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x63EB2B972A218CAC");
				fn__0x63EB2B972A218CAC();
			}
		}

		public bool _0xFB199266061F820A()
		{
			unsafe {
				if (fn__0xFB199266061F820A == null) fn__0xFB199266061F820A = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native__0xFB199266061F820A");
				var result = fn__0xFB199266061F820A();
				return result;
			}
		}

		public void _0xF4A0DADB70F57FA6()
		{
			unsafe {
				if (fn__0xF4A0DADB70F57FA6 == null) fn__0xF4A0DADB70F57FA6 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xF4A0DADB70F57FA6");
				fn__0xF4A0DADB70F57FA6();
			}
		}

		public int _0x5068F488DDB54DD8()
		{
			unsafe {
				if (fn__0x5068F488DDB54DD8 == null) fn__0x5068F488DDB54DD8 = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native__0x5068F488DDB54DD8");
				var result = fn__0x5068F488DDB54DD8();
				return result;
			}
		}

		public void PrefetchSrl(string _srl)
		{
			unsafe {
				if (fn__prefetchSrl == null) fn__prefetchSrl = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_prefetchSrl");
				var ptr_srl = MemoryUtils.StringToHGlobalUtf8(_srl);
				fn__prefetchSrl(ptr_srl);
				Marshal.FreeHGlobal(ptr_srl);
			}
		}

		public bool IsSrlLoaded()
		{
			unsafe {
				if (fn__isSrlLoaded == null) fn__isSrlLoaded = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_isSrlLoaded");
				var result = fn__isSrlLoaded();
				return result;
			}
		}

		public void BeginSrl()
		{
			unsafe {
				if (fn__beginSrl == null) fn__beginSrl = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_beginSrl");
				fn__beginSrl();
			}
		}

		public void EndSrl()
		{
			unsafe {
				if (fn__endSrl == null) fn__endSrl = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_endSrl");
				fn__endSrl();
			}
		}

		public void SetSrlTime(float _p0)
		{
			unsafe {
				if (fn__setSrlTime == null) fn__setSrlTime = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setSrlTime");
				fn__setSrlTime(_p0);
			}
		}

		public void _0xEF39EE20C537E98C(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__0xEF39EE20C537E98C == null) fn__0xEF39EE20C537E98C = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xEF39EE20C537E98C");
				fn__0xEF39EE20C537E98C(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void _0xBEB2D9A1D9A8F55A(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__0xBEB2D9A1D9A8F55A == null) fn__0xBEB2D9A1D9A8F55A = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xBEB2D9A1D9A8F55A");
				fn__0xBEB2D9A1D9A8F55A(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x20C6C7E4EB082A7F(bool _p0)
		{
			unsafe {
				if (fn__0x20C6C7E4EB082A7F == null) fn__0x20C6C7E4EB082A7F = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x20C6C7E4EB082A7F");
				fn__0x20C6C7E4EB082A7F(_p0);
			}
		}

		public void _0xF8155A7F03DDFC8E(int _p0)
		{
			unsafe {
				if (fn__0xF8155A7F03DDFC8E == null) fn__0xF8155A7F03DDFC8E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xF8155A7F03DDFC8E");
				fn__0xF8155A7F03DDFC8E(_p0);
			}
		}

		public void SetHdArea(float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__setHdArea == null) fn__setHdArea = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setHdArea");
				fn__setHdArea(_x, _y, _z, _radius);
			}
		}

		public void ClearHdArea()
		{
			unsafe {
				if (fn__clearHdArea == null) fn__clearHdArea = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearHdArea");
				fn__clearHdArea();
			}
		}

		public void InitCreatorBudget()
		{
			unsafe {
				if (fn__initCreatorBudget == null) fn__initCreatorBudget = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_initCreatorBudget");
				fn__initCreatorBudget();
			}
		}

		public void ShutdownCreatorBudget()
		{
			unsafe {
				if (fn__shutdownCreatorBudget == null) fn__shutdownCreatorBudget = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_shutdownCreatorBudget");
				fn__shutdownCreatorBudget();
			}
		}

		public bool AddModelToCreatorBudget(int _modelHash)
		{
			unsafe {
				if (fn__addModelToCreatorBudget == null) fn__addModelToCreatorBudget = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_addModelToCreatorBudget");
				var result = fn__addModelToCreatorBudget(_modelHash);
				return result;
			}
		}

		public void RemoveModelFromCreatorBudget(int _modelHash)
		{
			unsafe {
				if (fn__removeModelFromCreatorBudget == null) fn__removeModelFromCreatorBudget = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeModelFromCreatorBudget");
				fn__removeModelFromCreatorBudget(_modelHash);
			}
		}

		public float GetUsedCreatorModelMemoryPercentage()
		{
			unsafe {
				if (fn__getUsedCreatorModelMemoryPercentage == null) fn__getUsedCreatorModelMemoryPercentage = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getUsedCreatorModelMemoryPercentage");
				var result = fn__getUsedCreatorModelMemoryPercentage();
				return result;
			}
		}

		public void SetIslandHopperEnabled(string _name, bool _toggle)
		{
			unsafe {
				if (fn__setIslandHopperEnabled == null) fn__setIslandHopperEnabled = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setIslandHopperEnabled");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setIslandHopperEnabled(ptr_name, _toggle);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void TaskPause(int _ped, int _ms)
		{
			unsafe {
				if (fn__taskPause == null) fn__taskPause = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskPause");
				fn__taskPause(_ped, _ms);
			}
		}

		public void TaskStandStill(int _ped, int _time)
		{
			unsafe {
				if (fn__taskStandStill == null) fn__taskStandStill = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskStandStill");
				fn__taskStandStill(_ped, _time);
			}
		}

		public void TaskJump(int _ped, bool _unused, int _p2, int _p3)
		{
			unsafe {
				if (fn__taskJump == null) fn__taskJump = (delegate* unmanaged[Cdecl]<int, bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskJump");
				fn__taskJump(_ped, _unused, _p2, _p3);
			}
		}

		public void TaskCower(int _ped, int _duration)
		{
			unsafe {
				if (fn__taskCower == null) fn__taskCower = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskCower");
				fn__taskCower(_ped, _duration);
			}
		}

		public void TaskHandsUp(int _ped, int _duration, int _facingPed, int _p3, bool _p4)
		{
			unsafe {
				if (fn__taskHandsUp == null) fn__taskHandsUp = (delegate* unmanaged[Cdecl]<int, int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskHandsUp");
				fn__taskHandsUp(_ped, _duration, _facingPed, _p3, _p4);
			}
		}

		public void UpdateTaskHandsUpDuration(int _ped, int _duration)
		{
			unsafe {
				if (fn__updateTaskHandsUpDuration == null) fn__updateTaskHandsUpDuration = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_updateTaskHandsUpDuration");
				fn__updateTaskHandsUpDuration(_ped, _duration);
			}
		}

		public void TaskOpenVehicleDoor(int _ped, int _vehicle, int _timeOut, int _seat, float _speed)
		{
			unsafe {
				if (fn__taskOpenVehicleDoor == null) fn__taskOpenVehicleDoor = (delegate* unmanaged[Cdecl]<int, int, int, int, float, void>) NativeLibrary.GetExport(handle, "Native_taskOpenVehicleDoor");
				fn__taskOpenVehicleDoor(_ped, _vehicle, _timeOut, _seat, _speed);
			}
		}

		public void TaskEnterVehicle(int _ped, int _vehicle, int _timeout, int _seat, float _speed, int _flag, int _p6)
		{
			unsafe {
				if (fn__taskEnterVehicle == null) fn__taskEnterVehicle = (delegate* unmanaged[Cdecl]<int, int, int, int, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskEnterVehicle");
				fn__taskEnterVehicle(_ped, _vehicle, _timeout, _seat, _speed, _flag, _p6);
			}
		}

		public void TaskLeaveVehicle(int _ped, int _vehicle, int _flags)
		{
			unsafe {
				if (fn__taskLeaveVehicle == null) fn__taskLeaveVehicle = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskLeaveVehicle");
				fn__taskLeaveVehicle(_ped, _vehicle, _flags);
			}
		}

		public void TaskGetOffBoat(int _ped, int _boat)
		{
			unsafe {
				if (fn__taskGetOffBoat == null) fn__taskGetOffBoat = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskGetOffBoat");
				fn__taskGetOffBoat(_ped, _boat);
			}
		}

		public void TaskSkyDive(int _ped, bool _p1)
		{
			unsafe {
				if (fn__taskSkyDive == null) fn__taskSkyDive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskSkyDive");
				fn__taskSkyDive(_ped, _p1);
			}
		}

		public void TaskParachute(int _ped, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__taskParachute == null) fn__taskParachute = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskParachute");
				fn__taskParachute(_ped, _p1, _p2);
			}
		}

		public void TaskParachuteToTarget(int _ped, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__taskParachuteToTarget == null) fn__taskParachuteToTarget = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskParachuteToTarget");
				fn__taskParachuteToTarget(_ped, _x, _y, _z);
			}
		}

		public void SetParachuteTaskTarget(int _ped, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setParachuteTaskTarget == null) fn__setParachuteTaskTarget = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setParachuteTaskTarget");
				fn__setParachuteTaskTarget(_ped, _x, _y, _z);
			}
		}

		public void SetParachuteTaskThrust(int _ped, float _thrust)
		{
			unsafe {
				if (fn__setParachuteTaskThrust == null) fn__setParachuteTaskThrust = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setParachuteTaskThrust");
				fn__setParachuteTaskThrust(_ped, _thrust);
			}
		}

		public void TaskRappelFromHeli(int _ped, float _p1)
		{
			unsafe {
				if (fn__taskRappelFromHeli == null) fn__taskRappelFromHeli = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_taskRappelFromHeli");
				fn__taskRappelFromHeli(_ped, _p1);
			}
		}

		public void TaskVehicleDriveToCoord(int _ped, int _vehicle, float _x, float _y, float _z, float _speed, int _p6, int _vehicleModel, int _drivingMode, float _stopRange, float _p10)
		{
			unsafe {
				if (fn__taskVehicleDriveToCoord == null) fn__taskVehicleDriveToCoord = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, int, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleDriveToCoord");
				fn__taskVehicleDriveToCoord(_ped, _vehicle, _x, _y, _z, _speed, _p6, _vehicleModel, _drivingMode, _stopRange, _p10);
			}
		}

		public void TaskVehicleDriveToCoordLongrange(int _ped, int _vehicle, float _x, float _y, float _z, float _speed, int _driveMode, float _stopRange)
		{
			unsafe {
				if (fn__taskVehicleDriveToCoordLongrange == null) fn__taskVehicleDriveToCoordLongrange = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleDriveToCoordLongrange");
				fn__taskVehicleDriveToCoordLongrange(_ped, _vehicle, _x, _y, _z, _speed, _driveMode, _stopRange);
			}
		}

		public void TaskVehicleDriveWander(int _ped, int _vehicle, float _speed, int _drivingStyle)
		{
			unsafe {
				if (fn__taskVehicleDriveWander == null) fn__taskVehicleDriveWander = (delegate* unmanaged[Cdecl]<int, int, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleDriveWander");
				fn__taskVehicleDriveWander(_ped, _vehicle, _speed, _drivingStyle);
			}
		}

		public void TaskFollowToOffsetOfEntity(int _ped, int _entity, float _offsetX, float _offsetY, float _offsetZ, float _movementSpeed, int _timeout, float _stoppingRange, bool _persistFollowing)
		{
			unsafe {
				if (fn__taskFollowToOffsetOfEntity == null) fn__taskFollowToOffsetOfEntity = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, bool, void>) NativeLibrary.GetExport(handle, "Native_taskFollowToOffsetOfEntity");
				fn__taskFollowToOffsetOfEntity(_ped, _entity, _offsetX, _offsetY, _offsetZ, _movementSpeed, _timeout, _stoppingRange, _persistFollowing);
			}
		}

		public void TaskGoStraightToCoord(int _ped, float _x, float _y, float _z, float _speed, int _timeout, float _targetHeading, float _distanceToSlide)
		{
			unsafe {
				if (fn__taskGoStraightToCoord == null) fn__taskGoStraightToCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskGoStraightToCoord");
				fn__taskGoStraightToCoord(_ped, _x, _y, _z, _speed, _timeout, _targetHeading, _distanceToSlide);
			}
		}

		public void TaskGoStraightToCoordRelativeToEntity(int _entity1, int _entity2, float _p2, float _p3, float _p4, float _p5, int _p6)
		{
			unsafe {
				if (fn__taskGoStraightToCoordRelativeToEntity == null) fn__taskGoStraightToCoordRelativeToEntity = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskGoStraightToCoordRelativeToEntity");
				fn__taskGoStraightToCoordRelativeToEntity(_entity1, _entity2, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void TaskAchieveHeading(int _ped, float _heading, int _timeout)
		{
			unsafe {
				if (fn__taskAchieveHeading == null) fn__taskAchieveHeading = (delegate* unmanaged[Cdecl]<int, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskAchieveHeading");
				fn__taskAchieveHeading(_ped, _heading, _timeout);
			}
		}

		public void TaskFlushRoute()
		{
			unsafe {
				if (fn__taskFlushRoute == null) fn__taskFlushRoute = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_taskFlushRoute");
				fn__taskFlushRoute();
			}
		}

		public void TaskExtendRoute(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__taskExtendRoute == null) fn__taskExtendRoute = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskExtendRoute");
				fn__taskExtendRoute(_x, _y, _z);
			}
		}

		public void TaskFollowPointRoute(int _ped, float _speed, int _unknown)
		{
			unsafe {
				if (fn__taskFollowPointRoute == null) fn__taskFollowPointRoute = (delegate* unmanaged[Cdecl]<int, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskFollowPointRoute");
				fn__taskFollowPointRoute(_ped, _speed, _unknown);
			}
		}

		public void TaskGoToEntity(int _entity, int _target, int _duration, float _distance, float _speed, float _p5, int _p6)
		{
			unsafe {
				if (fn__taskGoToEntity == null) fn__taskGoToEntity = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskGoToEntity");
				fn__taskGoToEntity(_entity, _target, _duration, _distance, _speed, _p5, _p6);
			}
		}

		public void TaskSmartFleeCoord(int _ped, float _x, float _y, float _z, float _distance, int _time, bool _p6, bool _p7)
		{
			unsafe {
				if (fn__taskSmartFleeCoord == null) fn__taskSmartFleeCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskSmartFleeCoord");
				fn__taskSmartFleeCoord(_ped, _x, _y, _z, _distance, _time, _p6, _p7);
			}
		}

		public void TaskSmartFleePed(int _ped, int _fleeTarget, float _distance, int _fleeTime, bool _p4, bool _p5)
		{
			unsafe {
				if (fn__taskSmartFleePed == null) fn__taskSmartFleePed = (delegate* unmanaged[Cdecl]<int, int, float, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskSmartFleePed");
				fn__taskSmartFleePed(_ped, _fleeTarget, _distance, _fleeTime, _p4, _p5);
			}
		}

		public void TaskReactAndFleePed(int _ped, int _fleeTarget)
		{
			unsafe {
				if (fn__taskReactAndFleePed == null) fn__taskReactAndFleePed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskReactAndFleePed");
				fn__taskReactAndFleePed(_ped, _fleeTarget);
			}
		}

		public void TaskShockingEventReact(int _ped, int _eventHandle)
		{
			unsafe {
				if (fn__taskShockingEventReact == null) fn__taskShockingEventReact = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskShockingEventReact");
				fn__taskShockingEventReact(_ped, _eventHandle);
			}
		}

		public void TaskWanderInArea(int _ped, float _x, float _y, float _z, float _radius, float _minimalLength, float _timeBetweenWalks)
		{
			unsafe {
				if (fn__taskWanderInArea == null) fn__taskWanderInArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskWanderInArea");
				fn__taskWanderInArea(_ped, _x, _y, _z, _radius, _minimalLength, _timeBetweenWalks);
			}
		}

		public void TaskWanderStandard(int _ped, float _p1, int _p2)
		{
			unsafe {
				if (fn__taskWanderStandard == null) fn__taskWanderStandard = (delegate* unmanaged[Cdecl]<int, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskWanderStandard");
				fn__taskWanderStandard(_ped, _p1, _p2);
			}
		}

		public void TaskWanderSpecific(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__taskWanderSpecific == null) fn__taskWanderSpecific = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskWanderSpecific");
				fn__taskWanderSpecific(_p0, _p1, _p2, _p3);
			}
		}

		public void TaskVehiclePark(int _ped, int _vehicle, float _x, float _y, float _z, float _heading, int _mode, float _radius, bool _keepEngineOn)
		{
			unsafe {
				if (fn__taskVehiclePark == null) fn__taskVehiclePark = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, bool, void>) NativeLibrary.GetExport(handle, "Native_taskVehiclePark");
				fn__taskVehiclePark(_ped, _vehicle, _x, _y, _z, _heading, _mode, _radius, _keepEngineOn);
			}
		}

		public void TaskStealthKill(int _killer, int _target, int _actionType, float _p3, int _p4)
		{
			unsafe {
				if (fn__taskStealthKill == null) fn__taskStealthKill = (delegate* unmanaged[Cdecl]<int, int, int, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskStealthKill");
				fn__taskStealthKill(_killer, _target, _actionType, _p3, _p4);
			}
		}

		public void TaskPlantBomb(int _ped, float _x, float _y, float _z, float _heading)
		{
			unsafe {
				if (fn__taskPlantBomb == null) fn__taskPlantBomb = (delegate* unmanaged[Cdecl]<int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskPlantBomb");
				fn__taskPlantBomb(_ped, _x, _y, _z, _heading);
			}
		}

		public void TaskFollowNavMeshToCoord(int _ped, float _x, float _y, float _z, float _speed, int _timeout, float _stoppingRange, bool _persistFollowing, float _unk)
		{
			unsafe {
				if (fn__taskFollowNavMeshToCoord == null) fn__taskFollowNavMeshToCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, float, bool, float, void>) NativeLibrary.GetExport(handle, "Native_taskFollowNavMeshToCoord");
				fn__taskFollowNavMeshToCoord(_ped, _x, _y, _z, _speed, _timeout, _stoppingRange, _persistFollowing, _unk);
			}
		}

		public void TaskFollowNavMeshToCoordAdvanced(int _ped, float _x, float _y, float _z, float _speed, int _timeout, float _unkFloat, int _unkInt, float _unkX, float _unkY, float _unkZ, float _unk_40000f)
		{
			unsafe {
				if (fn__taskFollowNavMeshToCoordAdvanced == null) fn__taskFollowNavMeshToCoordAdvanced = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, float, int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskFollowNavMeshToCoordAdvanced");
				fn__taskFollowNavMeshToCoordAdvanced(_ped, _x, _y, _z, _speed, _timeout, _unkFloat, _unkInt, _unkX, _unkY, _unkZ, _unk_40000f);
			}
		}

		public void SetPedPathCanUseClimbovers(int _ped, bool _Toggle)
		{
			unsafe {
				if (fn__setPedPathCanUseClimbovers == null) fn__setPedPathCanUseClimbovers = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedPathCanUseClimbovers");
				fn__setPedPathCanUseClimbovers(_ped, _Toggle);
			}
		}

		public void SetPedPathCanUseLadders(int _ped, bool _Toggle)
		{
			unsafe {
				if (fn__setPedPathCanUseLadders == null) fn__setPedPathCanUseLadders = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedPathCanUseLadders");
				fn__setPedPathCanUseLadders(_ped, _Toggle);
			}
		}

		public void SetPedPathCanDropFromHeight(int _ped, bool _Toggle)
		{
			unsafe {
				if (fn__setPedPathCanDropFromHeight == null) fn__setPedPathCanDropFromHeight = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedPathCanDropFromHeight");
				fn__setPedPathCanDropFromHeight(_ped, _Toggle);
			}
		}

		public void SetPedPathClimbCostModifier(int _ped, float _modifier)
		{
			unsafe {
				if (fn__setPedPathClimbCostModifier == null) fn__setPedPathClimbCostModifier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedPathClimbCostModifier");
				fn__setPedPathClimbCostModifier(_ped, _modifier);
			}
		}

		public void SetPedPathMayEnterWater(int _ped, bool _mayEnterWater)
		{
			unsafe {
				if (fn__setPedPathMayEnterWater == null) fn__setPedPathMayEnterWater = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedPathMayEnterWater");
				fn__setPedPathMayEnterWater(_ped, _mayEnterWater);
			}
		}

		public void SetPedPathPreferToAvoidWater(int _ped, bool _avoidWater)
		{
			unsafe {
				if (fn__setPedPathPreferToAvoidWater == null) fn__setPedPathPreferToAvoidWater = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedPathPreferToAvoidWater");
				fn__setPedPathPreferToAvoidWater(_ped, _avoidWater);
			}
		}

		public void SetPedPathAvoidFire(int _ped, bool _avoidFire)
		{
			unsafe {
				if (fn__setPedPathAvoidFire == null) fn__setPedPathAvoidFire = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedPathAvoidFire");
				fn__setPedPathAvoidFire(_ped, _avoidFire);
			}
		}

		public void SetGlobalMinBirdFlightHeight(float _height)
		{
			unsafe {
				if (fn__setGlobalMinBirdFlightHeight == null) fn__setGlobalMinBirdFlightHeight = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setGlobalMinBirdFlightHeight");
				fn__setGlobalMinBirdFlightHeight(_height);
			}
		}

		public int GetNavmeshRouteDistanceRemaining(int _ped, ref float _distanceRemaining, ref bool _isPathReady)
		{
			unsafe {
				if (fn__getNavmeshRouteDistanceRemaining == null) fn__getNavmeshRouteDistanceRemaining = (delegate* unmanaged[Cdecl]<int, float*, bool*, int>) NativeLibrary.GetExport(handle, "Native_getNavmeshRouteDistanceRemaining");
				var ref_distanceRemaining = _distanceRemaining;
				var ref_isPathReady = _isPathReady;
				var result = fn__getNavmeshRouteDistanceRemaining(_ped, &ref_distanceRemaining, &ref_isPathReady);
				_distanceRemaining = ref_distanceRemaining;
				_isPathReady = ref_isPathReady;
				return result;
			}
		}

		public int GetNavmeshRouteResult(int _ped)
		{
			unsafe {
				if (fn__getNavmeshRouteResult == null) fn__getNavmeshRouteResult = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNavmeshRouteResult");
				var result = fn__getNavmeshRouteResult(_ped);
				return result;
			}
		}

		public bool _0x3E38E28A1D80DDF6(int _ped)
		{
			unsafe {
				if (fn__0x3E38E28A1D80DDF6 == null) fn__0x3E38E28A1D80DDF6 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0x3E38E28A1D80DDF6");
				var result = fn__0x3E38E28A1D80DDF6(_ped);
				return result;
			}
		}

		public void TaskGoToCoordAnyMeans(int _ped, float _x, float _y, float _z, float _speed, int _p5, bool _p6, int _walkingStyle, float _p8)
		{
			unsafe {
				if (fn__taskGoToCoordAnyMeans == null) fn__taskGoToCoordAnyMeans = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, bool, int, float, void>) NativeLibrary.GetExport(handle, "Native_taskGoToCoordAnyMeans");
				fn__taskGoToCoordAnyMeans(_ped, _x, _y, _z, _speed, _p5, _p6, _walkingStyle, _p8);
			}
		}

		public void TaskGoToCoordAnyMeansExtraParams(int _ped, float _x, float _y, float _z, float _speed, int _p5, bool _p6, int _walkingStyle, float _p8, int _p9, int _p10, int _p11, int _p12)
		{
			unsafe {
				if (fn__taskGoToCoordAnyMeansExtraParams == null) fn__taskGoToCoordAnyMeansExtraParams = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, bool, int, float, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskGoToCoordAnyMeansExtraParams");
				fn__taskGoToCoordAnyMeansExtraParams(_ped, _x, _y, _z, _speed, _p5, _p6, _walkingStyle, _p8, _p9, _p10, _p11, _p12);
			}
		}

		public void TaskGoToCoordAnyMeansExtraParamsWithCruiseSpeed(int _ped, float _x, float _y, float _z, float _speed, int _p5, bool _p6, int _walkingStyle, float _p8, int _p9, int _p10, int _p11, int _p12, int _p13)
		{
			unsafe {
				if (fn__taskGoToCoordAnyMeansExtraParamsWithCruiseSpeed == null) fn__taskGoToCoordAnyMeansExtraParamsWithCruiseSpeed = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, bool, int, float, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskGoToCoordAnyMeansExtraParamsWithCruiseSpeed");
				fn__taskGoToCoordAnyMeansExtraParamsWithCruiseSpeed(_ped, _x, _y, _z, _speed, _p5, _p6, _walkingStyle, _p8, _p9, _p10, _p11, _p12, _p13);
			}
		}

		public void TaskPlayAnim(int _ped, string _animDictionary, string _animationName, float _blendInSpeed, float _blendOutSpeed, int _duration, int _flag, float _playbackRate, bool _lockX, bool _lockY, bool _lockZ)
		{
			unsafe {
				if (fn__taskPlayAnim == null) fn__taskPlayAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, float, float, int, int, float, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskPlayAnim");
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var ptr_animationName = MemoryUtils.StringToHGlobalUtf8(_animationName);
				fn__taskPlayAnim(_ped, ptr_animDictionary, ptr_animationName, _blendInSpeed, _blendOutSpeed, _duration, _flag, _playbackRate, _lockX, _lockY, _lockZ);
				Marshal.FreeHGlobal(ptr_animDictionary);
				Marshal.FreeHGlobal(ptr_animationName);
			}
		}

		public void TaskPlayAnimAdvanced(int _ped, string _animDict, string _animName, float _posX, float _posY, float _posZ, float _rotX, float _rotY, float _rotZ, float _animEnterSpeed, float _animExitSpeed, int _duration, int _flag, float _animTime, int _p14, int _p15)
		{
			unsafe {
				if (fn__taskPlayAnimAdvanced == null) fn__taskPlayAnimAdvanced = (delegate* unmanaged[Cdecl]<int, nint, nint, float, float, float, float, float, float, float, float, int, int, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskPlayAnimAdvanced");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				fn__taskPlayAnimAdvanced(_ped, ptr_animDict, ptr_animName, _posX, _posY, _posZ, _rotX, _rotY, _rotZ, _animEnterSpeed, _animExitSpeed, _duration, _flag, _animTime, _p14, _p15);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
			}
		}

		public void StopAnimTask(int _ped, string _animDictionary, string _animationName, float _p3)
		{
			unsafe {
				if (fn__stopAnimTask == null) fn__stopAnimTask = (delegate* unmanaged[Cdecl]<int, nint, nint, float, void>) NativeLibrary.GetExport(handle, "Native_stopAnimTask");
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var ptr_animationName = MemoryUtils.StringToHGlobalUtf8(_animationName);
				fn__stopAnimTask(_ped, ptr_animDictionary, ptr_animationName, _p3);
				Marshal.FreeHGlobal(ptr_animDictionary);
				Marshal.FreeHGlobal(ptr_animationName);
			}
		}

		public void TaskScriptedAnimation(int _ped, ref int _p1, ref int _p2, ref int _p3, float _p4, float _p5)
		{
			unsafe {
				if (fn__taskScriptedAnimation == null) fn__taskScriptedAnimation = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskScriptedAnimation");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				fn__taskScriptedAnimation(_ped, &ref_p1, &ref_p2, &ref_p3, _p4, _p5);
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
			}
		}

		public void PlayEntityScriptedAnim(int _p0, ref int _p1, ref int _p2, ref int _p3, float _p4, float _p5)
		{
			unsafe {
				if (fn__playEntityScriptedAnim == null) fn__playEntityScriptedAnim = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, float, float, void>) NativeLibrary.GetExport(handle, "Native_playEntityScriptedAnim");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				fn__playEntityScriptedAnim(_p0, &ref_p1, &ref_p2, &ref_p3, _p4, _p5);
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
			}
		}

		public void StopAnimPlayback(int _ped, int _p1, bool _p2)
		{
			unsafe {
				if (fn__stopAnimPlayback == null) fn__stopAnimPlayback = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_stopAnimPlayback");
				fn__stopAnimPlayback(_ped, _p1, _p2);
			}
		}

		public void SetAnimWeight(int _p0, float _p1, int _p2, int _p3, bool _p4)
		{
			unsafe {
				if (fn__setAnimWeight == null) fn__setAnimWeight = (delegate* unmanaged[Cdecl]<int, float, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setAnimWeight");
				fn__setAnimWeight(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void SetAnimPlaybackTime(int _entity, float _p1, int _p2, bool _p3)
		{
			unsafe {
				if (fn__setAnimPlaybackTime == null) fn__setAnimPlaybackTime = (delegate* unmanaged[Cdecl]<int, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setAnimPlaybackTime");
				fn__setAnimPlaybackTime(_entity, _p1, _p2, _p3);
			}
		}

		public void SetAnimRate(int _p0, float _p1, int _p2, bool _p3)
		{
			unsafe {
				if (fn__setAnimRate == null) fn__setAnimRate = (delegate* unmanaged[Cdecl]<int, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setAnimRate");
				fn__setAnimRate(_p0, _p1, _p2, _p3);
			}
		}

		public void SetAnimLooped(int _p0, bool _p1, int _p2, bool _p3)
		{
			unsafe {
				if (fn__setAnimLooped == null) fn__setAnimLooped = (delegate* unmanaged[Cdecl]<int, bool, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setAnimLooped");
				fn__setAnimLooped(_p0, _p1, _p2, _p3);
			}
		}

		public void TaskPlayPhoneGestureAnimation(int _ped, string _animDict, string _animation, string _boneMaskType, float _p4, float _p5, bool _p6, bool _p7)
		{
			unsafe {
				if (fn__taskPlayPhoneGestureAnimation == null) fn__taskPlayPhoneGestureAnimation = (delegate* unmanaged[Cdecl]<int, nint, nint, nint, float, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskPlayPhoneGestureAnimation");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animation = MemoryUtils.StringToHGlobalUtf8(_animation);
				var ptr_boneMaskType = MemoryUtils.StringToHGlobalUtf8(_boneMaskType);
				fn__taskPlayPhoneGestureAnimation(_ped, ptr_animDict, ptr_animation, ptr_boneMaskType, _p4, _p5, _p6, _p7);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animation);
				Marshal.FreeHGlobal(ptr_boneMaskType);
			}
		}

		public void TaskStopPhoneGestureAnimation(int _ped, int _p1)
		{
			unsafe {
				if (fn__taskStopPhoneGestureAnimation == null) fn__taskStopPhoneGestureAnimation = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskStopPhoneGestureAnimation");
				fn__taskStopPhoneGestureAnimation(_ped, _p1);
			}
		}

		public bool IsPlayingPhoneGestureAnim(int _ped)
		{
			unsafe {
				if (fn__isPlayingPhoneGestureAnim == null) fn__isPlayingPhoneGestureAnim = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlayingPhoneGestureAnim");
				var result = fn__isPlayingPhoneGestureAnim(_ped);
				return result;
			}
		}

		public float GetPhoneGestureAnimCurrentTime(int _ped)
		{
			unsafe {
				if (fn__getPhoneGestureAnimCurrentTime == null) fn__getPhoneGestureAnimCurrentTime = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPhoneGestureAnimCurrentTime");
				var result = fn__getPhoneGestureAnimCurrentTime(_ped);
				return result;
			}
		}

		public float GetPhoneGestureAnimTotalTime(int _ped)
		{
			unsafe {
				if (fn__getPhoneGestureAnimTotalTime == null) fn__getPhoneGestureAnimTotalTime = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPhoneGestureAnimTotalTime");
				var result = fn__getPhoneGestureAnimTotalTime(_ped);
				return result;
			}
		}

		public void TaskVehiclePlayAnim(int _vehicle, string _animationSet, string _animationName)
		{
			unsafe {
				if (fn__taskVehiclePlayAnim == null) fn__taskVehiclePlayAnim = (delegate* unmanaged[Cdecl]<int, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_taskVehiclePlayAnim");
				var ptr_animationSet = MemoryUtils.StringToHGlobalUtf8(_animationSet);
				var ptr_animationName = MemoryUtils.StringToHGlobalUtf8(_animationName);
				fn__taskVehiclePlayAnim(_vehicle, ptr_animationSet, ptr_animationName);
				Marshal.FreeHGlobal(ptr_animationSet);
				Marshal.FreeHGlobal(ptr_animationName);
			}
		}

		public void TaskLookAtCoord(int _entity, float _x, float _y, float _z, int _duration, int _p5, int _p6)
		{
			unsafe {
				if (fn__taskLookAtCoord == null) fn__taskLookAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskLookAtCoord");
				fn__taskLookAtCoord(_entity, _x, _y, _z, _duration, _p5, _p6);
			}
		}

		public void TaskLookAtEntity(int _ped, int _lookAt, int _duration, int _unknown1, int _unknown2)
		{
			unsafe {
				if (fn__taskLookAtEntity == null) fn__taskLookAtEntity = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskLookAtEntity");
				fn__taskLookAtEntity(_ped, _lookAt, _duration, _unknown1, _unknown2);
			}
		}

		public void TaskClearLookAt(int _ped)
		{
			unsafe {
				if (fn__taskClearLookAt == null) fn__taskClearLookAt = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_taskClearLookAt");
				fn__taskClearLookAt(_ped);
			}
		}

		public void OpenSequenceTask(ref int _taskSequenceId)
		{
			unsafe {
				if (fn__openSequenceTask == null) fn__openSequenceTask = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_openSequenceTask");
				var ref_taskSequenceId = _taskSequenceId;
				fn__openSequenceTask(&ref_taskSequenceId);
				_taskSequenceId = ref_taskSequenceId;
			}
		}

		public void CloseSequenceTask(int _taskSequenceId)
		{
			unsafe {
				if (fn__closeSequenceTask == null) fn__closeSequenceTask = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_closeSequenceTask");
				fn__closeSequenceTask(_taskSequenceId);
			}
		}

		public void TaskPerformSequence(int _ped, int _taskSequenceId)
		{
			unsafe {
				if (fn__taskPerformSequence == null) fn__taskPerformSequence = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskPerformSequence");
				fn__taskPerformSequence(_ped, _taskSequenceId);
			}
		}

		public void TaskPerformSequenceLocally(int _ped, int _taskSequenceId)
		{
			unsafe {
				if (fn__taskPerformSequenceLocally == null) fn__taskPerformSequenceLocally = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskPerformSequenceLocally");
				fn__taskPerformSequenceLocally(_ped, _taskSequenceId);
			}
		}

		public void ClearSequenceTask(ref int _taskSequenceId)
		{
			unsafe {
				if (fn__clearSequenceTask == null) fn__clearSequenceTask = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_clearSequenceTask");
				var ref_taskSequenceId = _taskSequenceId;
				fn__clearSequenceTask(&ref_taskSequenceId);
				_taskSequenceId = ref_taskSequenceId;
			}
		}

		public void SetSequenceToRepeat(int _taskSequenceId, bool _repeat)
		{
			unsafe {
				if (fn__setSequenceToRepeat == null) fn__setSequenceToRepeat = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setSequenceToRepeat");
				fn__setSequenceToRepeat(_taskSequenceId, _repeat);
			}
		}

		public int GetSequenceProgress(int _ped)
		{
			unsafe {
				if (fn__getSequenceProgress == null) fn__getSequenceProgress = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getSequenceProgress");
				var result = fn__getSequenceProgress(_ped);
				return result;
			}
		}

		public bool GetIsTaskActive(int _ped, int _taskIndex)
		{
			unsafe {
				if (fn__getIsTaskActive == null) fn__getIsTaskActive = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_getIsTaskActive");
				var result = fn__getIsTaskActive(_ped, _taskIndex);
				return result;
			}
		}

		public int GetScriptTaskStatus(int _ped, int _taskHash)
		{
			unsafe {
				if (fn__getScriptTaskStatus == null) fn__getScriptTaskStatus = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getScriptTaskStatus");
				var result = fn__getScriptTaskStatus(_ped, _taskHash);
				return result;
			}
		}

		public int GetActiveVehicleMissionType(int _vehicle)
		{
			unsafe {
				if (fn__getActiveVehicleMissionType == null) fn__getActiveVehicleMissionType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getActiveVehicleMissionType");
				var result = fn__getActiveVehicleMissionType(_vehicle);
				return result;
			}
		}

		public void TaskLeaveAnyVehicle(int _ped, int _p1, int _flags)
		{
			unsafe {
				if (fn__taskLeaveAnyVehicle == null) fn__taskLeaveAnyVehicle = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskLeaveAnyVehicle");
				fn__taskLeaveAnyVehicle(_ped, _p1, _flags);
			}
		}

		public void TaskAimGunScripted(int _ped, int _scriptTask, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__taskAimGunScripted == null) fn__taskAimGunScripted = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskAimGunScripted");
				fn__taskAimGunScripted(_ped, _scriptTask, _p2, _p3);
			}
		}

		public void TaskAimGunScriptedWithTarget(int _p0, int _p1, float _p2, float _p3, float _p4, int _p5, bool _p6, bool _p7)
		{
			unsafe {
				if (fn__taskAimGunScriptedWithTarget == null) fn__taskAimGunScriptedWithTarget = (delegate* unmanaged[Cdecl]<int, int, float, float, float, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskAimGunScriptedWithTarget");
				fn__taskAimGunScriptedWithTarget(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
			}
		}

		public void UpdateTaskAimGunScriptedTarget(int _p0, int _p1, float _p2, float _p3, float _p4, bool _p5)
		{
			unsafe {
				if (fn__updateTaskAimGunScriptedTarget == null) fn__updateTaskAimGunScriptedTarget = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_updateTaskAimGunScriptedTarget");
				fn__updateTaskAimGunScriptedTarget(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public string GetClipSetForScriptedGunTask(int _p0)
		{
			unsafe {
				if (fn__getClipSetForScriptedGunTask == null) fn__getClipSetForScriptedGunTask = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getClipSetForScriptedGunTask");
				var result = fn__getClipSetForScriptedGunTask(_p0);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void TaskAimGunAtEntity(int _ped, int _entity, int _duration, bool _p3)
		{
			unsafe {
				if (fn__taskAimGunAtEntity == null) fn__taskAimGunAtEntity = (delegate* unmanaged[Cdecl]<int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskAimGunAtEntity");
				fn__taskAimGunAtEntity(_ped, _entity, _duration, _p3);
			}
		}

		public void TaskTurnPedToFaceEntity(int _ped, int _entity, int _duration)
		{
			unsafe {
				if (fn__taskTurnPedToFaceEntity == null) fn__taskTurnPedToFaceEntity = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskTurnPedToFaceEntity");
				fn__taskTurnPedToFaceEntity(_ped, _entity, _duration);
			}
		}

		public void TaskAimGunAtCoord(int _ped, float _x, float _y, float _z, int _time, bool _p5, bool _p6)
		{
			unsafe {
				if (fn__taskAimGunAtCoord == null) fn__taskAimGunAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskAimGunAtCoord");
				fn__taskAimGunAtCoord(_ped, _x, _y, _z, _time, _p5, _p6);
			}
		}

		public void TaskShootAtCoord(int _ped, float _x, float _y, float _z, int _duration, int _firingPattern)
		{
			unsafe {
				if (fn__taskShootAtCoord == null) fn__taskShootAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskShootAtCoord");
				fn__taskShootAtCoord(_ped, _x, _y, _z, _duration, _firingPattern);
			}
		}

		public void TaskShuffleToNextVehicleSeat(int _ped, int _vehicle, int _p2)
		{
			unsafe {
				if (fn__taskShuffleToNextVehicleSeat == null) fn__taskShuffleToNextVehicleSeat = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskShuffleToNextVehicleSeat");
				fn__taskShuffleToNextVehicleSeat(_ped, _vehicle, _p2);
			}
		}

		public void ClearPedTasks(int _ped)
		{
			unsafe {
				if (fn__clearPedTasks == null) fn__clearPedTasks = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedTasks");
				fn__clearPedTasks(_ped);
			}
		}

		public void ClearPedSecondaryTask(int _ped)
		{
			unsafe {
				if (fn__clearPedSecondaryTask == null) fn__clearPedSecondaryTask = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedSecondaryTask");
				fn__clearPedSecondaryTask(_ped);
			}
		}

		public void TaskEveryoneLeaveVehicle(int _vehicle)
		{
			unsafe {
				if (fn__taskEveryoneLeaveVehicle == null) fn__taskEveryoneLeaveVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_taskEveryoneLeaveVehicle");
				fn__taskEveryoneLeaveVehicle(_vehicle);
			}
		}

		public void TaskGotoEntityOffset(int _ped, int _p1, int _p2, float _x, float _y, float _z, int _duration)
		{
			unsafe {
				if (fn__taskGotoEntityOffset == null) fn__taskGotoEntityOffset = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskGotoEntityOffset");
				fn__taskGotoEntityOffset(_ped, _p1, _p2, _x, _y, _z, _duration);
			}
		}

		public void TaskGotoEntityOffsetXy(int _p0, int _oed, int _duration, float _p3, float _p4, float _p5, float _p6, bool _p7)
		{
			unsafe {
				if (fn__taskGotoEntityOffsetXy == null) fn__taskGotoEntityOffsetXy = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_taskGotoEntityOffsetXy");
				fn__taskGotoEntityOffsetXy(_p0, _oed, _duration, _p3, _p4, _p5, _p6, _p7);
			}
		}

		public void TaskTurnPedToFaceCoord(int _ped, float _x, float _y, float _z, int _duration)
		{
			unsafe {
				if (fn__taskTurnPedToFaceCoord == null) fn__taskTurnPedToFaceCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskTurnPedToFaceCoord");
				fn__taskTurnPedToFaceCoord(_ped, _x, _y, _z, _duration);
			}
		}

		public void TaskVehicleTempAction(int _driver, int _vehicle, int _action, int _time)
		{
			unsafe {
				if (fn__taskVehicleTempAction == null) fn__taskVehicleTempAction = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleTempAction");
				fn__taskVehicleTempAction(_driver, _vehicle, _action, _time);
			}
		}

		public void TaskVehicleMission(int _driver, int _vehicle, int _vehicleTarget, int _missionType, float _p4, int _p5, float _p6, float _p7, bool _DriveAgainstTraffic)
		{
			unsafe {
				if (fn__taskVehicleMission == null) fn__taskVehicleMission = (delegate* unmanaged[Cdecl]<int, int, int, int, float, int, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleMission");
				fn__taskVehicleMission(_driver, _vehicle, _vehicleTarget, _missionType, _p4, _p5, _p6, _p7, _DriveAgainstTraffic);
			}
		}

		public void TaskVehicleMissionPedTarget(int _ped, int _vehicle, int _pedTarget, int _missionType, float _maxSpeed, int _drivingStyle, float _minDistance, float _p7, bool _DriveAgainstTraffic)
		{
			unsafe {
				if (fn__taskVehicleMissionPedTarget == null) fn__taskVehicleMissionPedTarget = (delegate* unmanaged[Cdecl]<int, int, int, int, float, int, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleMissionPedTarget");
				fn__taskVehicleMissionPedTarget(_ped, _vehicle, _pedTarget, _missionType, _maxSpeed, _drivingStyle, _minDistance, _p7, _DriveAgainstTraffic);
			}
		}

		public void TaskVehicleMissionCoorsTarget(int _ped, int _vehicle, float _x, float _y, float _z, int _p5, int _p6, int _p7, float _p8, float _p9, bool _DriveAgainstTraffic)
		{
			unsafe {
				if (fn__taskVehicleMissionCoorsTarget == null) fn__taskVehicleMissionCoorsTarget = (delegate* unmanaged[Cdecl]<int, int, float, float, float, int, int, int, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleMissionCoorsTarget");
				fn__taskVehicleMissionCoorsTarget(_ped, _vehicle, _x, _y, _z, _p5, _p6, _p7, _p8, _p9, _DriveAgainstTraffic);
			}
		}

		public void TaskVehicleEscort(int _ped, int _vehicle, int _targetVehicle, int _mode, float _speed, int _drivingStyle, float _minDistance, int _p7, float _noRoadsDistance)
		{
			unsafe {
				if (fn__taskVehicleEscort == null) fn__taskVehicleEscort = (delegate* unmanaged[Cdecl]<int, int, int, int, float, int, float, int, float, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleEscort");
				fn__taskVehicleEscort(_ped, _vehicle, _targetVehicle, _mode, _speed, _drivingStyle, _minDistance, _p7, _noRoadsDistance);
			}
		}

		public void TaskVehicleFollow(int _driver, int _vehicle, int _targetEntity, float _speed, int _drivingStyle, int _minDistance)
		{
			unsafe {
				if (fn__taskVehicleFollow == null) fn__taskVehicleFollow = (delegate* unmanaged[Cdecl]<int, int, int, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleFollow");
				fn__taskVehicleFollow(_driver, _vehicle, _targetEntity, _speed, _drivingStyle, _minDistance);
			}
		}

		public void TaskVehicleChase(int _driver, int _targetEnt)
		{
			unsafe {
				if (fn__taskVehicleChase == null) fn__taskVehicleChase = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleChase");
				fn__taskVehicleChase(_driver, _targetEnt);
			}
		}

		public void TaskVehicleHeliProtect(int _pilot, int _vehicle, int _entityToFollow, float _targetSpeed, int _p4, float _radius, int _altitude, int _p7)
		{
			unsafe {
				if (fn__taskVehicleHeliProtect == null) fn__taskVehicleHeliProtect = (delegate* unmanaged[Cdecl]<int, int, int, float, int, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleHeliProtect");
				fn__taskVehicleHeliProtect(_pilot, _vehicle, _entityToFollow, _targetSpeed, _p4, _radius, _altitude, _p7);
			}
		}

		public void SetTaskVehicleChaseBehaviorFlag(int _ped, int _flag, bool _set)
		{
			unsafe {
				if (fn__setTaskVehicleChaseBehaviorFlag == null) fn__setTaskVehicleChaseBehaviorFlag = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setTaskVehicleChaseBehaviorFlag");
				fn__setTaskVehicleChaseBehaviorFlag(_ped, _flag, _set);
			}
		}

		public void SetTaskVehicleChaseIdealPursuitDistance(int _ped, float _distance)
		{
			unsafe {
				if (fn__setTaskVehicleChaseIdealPursuitDistance == null) fn__setTaskVehicleChaseIdealPursuitDistance = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setTaskVehicleChaseIdealPursuitDistance");
				fn__setTaskVehicleChaseIdealPursuitDistance(_ped, _distance);
			}
		}

		public void TaskHeliChase(int _pilot, int _entityToFollow, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__taskHeliChase == null) fn__taskHeliChase = (delegate* unmanaged[Cdecl]<int, int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskHeliChase");
				fn__taskHeliChase(_pilot, _entityToFollow, _x, _y, _z);
			}
		}

		public void TaskPlaneChase(int _pilot, int _entityToFollow, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__taskPlaneChase == null) fn__taskPlaneChase = (delegate* unmanaged[Cdecl]<int, int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskPlaneChase");
				fn__taskPlaneChase(_pilot, _entityToFollow, _x, _y, _z);
			}
		}

		public void TaskPlaneLand(int _pilot, int _plane, float _runwayStartX, float _runwayStartY, float _runwayStartZ, float _runwayEndX, float _runwayEndY, float _runwayEndZ)
		{
			unsafe {
				if (fn__taskPlaneLand == null) fn__taskPlaneLand = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskPlaneLand");
				fn__taskPlaneLand(_pilot, _plane, _runwayStartX, _runwayStartY, _runwayStartZ, _runwayEndX, _runwayEndY, _runwayEndZ);
			}
		}

		public void _0x6100B3CEFD43452E(int _p0)
		{
			unsafe {
				if (fn__0x6100B3CEFD43452E == null) fn__0x6100B3CEFD43452E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x6100B3CEFD43452E");
				fn__0x6100B3CEFD43452E(_p0);
			}
		}

		public void ClearVehicleTasks(int _vehicle)
		{
			unsafe {
				if (fn__clearVehicleTasks == null) fn__clearVehicleTasks = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearVehicleTasks");
				fn__clearVehicleTasks(_vehicle);
			}
		}

		public void _0x53DDC75BC3AC0A90(int _vehicle)
		{
			unsafe {
				if (fn__0x53DDC75BC3AC0A90 == null) fn__0x53DDC75BC3AC0A90 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x53DDC75BC3AC0A90");
				fn__0x53DDC75BC3AC0A90(_vehicle);
			}
		}

		public void TaskPlaneGotoPreciseVtol(int _ped, int _vehicle, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__taskPlaneGotoPreciseVtol == null) fn__taskPlaneGotoPreciseVtol = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskPlaneGotoPreciseVtol");
				fn__taskPlaneGotoPreciseVtol(_ped, _vehicle, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void TaskSubmarineGotoAndStop(int _p0, int _submarine, float _x, float _y, float _z, int _p5)
		{
			unsafe {
				if (fn__taskSubmarineGotoAndStop == null) fn__taskSubmarineGotoAndStop = (delegate* unmanaged[Cdecl]<int, int, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskSubmarineGotoAndStop");
				fn__taskSubmarineGotoAndStop(_p0, _submarine, _x, _y, _z, _p5);
			}
		}

		public void TaskHeliMission(int _pilot, int _aircraft, int _targetVehicle, int _targetPed, float _destinationX, float _destinationY, float _destinationZ, int _missionFlag, float _maxSpeed, float _radius, float _targetHeading, int _maxHeight, int _minHeight, float _unk3, int _behaviorFlags)
		{
			unsafe {
				if (fn__taskHeliMission == null) fn__taskHeliMission = (delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, int, float, float, float, int, int, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskHeliMission");
				fn__taskHeliMission(_pilot, _aircraft, _targetVehicle, _targetPed, _destinationX, _destinationY, _destinationZ, _missionFlag, _maxSpeed, _radius, _targetHeading, _maxHeight, _minHeight, _unk3, _behaviorFlags);
			}
		}

		public void TaskHeliEscortHeli(int _pilot, int _heli1, int _heli2, float _p3, float _p4, float _p5)
		{
			unsafe {
				if (fn__taskHeliEscortHeli == null) fn__taskHeliEscortHeli = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskHeliEscortHeli");
				fn__taskHeliEscortHeli(_pilot, _heli1, _heli2, _p3, _p4, _p5);
			}
		}

		public void TaskPlaneMission(int _pilot, int _aircraft, int _targetVehicle, int _targetPed, float _destinationX, float _destinationY, float _destinationZ, int _missionFlag, float _angularDrag, float _unk, float _targetHeading, float _maxZ, float _minZ, int _p13)
		{
			unsafe {
				if (fn__taskPlaneMission == null) fn__taskPlaneMission = (delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, int, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskPlaneMission");
				fn__taskPlaneMission(_pilot, _aircraft, _targetVehicle, _targetPed, _destinationX, _destinationY, _destinationZ, _missionFlag, _angularDrag, _unk, _targetHeading, _maxZ, _minZ, _p13);
			}
		}

		public void TaskPlaneTaxi(int _pilot, int _aircraft, int _p2, int _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__taskPlaneTaxi == null) fn__taskPlaneTaxi = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskPlaneTaxi");
				fn__taskPlaneTaxi(_pilot, _aircraft, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void TaskBoatMission(int _pedDriver, int _boat, int _p2, int _p3, float _x, float _y, float _z, int _p7, float _maxSpeed, int _drivingStyle, float _p10, int _p11)
		{
			unsafe {
				if (fn__taskBoatMission == null) fn__taskBoatMission = (delegate* unmanaged[Cdecl]<int, int, int, int, float, float, float, int, float, int, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskBoatMission");
				fn__taskBoatMission(_pedDriver, _boat, _p2, _p3, _x, _y, _z, _p7, _maxSpeed, _drivingStyle, _p10, _p11);
			}
		}

		public void TaskDriveBy(int _driverPed, int _targetPed, int _targetVehicle, float _targetX, float _targetY, float _targetZ, float _distanceToShoot, int _pedAccuracy, bool _p8, int _firingPattern)
		{
			unsafe {
				if (fn__taskDriveBy == null) fn__taskDriveBy = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_taskDriveBy");
				fn__taskDriveBy(_driverPed, _targetPed, _targetVehicle, _targetX, _targetY, _targetZ, _distanceToShoot, _pedAccuracy, _p8, _firingPattern);
			}
		}

		public void SetDrivebyTaskTarget(int _shootingPed, int _targetPed, int _targetVehicle, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setDrivebyTaskTarget == null) fn__setDrivebyTaskTarget = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setDrivebyTaskTarget");
				fn__setDrivebyTaskTarget(_shootingPed, _targetPed, _targetVehicle, _x, _y, _z);
			}
		}

		public void ClearDrivebyTaskUnderneathDrivingTask(int _ped)
		{
			unsafe {
				if (fn__clearDrivebyTaskUnderneathDrivingTask == null) fn__clearDrivebyTaskUnderneathDrivingTask = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearDrivebyTaskUnderneathDrivingTask");
				fn__clearDrivebyTaskUnderneathDrivingTask(_ped);
			}
		}

		public bool IsDrivebyTaskUnderneathDrivingTask(int _ped)
		{
			unsafe {
				if (fn__isDrivebyTaskUnderneathDrivingTask == null) fn__isDrivebyTaskUnderneathDrivingTask = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isDrivebyTaskUnderneathDrivingTask");
				var result = fn__isDrivebyTaskUnderneathDrivingTask(_ped);
				return result;
			}
		}

		public bool ControlMountedWeapon(int _ped)
		{
			unsafe {
				if (fn__controlMountedWeapon == null) fn__controlMountedWeapon = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_controlMountedWeapon");
				var result = fn__controlMountedWeapon(_ped);
				return result;
			}
		}

		public void SetMountedWeaponTarget(int _shootingPed, int _targetPed, int _targetVehicle, float _x, float _y, float _z, int _p6, int _p7)
		{
			unsafe {
				if (fn__setMountedWeaponTarget == null) fn__setMountedWeaponTarget = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_setMountedWeaponTarget");
				fn__setMountedWeaponTarget(_shootingPed, _targetPed, _targetVehicle, _x, _y, _z, _p6, _p7);
			}
		}

		public bool IsMountedWeaponTaskUnderneathDrivingTask(int _ped)
		{
			unsafe {
				if (fn__isMountedWeaponTaskUnderneathDrivingTask == null) fn__isMountedWeaponTaskUnderneathDrivingTask = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMountedWeaponTaskUnderneathDrivingTask");
				var result = fn__isMountedWeaponTaskUnderneathDrivingTask(_ped);
				return result;
			}
		}

		public void TaskUseMobilePhone(int _ped, int _p1, int _p2)
		{
			unsafe {
				if (fn__taskUseMobilePhone == null) fn__taskUseMobilePhone = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskUseMobilePhone");
				fn__taskUseMobilePhone(_ped, _p1, _p2);
			}
		}

		public void TaskUseMobilePhoneTimed(int _ped, int _duration)
		{
			unsafe {
				if (fn__taskUseMobilePhoneTimed == null) fn__taskUseMobilePhoneTimed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskUseMobilePhoneTimed");
				fn__taskUseMobilePhoneTimed(_ped, _duration);
			}
		}

		public void TaskChatToPed(int _ped, int _target, int _p2, float _p3, float _p4, float _p5, float _p6, float _p7)
		{
			unsafe {
				if (fn__taskChatToPed == null) fn__taskChatToPed = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskChatToPed");
				fn__taskChatToPed(_ped, _target, _p2, _p3, _p4, _p5, _p6, _p7);
			}
		}

		public void TaskWarpPedIntoVehicle(int _ped, int _vehicle, int _seat)
		{
			unsafe {
				if (fn__taskWarpPedIntoVehicle == null) fn__taskWarpPedIntoVehicle = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskWarpPedIntoVehicle");
				fn__taskWarpPedIntoVehicle(_ped, _vehicle, _seat);
			}
		}

		public void TaskShootAtEntity(int _entity, int _target, int _duration, int _firingPattern)
		{
			unsafe {
				if (fn__taskShootAtEntity == null) fn__taskShootAtEntity = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskShootAtEntity");
				fn__taskShootAtEntity(_entity, _target, _duration, _firingPattern);
			}
		}

		public void TaskClimb(int _ped, bool _unused)
		{
			unsafe {
				if (fn__taskClimb == null) fn__taskClimb = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskClimb");
				fn__taskClimb(_ped, _unused);
			}
		}

		public void TaskClimbLadder(int _ped, int _p1)
		{
			unsafe {
				if (fn__taskClimbLadder == null) fn__taskClimbLadder = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskClimbLadder");
				fn__taskClimbLadder(_ped, _p1);
			}
		}

		public void TaskRappelDownWall(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9, int _p10)
		{
			unsafe {
				if (fn__taskRappelDownWall == null) fn__taskRappelDownWall = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskRappelDownWall");
				fn__taskRappelDownWall(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10);
			}
		}

		public int _0x9D252648778160DF(int _p0)
		{
			unsafe {
				if (fn__0x9D252648778160DF == null) fn__0x9D252648778160DF = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x9D252648778160DF");
				var result = fn__0x9D252648778160DF(_p0);
				return result;
			}
		}

		public void ClearPedTasksImmediately(int _ped)
		{
			unsafe {
				if (fn__clearPedTasksImmediately == null) fn__clearPedTasksImmediately = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedTasksImmediately");
				fn__clearPedTasksImmediately(_ped);
			}
		}

		public void TaskPerformSequenceFromProgress(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__taskPerformSequenceFromProgress == null) fn__taskPerformSequenceFromProgress = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskPerformSequenceFromProgress");
				fn__taskPerformSequenceFromProgress(_p0, _p1, _p2, _p3);
			}
		}

		public void SetNextDesiredMoveState(float _p0)
		{
			unsafe {
				if (fn__setNextDesiredMoveState == null) fn__setNextDesiredMoveState = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setNextDesiredMoveState");
				fn__setNextDesiredMoveState(_p0);
			}
		}

		public void SetPedDesiredMoveBlendRatio(int _ped, float _p1)
		{
			unsafe {
				if (fn__setPedDesiredMoveBlendRatio == null) fn__setPedDesiredMoveBlendRatio = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPedDesiredMoveBlendRatio");
				fn__setPedDesiredMoveBlendRatio(_ped, _p1);
			}
		}

		public float GetPedDesiredMoveBlendRatio(int _ped)
		{
			unsafe {
				if (fn__getPedDesiredMoveBlendRatio == null) fn__getPedDesiredMoveBlendRatio = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPedDesiredMoveBlendRatio");
				var result = fn__getPedDesiredMoveBlendRatio(_ped);
				return result;
			}
		}

		public void TaskGotoEntityAiming(int _ped, int _target, float _distanceToStopAt, float _StartAimingDist)
		{
			unsafe {
				if (fn__taskGotoEntityAiming == null) fn__taskGotoEntityAiming = (delegate* unmanaged[Cdecl]<int, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskGotoEntityAiming");
				fn__taskGotoEntityAiming(_ped, _target, _distanceToStopAt, _StartAimingDist);
			}
		}

		public void TaskSetDecisionMaker(int _ped, int _p1)
		{
			unsafe {
				if (fn__taskSetDecisionMaker == null) fn__taskSetDecisionMaker = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskSetDecisionMaker");
				fn__taskSetDecisionMaker(_ped, _p1);
			}
		}

		public void TaskSetSphereDefensiveArea(int _p0, float _p1, float _p2, float _p3, float _p4)
		{
			unsafe {
				if (fn__taskSetSphereDefensiveArea == null) fn__taskSetSphereDefensiveArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskSetSphereDefensiveArea");
				fn__taskSetSphereDefensiveArea(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void TaskClearDefensiveArea(int _p0)
		{
			unsafe {
				if (fn__taskClearDefensiveArea == null) fn__taskClearDefensiveArea = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_taskClearDefensiveArea");
				fn__taskClearDefensiveArea(_p0);
			}
		}

		public void TaskPedSlideToCoord(int _ped, float _x, float _y, float _z, float _heading, float _p5)
		{
			unsafe {
				if (fn__taskPedSlideToCoord == null) fn__taskPedSlideToCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskPedSlideToCoord");
				fn__taskPedSlideToCoord(_ped, _x, _y, _z, _heading, _p5);
			}
		}

		public void TaskPedSlideToCoordHdgRate(int _ped, float _x, float _y, float _z, float _heading, float _p5, float _p6)
		{
			unsafe {
				if (fn__taskPedSlideToCoordHdgRate == null) fn__taskPedSlideToCoordHdgRate = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskPedSlideToCoordHdgRate");
				fn__taskPedSlideToCoordHdgRate(_ped, _x, _y, _z, _heading, _p5, _p6);
			}
		}

		public int AddCoverPoint(float _p0, float _p1, float _p2, float _p3, int _p4, int _p5, int _p6, bool _p7)
		{
			unsafe {
				if (fn__addCoverPoint == null) fn__addCoverPoint = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, bool, int>) NativeLibrary.GetExport(handle, "Native_addCoverPoint");
				var result = fn__addCoverPoint(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
				return result;
			}
		}

		public void RemoveCoverPoint(int _coverpoint)
		{
			unsafe {
				if (fn__removeCoverPoint == null) fn__removeCoverPoint = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeCoverPoint");
				fn__removeCoverPoint(_coverpoint);
			}
		}

		public bool DoesScriptedCoverPointExistAtCoords(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__doesScriptedCoverPointExistAtCoords == null) fn__doesScriptedCoverPointExistAtCoords = (delegate* unmanaged[Cdecl]<float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_doesScriptedCoverPointExistAtCoords");
				var result = fn__doesScriptedCoverPointExistAtCoords(_x, _y, _z);
				return result;
			}
		}

		public Vector3 GetScriptedCoverPointCoords(int _coverpoint)
		{
			unsafe {
				if (fn__getScriptedCoverPointCoords == null) fn__getScriptedCoverPointCoords = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getScriptedCoverPointCoords");
				var result = fn__getScriptedCoverPointCoords(_coverpoint);
				return result;
			}
		}

		public void TaskCombatPed(int _ped, int _targetPed, int _p2, int _p3)
		{
			unsafe {
				if (fn__taskCombatPed == null) fn__taskCombatPed = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskCombatPed");
				fn__taskCombatPed(_ped, _targetPed, _p2, _p3);
			}
		}

		public void TaskCombatPedTimed(int _p0, int _ped, int _p2, int _p3)
		{
			unsafe {
				if (fn__taskCombatPedTimed == null) fn__taskCombatPedTimed = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskCombatPedTimed");
				fn__taskCombatPedTimed(_p0, _ped, _p2, _p3);
			}
		}

		public void TaskSeekCoverFromPos(int _ped, float _x, float _y, float _z, int _duration, bool _p5)
		{
			unsafe {
				if (fn__taskSeekCoverFromPos == null) fn__taskSeekCoverFromPos = (delegate* unmanaged[Cdecl]<int, float, float, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskSeekCoverFromPos");
				fn__taskSeekCoverFromPos(_ped, _x, _y, _z, _duration, _p5);
			}
		}

		public void TaskSeekCoverFromPed(int _ped, int _target, int _duration, bool _p3)
		{
			unsafe {
				if (fn__taskSeekCoverFromPed == null) fn__taskSeekCoverFromPed = (delegate* unmanaged[Cdecl]<int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskSeekCoverFromPed");
				fn__taskSeekCoverFromPed(_ped, _target, _duration, _p3);
			}
		}

		public void TaskSeekCoverToCoverPoint(int _p0, int _p1, float _p2, float _p3, float _p4, int _p5, bool _p6)
		{
			unsafe {
				if (fn__taskSeekCoverToCoverPoint == null) fn__taskSeekCoverToCoverPoint = (delegate* unmanaged[Cdecl]<int, int, float, float, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskSeekCoverToCoverPoint");
				fn__taskSeekCoverToCoverPoint(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void TaskSeekCoverToCoords(int _ped, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _p7, bool _p8)
		{
			unsafe {
				if (fn__taskSeekCoverToCoords == null) fn__taskSeekCoverToCoords = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskSeekCoverToCoords");
				fn__taskSeekCoverToCoords(_ped, _x1, _y1, _z1, _x2, _y2, _z2, _p7, _p8);
			}
		}

		public void TaskPutPedDirectlyIntoCover(int _ped, float _x, float _y, float _z, int _timeout, bool _p5, float _p6, bool _p7, bool _p8, int _p9, bool _p10)
		{
			unsafe {
				if (fn__taskPutPedDirectlyIntoCover == null) fn__taskPutPedDirectlyIntoCover = (delegate* unmanaged[Cdecl]<int, float, float, float, int, bool, float, bool, bool, int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskPutPedDirectlyIntoCover");
				fn__taskPutPedDirectlyIntoCover(_ped, _x, _y, _z, _timeout, _p5, _p6, _p7, _p8, _p9, _p10);
			}
		}

		public void TaskExitCover(int _p0, int _p1, float _p2, float _p3, float _p4)
		{
			unsafe {
				if (fn__taskExitCover == null) fn__taskExitCover = (delegate* unmanaged[Cdecl]<int, int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskExitCover");
				fn__taskExitCover(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void TaskPutPedDirectlyIntoMelee(int _ped, int _meleeTarget, float _p2, float _p3, float _p4, bool _p5)
		{
			unsafe {
				if (fn__taskPutPedDirectlyIntoMelee == null) fn__taskPutPedDirectlyIntoMelee = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_taskPutPedDirectlyIntoMelee");
				fn__taskPutPedDirectlyIntoMelee(_ped, _meleeTarget, _p2, _p3, _p4, _p5);
			}
		}

		public void TaskToggleDuck(bool _p0, bool _p1)
		{
			unsafe {
				if (fn__taskToggleDuck == null) fn__taskToggleDuck = (delegate* unmanaged[Cdecl]<bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskToggleDuck");
				fn__taskToggleDuck(_p0, _p1);
			}
		}

		public void TaskGuardCurrentPosition(int _p0, float _p1, float _p2, bool _p3)
		{
			unsafe {
				if (fn__taskGuardCurrentPosition == null) fn__taskGuardCurrentPosition = (delegate* unmanaged[Cdecl]<int, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_taskGuardCurrentPosition");
				fn__taskGuardCurrentPosition(_p0, _p1, _p2, _p3);
			}
		}

		public void TaskGuardAssignedDefensiveArea(int _p0, float _p1, float _p2, float _p3, float _p4, float _p5, int _p6)
		{
			unsafe {
				if (fn__taskGuardAssignedDefensiveArea == null) fn__taskGuardAssignedDefensiveArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskGuardAssignedDefensiveArea");
				fn__taskGuardAssignedDefensiveArea(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void TaskGuardSphereDefensiveArea(int _p0, float _p1, float _p2, float _p3, float _p4, float _p5, int _p6, float _p7, float _p8, float _p9, float _p10)
		{
			unsafe {
				if (fn__taskGuardSphereDefensiveArea == null) fn__taskGuardSphereDefensiveArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskGuardSphereDefensiveArea");
				fn__taskGuardSphereDefensiveArea(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10);
			}
		}

		public void TaskStandGuard(int _ped, float _x, float _y, float _z, float _heading, string _scenarioName)
		{
			unsafe {
				if (fn__taskStandGuard == null) fn__taskStandGuard = (delegate* unmanaged[Cdecl]<int, float, float, float, float, nint, void>) NativeLibrary.GetExport(handle, "Native_taskStandGuard");
				var ptr_scenarioName = MemoryUtils.StringToHGlobalUtf8(_scenarioName);
				fn__taskStandGuard(_ped, _x, _y, _z, _heading, ptr_scenarioName);
				Marshal.FreeHGlobal(ptr_scenarioName);
			}
		}

		public void SetDriveTaskCruiseSpeed(int _driver, float _cruiseSpeed)
		{
			unsafe {
				if (fn__setDriveTaskCruiseSpeed == null) fn__setDriveTaskCruiseSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setDriveTaskCruiseSpeed");
				fn__setDriveTaskCruiseSpeed(_driver, _cruiseSpeed);
			}
		}

		public void SetDriveTaskMaxCruiseSpeed(int _p0, float _p1)
		{
			unsafe {
				if (fn__setDriveTaskMaxCruiseSpeed == null) fn__setDriveTaskMaxCruiseSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setDriveTaskMaxCruiseSpeed");
				fn__setDriveTaskMaxCruiseSpeed(_p0, _p1);
			}
		}

		public void SetDriveTaskDrivingStyle(int _ped, int _drivingStyle)
		{
			unsafe {
				if (fn__setDriveTaskDrivingStyle == null) fn__setDriveTaskDrivingStyle = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setDriveTaskDrivingStyle");
				fn__setDriveTaskDrivingStyle(_ped, _drivingStyle);
			}
		}

		public void AddCoverBlockingArea(float _playerX, float _playerY, float _playerZ, float _radiusX, float _radiusY, float _radiusZ, bool _p6, bool _p7, bool _p8, bool _p9)
		{
			unsafe {
				if (fn__addCoverBlockingArea == null) fn__addCoverBlockingArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_addCoverBlockingArea");
				fn__addCoverBlockingArea(_playerX, _playerY, _playerZ, _radiusX, _radiusY, _radiusZ, _p6, _p7, _p8, _p9);
			}
		}

		public void RemoveAllCoverBlockingAreas()
		{
			unsafe {
				if (fn__removeAllCoverBlockingAreas == null) fn__removeAllCoverBlockingAreas = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeAllCoverBlockingAreas");
				fn__removeAllCoverBlockingAreas();
			}
		}

		public void _0xFA83CA6776038F64(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__0xFA83CA6776038F64 == null) fn__0xFA83CA6776038F64 = (delegate* unmanaged[Cdecl]<float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0xFA83CA6776038F64");
				fn__0xFA83CA6776038F64(_x, _y, _z);
			}
		}

		public void _0x1F351CF1C6475734(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__0x1F351CF1C6475734 == null) fn__0x1F351CF1C6475734 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1F351CF1C6475734");
				fn__0x1F351CF1C6475734(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
			}
		}

		public void TaskStartScenarioInPlace(int _ped, string _scenarioName, int _unkDelay, bool _playEnterAnim)
		{
			unsafe {
				if (fn__taskStartScenarioInPlace == null) fn__taskStartScenarioInPlace = (delegate* unmanaged[Cdecl]<int, nint, int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskStartScenarioInPlace");
				var ptr_scenarioName = MemoryUtils.StringToHGlobalUtf8(_scenarioName);
				fn__taskStartScenarioInPlace(_ped, ptr_scenarioName, _unkDelay, _playEnterAnim);
				Marshal.FreeHGlobal(ptr_scenarioName);
			}
		}

		public void TaskStartScenarioAtPosition(int _ped, string _scenarioName, float _x, float _y, float _z, float _heading, int _duration, bool _sittingScenario, bool _teleport)
		{
			unsafe {
				if (fn__taskStartScenarioAtPosition == null) fn__taskStartScenarioAtPosition = (delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskStartScenarioAtPosition");
				var ptr_scenarioName = MemoryUtils.StringToHGlobalUtf8(_scenarioName);
				fn__taskStartScenarioAtPosition(_ped, ptr_scenarioName, _x, _y, _z, _heading, _duration, _sittingScenario, _teleport);
				Marshal.FreeHGlobal(ptr_scenarioName);
			}
		}

		public void TaskUseNearestScenarioToCoord(int _ped, float _x, float _y, float _z, float _distance, int _duration)
		{
			unsafe {
				if (fn__taskUseNearestScenarioToCoord == null) fn__taskUseNearestScenarioToCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskUseNearestScenarioToCoord");
				fn__taskUseNearestScenarioToCoord(_ped, _x, _y, _z, _distance, _duration);
			}
		}

		public void TaskUseNearestScenarioToCoordWarp(int _ped, float _x, float _y, float _z, float _radius, int _p5)
		{
			unsafe {
				if (fn__taskUseNearestScenarioToCoordWarp == null) fn__taskUseNearestScenarioToCoordWarp = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskUseNearestScenarioToCoordWarp");
				fn__taskUseNearestScenarioToCoordWarp(_ped, _x, _y, _z, _radius, _p5);
			}
		}

		public void TaskUseNearestScenarioChainToCoord(int _p0, float _p1, float _p2, float _p3, float _p4, int _p5)
		{
			unsafe {
				if (fn__taskUseNearestScenarioChainToCoord == null) fn__taskUseNearestScenarioChainToCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskUseNearestScenarioChainToCoord");
				fn__taskUseNearestScenarioChainToCoord(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void TaskUseNearestScenarioChainToCoordWarp(int _p0, float _p1, float _p2, float _p3, float _p4, int _p5)
		{
			unsafe {
				if (fn__taskUseNearestScenarioChainToCoordWarp == null) fn__taskUseNearestScenarioChainToCoordWarp = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskUseNearestScenarioChainToCoordWarp");
				fn__taskUseNearestScenarioChainToCoordWarp(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public bool DoesScenarioExistInArea(float _x, float _y, float _z, float _radius, bool _b)
		{
			unsafe {
				if (fn__doesScenarioExistInArea == null) fn__doesScenarioExistInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_doesScenarioExistInArea");
				var result = fn__doesScenarioExistInArea(_x, _y, _z, _radius, _b);
				return result;
			}
		}

		public bool DoesScenarioOfTypeExistInArea(float _p0, float _p1, float _p2, ref int _p3, float _p4, bool _p5)
		{
			unsafe {
				if (fn__doesScenarioOfTypeExistInArea == null) fn__doesScenarioOfTypeExistInArea = (delegate* unmanaged[Cdecl]<float, float, float, int*, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_doesScenarioOfTypeExistInArea");
				var ref_p3 = _p3;
				var result = fn__doesScenarioOfTypeExistInArea(_p0, _p1, _p2, &ref_p3, _p4, _p5);
				_p3 = ref_p3;
				return result;
			}
		}

		public bool IsScenarioOccupied(float _p0, float _p1, float _p2, float _p3, bool _p4)
		{
			unsafe {
				if (fn__isScenarioOccupied == null) fn__isScenarioOccupied = (delegate* unmanaged[Cdecl]<float, float, float, float, bool, bool>) NativeLibrary.GetExport(handle, "Native_isScenarioOccupied");
				var result = fn__isScenarioOccupied(_p0, _p1, _p2, _p3, _p4);
				return result;
			}
		}

		public bool PedHasUseScenarioTask(int _ped)
		{
			unsafe {
				if (fn__pedHasUseScenarioTask == null) fn__pedHasUseScenarioTask = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_pedHasUseScenarioTask");
				var result = fn__pedHasUseScenarioTask(_ped);
				return result;
			}
		}

		public void PlayAnimOnRunningScenario(int _ped, string _animDict, string _animName)
		{
			unsafe {
				if (fn__playAnimOnRunningScenario == null) fn__playAnimOnRunningScenario = (delegate* unmanaged[Cdecl]<int, nint, nint, void>) NativeLibrary.GetExport(handle, "Native_playAnimOnRunningScenario");
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				var ptr_animName = MemoryUtils.StringToHGlobalUtf8(_animName);
				fn__playAnimOnRunningScenario(_ped, ptr_animDict, ptr_animName);
				Marshal.FreeHGlobal(ptr_animDict);
				Marshal.FreeHGlobal(ptr_animName);
			}
		}

		public bool DoesScenarioGroupExist(string _scenarioGroup)
		{
			unsafe {
				if (fn__doesScenarioGroupExist == null) fn__doesScenarioGroupExist = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_doesScenarioGroupExist");
				var ptr_scenarioGroup = MemoryUtils.StringToHGlobalUtf8(_scenarioGroup);
				var result = fn__doesScenarioGroupExist(ptr_scenarioGroup);
				Marshal.FreeHGlobal(ptr_scenarioGroup);
				return result;
			}
		}

		public bool IsScenarioGroupEnabled(string _scenarioGroup)
		{
			unsafe {
				if (fn__isScenarioGroupEnabled == null) fn__isScenarioGroupEnabled = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isScenarioGroupEnabled");
				var ptr_scenarioGroup = MemoryUtils.StringToHGlobalUtf8(_scenarioGroup);
				var result = fn__isScenarioGroupEnabled(ptr_scenarioGroup);
				Marshal.FreeHGlobal(ptr_scenarioGroup);
				return result;
			}
		}

		public void SetScenarioGroupEnabled(string _scenarioGroup, bool _p1)
		{
			unsafe {
				if (fn__setScenarioGroupEnabled == null) fn__setScenarioGroupEnabled = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setScenarioGroupEnabled");
				var ptr_scenarioGroup = MemoryUtils.StringToHGlobalUtf8(_scenarioGroup);
				fn__setScenarioGroupEnabled(ptr_scenarioGroup, _p1);
				Marshal.FreeHGlobal(ptr_scenarioGroup);
			}
		}

		public void ResetScenarioGroupsEnabled()
		{
			unsafe {
				if (fn__resetScenarioGroupsEnabled == null) fn__resetScenarioGroupsEnabled = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetScenarioGroupsEnabled");
				fn__resetScenarioGroupsEnabled();
			}
		}

		public void SetExclusiveScenarioGroup(string _scenarioGroup)
		{
			unsafe {
				if (fn__setExclusiveScenarioGroup == null) fn__setExclusiveScenarioGroup = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_setExclusiveScenarioGroup");
				var ptr_scenarioGroup = MemoryUtils.StringToHGlobalUtf8(_scenarioGroup);
				fn__setExclusiveScenarioGroup(ptr_scenarioGroup);
				Marshal.FreeHGlobal(ptr_scenarioGroup);
			}
		}

		public void ResetExclusiveScenarioGroup()
		{
			unsafe {
				if (fn__resetExclusiveScenarioGroup == null) fn__resetExclusiveScenarioGroup = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetExclusiveScenarioGroup");
				fn__resetExclusiveScenarioGroup();
			}
		}

		public bool IsScenarioTypeEnabled(string _scenarioType)
		{
			unsafe {
				if (fn__isScenarioTypeEnabled == null) fn__isScenarioTypeEnabled = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_isScenarioTypeEnabled");
				var ptr_scenarioType = MemoryUtils.StringToHGlobalUtf8(_scenarioType);
				var result = fn__isScenarioTypeEnabled(ptr_scenarioType);
				Marshal.FreeHGlobal(ptr_scenarioType);
				return result;
			}
		}

		public void SetScenarioTypeEnabled(string _scenarioType, bool _toggle)
		{
			unsafe {
				if (fn__setScenarioTypeEnabled == null) fn__setScenarioTypeEnabled = (delegate* unmanaged[Cdecl]<nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setScenarioTypeEnabled");
				var ptr_scenarioType = MemoryUtils.StringToHGlobalUtf8(_scenarioType);
				fn__setScenarioTypeEnabled(ptr_scenarioType, _toggle);
				Marshal.FreeHGlobal(ptr_scenarioType);
			}
		}

		public void ResetScenarioTypesEnabled()
		{
			unsafe {
				if (fn__resetScenarioTypesEnabled == null) fn__resetScenarioTypesEnabled = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetScenarioTypesEnabled");
				fn__resetScenarioTypesEnabled();
			}
		}

		public bool IsPedActiveInScenario(int _ped)
		{
			unsafe {
				if (fn__isPedActiveInScenario == null) fn__isPedActiveInScenario = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedActiveInScenario");
				var result = fn__isPedActiveInScenario(_ped);
				return result;
			}
		}

		public bool IsPedPlayingBaseClipInScenario(int _ped)
		{
			unsafe {
				if (fn__isPedPlayingBaseClipInScenario == null) fn__isPedPlayingBaseClipInScenario = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedPlayingBaseClipInScenario");
				var result = fn__isPedPlayingBaseClipInScenario(_ped);
				return result;
			}
		}

		public void SetPedCanPlayAmbientIdles(int _ped, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__setPedCanPlayAmbientIdles == null) fn__setPedCanPlayAmbientIdles = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCanPlayAmbientIdles");
				fn__setPedCanPlayAmbientIdles(_ped, _p1, _p2);
			}
		}

		public void TaskCombatHatedTargetsInArea(int _ped, float _x, float _y, float _z, float _radius, int _p5)
		{
			unsafe {
				if (fn__taskCombatHatedTargetsInArea == null) fn__taskCombatHatedTargetsInArea = (delegate* unmanaged[Cdecl]<int, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskCombatHatedTargetsInArea");
				fn__taskCombatHatedTargetsInArea(_ped, _x, _y, _z, _radius, _p5);
			}
		}

		public void TaskCombatHatedTargetsAroundPed(int _ped, float _radius, int _p2)
		{
			unsafe {
				if (fn__taskCombatHatedTargetsAroundPed == null) fn__taskCombatHatedTargetsAroundPed = (delegate* unmanaged[Cdecl]<int, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskCombatHatedTargetsAroundPed");
				fn__taskCombatHatedTargetsAroundPed(_ped, _radius, _p2);
			}
		}

		public void TaskCombatHatedTargetsAroundPedTimed(int _p0, float _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__taskCombatHatedTargetsAroundPedTimed == null) fn__taskCombatHatedTargetsAroundPedTimed = (delegate* unmanaged[Cdecl]<int, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskCombatHatedTargetsAroundPedTimed");
				fn__taskCombatHatedTargetsAroundPedTimed(_p0, _p1, _p2, _p3);
			}
		}

		public void TaskThrowProjectile(int _ped, float _x, float _y, float _z, int _p4, int _p5)
		{
			unsafe {
				if (fn__taskThrowProjectile == null) fn__taskThrowProjectile = (delegate* unmanaged[Cdecl]<int, float, float, float, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskThrowProjectile");
				fn__taskThrowProjectile(_ped, _x, _y, _z, _p4, _p5);
			}
		}

		public void TaskSwapWeapon(int _ped, bool _p1)
		{
			unsafe {
				if (fn__taskSwapWeapon == null) fn__taskSwapWeapon = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskSwapWeapon");
				fn__taskSwapWeapon(_ped, _p1);
			}
		}

		public void TaskReloadWeapon(int _ped, bool _unused)
		{
			unsafe {
				if (fn__taskReloadWeapon == null) fn__taskReloadWeapon = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskReloadWeapon");
				fn__taskReloadWeapon(_ped, _unused);
			}
		}

		public bool IsPedGettingUp(int _ped)
		{
			unsafe {
				if (fn__isPedGettingUp == null) fn__isPedGettingUp = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedGettingUp");
				var result = fn__isPedGettingUp(_ped);
				return result;
			}
		}

		public void TaskWrithe(int _ped, int _target, int _time, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__taskWrithe == null) fn__taskWrithe = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskWrithe");
				fn__taskWrithe(_ped, _target, _time, _p3, _p4, _p5);
			}
		}

		public bool IsPedInWrithe(int _ped)
		{
			unsafe {
				if (fn__isPedInWrithe == null) fn__isPedInWrithe = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedInWrithe");
				var result = fn__isPedInWrithe(_ped);
				return result;
			}
		}

		public void OpenPatrolRoute(string _patrolRoute)
		{
			unsafe {
				if (fn__openPatrolRoute == null) fn__openPatrolRoute = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_openPatrolRoute");
				var ptr_patrolRoute = MemoryUtils.StringToHGlobalUtf8(_patrolRoute);
				fn__openPatrolRoute(ptr_patrolRoute);
				Marshal.FreeHGlobal(ptr_patrolRoute);
			}
		}

		public void ClosePatrolRoute()
		{
			unsafe {
				if (fn__closePatrolRoute == null) fn__closePatrolRoute = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_closePatrolRoute");
				fn__closePatrolRoute();
			}
		}

		public void AddPatrolRouteNode(int _p0, string _p1, float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _p8)
		{
			unsafe {
				if (fn__addPatrolRouteNode == null) fn__addPatrolRouteNode = (delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_addPatrolRouteNode");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__addPatrolRouteNode(_p0, ptr_p1, _x1, _y1, _z1, _x2, _y2, _z2, _p8);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void AddPatrolRouteLink(int _p0, int _p1)
		{
			unsafe {
				if (fn__addPatrolRouteLink == null) fn__addPatrolRouteLink = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_addPatrolRouteLink");
				fn__addPatrolRouteLink(_p0, _p1);
			}
		}

		public void CreatePatrolRoute()
		{
			unsafe {
				if (fn__createPatrolRoute == null) fn__createPatrolRoute = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_createPatrolRoute");
				fn__createPatrolRoute();
			}
		}

		public void DeletePatrolRoute(string _patrolRoute)
		{
			unsafe {
				if (fn__deletePatrolRoute == null) fn__deletePatrolRoute = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_deletePatrolRoute");
				var ptr_patrolRoute = MemoryUtils.StringToHGlobalUtf8(_patrolRoute);
				fn__deletePatrolRoute(ptr_patrolRoute);
				Marshal.FreeHGlobal(ptr_patrolRoute);
			}
		}

		public void TaskPatrol(int _ped, string _p1, int _p2, bool _p3, bool _p4)
		{
			unsafe {
				if (fn__taskPatrol == null) fn__taskPatrol = (delegate* unmanaged[Cdecl]<int, nint, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_taskPatrol");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__taskPatrol(_ped, ptr_p1, _p2, _p3, _p4);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void TaskStayInCover(int _ped)
		{
			unsafe {
				if (fn__taskStayInCover == null) fn__taskStayInCover = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_taskStayInCover");
				fn__taskStayInCover(_ped);
			}
		}

		public void AddVehicleSubtaskAttackCoord(int _ped, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__addVehicleSubtaskAttackCoord == null) fn__addVehicleSubtaskAttackCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_addVehicleSubtaskAttackCoord");
				fn__addVehicleSubtaskAttackCoord(_ped, _x, _y, _z);
			}
		}

		public void AddVehicleSubtaskAttackPed(int _ped, int _ped2)
		{
			unsafe {
				if (fn__addVehicleSubtaskAttackPed == null) fn__addVehicleSubtaskAttackPed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_addVehicleSubtaskAttackPed");
				fn__addVehicleSubtaskAttackPed(_ped, _ped2);
			}
		}

		public void TaskVehicleShootAtPed(int _ped, int _target, float _p2)
		{
			unsafe {
				if (fn__taskVehicleShootAtPed == null) fn__taskVehicleShootAtPed = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleShootAtPed");
				fn__taskVehicleShootAtPed(_ped, _target, _p2);
			}
		}

		public void TaskVehicleAimAtPed(int _ped, int _target)
		{
			unsafe {
				if (fn__taskVehicleAimAtPed == null) fn__taskVehicleAimAtPed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleAimAtPed");
				fn__taskVehicleAimAtPed(_ped, _target);
			}
		}

		public void TaskVehicleShootAtCoord(int _ped, float _x, float _y, float _z, float _p4)
		{
			unsafe {
				if (fn__taskVehicleShootAtCoord == null) fn__taskVehicleShootAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleShootAtCoord");
				fn__taskVehicleShootAtCoord(_ped, _x, _y, _z, _p4);
			}
		}

		public void TaskVehicleAimAtCoord(int _ped, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__taskVehicleAimAtCoord == null) fn__taskVehicleAimAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleAimAtCoord");
				fn__taskVehicleAimAtCoord(_ped, _x, _y, _z);
			}
		}

		public void TaskVehicleGotoNavmesh(int _ped, int _vehicle, float _x, float _y, float _z, float _speed, int _behaviorFlag, float _stoppingRange)
		{
			unsafe {
				if (fn__taskVehicleGotoNavmesh == null) fn__taskVehicleGotoNavmesh = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, int, float, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleGotoNavmesh");
				fn__taskVehicleGotoNavmesh(_ped, _vehicle, _x, _y, _z, _speed, _behaviorFlag, _stoppingRange);
			}
		}

		public void TaskGoToCoordWhileAimingAtCoord(int _ped, float _x, float _y, float _z, float _aimAtX, float _aimAtY, float _aimAtZ, float _moveSpeed, bool _p8, float _p9, float _p10, bool _p11, int _flags, bool _p13, int _firingPattern)
		{
			unsafe {
				if (fn__taskGoToCoordWhileAimingAtCoord == null) fn__taskGoToCoordWhileAimingAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, float, float, bool, int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_taskGoToCoordWhileAimingAtCoord");
				fn__taskGoToCoordWhileAimingAtCoord(_ped, _x, _y, _z, _aimAtX, _aimAtY, _aimAtZ, _moveSpeed, _p8, _p9, _p10, _p11, _flags, _p13, _firingPattern);
			}
		}

		public void TaskGoToCoordWhileAimingAtEntity(int _p0, float _p1, float _p2, float _p3, int _p4, float _p5, bool _p6, float _p7, float _p8, bool _p9, int _p10, bool _p11, int _p12, int _p13)
		{
			unsafe {
				if (fn__taskGoToCoordWhileAimingAtEntity == null) fn__taskGoToCoordWhileAimingAtEntity = (delegate* unmanaged[Cdecl]<int, float, float, float, int, float, bool, float, float, bool, int, bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskGoToCoordWhileAimingAtEntity");
				fn__taskGoToCoordWhileAimingAtEntity(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12, _p13);
			}
		}

		public void TaskGoToCoordAndAimAtHatedEntitiesNearCoord(int _pedHandle, float _goToLocationX, float _goToLocationY, float _goToLocationZ, float _focusLocationX, float _focusLocationY, float _focusLocationZ, float _speed, bool _shootAtEnemies, float _distanceToStopAt, float _noRoadsDistance, bool _unkTrue, int _unkFlag, int _aimingFlag, int _firingPattern)
		{
			unsafe {
				if (fn__taskGoToCoordAndAimAtHatedEntitiesNearCoord == null) fn__taskGoToCoordAndAimAtHatedEntitiesNearCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float, bool, float, float, bool, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskGoToCoordAndAimAtHatedEntitiesNearCoord");
				fn__taskGoToCoordAndAimAtHatedEntitiesNearCoord(_pedHandle, _goToLocationX, _goToLocationY, _goToLocationZ, _focusLocationX, _focusLocationY, _focusLocationZ, _speed, _shootAtEnemies, _distanceToStopAt, _noRoadsDistance, _unkTrue, _unkFlag, _aimingFlag, _firingPattern);
			}
		}

		public void TaskGoToEntityWhileAimingAtCoord(int _p0, int _p1, float _p2, float _p3, float _p4, float _p5, bool _p6, float _p7, float _p8, bool _p9, bool _p10, int _p11)
		{
			unsafe {
				if (fn__taskGoToEntityWhileAimingAtCoord == null) fn__taskGoToEntityWhileAimingAtCoord = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, bool, float, float, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_taskGoToEntityWhileAimingAtCoord");
				fn__taskGoToEntityWhileAimingAtCoord(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11);
			}
		}

		public void TaskGoToEntityWhileAimingAtEntity(int _ped, int _entityToWalkTo, int _entityToAimAt, float _speed, bool _shootatEntity, float _p5, float _p6, bool _p7, bool _p8, int _firingPattern)
		{
			unsafe {
				if (fn__taskGoToEntityWhileAimingAtEntity == null) fn__taskGoToEntityWhileAimingAtEntity = (delegate* unmanaged[Cdecl]<int, int, int, float, bool, float, float, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_taskGoToEntityWhileAimingAtEntity");
				fn__taskGoToEntityWhileAimingAtEntity(_ped, _entityToWalkTo, _entityToAimAt, _speed, _shootatEntity, _p5, _p6, _p7, _p8, _firingPattern);
			}
		}

		public void SetHighFallTask(int _ped, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__setHighFallTask == null) fn__setHighFallTask = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setHighFallTask");
				fn__setHighFallTask(_ped, _p1, _p2, _p3);
			}
		}

		public void RequestWaypointRecording(string _name)
		{
			unsafe {
				if (fn__requestWaypointRecording == null) fn__requestWaypointRecording = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_requestWaypointRecording");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__requestWaypointRecording(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public bool GetIsWaypointRecordingLoaded(string _name)
		{
			unsafe {
				if (fn__getIsWaypointRecordingLoaded == null) fn__getIsWaypointRecordingLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_getIsWaypointRecordingLoaded");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__getIsWaypointRecordingLoaded(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public void RemoveWaypointRecording(string _name)
		{
			unsafe {
				if (fn__removeWaypointRecording == null) fn__removeWaypointRecording = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_removeWaypointRecording");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__removeWaypointRecording(ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public bool WaypointRecordingGetNumPoints(string _name, ref int _points)
		{
			unsafe {
				if (fn__waypointRecordingGetNumPoints == null) fn__waypointRecordingGetNumPoints = (delegate* unmanaged[Cdecl]<nint, int*, bool>) NativeLibrary.GetExport(handle, "Native_waypointRecordingGetNumPoints");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var ref_points = _points;
				var result = fn__waypointRecordingGetNumPoints(ptr_name, &ref_points);
				Marshal.FreeHGlobal(ptr_name);
				_points = ref_points;
				return result;
			}
		}

		public bool WaypointRecordingGetCoord(string _name, int _point, ref Vector3 _coord)
		{
			unsafe {
				if (fn__waypointRecordingGetCoord == null) fn__waypointRecordingGetCoord = (delegate* unmanaged[Cdecl]<nint, int, Vector3*, bool>) NativeLibrary.GetExport(handle, "Native_waypointRecordingGetCoord");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var ref_coord = _coord;
				var result = fn__waypointRecordingGetCoord(ptr_name, _point, &ref_coord);
				Marshal.FreeHGlobal(ptr_name);
				_coord = ref_coord;
				return result;
			}
		}

		public float WaypointRecordingGetSpeedAtPoint(string _name, int _point)
		{
			unsafe {
				if (fn__waypointRecordingGetSpeedAtPoint == null) fn__waypointRecordingGetSpeedAtPoint = (delegate* unmanaged[Cdecl]<nint, int, float>) NativeLibrary.GetExport(handle, "Native_waypointRecordingGetSpeedAtPoint");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__waypointRecordingGetSpeedAtPoint(ptr_name, _point);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public bool WaypointRecordingGetClosestWaypoint(string _name, float _x, float _y, float _z, ref int _point)
		{
			unsafe {
				if (fn__waypointRecordingGetClosestWaypoint == null) fn__waypointRecordingGetClosestWaypoint = (delegate* unmanaged[Cdecl]<nint, float, float, float, int*, bool>) NativeLibrary.GetExport(handle, "Native_waypointRecordingGetClosestWaypoint");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var ref_point = _point;
				var result = fn__waypointRecordingGetClosestWaypoint(ptr_name, _x, _y, _z, &ref_point);
				Marshal.FreeHGlobal(ptr_name);
				_point = ref_point;
				return result;
			}
		}

		public void TaskFollowWaypointRecording(int _p0, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__taskFollowWaypointRecording == null) fn__taskFollowWaypointRecording = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_taskFollowWaypointRecording");
				fn__taskFollowWaypointRecording(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public bool IsWaypointPlaybackGoingOnForPed(int _p0)
		{
			unsafe {
				if (fn__isWaypointPlaybackGoingOnForPed == null) fn__isWaypointPlaybackGoingOnForPed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isWaypointPlaybackGoingOnForPed");
				var result = fn__isWaypointPlaybackGoingOnForPed(_p0);
				return result;
			}
		}

		public int GetPedWaypointProgress(int _ped)
		{
			unsafe {
				if (fn__getPedWaypointProgress == null) fn__getPedWaypointProgress = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getPedWaypointProgress");
				var result = fn__getPedWaypointProgress(_ped);
				return result;
			}
		}

		public float GetPedWaypointDistance(int _p0)
		{
			unsafe {
				if (fn__getPedWaypointDistance == null) fn__getPedWaypointDistance = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPedWaypointDistance");
				var result = fn__getPedWaypointDistance(_p0);
				return result;
			}
		}

		public int SetPedWaypointRouteOffset(int _p0, int _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__setPedWaypointRouteOffset == null) fn__setPedWaypointRouteOffset = (delegate* unmanaged[Cdecl]<int, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_setPedWaypointRouteOffset");
				var result = fn__setPedWaypointRouteOffset(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public float GetWaypointDistanceAlongRoute(string _p0, int _p1)
		{
			unsafe {
				if (fn__getWaypointDistanceAlongRoute == null) fn__getWaypointDistanceAlongRoute = (delegate* unmanaged[Cdecl]<nint, int, float>) NativeLibrary.GetExport(handle, "Native_getWaypointDistanceAlongRoute");
				var ptr_p0 = MemoryUtils.StringToHGlobalUtf8(_p0);
				var result = fn__getWaypointDistanceAlongRoute(ptr_p0, _p1);
				Marshal.FreeHGlobal(ptr_p0);
				return result;
			}
		}

		public bool WaypointPlaybackGetIsPaused(int _p0)
		{
			unsafe {
				if (fn__waypointPlaybackGetIsPaused == null) fn__waypointPlaybackGetIsPaused = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackGetIsPaused");
				var result = fn__waypointPlaybackGetIsPaused(_p0);
				return result;
			}
		}

		public void WaypointPlaybackPause(int _p0, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__waypointPlaybackPause == null) fn__waypointPlaybackPause = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackPause");
				fn__waypointPlaybackPause(_p0, _p1, _p2);
			}
		}

		public void WaypointPlaybackResume(int _p0, bool _p1, int _p2, int _p3)
		{
			unsafe {
				if (fn__waypointPlaybackResume == null) fn__waypointPlaybackResume = (delegate* unmanaged[Cdecl]<int, bool, int, int, void>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackResume");
				fn__waypointPlaybackResume(_p0, _p1, _p2, _p3);
			}
		}

		public void WaypointPlaybackOverrideSpeed(int _p0, float _p1, bool _p2)
		{
			unsafe {
				if (fn__waypointPlaybackOverrideSpeed == null) fn__waypointPlaybackOverrideSpeed = (delegate* unmanaged[Cdecl]<int, float, bool, void>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackOverrideSpeed");
				fn__waypointPlaybackOverrideSpeed(_p0, _p1, _p2);
			}
		}

		public void WaypointPlaybackUseDefaultSpeed(int _p0)
		{
			unsafe {
				if (fn__waypointPlaybackUseDefaultSpeed == null) fn__waypointPlaybackUseDefaultSpeed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackUseDefaultSpeed");
				fn__waypointPlaybackUseDefaultSpeed(_p0);
			}
		}

		public void UseWaypointRecordingAsAssistedMovementRoute(string _name, bool _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__useWaypointRecordingAsAssistedMovementRoute == null) fn__useWaypointRecordingAsAssistedMovementRoute = (delegate* unmanaged[Cdecl]<nint, bool, float, float, void>) NativeLibrary.GetExport(handle, "Native_useWaypointRecordingAsAssistedMovementRoute");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__useWaypointRecordingAsAssistedMovementRoute(ptr_name, _p1, _p2, _p3);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void WaypointPlaybackStartAimingAtPed(int _p0, int _p1, bool _p2)
		{
			unsafe {
				if (fn__waypointPlaybackStartAimingAtPed == null) fn__waypointPlaybackStartAimingAtPed = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackStartAimingAtPed");
				fn__waypointPlaybackStartAimingAtPed(_p0, _p1, _p2);
			}
		}

		public void WaypointPlaybackStartAimingAtCoord(int _p0, float _p1, float _p2, float _p3, bool _p4)
		{
			unsafe {
				if (fn__waypointPlaybackStartAimingAtCoord == null) fn__waypointPlaybackStartAimingAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackStartAimingAtCoord");
				fn__waypointPlaybackStartAimingAtCoord(_p0, _p1, _p2, _p3, _p4);
			}
		}

		public void WaypointPlaybackStartShootingAtPed(int _p0, int _p1, bool _p2, int _p3)
		{
			unsafe {
				if (fn__waypointPlaybackStartShootingAtPed == null) fn__waypointPlaybackStartShootingAtPed = (delegate* unmanaged[Cdecl]<int, int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackStartShootingAtPed");
				fn__waypointPlaybackStartShootingAtPed(_p0, _p1, _p2, _p3);
			}
		}

		public void WaypointPlaybackStartShootingAtCoord(int _p0, float _p1, float _p2, float _p3, bool _p4, int _p5)
		{
			unsafe {
				if (fn__waypointPlaybackStartShootingAtCoord == null) fn__waypointPlaybackStartShootingAtCoord = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, void>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackStartShootingAtCoord");
				fn__waypointPlaybackStartShootingAtCoord(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void WaypointPlaybackStopAimingOrShooting(int _p0)
		{
			unsafe {
				if (fn__waypointPlaybackStopAimingOrShooting == null) fn__waypointPlaybackStopAimingOrShooting = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_waypointPlaybackStopAimingOrShooting");
				fn__waypointPlaybackStopAimingOrShooting(_p0);
			}
		}

		public void AssistedMovementRequestRoute(string _route)
		{
			unsafe {
				if (fn__assistedMovementRequestRoute == null) fn__assistedMovementRequestRoute = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_assistedMovementRequestRoute");
				var ptr_route = MemoryUtils.StringToHGlobalUtf8(_route);
				fn__assistedMovementRequestRoute(ptr_route);
				Marshal.FreeHGlobal(ptr_route);
			}
		}

		public void AssistedMovementRemoveRoute(string _route)
		{
			unsafe {
				if (fn__assistedMovementRemoveRoute == null) fn__assistedMovementRemoveRoute = (delegate* unmanaged[Cdecl]<nint, void>) NativeLibrary.GetExport(handle, "Native_assistedMovementRemoveRoute");
				var ptr_route = MemoryUtils.StringToHGlobalUtf8(_route);
				fn__assistedMovementRemoveRoute(ptr_route);
				Marshal.FreeHGlobal(ptr_route);
			}
		}

		public bool AssistedMovementIsRouteLoaded(string _route)
		{
			unsafe {
				if (fn__assistedMovementIsRouteLoaded == null) fn__assistedMovementIsRouteLoaded = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_assistedMovementIsRouteLoaded");
				var ptr_route = MemoryUtils.StringToHGlobalUtf8(_route);
				var result = fn__assistedMovementIsRouteLoaded(ptr_route);
				Marshal.FreeHGlobal(ptr_route);
				return result;
			}
		}

		public void AssistedMovementSetRouteProperties(string _route, int _props)
		{
			unsafe {
				if (fn__assistedMovementSetRouteProperties == null) fn__assistedMovementSetRouteProperties = (delegate* unmanaged[Cdecl]<nint, int, void>) NativeLibrary.GetExport(handle, "Native_assistedMovementSetRouteProperties");
				var ptr_route = MemoryUtils.StringToHGlobalUtf8(_route);
				fn__assistedMovementSetRouteProperties(ptr_route, _props);
				Marshal.FreeHGlobal(ptr_route);
			}
		}

		public void AssistedMovementOverrideLoadDistanceThisFrame(float _dist)
		{
			unsafe {
				if (fn__assistedMovementOverrideLoadDistanceThisFrame == null) fn__assistedMovementOverrideLoadDistanceThisFrame = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_assistedMovementOverrideLoadDistanceThisFrame");
				fn__assistedMovementOverrideLoadDistanceThisFrame(_dist);
			}
		}

		public void TaskVehicleFollowWaypointRecording(int _ped, int _vehicle, string _WPRecording, int _p3, int _p4, int _p5, int _p6, float _p7, bool _p8, float _p9)
		{
			unsafe {
				if (fn__taskVehicleFollowWaypointRecording == null) fn__taskVehicleFollowWaypointRecording = (delegate* unmanaged[Cdecl]<int, int, nint, int, int, int, int, float, bool, float, void>) NativeLibrary.GetExport(handle, "Native_taskVehicleFollowWaypointRecording");
				var ptr_WPRecording = MemoryUtils.StringToHGlobalUtf8(_WPRecording);
				fn__taskVehicleFollowWaypointRecording(_ped, _vehicle, ptr_WPRecording, _p3, _p4, _p5, _p6, _p7, _p8, _p9);
				Marshal.FreeHGlobal(ptr_WPRecording);
			}
		}

		public bool IsWaypointPlaybackGoingOnForVehicle(int _vehicle)
		{
			unsafe {
				if (fn__isWaypointPlaybackGoingOnForVehicle == null) fn__isWaypointPlaybackGoingOnForVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isWaypointPlaybackGoingOnForVehicle");
				var result = fn__isWaypointPlaybackGoingOnForVehicle(_vehicle);
				return result;
			}
		}

		public int GetVehicleWaypointProgress(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleWaypointProgress == null) fn__getVehicleWaypointProgress = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleWaypointProgress");
				var result = fn__getVehicleWaypointProgress(_vehicle);
				return result;
			}
		}

		public int GetVehicleWaypointTargetPoint(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleWaypointTargetPoint == null) fn__getVehicleWaypointTargetPoint = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleWaypointTargetPoint");
				var result = fn__getVehicleWaypointTargetPoint(_vehicle);
				return result;
			}
		}

		public void VehicleWaypointPlaybackPause(int _vehicle)
		{
			unsafe {
				if (fn__vehicleWaypointPlaybackPause == null) fn__vehicleWaypointPlaybackPause = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_vehicleWaypointPlaybackPause");
				fn__vehicleWaypointPlaybackPause(_vehicle);
			}
		}

		public void VehicleWaypointPlaybackResume(int _vehicle)
		{
			unsafe {
				if (fn__vehicleWaypointPlaybackResume == null) fn__vehicleWaypointPlaybackResume = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_vehicleWaypointPlaybackResume");
				fn__vehicleWaypointPlaybackResume(_vehicle);
			}
		}

		public void VehicleWaypointPlaybackUseDefaultSpeed(int _vehicle)
		{
			unsafe {
				if (fn__vehicleWaypointPlaybackUseDefaultSpeed == null) fn__vehicleWaypointPlaybackUseDefaultSpeed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_vehicleWaypointPlaybackUseDefaultSpeed");
				fn__vehicleWaypointPlaybackUseDefaultSpeed(_vehicle);
			}
		}

		public void VehicleWaypointPlaybackOverrideSpeed(int _vehicle, float _speed)
		{
			unsafe {
				if (fn__vehicleWaypointPlaybackOverrideSpeed == null) fn__vehicleWaypointPlaybackOverrideSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_vehicleWaypointPlaybackOverrideSpeed");
				fn__vehicleWaypointPlaybackOverrideSpeed(_vehicle, _speed);
			}
		}

		public void TaskSetBlockingOfNonTemporaryEvents(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__taskSetBlockingOfNonTemporaryEvents == null) fn__taskSetBlockingOfNonTemporaryEvents = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskSetBlockingOfNonTemporaryEvents");
				fn__taskSetBlockingOfNonTemporaryEvents(_ped, _toggle);
			}
		}

		public void TaskForceMotionState(int _ped, int _state, bool _p2)
		{
			unsafe {
				if (fn__taskForceMotionState == null) fn__taskForceMotionState = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_taskForceMotionState");
				fn__taskForceMotionState(_ped, _state, _p2);
			}
		}

		public void TaskMoveNetworkByName(int _ped, string _task, float _multiplier, bool _p3, string _animDict, int _flags)
		{
			unsafe {
				if (fn__taskMoveNetworkByName == null) fn__taskMoveNetworkByName = (delegate* unmanaged[Cdecl]<int, nint, float, bool, nint, int, void>) NativeLibrary.GetExport(handle, "Native_taskMoveNetworkByName");
				var ptr_task = MemoryUtils.StringToHGlobalUtf8(_task);
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				fn__taskMoveNetworkByName(_ped, ptr_task, _multiplier, _p3, ptr_animDict, _flags);
				Marshal.FreeHGlobal(ptr_task);
				Marshal.FreeHGlobal(ptr_animDict);
			}
		}

		public void TaskMoveNetworkAdvancedByName(int _ped, string _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, int _p8, float _p9, bool _p10, string _animDict, int _flags)
		{
			unsafe {
				if (fn__taskMoveNetworkAdvancedByName == null) fn__taskMoveNetworkAdvancedByName = (delegate* unmanaged[Cdecl]<int, nint, float, float, float, float, float, float, int, float, bool, nint, int, void>) NativeLibrary.GetExport(handle, "Native_taskMoveNetworkAdvancedByName");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				fn__taskMoveNetworkAdvancedByName(_ped, ptr_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, ptr_animDict, _flags);
				Marshal.FreeHGlobal(ptr_p1);
				Marshal.FreeHGlobal(ptr_animDict);
			}
		}

		public void TaskMoveNetworkByNameWithInitParams(int _ped, string _p1, ref int _data, float _p3, bool _p4, string _animDict, int _flags)
		{
			unsafe {
				if (fn__taskMoveNetworkByNameWithInitParams == null) fn__taskMoveNetworkByNameWithInitParams = (delegate* unmanaged[Cdecl]<int, nint, int*, float, bool, nint, int, void>) NativeLibrary.GetExport(handle, "Native_taskMoveNetworkByNameWithInitParams");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var ref_data = _data;
				var ptr_animDict = MemoryUtils.StringToHGlobalUtf8(_animDict);
				fn__taskMoveNetworkByNameWithInitParams(_ped, ptr_p1, &ref_data, _p3, _p4, ptr_animDict, _flags);
				Marshal.FreeHGlobal(ptr_p1);
				_data = ref_data;
				Marshal.FreeHGlobal(ptr_animDict);
			}
		}

		public void _0x29682E2CCF21E9B5(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8, int _p9, int _p10, int _p11, int _p12, int _p13)
		{
			unsafe {
				if (fn__0x29682E2CCF21E9B5 == null) fn__0x29682E2CCF21E9B5 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x29682E2CCF21E9B5");
				fn__0x29682E2CCF21E9B5(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _p10, _p11, _p12, _p13);
			}
		}

		public bool IsTaskMoveNetworkActive(int _ped)
		{
			unsafe {
				if (fn__isTaskMoveNetworkActive == null) fn__isTaskMoveNetworkActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isTaskMoveNetworkActive");
				var result = fn__isTaskMoveNetworkActive(_ped);
				return result;
			}
		}

		public bool IsTaskMoveNetworkReadyForTransition(int _ped)
		{
			unsafe {
				if (fn__isTaskMoveNetworkReadyForTransition == null) fn__isTaskMoveNetworkReadyForTransition = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isTaskMoveNetworkReadyForTransition");
				var result = fn__isTaskMoveNetworkReadyForTransition(_ped);
				return result;
			}
		}

		public bool RequestTaskMoveNetworkStateTransition(int _ped, string _name)
		{
			unsafe {
				if (fn__requestTaskMoveNetworkStateTransition == null) fn__requestTaskMoveNetworkStateTransition = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_requestTaskMoveNetworkStateTransition");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				var result = fn__requestTaskMoveNetworkStateTransition(_ped, ptr_name);
				Marshal.FreeHGlobal(ptr_name);
				return result;
			}
		}

		public int _0xAB13A5565480B6D9(int _ped, string _p1)
		{
			unsafe {
				if (fn__0xAB13A5565480B6D9 == null) fn__0xAB13A5565480B6D9 = (delegate* unmanaged[Cdecl]<int, nint, int>) NativeLibrary.GetExport(handle, "Native__0xAB13A5565480B6D9");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				var result = fn__0xAB13A5565480B6D9(_ped, ptr_p1);
				Marshal.FreeHGlobal(ptr_p1);
				return result;
			}
		}

		public string GetTaskMoveNetworkState(int _ped)
		{
			unsafe {
				if (fn__getTaskMoveNetworkState == null) fn__getTaskMoveNetworkState = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getTaskMoveNetworkState");
				var result = fn__getTaskMoveNetworkState(_ped);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void _0x8423541E8B3A1589(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x8423541E8B3A1589 == null) fn__0x8423541E8B3A1589 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x8423541E8B3A1589");
				fn__0x8423541E8B3A1589(_p0, _p1, _p2);
			}
		}

		public void SetTaskMoveNetworkSignalFloat(int _ped, string _signalName, float _value)
		{
			unsafe {
				if (fn__setTaskMoveNetworkSignalFloat == null) fn__setTaskMoveNetworkSignalFloat = (delegate* unmanaged[Cdecl]<int, nint, float, void>) NativeLibrary.GetExport(handle, "Native_setTaskMoveNetworkSignalFloat");
				var ptr_signalName = MemoryUtils.StringToHGlobalUtf8(_signalName);
				fn__setTaskMoveNetworkSignalFloat(_ped, ptr_signalName, _value);
				Marshal.FreeHGlobal(ptr_signalName);
			}
		}

		public void SetTaskMoveNetworkSignalFloat2(int _ped, string _signalName, float _value)
		{
			unsafe {
				if (fn__setTaskMoveNetworkSignalFloat2 == null) fn__setTaskMoveNetworkSignalFloat2 = (delegate* unmanaged[Cdecl]<int, nint, float, void>) NativeLibrary.GetExport(handle, "Native_setTaskMoveNetworkSignalFloat2");
				var ptr_signalName = MemoryUtils.StringToHGlobalUtf8(_signalName);
				fn__setTaskMoveNetworkSignalFloat2(_ped, ptr_signalName, _value);
				Marshal.FreeHGlobal(ptr_signalName);
			}
		}

		public void _0x8634CEF2522D987B(int _ped, string _p1, float _value)
		{
			unsafe {
				if (fn__0x8634CEF2522D987B == null) fn__0x8634CEF2522D987B = (delegate* unmanaged[Cdecl]<int, nint, float, void>) NativeLibrary.GetExport(handle, "Native__0x8634CEF2522D987B");
				var ptr_p1 = MemoryUtils.StringToHGlobalUtf8(_p1);
				fn__0x8634CEF2522D987B(_ped, ptr_p1, _value);
				Marshal.FreeHGlobal(ptr_p1);
			}
		}

		public void SetTaskMoveNetworkSignalBool(int _ped, string _signalName, bool _value)
		{
			unsafe {
				if (fn__setTaskMoveNetworkSignalBool == null) fn__setTaskMoveNetworkSignalBool = (delegate* unmanaged[Cdecl]<int, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_setTaskMoveNetworkSignalBool");
				var ptr_signalName = MemoryUtils.StringToHGlobalUtf8(_signalName);
				fn__setTaskMoveNetworkSignalBool(_ped, ptr_signalName, _value);
				Marshal.FreeHGlobal(ptr_signalName);
			}
		}

		public float GetTaskMoveNetworkSignalFloat(int _ped, string _signalName)
		{
			unsafe {
				if (fn__getTaskMoveNetworkSignalFloat == null) fn__getTaskMoveNetworkSignalFloat = (delegate* unmanaged[Cdecl]<int, nint, float>) NativeLibrary.GetExport(handle, "Native_getTaskMoveNetworkSignalFloat");
				var ptr_signalName = MemoryUtils.StringToHGlobalUtf8(_signalName);
				var result = fn__getTaskMoveNetworkSignalFloat(_ped, ptr_signalName);
				Marshal.FreeHGlobal(ptr_signalName);
				return result;
			}
		}

		public bool GetTaskMoveNetworkSignalBool(int _ped, string _signalName)
		{
			unsafe {
				if (fn__getTaskMoveNetworkSignalBool == null) fn__getTaskMoveNetworkSignalBool = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_getTaskMoveNetworkSignalBool");
				var ptr_signalName = MemoryUtils.StringToHGlobalUtf8(_signalName);
				var result = fn__getTaskMoveNetworkSignalBool(_ped, ptr_signalName);
				Marshal.FreeHGlobal(ptr_signalName);
				return result;
			}
		}

		public bool GetTaskMoveNetworkEvent(int _ped, string _eventName)
		{
			unsafe {
				if (fn__getTaskMoveNetworkEvent == null) fn__getTaskMoveNetworkEvent = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_getTaskMoveNetworkEvent");
				var ptr_eventName = MemoryUtils.StringToHGlobalUtf8(_eventName);
				var result = fn__getTaskMoveNetworkEvent(_ped, ptr_eventName);
				Marshal.FreeHGlobal(ptr_eventName);
				return result;
			}
		}

		public int _0x0FFB3C758E8C07B9(int _ped, bool _p1)
		{
			unsafe {
				if (fn__0x0FFB3C758E8C07B9 == null) fn__0x0FFB3C758E8C07B9 = (delegate* unmanaged[Cdecl]<int, bool, int>) NativeLibrary.GetExport(handle, "Native__0x0FFB3C758E8C07B9");
				var result = fn__0x0FFB3C758E8C07B9(_ped, _p1);
				return result;
			}
		}

		public bool IsMoveBlendRatioStill(int _ped)
		{
			unsafe {
				if (fn__isMoveBlendRatioStill == null) fn__isMoveBlendRatioStill = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMoveBlendRatioStill");
				var result = fn__isMoveBlendRatioStill(_ped);
				return result;
			}
		}

		public bool IsMoveBlendRatioWalking(int _ped)
		{
			unsafe {
				if (fn__isMoveBlendRatioWalking == null) fn__isMoveBlendRatioWalking = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMoveBlendRatioWalking");
				var result = fn__isMoveBlendRatioWalking(_ped);
				return result;
			}
		}

		public bool IsMoveBlendRatioRunning(int _ped)
		{
			unsafe {
				if (fn__isMoveBlendRatioRunning == null) fn__isMoveBlendRatioRunning = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMoveBlendRatioRunning");
				var result = fn__isMoveBlendRatioRunning(_ped);
				return result;
			}
		}

		public bool IsMoveBlendRatioSprinting(int _ped)
		{
			unsafe {
				if (fn__isMoveBlendRatioSprinting == null) fn__isMoveBlendRatioSprinting = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMoveBlendRatioSprinting");
				var result = fn__isMoveBlendRatioSprinting(_ped);
				return result;
			}
		}

		public bool IsPedStill(int _ped)
		{
			unsafe {
				if (fn__isPedStill == null) fn__isPedStill = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedStill");
				var result = fn__isPedStill(_ped);
				return result;
			}
		}

		public bool IsPedWalking(int _ped)
		{
			unsafe {
				if (fn__isPedWalking == null) fn__isPedWalking = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedWalking");
				var result = fn__isPedWalking(_ped);
				return result;
			}
		}

		public bool IsPedRunning(int _ped)
		{
			unsafe {
				if (fn__isPedRunning == null) fn__isPedRunning = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedRunning");
				var result = fn__isPedRunning(_ped);
				return result;
			}
		}

		public bool IsPedSprinting(int _ped)
		{
			unsafe {
				if (fn__isPedSprinting == null) fn__isPedSprinting = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedSprinting");
				var result = fn__isPedSprinting(_ped);
				return result;
			}
		}

		public bool IsPedStrafing(int _ped)
		{
			unsafe {
				if (fn__isPedStrafing == null) fn__isPedStrafing = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedStrafing");
				var result = fn__isPedStrafing(_ped);
				return result;
			}
		}

		public void TaskSynchronizedScene(int _ped, int _scene, string _animDictionary, string _animationName, float _speed, float _speedMultiplier, int _duration, int _flag, float _playbackRate, int _p9)
		{
			unsafe {
				if (fn__taskSynchronizedScene == null) fn__taskSynchronizedScene = (delegate* unmanaged[Cdecl]<int, int, nint, nint, float, float, int, int, float, int, void>) NativeLibrary.GetExport(handle, "Native_taskSynchronizedScene");
				var ptr_animDictionary = MemoryUtils.StringToHGlobalUtf8(_animDictionary);
				var ptr_animationName = MemoryUtils.StringToHGlobalUtf8(_animationName);
				fn__taskSynchronizedScene(_ped, _scene, ptr_animDictionary, ptr_animationName, _speed, _speedMultiplier, _duration, _flag, _playbackRate, _p9);
				Marshal.FreeHGlobal(ptr_animDictionary);
				Marshal.FreeHGlobal(ptr_animationName);
			}
		}

		public void TaskAgitatedAction(int _ped, int _ped2)
		{
			unsafe {
				if (fn__taskAgitatedAction == null) fn__taskAgitatedAction = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskAgitatedAction");
				fn__taskAgitatedAction(_ped, _ped2);
			}
		}

		public void TaskSweepAimEntity(int _ped, string _anim, string _p2, string _p3, string _p4, int _p5, int _vehicle, float _p7, float _p8)
		{
			unsafe {
				if (fn__taskSweepAimEntity == null) fn__taskSweepAimEntity = (delegate* unmanaged[Cdecl]<int, nint, nint, nint, nint, int, int, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskSweepAimEntity");
				var ptr_anim = MemoryUtils.StringToHGlobalUtf8(_anim);
				var ptr_p2 = MemoryUtils.StringToHGlobalUtf8(_p2);
				var ptr_p3 = MemoryUtils.StringToHGlobalUtf8(_p3);
				var ptr_p4 = MemoryUtils.StringToHGlobalUtf8(_p4);
				fn__taskSweepAimEntity(_ped, ptr_anim, ptr_p2, ptr_p3, ptr_p4, _p5, _vehicle, _p7, _p8);
				Marshal.FreeHGlobal(ptr_anim);
				Marshal.FreeHGlobal(ptr_p2);
				Marshal.FreeHGlobal(ptr_p3);
				Marshal.FreeHGlobal(ptr_p4);
			}
		}

		public void UpdateTaskSweepAimEntity(int _ped, int _entity)
		{
			unsafe {
				if (fn__updateTaskSweepAimEntity == null) fn__updateTaskSweepAimEntity = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_updateTaskSweepAimEntity");
				fn__updateTaskSweepAimEntity(_ped, _entity);
			}
		}

		public void TaskSweepAimPosition(int _p0, ref int _p1, ref int _p2, ref int _p3, ref int _p4, int _p5, float _p6, float _p7, float _p8, float _p9, float _p10)
		{
			unsafe {
				if (fn__taskSweepAimPosition == null) fn__taskSweepAimPosition = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, int*, int, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_taskSweepAimPosition");
				var ref_p1 = _p1;
				var ref_p2 = _p2;
				var ref_p3 = _p3;
				var ref_p4 = _p4;
				fn__taskSweepAimPosition(_p0, &ref_p1, &ref_p2, &ref_p3, &ref_p4, _p5, _p6, _p7, _p8, _p9, _p10);
				_p1 = ref_p1;
				_p2 = ref_p2;
				_p3 = ref_p3;
				_p4 = ref_p4;
			}
		}

		public void UpdateTaskSweepAimPosition(int _p0, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__updateTaskSweepAimPosition == null) fn__updateTaskSweepAimPosition = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_updateTaskSweepAimPosition");
				fn__updateTaskSweepAimPosition(_p0, _p1, _p2, _p3);
			}
		}

		public void TaskArrestPed(int _ped, int _target)
		{
			unsafe {
				if (fn__taskArrestPed == null) fn__taskArrestPed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_taskArrestPed");
				fn__taskArrestPed(_ped, _target);
			}
		}

		public bool IsPedRunningArrestTask(int _ped)
		{
			unsafe {
				if (fn__isPedRunningArrestTask == null) fn__isPedRunningArrestTask = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedRunningArrestTask");
				var result = fn__isPedRunningArrestTask(_ped);
				return result;
			}
		}

		public bool IsPedBeingArrested(int _ped)
		{
			unsafe {
				if (fn__isPedBeingArrested == null) fn__isPedBeingArrested = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedBeingArrested");
				var result = fn__isPedBeingArrested(_ped);
				return result;
			}
		}

		public void UncuffPed(int _ped)
		{
			unsafe {
				if (fn__uncuffPed == null) fn__uncuffPed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_uncuffPed");
				fn__uncuffPed(_ped);
			}
		}

		public bool IsPedCuffed(int _ped)
		{
			unsafe {
				if (fn__isPedCuffed == null) fn__isPedCuffed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedCuffed");
				var result = fn__isPedCuffed(_ped);
				return result;
			}
		}

		public int CreateVehicle(int _modelHash, float _x, float _y, float _z, float _heading, bool _isNetwork, bool _bScriptHostVeh, bool _p7)
		{
			unsafe {
				if (fn__createVehicle == null) fn__createVehicle = (delegate* unmanaged[Cdecl]<int, float, float, float, float, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_createVehicle");
				var result = fn__createVehicle(_modelHash, _x, _y, _z, _heading, _isNetwork, _bScriptHostVeh, _p7);
				return result;
			}
		}

		public void DeleteVehicle(ref int _vehicle)
		{
			unsafe {
				if (fn__deleteVehicle == null) fn__deleteVehicle = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_deleteVehicle");
				var ref_vehicle = _vehicle;
				fn__deleteVehicle(&ref_vehicle);
				_vehicle = ref_vehicle;
			}
		}

		public void _0x7D6F9A3EF26136A0(int _vehicle, bool _toggle, bool _p2)
		{
			unsafe {
				if (fn__0x7D6F9A3EF26136A0 == null) fn__0x7D6F9A3EF26136A0 = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native__0x7D6F9A3EF26136A0");
				fn__0x7D6F9A3EF26136A0(_vehicle, _toggle, _p2);
			}
		}

		public void SetVehicleCanBeLockedOn(int _vehicle, bool _canBeLockedOn, bool _unk)
		{
			unsafe {
				if (fn__setVehicleCanBeLockedOn == null) fn__setVehicleCanBeLockedOn = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanBeLockedOn");
				fn__setVehicleCanBeLockedOn(_vehicle, _canBeLockedOn, _unk);
			}
		}

		public void SetVehicleAllowNoPassengersLockon(int _veh, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleAllowNoPassengersLockon == null) fn__setVehicleAllowNoPassengersLockon = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleAllowNoPassengersLockon");
				fn__setVehicleAllowNoPassengersLockon(_veh, _toggle);
			}
		}

		public int GetVehicleHomingLockonState(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleHomingLockonState == null) fn__getVehicleHomingLockonState = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleHomingLockonState");
				var result = fn__getVehicleHomingLockonState(_vehicle);
				return result;
			}
		}

		public int _0x6EAAEFC76ACC311F(int _p0)
		{
			unsafe {
				if (fn__0x6EAAEFC76ACC311F == null) fn__0x6EAAEFC76ACC311F = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x6EAAEFC76ACC311F");
				var result = fn__0x6EAAEFC76ACC311F(_p0);
				return result;
			}
		}

		public void _0x407DC5E97DB1A4D3(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x407DC5E97DB1A4D3 == null) fn__0x407DC5E97DB1A4D3 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x407DC5E97DB1A4D3");
				fn__0x407DC5E97DB1A4D3(_p0, _p1);
			}
		}

		public bool IsVehicleModel(int _vehicle, int _model)
		{
			unsafe {
				if (fn__isVehicleModel == null) fn__isVehicleModel = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleModel");
				var result = fn__isVehicleModel(_vehicle, _model);
				return result;
			}
		}

		public bool DoesScriptVehicleGeneratorExist(int _vehicleGenerator)
		{
			unsafe {
				if (fn__doesScriptVehicleGeneratorExist == null) fn__doesScriptVehicleGeneratorExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesScriptVehicleGeneratorExist");
				var result = fn__doesScriptVehicleGeneratorExist(_vehicleGenerator);
				return result;
			}
		}

		public int CreateScriptVehicleGenerator(float _x, float _y, float _z, float _heading, float _p4, float _p5, int _modelHash, int _p7, int _p8, int _p9, int _p10, bool _p11, bool _p12, bool _p13, bool _p14, bool _p15, int _p16)
		{
			unsafe {
				if (fn__createScriptVehicleGenerator == null) fn__createScriptVehicleGenerator = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, int, int, int, int, bool, bool, bool, bool, bool, int, int>) NativeLibrary.GetExport(handle, "Native_createScriptVehicleGenerator");
				var result = fn__createScriptVehicleGenerator(_x, _y, _z, _heading, _p4, _p5, _modelHash, _p7, _p8, _p9, _p10, _p11, _p12, _p13, _p14, _p15, _p16);
				return result;
			}
		}

		public void DeleteScriptVehicleGenerator(int _vehicleGenerator)
		{
			unsafe {
				if (fn__deleteScriptVehicleGenerator == null) fn__deleteScriptVehicleGenerator = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_deleteScriptVehicleGenerator");
				fn__deleteScriptVehicleGenerator(_vehicleGenerator);
			}
		}

		public void SetScriptVehicleGenerator(int _vehicleGenerator, bool _enabled)
		{
			unsafe {
				if (fn__setScriptVehicleGenerator == null) fn__setScriptVehicleGenerator = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setScriptVehicleGenerator");
				fn__setScriptVehicleGenerator(_vehicleGenerator, _enabled);
			}
		}

		public void SetAllVehicleGeneratorsActiveInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, bool _p6, bool _p7)
		{
			unsafe {
				if (fn__setAllVehicleGeneratorsActiveInArea == null) fn__setAllVehicleGeneratorsActiveInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setAllVehicleGeneratorsActiveInArea");
				fn__setAllVehicleGeneratorsActiveInArea(_x1, _y1, _z1, _x2, _y2, _z2, _p6, _p7);
			}
		}

		public void SetAllVehicleGeneratorsActive()
		{
			unsafe {
				if (fn__setAllVehicleGeneratorsActive == null) fn__setAllVehicleGeneratorsActive = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_setAllVehicleGeneratorsActive");
				fn__setAllVehicleGeneratorsActive();
			}
		}

		public void SetAllLowPriorityVehicleGeneratorsActive(bool _active)
		{
			unsafe {
				if (fn__setAllLowPriorityVehicleGeneratorsActive == null) fn__setAllLowPriorityVehicleGeneratorsActive = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setAllLowPriorityVehicleGeneratorsActive");
				fn__setAllLowPriorityVehicleGeneratorsActive(_active);
			}
		}

		public void _0x9A75585FB2E54FAD(float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__0x9A75585FB2E54FAD == null) fn__0x9A75585FB2E54FAD = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0x9A75585FB2E54FAD");
				fn__0x9A75585FB2E54FAD(_x, _y, _z, _radius);
			}
		}

		public void _0x0A436B8643716D14()
		{
			unsafe {
				if (fn__0x0A436B8643716D14 == null) fn__0x0A436B8643716D14 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0x0A436B8643716D14");
				fn__0x0A436B8643716D14();
			}
		}

		public bool SetVehicleOnGroundProperly(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__setVehicleOnGroundProperly == null) fn__setVehicleOnGroundProperly = (delegate* unmanaged[Cdecl]<int, float, bool>) NativeLibrary.GetExport(handle, "Native_setVehicleOnGroundProperly");
				var result = fn__setVehicleOnGroundProperly(_vehicle, _p1);
				return result;
			}
		}

		public int SetVehicleUseCutsceneWheelCompression(int _p0, bool _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__setVehicleUseCutsceneWheelCompression == null) fn__setVehicleUseCutsceneWheelCompression = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, int>) NativeLibrary.GetExport(handle, "Native_setVehicleUseCutsceneWheelCompression");
				var result = fn__setVehicleUseCutsceneWheelCompression(_p0, _p1, _p2, _p3);
				return result;
			}
		}

		public bool IsVehicleStuckOnRoof(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleStuckOnRoof == null) fn__isVehicleStuckOnRoof = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleStuckOnRoof");
				var result = fn__isVehicleStuckOnRoof(_vehicle);
				return result;
			}
		}

		public void AddVehicleUpsidedownCheck(int _vehicle)
		{
			unsafe {
				if (fn__addVehicleUpsidedownCheck == null) fn__addVehicleUpsidedownCheck = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_addVehicleUpsidedownCheck");
				fn__addVehicleUpsidedownCheck(_vehicle);
			}
		}

		public void RemoveVehicleUpsidedownCheck(int _vehicle)
		{
			unsafe {
				if (fn__removeVehicleUpsidedownCheck == null) fn__removeVehicleUpsidedownCheck = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleUpsidedownCheck");
				fn__removeVehicleUpsidedownCheck(_vehicle);
			}
		}

		public bool IsVehicleStopped(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleStopped == null) fn__isVehicleStopped = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleStopped");
				var result = fn__isVehicleStopped(_vehicle);
				return result;
			}
		}

		public int GetVehicleNumberOfPassengers(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleNumberOfPassengers == null) fn__getVehicleNumberOfPassengers = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleNumberOfPassengers");
				var result = fn__getVehicleNumberOfPassengers(_vehicle);
				return result;
			}
		}

		public int GetVehicleMaxNumberOfPassengers(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleMaxNumberOfPassengers == null) fn__getVehicleMaxNumberOfPassengers = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleMaxNumberOfPassengers");
				var result = fn__getVehicleMaxNumberOfPassengers(_vehicle);
				return result;
			}
		}

		public int GetVehicleModelNumberOfSeats(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleModelNumberOfSeats == null) fn__getVehicleModelNumberOfSeats = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleModelNumberOfSeats");
				var result = fn__getVehicleModelNumberOfSeats(_modelHash);
				return result;
			}
		}

		public bool IsSeatWarpOnly(int _vehicle, int _seatIndex)
		{
			unsafe {
				if (fn__isSeatWarpOnly == null) fn__isSeatWarpOnly = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isSeatWarpOnly");
				var result = fn__isSeatWarpOnly(_vehicle, _seatIndex);
				return result;
			}
		}

		public bool IsTurretSeat(int _vehicle, int _seatIndex)
		{
			unsafe {
				if (fn__isTurretSeat == null) fn__isTurretSeat = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isTurretSeat");
				var result = fn__isTurretSeat(_vehicle, _seatIndex);
				return result;
			}
		}

		public bool DoesVehicleAllowRappel(int _vehicle)
		{
			unsafe {
				if (fn__doesVehicleAllowRappel == null) fn__doesVehicleAllowRappel = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesVehicleAllowRappel");
				var result = fn__doesVehicleAllowRappel(_vehicle);
				return result;
			}
		}

		public void SetVehicleDensityMultiplierThisFrame(float _multiplier)
		{
			unsafe {
				if (fn__setVehicleDensityMultiplierThisFrame == null) fn__setVehicleDensityMultiplierThisFrame = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDensityMultiplierThisFrame");
				fn__setVehicleDensityMultiplierThisFrame(_multiplier);
			}
		}

		public void SetRandomVehicleDensityMultiplierThisFrame(float _multiplier)
		{
			unsafe {
				if (fn__setRandomVehicleDensityMultiplierThisFrame == null) fn__setRandomVehicleDensityMultiplierThisFrame = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setRandomVehicleDensityMultiplierThisFrame");
				fn__setRandomVehicleDensityMultiplierThisFrame(_multiplier);
			}
		}

		public void SetParkedVehicleDensityMultiplierThisFrame(float _multiplier)
		{
			unsafe {
				if (fn__setParkedVehicleDensityMultiplierThisFrame == null) fn__setParkedVehicleDensityMultiplierThisFrame = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setParkedVehicleDensityMultiplierThisFrame");
				fn__setParkedVehicleDensityMultiplierThisFrame(_multiplier);
			}
		}

		public void SetDisableRandomTrainsThisFrame(bool _toggle)
		{
			unsafe {
				if (fn__setDisableRandomTrainsThisFrame == null) fn__setDisableRandomTrainsThisFrame = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableRandomTrainsThisFrame");
				fn__setDisableRandomTrainsThisFrame(_toggle);
			}
		}

		public void SetAmbientVehicleRangeMultiplierThisFrame(float _value)
		{
			unsafe {
				if (fn__setAmbientVehicleRangeMultiplierThisFrame == null) fn__setAmbientVehicleRangeMultiplierThisFrame = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setAmbientVehicleRangeMultiplierThisFrame");
				fn__setAmbientVehicleRangeMultiplierThisFrame(_value);
			}
		}

		public void SetFarDrawVehicles(bool _toggle)
		{
			unsafe {
				if (fn__setFarDrawVehicles == null) fn__setFarDrawVehicles = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setFarDrawVehicles");
				fn__setFarDrawVehicles(_toggle);
			}
		}

		public void SetNumberOfParkedVehicles(int _value)
		{
			unsafe {
				if (fn__setNumberOfParkedVehicles == null) fn__setNumberOfParkedVehicles = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setNumberOfParkedVehicles");
				fn__setNumberOfParkedVehicles(_value);
			}
		}

		public void SetVehicleDoorsLocked(int _vehicle, int _doorLockStatus)
		{
			unsafe {
				if (fn__setVehicleDoorsLocked == null) fn__setVehicleDoorsLocked = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorsLocked");
				fn__setVehicleDoorsLocked(_vehicle, _doorLockStatus);
			}
		}

		public void SetVehicleIndividualDoorsLocked(int _vehicle, int _doorId, int _doorLockStatus)
		{
			unsafe {
				if (fn__setVehicleIndividualDoorsLocked == null) fn__setVehicleIndividualDoorsLocked = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleIndividualDoorsLocked");
				fn__setVehicleIndividualDoorsLocked(_vehicle, _doorId, _doorLockStatus);
			}
		}

		public void SetVehicleHasMutedSirens(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleHasMutedSirens == null) fn__setVehicleHasMutedSirens = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHasMutedSirens");
				fn__setVehicleHasMutedSirens(_vehicle, _toggle);
			}
		}

		public void SetVehicleDoorsLockedForPlayer(int _vehicle, int _player, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleDoorsLockedForPlayer == null) fn__setVehicleDoorsLockedForPlayer = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorsLockedForPlayer");
				fn__setVehicleDoorsLockedForPlayer(_vehicle, _player, _toggle);
			}
		}

		public bool GetVehicleDoorsLockedForPlayer(int _vehicle, int _player)
		{
			unsafe {
				if (fn__getVehicleDoorsLockedForPlayer == null) fn__getVehicleDoorsLockedForPlayer = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleDoorsLockedForPlayer");
				var result = fn__getVehicleDoorsLockedForPlayer(_vehicle, _player);
				return result;
			}
		}

		public void SetVehicleDoorsLockedForAllPlayers(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleDoorsLockedForAllPlayers == null) fn__setVehicleDoorsLockedForAllPlayers = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorsLockedForAllPlayers");
				fn__setVehicleDoorsLockedForAllPlayers(_vehicle, _toggle);
			}
		}

		public void SetVehicleDoorsLockedForNonScriptPlayers(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleDoorsLockedForNonScriptPlayers == null) fn__setVehicleDoorsLockedForNonScriptPlayers = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorsLockedForNonScriptPlayers");
				fn__setVehicleDoorsLockedForNonScriptPlayers(_vehicle, _toggle);
			}
		}

		public void SetVehicleDoorsLockedForTeam(int _vehicle, int _team, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleDoorsLockedForTeam == null) fn__setVehicleDoorsLockedForTeam = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorsLockedForTeam");
				fn__setVehicleDoorsLockedForTeam(_vehicle, _team, _toggle);
			}
		}

		public void SetVehicleDoorsLockedForUnk(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleDoorsLockedForUnk == null) fn__setVehicleDoorsLockedForUnk = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorsLockedForUnk");
				fn__setVehicleDoorsLockedForUnk(_vehicle, _toggle);
			}
		}

		public void _0x76D26A22750E849E(int _vehicle)
		{
			unsafe {
				if (fn__0x76D26A22750E849E == null) fn__0x76D26A22750E849E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x76D26A22750E849E");
				fn__0x76D26A22750E849E(_vehicle);
			}
		}

		public void ExplodeVehicle(int _vehicle, bool _isAudible, bool _isInvisible)
		{
			unsafe {
				if (fn__explodeVehicle == null) fn__explodeVehicle = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_explodeVehicle");
				fn__explodeVehicle(_vehicle, _isAudible, _isInvisible);
			}
		}

		public void SetVehicleOutOfControl(int _vehicle, bool _killDriver, bool _explodeOnImpact)
		{
			unsafe {
				if (fn__setVehicleOutOfControl == null) fn__setVehicleOutOfControl = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleOutOfControl");
				fn__setVehicleOutOfControl(_vehicle, _killDriver, _explodeOnImpact);
			}
		}

		public void SetVehicleTimedExplosion(int _vehicle, int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleTimedExplosion == null) fn__setVehicleTimedExplosion = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleTimedExplosion");
				fn__setVehicleTimedExplosion(_vehicle, _ped, _toggle);
			}
		}

		public void AddVehiclePhoneExplosiveDevice(int _vehicle)
		{
			unsafe {
				if (fn__addVehiclePhoneExplosiveDevice == null) fn__addVehiclePhoneExplosiveDevice = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_addVehiclePhoneExplosiveDevice");
				fn__addVehiclePhoneExplosiveDevice(_vehicle);
			}
		}

		public void ClearVehiclePhoneExplosiveDevice()
		{
			unsafe {
				if (fn__clearVehiclePhoneExplosiveDevice == null) fn__clearVehiclePhoneExplosiveDevice = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearVehiclePhoneExplosiveDevice");
				fn__clearVehiclePhoneExplosiveDevice();
			}
		}

		public bool HasVehiclePhoneExplosiveDevice()
		{
			unsafe {
				if (fn__hasVehiclePhoneExplosiveDevice == null) fn__hasVehiclePhoneExplosiveDevice = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasVehiclePhoneExplosiveDevice");
				var result = fn__hasVehiclePhoneExplosiveDevice();
				return result;
			}
		}

		public void DetonateVehiclePhoneExplosiveDevice()
		{
			unsafe {
				if (fn__detonateVehiclePhoneExplosiveDevice == null) fn__detonateVehiclePhoneExplosiveDevice = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_detonateVehiclePhoneExplosiveDevice");
				fn__detonateVehiclePhoneExplosiveDevice();
			}
		}

		public void SetTaxiLights(int _vehicle, bool _state)
		{
			unsafe {
				if (fn__setTaxiLights == null) fn__setTaxiLights = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setTaxiLights");
				fn__setTaxiLights(_vehicle, _state);
			}
		}

		public bool IsTaxiLightOn(int _vehicle)
		{
			unsafe {
				if (fn__isTaxiLightOn == null) fn__isTaxiLightOn = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isTaxiLightOn");
				var result = fn__isTaxiLightOn(_vehicle);
				return result;
			}
		}

		public bool IsVehicleInGarageArea(string _garageName, int _vehicle)
		{
			unsafe {
				if (fn__isVehicleInGarageArea == null) fn__isVehicleInGarageArea = (delegate* unmanaged[Cdecl]<nint, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleInGarageArea");
				var ptr_garageName = MemoryUtils.StringToHGlobalUtf8(_garageName);
				var result = fn__isVehicleInGarageArea(ptr_garageName, _vehicle);
				Marshal.FreeHGlobal(ptr_garageName);
				return result;
			}
		}

		public void SetVehicleColours(int _vehicle, int _colorPrimary, int _colorSecondary)
		{
			unsafe {
				if (fn__setVehicleColours == null) fn__setVehicleColours = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleColours");
				fn__setVehicleColours(_vehicle, _colorPrimary, _colorSecondary);
			}
		}

		public void SetVehicleFullbeam(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleFullbeam == null) fn__setVehicleFullbeam = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleFullbeam");
				fn__setVehicleFullbeam(_vehicle, _toggle);
			}
		}

		public void SetVehicleIsRacing(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleIsRacing == null) fn__setVehicleIsRacing = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleIsRacing");
				fn__setVehicleIsRacing(_vehicle, _toggle);
			}
		}

		public void SetVehicleCustomPrimaryColour(int _vehicle, int _r, int _g, int _b)
		{
			unsafe {
				if (fn__setVehicleCustomPrimaryColour == null) fn__setVehicleCustomPrimaryColour = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCustomPrimaryColour");
				fn__setVehicleCustomPrimaryColour(_vehicle, _r, _g, _b);
			}
		}

		public void GetVehicleCustomPrimaryColour(int _vehicle, ref int _r, ref int _g, ref int _b)
		{
			unsafe {
				if (fn__getVehicleCustomPrimaryColour == null) fn__getVehicleCustomPrimaryColour = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleCustomPrimaryColour");
				var ref_r = _r;
				var ref_g = _g;
				var ref_b = _b;
				fn__getVehicleCustomPrimaryColour(_vehicle, &ref_r, &ref_g, &ref_b);
				_r = ref_r;
				_g = ref_g;
				_b = ref_b;
			}
		}

		public void ClearVehicleCustomPrimaryColour(int _vehicle)
		{
			unsafe {
				if (fn__clearVehicleCustomPrimaryColour == null) fn__clearVehicleCustomPrimaryColour = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearVehicleCustomPrimaryColour");
				fn__clearVehicleCustomPrimaryColour(_vehicle);
			}
		}

		public bool GetIsVehiclePrimaryColourCustom(int _vehicle)
		{
			unsafe {
				if (fn__getIsVehiclePrimaryColourCustom == null) fn__getIsVehiclePrimaryColourCustom = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getIsVehiclePrimaryColourCustom");
				var result = fn__getIsVehiclePrimaryColourCustom(_vehicle);
				return result;
			}
		}

		public void SetVehicleCustomSecondaryColour(int _vehicle, int _r, int _g, int _b)
		{
			unsafe {
				if (fn__setVehicleCustomSecondaryColour == null) fn__setVehicleCustomSecondaryColour = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCustomSecondaryColour");
				fn__setVehicleCustomSecondaryColour(_vehicle, _r, _g, _b);
			}
		}

		public void GetVehicleCustomSecondaryColour(int _vehicle, ref int _r, ref int _g, ref int _b)
		{
			unsafe {
				if (fn__getVehicleCustomSecondaryColour == null) fn__getVehicleCustomSecondaryColour = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleCustomSecondaryColour");
				var ref_r = _r;
				var ref_g = _g;
				var ref_b = _b;
				fn__getVehicleCustomSecondaryColour(_vehicle, &ref_r, &ref_g, &ref_b);
				_r = ref_r;
				_g = ref_g;
				_b = ref_b;
			}
		}

		public void ClearVehicleCustomSecondaryColour(int _vehicle)
		{
			unsafe {
				if (fn__clearVehicleCustomSecondaryColour == null) fn__clearVehicleCustomSecondaryColour = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearVehicleCustomSecondaryColour");
				fn__clearVehicleCustomSecondaryColour(_vehicle);
			}
		}

		public bool GetIsVehicleSecondaryColourCustom(int _vehicle)
		{
			unsafe {
				if (fn__getIsVehicleSecondaryColourCustom == null) fn__getIsVehicleSecondaryColourCustom = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getIsVehicleSecondaryColourCustom");
				var result = fn__getIsVehicleSecondaryColourCustom(_vehicle);
				return result;
			}
		}

		public void SetVehicleEnveffScale(int _vehicle, float _fade)
		{
			unsafe {
				if (fn__setVehicleEnveffScale == null) fn__setVehicleEnveffScale = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleEnveffScale");
				fn__setVehicleEnveffScale(_vehicle, _fade);
			}
		}

		public float GetVehicleEnveffScale(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleEnveffScale == null) fn__getVehicleEnveffScale = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleEnveffScale");
				var result = fn__getVehicleEnveffScale(_vehicle);
				return result;
			}
		}

		public void SetCanResprayVehicle(int _vehicle, bool _state)
		{
			unsafe {
				if (fn__setCanResprayVehicle == null) fn__setCanResprayVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCanResprayVehicle");
				fn__setCanResprayVehicle(_vehicle, _state);
			}
		}

		public void _0xAB31EF4DE6800CE9(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xAB31EF4DE6800CE9 == null) fn__0xAB31EF4DE6800CE9 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xAB31EF4DE6800CE9");
				fn__0xAB31EF4DE6800CE9(_p0, _p1);
			}
		}

		public void _0x1B212B26DD3C04DF(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0x1B212B26DD3C04DF == null) fn__0x1B212B26DD3C04DF = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x1B212B26DD3C04DF");
				fn__0x1B212B26DD3C04DF(_vehicle, _toggle);
			}
		}

		public void ForceSubmarineSurfaceMode(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__forceSubmarineSurfaceMode == null) fn__forceSubmarineSurfaceMode = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_forceSubmarineSurfaceMode");
				fn__forceSubmarineSurfaceMode(_vehicle, _toggle);
			}
		}

		public void _0xC67DB108A9ADE3BE(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xC67DB108A9ADE3BE == null) fn__0xC67DB108A9ADE3BE = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xC67DB108A9ADE3BE");
				fn__0xC67DB108A9ADE3BE(_p0, _p1);
			}
		}

		public void SetSubmarineCrushDepths(int _vehicle, bool _p1, float _depth1, float _depth2, float _depth3)
		{
			unsafe {
				if (fn__setSubmarineCrushDepths == null) fn__setSubmarineCrushDepths = (delegate* unmanaged[Cdecl]<int, bool, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setSubmarineCrushDepths");
				fn__setSubmarineCrushDepths(_vehicle, _p1, _depth1, _depth2, _depth3);
			}
		}

		public bool GetSubmarineIsBelowFirstCrushDepth(int _submarine)
		{
			unsafe {
				if (fn__getSubmarineIsBelowFirstCrushDepth == null) fn__getSubmarineIsBelowFirstCrushDepth = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getSubmarineIsBelowFirstCrushDepth");
				var result = fn__getSubmarineIsBelowFirstCrushDepth(_submarine);
				return result;
			}
		}

		public int GetSubmarineCrushDepthWarningState(int _submarine)
		{
			unsafe {
				if (fn__getSubmarineCrushDepthWarningState == null) fn__getSubmarineCrushDepthWarningState = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getSubmarineCrushDepthWarningState");
				var result = fn__getSubmarineCrushDepthWarningState(_submarine);
				return result;
			}
		}

		public void _0xED5EDE9E676643C9(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xED5EDE9E676643C9 == null) fn__0xED5EDE9E676643C9 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xED5EDE9E676643C9");
				fn__0xED5EDE9E676643C9(_p0, _p1);
			}
		}

		public void SetBoatAnchor(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setBoatAnchor == null) fn__setBoatAnchor = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBoatAnchor");
				fn__setBoatAnchor(_vehicle, _toggle);
			}
		}

		public bool CanAnchorBoatHere(int _vehicle)
		{
			unsafe {
				if (fn__canAnchorBoatHere == null) fn__canAnchorBoatHere = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canAnchorBoatHere");
				var result = fn__canAnchorBoatHere(_vehicle);
				return result;
			}
		}

		public bool CanAnchorBoatHere2(int _vehicle)
		{
			unsafe {
				if (fn__canAnchorBoatHere2 == null) fn__canAnchorBoatHere2 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canAnchorBoatHere2");
				var result = fn__canAnchorBoatHere2(_vehicle);
				return result;
			}
		}

		public void SetBoatFrozenWhenAnchored(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setBoatFrozenWhenAnchored == null) fn__setBoatFrozenWhenAnchored = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBoatFrozenWhenAnchored");
				fn__setBoatFrozenWhenAnchored(_vehicle, _toggle);
			}
		}

		public void _0xB28B1FE5BFADD7F5(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0xB28B1FE5BFADD7F5 == null) fn__0xB28B1FE5BFADD7F5 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xB28B1FE5BFADD7F5");
				fn__0xB28B1FE5BFADD7F5(_vehicle, _p1);
			}
		}

		public void SetBoatMovementResistance(int _vehicle, float _value)
		{
			unsafe {
				if (fn__setBoatMovementResistance == null) fn__setBoatMovementResistance = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setBoatMovementResistance");
				fn__setBoatMovementResistance(_vehicle, _value);
			}
		}

		public bool IsBoatAnchoredAndFrozen(int _vehicle)
		{
			unsafe {
				if (fn__isBoatAnchoredAndFrozen == null) fn__isBoatAnchoredAndFrozen = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isBoatAnchoredAndFrozen");
				var result = fn__isBoatAnchoredAndFrozen(_vehicle);
				return result;
			}
		}

		public void SetBoatSinksWhenWrecked(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setBoatSinksWhenWrecked == null) fn__setBoatSinksWhenWrecked = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBoatSinksWhenWrecked");
				fn__setBoatSinksWhenWrecked(_vehicle, _toggle);
			}
		}

		public void SetBoatIsSinking(int _p0)
		{
			unsafe {
				if (fn__setBoatIsSinking == null) fn__setBoatIsSinking = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setBoatIsSinking");
				fn__setBoatIsSinking(_p0);
			}
		}

		public void SetVehicleSiren(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleSiren == null) fn__setVehicleSiren = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleSiren");
				fn__setVehicleSiren(_vehicle, _toggle);
			}
		}

		public bool IsVehicleSirenOn(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleSirenOn == null) fn__isVehicleSirenOn = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleSirenOn");
				var result = fn__isVehicleSirenOn(_vehicle);
				return result;
			}
		}

		public bool IsVehicleSirenAudioOn(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleSirenAudioOn == null) fn__isVehicleSirenAudioOn = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleSirenAudioOn");
				var result = fn__isVehicleSirenAudioOn(_vehicle);
				return result;
			}
		}

		public void SetVehicleStrong(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleStrong == null) fn__setVehicleStrong = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleStrong");
				fn__setVehicleStrong(_vehicle, _toggle);
			}
		}

		public void RemoveVehicleStuckCheck(int _vehicle)
		{
			unsafe {
				if (fn__removeVehicleStuckCheck == null) fn__removeVehicleStuckCheck = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleStuckCheck");
				fn__removeVehicleStuckCheck(_vehicle);
			}
		}

		public void GetVehicleColours(int _vehicle, ref int _colorPrimary, ref int _colorSecondary)
		{
			unsafe {
				if (fn__getVehicleColours == null) fn__getVehicleColours = (delegate* unmanaged[Cdecl]<int, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleColours");
				var ref_colorPrimary = _colorPrimary;
				var ref_colorSecondary = _colorSecondary;
				fn__getVehicleColours(_vehicle, &ref_colorPrimary, &ref_colorSecondary);
				_colorPrimary = ref_colorPrimary;
				_colorSecondary = ref_colorSecondary;
			}
		}

		public bool IsVehicleSeatFree(int _vehicle, int _seatIndex, bool _isTaskRunning)
		{
			unsafe {
				if (fn__isVehicleSeatFree == null) fn__isVehicleSeatFree = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleSeatFree");
				var result = fn__isVehicleSeatFree(_vehicle, _seatIndex, _isTaskRunning);
				return result;
			}
		}

		public int GetPedInVehicleSeat(int _vehicle, int _seatIndex, bool _p2)
		{
			unsafe {
				if (fn__getPedInVehicleSeat == null) fn__getPedInVehicleSeat = (delegate* unmanaged[Cdecl]<int, int, bool, int>) NativeLibrary.GetExport(handle, "Native_getPedInVehicleSeat");
				var result = fn__getPedInVehicleSeat(_vehicle, _seatIndex, _p2);
				return result;
			}
		}

		public int GetLastPedInVehicleSeat(int _vehicle, int _seatIndex)
		{
			unsafe {
				if (fn__getLastPedInVehicleSeat == null) fn__getLastPedInVehicleSeat = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getLastPedInVehicleSeat");
				var result = fn__getLastPedInVehicleSeat(_vehicle, _seatIndex);
				return result;
			}
		}

		public bool GetVehicleLightsState(int _vehicle, ref bool _lightsOn, ref bool _highbeamsOn)
		{
			unsafe {
				if (fn__getVehicleLightsState == null) fn__getVehicleLightsState = (delegate* unmanaged[Cdecl]<int, bool*, bool*, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleLightsState");
				var ref_lightsOn = _lightsOn;
				var ref_highbeamsOn = _highbeamsOn;
				var result = fn__getVehicleLightsState(_vehicle, &ref_lightsOn, &ref_highbeamsOn);
				_lightsOn = ref_lightsOn;
				_highbeamsOn = ref_highbeamsOn;
				return result;
			}
		}

		public bool IsVehicleTyreBurst(int _vehicle, int _wheelID, bool _completely)
		{
			unsafe {
				if (fn__isVehicleTyreBurst == null) fn__isVehicleTyreBurst = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleTyreBurst");
				var result = fn__isVehicleTyreBurst(_vehicle, _wheelID, _completely);
				return result;
			}
		}

		public void SetVehicleForwardSpeed(int _vehicle, float _speed)
		{
			unsafe {
				if (fn__setVehicleForwardSpeed == null) fn__setVehicleForwardSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleForwardSpeed");
				fn__setVehicleForwardSpeed(_vehicle, _speed);
			}
		}

		public void _0x6501129C9E0FFA05(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x6501129C9E0FFA05 == null) fn__0x6501129C9E0FFA05 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x6501129C9E0FFA05");
				fn__0x6501129C9E0FFA05(_p0, _p1);
			}
		}

		public void BringVehicleToHalt(int _vehicle, float _distance, int _duration, bool _unknown)
		{
			unsafe {
				if (fn__bringVehicleToHalt == null) fn__bringVehicleToHalt = (delegate* unmanaged[Cdecl]<int, float, int, bool, void>) NativeLibrary.GetExport(handle, "Native_bringVehicleToHalt");
				fn__bringVehicleToHalt(_vehicle, _distance, _duration, _unknown);
			}
		}

		public void _0xDCE97BDF8A0EABC8(int _vehicle, int _p1)
		{
			unsafe {
				if (fn__0xDCE97BDF8A0EABC8 == null) fn__0xDCE97BDF8A0EABC8 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xDCE97BDF8A0EABC8");
				fn__0xDCE97BDF8A0EABC8(_vehicle, _p1);
			}
		}

		public void _0x9849DE24FCF23CCC(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0x9849DE24FCF23CCC == null) fn__0x9849DE24FCF23CCC = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x9849DE24FCF23CCC");
				fn__0x9849DE24FCF23CCC(_vehicle, _toggle);
			}
		}

		public void _0x8664170EF165C4A6(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x8664170EF165C4A6 == null) fn__0x8664170EF165C4A6 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x8664170EF165C4A6");
				fn__0x8664170EF165C4A6(_p0, _p1);
			}
		}

		public void StopBringVehicleToHalt(int _vehicle)
		{
			unsafe {
				if (fn__stopBringVehicleToHalt == null) fn__stopBringVehicleToHalt = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopBringVehicleToHalt");
				fn__stopBringVehicleToHalt(_vehicle);
			}
		}

		public bool IsVehicleBeingHalted(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleBeingHalted == null) fn__isVehicleBeingHalted = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleBeingHalted");
				var result = fn__isVehicleBeingHalted(_vehicle);
				return result;
			}
		}

		public void SetForkliftForkHeight(int _vehicle, float _height)
		{
			unsafe {
				if (fn__setForkliftForkHeight == null) fn__setForkliftForkHeight = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setForkliftForkHeight");
				fn__setForkliftForkHeight(_vehicle, _height);
			}
		}

		public bool IsEntityAttachedToHandlerFrame(int _vehicle, int _entity)
		{
			unsafe {
				if (fn__isEntityAttachedToHandlerFrame == null) fn__isEntityAttachedToHandlerFrame = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isEntityAttachedToHandlerFrame");
				var result = fn__isEntityAttachedToHandlerFrame(_vehicle, _entity);
				return result;
			}
		}

		public bool IsAnyEntityAttachedToHandlerFrame(int _vehicle)
		{
			unsafe {
				if (fn__isAnyEntityAttachedToHandlerFrame == null) fn__isAnyEntityAttachedToHandlerFrame = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isAnyEntityAttachedToHandlerFrame");
				var result = fn__isAnyEntityAttachedToHandlerFrame(_vehicle);
				return result;
			}
		}

		public int FindVehicleCarryingThisEntity(int _entity)
		{
			unsafe {
				if (fn__findVehicleCarryingThisEntity == null) fn__findVehicleCarryingThisEntity = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_findVehicleCarryingThisEntity");
				var result = fn__findVehicleCarryingThisEntity(_entity);
				return result;
			}
		}

		public bool IsHandlerFrameAboveContainer(int _vehicle, int _entity)
		{
			unsafe {
				if (fn__isHandlerFrameAboveContainer == null) fn__isHandlerFrameAboveContainer = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isHandlerFrameAboveContainer");
				var result = fn__isHandlerFrameAboveContainer(_vehicle, _entity);
				return result;
			}
		}

		public void _0x6A98C2ECF57FA5D4(int _vehicle, int _entity)
		{
			unsafe {
				if (fn__0x6A98C2ECF57FA5D4 == null) fn__0x6A98C2ECF57FA5D4 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x6A98C2ECF57FA5D4");
				fn__0x6A98C2ECF57FA5D4(_vehicle, _entity);
			}
		}

		public void DetachContainerFromHandlerFrame(int _vehicle)
		{
			unsafe {
				if (fn__detachContainerFromHandlerFrame == null) fn__detachContainerFromHandlerFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_detachContainerFromHandlerFrame");
				fn__detachContainerFromHandlerFrame(_vehicle);
			}
		}

		public void _0x8AA9180DE2FEDD45(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x8AA9180DE2FEDD45 == null) fn__0x8AA9180DE2FEDD45 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x8AA9180DE2FEDD45");
				fn__0x8AA9180DE2FEDD45(_vehicle, _p1);
			}
		}

		public void SetBoatDisableAvoidance(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__setBoatDisableAvoidance == null) fn__setBoatDisableAvoidance = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setBoatDisableAvoidance");
				fn__setBoatDisableAvoidance(_vehicle, _p1);
			}
		}

		public bool IsHeliLandingAreaBlocked(int _vehicle)
		{
			unsafe {
				if (fn__isHeliLandingAreaBlocked == null) fn__isHeliLandingAreaBlocked = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isHeliLandingAreaBlocked");
				var result = fn__isHeliLandingAreaBlocked(_vehicle);
				return result;
			}
		}

		public void _0x107A473D7A6647A9(int _vehicle)
		{
			unsafe {
				if (fn__0x107A473D7A6647A9 == null) fn__0x107A473D7A6647A9 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x107A473D7A6647A9");
				fn__0x107A473D7A6647A9(_vehicle);
			}
		}

		public void SetHeliTurbulenceScalar(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__setHeliTurbulenceScalar == null) fn__setHeliTurbulenceScalar = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setHeliTurbulenceScalar");
				fn__setHeliTurbulenceScalar(_vehicle, _p1);
			}
		}

		public void SetCarBootOpen(int _vehicle)
		{
			unsafe {
				if (fn__setCarBootOpen == null) fn__setCarBootOpen = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setCarBootOpen");
				fn__setCarBootOpen(_vehicle);
			}
		}

		public void SetVehicleTyreBurst(int _vehicle, int _index, bool _onRim, float _p3)
		{
			unsafe {
				if (fn__setVehicleTyreBurst == null) fn__setVehicleTyreBurst = (delegate* unmanaged[Cdecl]<int, int, bool, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleTyreBurst");
				fn__setVehicleTyreBurst(_vehicle, _index, _onRim, _p3);
			}
		}

		public void SetVehicleDoorsShut(int _vehicle, bool _closeInstantly)
		{
			unsafe {
				if (fn__setVehicleDoorsShut == null) fn__setVehicleDoorsShut = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorsShut");
				fn__setVehicleDoorsShut(_vehicle, _closeInstantly);
			}
		}

		public void SetVehicleTyresCanBurst(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleTyresCanBurst == null) fn__setVehicleTyresCanBurst = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleTyresCanBurst");
				fn__setVehicleTyresCanBurst(_vehicle, _toggle);
			}
		}

		public bool GetVehicleTyresCanBurst(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleTyresCanBurst == null) fn__getVehicleTyresCanBurst = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleTyresCanBurst");
				var result = fn__getVehicleTyresCanBurst(_vehicle);
				return result;
			}
		}

		public void SetVehicleWheelsCanBreak(int _vehicle, bool _enabled)
		{
			unsafe {
				if (fn__setVehicleWheelsCanBreak == null) fn__setVehicleWheelsCanBreak = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleWheelsCanBreak");
				fn__setVehicleWheelsCanBreak(_vehicle, _enabled);
			}
		}

		public void SetVehicleDoorOpen(int _vehicle, int _doorId, bool _loose, bool _openInstantly)
		{
			unsafe {
				if (fn__setVehicleDoorOpen == null) fn__setVehicleDoorOpen = (delegate* unmanaged[Cdecl]<int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorOpen");
				fn__setVehicleDoorOpen(_vehicle, _doorId, _loose, _openInstantly);
			}
		}

		public void _0x3B458DDB57038F08(int _vehicle, int _doorId, bool _toggle)
		{
			unsafe {
				if (fn__0x3B458DDB57038F08 == null) fn__0x3B458DDB57038F08 = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x3B458DDB57038F08");
				fn__0x3B458DDB57038F08(_vehicle, _doorId, _toggle);
			}
		}

		public void _0xA247F9EF01D8082E(int _p0)
		{
			unsafe {
				if (fn__0xA247F9EF01D8082E == null) fn__0xA247F9EF01D8082E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xA247F9EF01D8082E");
				fn__0xA247F9EF01D8082E(_p0);
			}
		}

		public void RemoveVehicleWindow(int _vehicle, int _windowIndex)
		{
			unsafe {
				if (fn__removeVehicleWindow == null) fn__removeVehicleWindow = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleWindow");
				fn__removeVehicleWindow(_vehicle, _windowIndex);
			}
		}

		public void RollDownWindows(int _vehicle)
		{
			unsafe {
				if (fn__rollDownWindows == null) fn__rollDownWindows = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_rollDownWindows");
				fn__rollDownWindows(_vehicle);
			}
		}

		public void RollDownWindow(int _vehicle, int _windowIndex)
		{
			unsafe {
				if (fn__rollDownWindow == null) fn__rollDownWindow = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_rollDownWindow");
				fn__rollDownWindow(_vehicle, _windowIndex);
			}
		}

		public void RollUpWindow(int _vehicle, int _windowIndex)
		{
			unsafe {
				if (fn__rollUpWindow == null) fn__rollUpWindow = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_rollUpWindow");
				fn__rollUpWindow(_vehicle, _windowIndex);
			}
		}

		public void SmashVehicleWindow(int _vehicle, int _index)
		{
			unsafe {
				if (fn__smashVehicleWindow == null) fn__smashVehicleWindow = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_smashVehicleWindow");
				fn__smashVehicleWindow(_vehicle, _index);
			}
		}

		public void FixVehicleWindow(int _vehicle, int _index)
		{
			unsafe {
				if (fn__fixVehicleWindow == null) fn__fixVehicleWindow = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_fixVehicleWindow");
				fn__fixVehicleWindow(_vehicle, _index);
			}
		}

		public void PopOutVehicleWindscreen(int _vehicle)
		{
			unsafe {
				if (fn__popOutVehicleWindscreen == null) fn__popOutVehicleWindscreen = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_popOutVehicleWindscreen");
				fn__popOutVehicleWindscreen(_vehicle);
			}
		}

		public void EjectJb700Roof(int _vehicle, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__ejectJb700Roof == null) fn__ejectJb700Roof = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_ejectJb700Roof");
				fn__ejectJb700Roof(_vehicle, _x, _y, _z);
			}
		}

		public void SetVehicleLights(int _vehicle, int _state)
		{
			unsafe {
				if (fn__setVehicleLights == null) fn__setVehicleLights = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleLights");
				fn__setVehicleLights(_vehicle, _state);
			}
		}

		public void SetVehicleUsePlayerLightSettings(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleUsePlayerLightSettings == null) fn__setVehicleUsePlayerLightSettings = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleUsePlayerLightSettings");
				fn__setVehicleUsePlayerLightSettings(_vehicle, _toggle);
			}
		}

		public void SetVehicleLightsMode(int _vehicle, int _p1)
		{
			unsafe {
				if (fn__setVehicleLightsMode == null) fn__setVehicleLightsMode = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleLightsMode");
				fn__setVehicleLightsMode(_vehicle, _p1);
			}
		}

		public void SetVehicleAlarm(int _vehicle, bool _state)
		{
			unsafe {
				if (fn__setVehicleAlarm == null) fn__setVehicleAlarm = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleAlarm");
				fn__setVehicleAlarm(_vehicle, _state);
			}
		}

		public void StartVehicleAlarm(int _vehicle)
		{
			unsafe {
				if (fn__startVehicleAlarm == null) fn__startVehicleAlarm = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_startVehicleAlarm");
				fn__startVehicleAlarm(_vehicle);
			}
		}

		public bool IsVehicleAlarmActivated(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleAlarmActivated == null) fn__isVehicleAlarmActivated = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleAlarmActivated");
				var result = fn__isVehicleAlarmActivated(_vehicle);
				return result;
			}
		}

		public void SetVehicleInteriorlight(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleInteriorlight == null) fn__setVehicleInteriorlight = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleInteriorlight");
				fn__setVehicleInteriorlight(_vehicle, _toggle);
			}
		}

		public void _0x8821196D91FA2DE5(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0x8821196D91FA2DE5 == null) fn__0x8821196D91FA2DE5 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x8821196D91FA2DE5");
				fn__0x8821196D91FA2DE5(_vehicle, _toggle);
			}
		}

		public void SetVehicleLightMultiplier(int _vehicle, float _multiplier)
		{
			unsafe {
				if (fn__setVehicleLightMultiplier == null) fn__setVehicleLightMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleLightMultiplier");
				fn__setVehicleLightMultiplier(_vehicle, _multiplier);
			}
		}

		public void AttachVehicleToTrailer(int _vehicle, int _trailer, float _radius)
		{
			unsafe {
				if (fn__attachVehicleToTrailer == null) fn__attachVehicleToTrailer = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_attachVehicleToTrailer");
				fn__attachVehicleToTrailer(_vehicle, _trailer, _radius);
			}
		}

		public void AttachVehicleOnToTrailer(int _vehicle, int _trailer, float _offsetX, float _offsetY, float _offsetZ, float _coordsX, float _coordsY, float _coordsZ, float _rotationX, float _rotationY, float _rotationZ, float _disableCollisions)
		{
			unsafe {
				if (fn__attachVehicleOnToTrailer == null) fn__attachVehicleOnToTrailer = (delegate* unmanaged[Cdecl]<int, int, float, float, float, float, float, float, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_attachVehicleOnToTrailer");
				fn__attachVehicleOnToTrailer(_vehicle, _trailer, _offsetX, _offsetY, _offsetZ, _coordsX, _coordsY, _coordsZ, _rotationX, _rotationY, _rotationZ, _disableCollisions);
			}
		}

		public void StabiliseEntityAttachedToHeli(int _vehicle, int _entity, float _p2)
		{
			unsafe {
				if (fn__stabiliseEntityAttachedToHeli == null) fn__stabiliseEntityAttachedToHeli = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_stabiliseEntityAttachedToHeli");
				fn__stabiliseEntityAttachedToHeli(_vehicle, _entity, _p2);
			}
		}

		public void DetachVehicleFromTrailer(int _vehicle)
		{
			unsafe {
				if (fn__detachVehicleFromTrailer == null) fn__detachVehicleFromTrailer = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_detachVehicleFromTrailer");
				fn__detachVehicleFromTrailer(_vehicle);
			}
		}

		public bool IsVehicleAttachedToTrailer(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleAttachedToTrailer == null) fn__isVehicleAttachedToTrailer = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleAttachedToTrailer");
				var result = fn__isVehicleAttachedToTrailer(_vehicle);
				return result;
			}
		}

		public void SetTrailerInverseMassScale(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__setTrailerInverseMassScale == null) fn__setTrailerInverseMassScale = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setTrailerInverseMassScale");
				fn__setTrailerInverseMassScale(_vehicle, _p1);
			}
		}

		public void SetTrailerLegsRaised(int _vehicle)
		{
			unsafe {
				if (fn__setTrailerLegsRaised == null) fn__setTrailerLegsRaised = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setTrailerLegsRaised");
				fn__setTrailerLegsRaised(_vehicle);
			}
		}

		public void SetTrailerLegsLowered(int _p0)
		{
			unsafe {
				if (fn__setTrailerLegsLowered == null) fn__setTrailerLegsLowered = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setTrailerLegsLowered");
				fn__setTrailerLegsLowered(_p0);
			}
		}

		public void SetVehicleTyreFixed(int _vehicle, int _tyreIndex)
		{
			unsafe {
				if (fn__setVehicleTyreFixed == null) fn__setVehicleTyreFixed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleTyreFixed");
				fn__setVehicleTyreFixed(_vehicle, _tyreIndex);
			}
		}

		public void SetVehicleNumberPlateText(int _vehicle, string _plateText)
		{
			unsafe {
				if (fn__setVehicleNumberPlateText == null) fn__setVehicleNumberPlateText = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setVehicleNumberPlateText");
				var ptr_plateText = MemoryUtils.StringToHGlobalUtf8(_plateText);
				fn__setVehicleNumberPlateText(_vehicle, ptr_plateText);
				Marshal.FreeHGlobal(ptr_plateText);
			}
		}

		public string GetVehicleNumberPlateText(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleNumberPlateText == null) fn__getVehicleNumberPlateText = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getVehicleNumberPlateText");
				var result = fn__getVehicleNumberPlateText(_vehicle);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int GetNumberOfVehicleNumberPlates()
		{
			unsafe {
				if (fn__getNumberOfVehicleNumberPlates == null) fn__getNumberOfVehicleNumberPlates = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumberOfVehicleNumberPlates");
				var result = fn__getNumberOfVehicleNumberPlates();
				return result;
			}
		}

		public void SetVehicleNumberPlateTextIndex(int _vehicle, int _plateIndex)
		{
			unsafe {
				if (fn__setVehicleNumberPlateTextIndex == null) fn__setVehicleNumberPlateTextIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleNumberPlateTextIndex");
				fn__setVehicleNumberPlateTextIndex(_vehicle, _plateIndex);
			}
		}

		public int GetVehicleNumberPlateTextIndex(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleNumberPlateTextIndex == null) fn__getVehicleNumberPlateTextIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleNumberPlateTextIndex");
				var result = fn__getVehicleNumberPlateTextIndex(_vehicle);
				return result;
			}
		}

		public void SetRandomTrains(bool _toggle)
		{
			unsafe {
				if (fn__setRandomTrains == null) fn__setRandomTrains = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setRandomTrains");
				fn__setRandomTrains(_toggle);
			}
		}

		public int CreateMissionTrain(int _unkVariation, float _x, float _y, float _z, bool _direction, int _p5, int _p6)
		{
			unsafe {
				if (fn__createMissionTrain == null) fn__createMissionTrain = (delegate* unmanaged[Cdecl]<int, float, float, float, bool, int, int, int>) NativeLibrary.GetExport(handle, "Native_createMissionTrain");
				var result = fn__createMissionTrain(_unkVariation, _x, _y, _z, _direction, _p5, _p6);
				return result;
			}
		}

		public void SwitchTrainTrack(int _trackId, bool _state)
		{
			unsafe {
				if (fn__switchTrainTrack == null) fn__switchTrainTrack = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_switchTrainTrack");
				fn__switchTrainTrack(_trackId, _state);
			}
		}

		public void SetTrainTrackSpawnFrequency(int _trackIndex, int _frequency)
		{
			unsafe {
				if (fn__setTrainTrackSpawnFrequency == null) fn__setTrainTrackSpawnFrequency = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setTrainTrackSpawnFrequency");
				fn__setTrainTrackSpawnFrequency(_trackIndex, _frequency);
			}
		}

		public void _0x2310A8F9421EBF43(int _p0)
		{
			unsafe {
				if (fn__0x2310A8F9421EBF43 == null) fn__0x2310A8F9421EBF43 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x2310A8F9421EBF43");
				fn__0x2310A8F9421EBF43(_p0);
			}
		}

		public void DeleteAllTrains()
		{
			unsafe {
				if (fn__deleteAllTrains == null) fn__deleteAllTrains = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_deleteAllTrains");
				fn__deleteAllTrains();
			}
		}

		public void SetTrainSpeed(int _train, float _speed)
		{
			unsafe {
				if (fn__setTrainSpeed == null) fn__setTrainSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setTrainSpeed");
				fn__setTrainSpeed(_train, _speed);
			}
		}

		public void SetTrainCruiseSpeed(int _train, float _speed)
		{
			unsafe {
				if (fn__setTrainCruiseSpeed == null) fn__setTrainCruiseSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setTrainCruiseSpeed");
				fn__setTrainCruiseSpeed(_train, _speed);
			}
		}

		public void SetRandomBoats(bool _toggle)
		{
			unsafe {
				if (fn__setRandomBoats == null) fn__setRandomBoats = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setRandomBoats");
				fn__setRandomBoats(_toggle);
			}
		}

		public void SetRandomBoatsInMp(bool _toggle)
		{
			unsafe {
				if (fn__setRandomBoatsInMp == null) fn__setRandomBoatsInMp = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setRandomBoatsInMp");
				fn__setRandomBoatsInMp(_toggle);
			}
		}

		public void SetGarbageTrucks(bool _toggle)
		{
			unsafe {
				if (fn__setGarbageTrucks == null) fn__setGarbageTrucks = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setGarbageTrucks");
				fn__setGarbageTrucks(_toggle);
			}
		}

		public bool DoesVehicleHaveStuckVehicleCheck(int _vehicle)
		{
			unsafe {
				if (fn__doesVehicleHaveStuckVehicleCheck == null) fn__doesVehicleHaveStuckVehicleCheck = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesVehicleHaveStuckVehicleCheck");
				var result = fn__doesVehicleHaveStuckVehicleCheck(_vehicle);
				return result;
			}
		}

		public int GetVehicleRecordingId(int _recording, string _script)
		{
			unsafe {
				if (fn__getVehicleRecordingId == null) fn__getVehicleRecordingId = (delegate* unmanaged[Cdecl]<int, nint, int>) NativeLibrary.GetExport(handle, "Native_getVehicleRecordingId");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				var result = fn__getVehicleRecordingId(_recording, ptr_script);
				Marshal.FreeHGlobal(ptr_script);
				return result;
			}
		}

		public void RequestVehicleRecording(int _recording, string _script)
		{
			unsafe {
				if (fn__requestVehicleRecording == null) fn__requestVehicleRecording = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_requestVehicleRecording");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				fn__requestVehicleRecording(_recording, ptr_script);
				Marshal.FreeHGlobal(ptr_script);
			}
		}

		public bool HasVehicleRecordingBeenLoaded(int _recording, string _script)
		{
			unsafe {
				if (fn__hasVehicleRecordingBeenLoaded == null) fn__hasVehicleRecordingBeenLoaded = (delegate* unmanaged[Cdecl]<int, nint, bool>) NativeLibrary.GetExport(handle, "Native_hasVehicleRecordingBeenLoaded");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				var result = fn__hasVehicleRecordingBeenLoaded(_recording, ptr_script);
				Marshal.FreeHGlobal(ptr_script);
				return result;
			}
		}

		public void RemoveVehicleRecording(int _recording, string _script)
		{
			unsafe {
				if (fn__removeVehicleRecording == null) fn__removeVehicleRecording = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleRecording");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				fn__removeVehicleRecording(_recording, ptr_script);
				Marshal.FreeHGlobal(ptr_script);
			}
		}

		public Vector3 GetPositionOfVehicleRecordingIdAtTime(int _id, float _time)
		{
			unsafe {
				if (fn__getPositionOfVehicleRecordingIdAtTime == null) fn__getPositionOfVehicleRecordingIdAtTime = (delegate* unmanaged[Cdecl]<int, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getPositionOfVehicleRecordingIdAtTime");
				var result = fn__getPositionOfVehicleRecordingIdAtTime(_id, _time);
				return result;
			}
		}

		public Vector3 GetPositionOfVehicleRecordingAtTime(int _recording, float _time, string _script)
		{
			unsafe {
				if (fn__getPositionOfVehicleRecordingAtTime == null) fn__getPositionOfVehicleRecordingAtTime = (delegate* unmanaged[Cdecl]<int, float, nint, Vector3>) NativeLibrary.GetExport(handle, "Native_getPositionOfVehicleRecordingAtTime");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				var result = fn__getPositionOfVehicleRecordingAtTime(_recording, _time, ptr_script);
				Marshal.FreeHGlobal(ptr_script);
				return result;
			}
		}

		public Vector3 GetRotationOfVehicleRecordingIdAtTime(int _id, float _time)
		{
			unsafe {
				if (fn__getRotationOfVehicleRecordingIdAtTime == null) fn__getRotationOfVehicleRecordingIdAtTime = (delegate* unmanaged[Cdecl]<int, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getRotationOfVehicleRecordingIdAtTime");
				var result = fn__getRotationOfVehicleRecordingIdAtTime(_id, _time);
				return result;
			}
		}

		public Vector3 GetRotationOfVehicleRecordingAtTime(int _recording, float _time, string _script)
		{
			unsafe {
				if (fn__getRotationOfVehicleRecordingAtTime == null) fn__getRotationOfVehicleRecordingAtTime = (delegate* unmanaged[Cdecl]<int, float, nint, Vector3>) NativeLibrary.GetExport(handle, "Native_getRotationOfVehicleRecordingAtTime");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				var result = fn__getRotationOfVehicleRecordingAtTime(_recording, _time, ptr_script);
				Marshal.FreeHGlobal(ptr_script);
				return result;
			}
		}

		public float GetTotalDurationOfVehicleRecordingId(int _id)
		{
			unsafe {
				if (fn__getTotalDurationOfVehicleRecordingId == null) fn__getTotalDurationOfVehicleRecordingId = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getTotalDurationOfVehicleRecordingId");
				var result = fn__getTotalDurationOfVehicleRecordingId(_id);
				return result;
			}
		}

		public float GetTotalDurationOfVehicleRecording(int _recording, string _script)
		{
			unsafe {
				if (fn__getTotalDurationOfVehicleRecording == null) fn__getTotalDurationOfVehicleRecording = (delegate* unmanaged[Cdecl]<int, nint, float>) NativeLibrary.GetExport(handle, "Native_getTotalDurationOfVehicleRecording");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				var result = fn__getTotalDurationOfVehicleRecording(_recording, ptr_script);
				Marshal.FreeHGlobal(ptr_script);
				return result;
			}
		}

		public float GetPositionInRecording(int _vehicle)
		{
			unsafe {
				if (fn__getPositionInRecording == null) fn__getPositionInRecording = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getPositionInRecording");
				var result = fn__getPositionInRecording(_vehicle);
				return result;
			}
		}

		public float GetTimePositionInRecording(int _vehicle)
		{
			unsafe {
				if (fn__getTimePositionInRecording == null) fn__getTimePositionInRecording = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getTimePositionInRecording");
				var result = fn__getTimePositionInRecording(_vehicle);
				return result;
			}
		}

		public void StartPlaybackRecordedVehicle(int _vehicle, int _recording, string _script, bool _p3)
		{
			unsafe {
				if (fn__startPlaybackRecordedVehicle == null) fn__startPlaybackRecordedVehicle = (delegate* unmanaged[Cdecl]<int, int, nint, bool, void>) NativeLibrary.GetExport(handle, "Native_startPlaybackRecordedVehicle");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				fn__startPlaybackRecordedVehicle(_vehicle, _recording, ptr_script, _p3);
				Marshal.FreeHGlobal(ptr_script);
			}
		}

		public void StartPlaybackRecordedVehicleWithFlags(int _vehicle, int _recording, string _script, int _flags, int _time, int _drivingStyle)
		{
			unsafe {
				if (fn__startPlaybackRecordedVehicleWithFlags == null) fn__startPlaybackRecordedVehicleWithFlags = (delegate* unmanaged[Cdecl]<int, int, nint, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_startPlaybackRecordedVehicleWithFlags");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				fn__startPlaybackRecordedVehicleWithFlags(_vehicle, _recording, ptr_script, _flags, _time, _drivingStyle);
				Marshal.FreeHGlobal(ptr_script);
			}
		}

		public void ForcePlaybackRecordedVehicleUpdate(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__forcePlaybackRecordedVehicleUpdate == null) fn__forcePlaybackRecordedVehicleUpdate = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_forcePlaybackRecordedVehicleUpdate");
				fn__forcePlaybackRecordedVehicleUpdate(_vehicle, _p1);
			}
		}

		public void StopPlaybackRecordedVehicle(int _vehicle)
		{
			unsafe {
				if (fn__stopPlaybackRecordedVehicle == null) fn__stopPlaybackRecordedVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_stopPlaybackRecordedVehicle");
				fn__stopPlaybackRecordedVehicle(_vehicle);
			}
		}

		public void PausePlaybackRecordedVehicle(int _vehicle)
		{
			unsafe {
				if (fn__pausePlaybackRecordedVehicle == null) fn__pausePlaybackRecordedVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_pausePlaybackRecordedVehicle");
				fn__pausePlaybackRecordedVehicle(_vehicle);
			}
		}

		public void UnpausePlaybackRecordedVehicle(int _vehicle)
		{
			unsafe {
				if (fn__unpausePlaybackRecordedVehicle == null) fn__unpausePlaybackRecordedVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_unpausePlaybackRecordedVehicle");
				fn__unpausePlaybackRecordedVehicle(_vehicle);
			}
		}

		public bool IsPlaybackGoingOnForVehicle(int _vehicle)
		{
			unsafe {
				if (fn__isPlaybackGoingOnForVehicle == null) fn__isPlaybackGoingOnForVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlaybackGoingOnForVehicle");
				var result = fn__isPlaybackGoingOnForVehicle(_vehicle);
				return result;
			}
		}

		public bool IsPlaybackUsingAiGoingOnForVehicle(int _vehicle)
		{
			unsafe {
				if (fn__isPlaybackUsingAiGoingOnForVehicle == null) fn__isPlaybackUsingAiGoingOnForVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlaybackUsingAiGoingOnForVehicle");
				var result = fn__isPlaybackUsingAiGoingOnForVehicle(_vehicle);
				return result;
			}
		}

		public int GetCurrentPlaybackForVehicle(int _vehicle)
		{
			unsafe {
				if (fn__getCurrentPlaybackForVehicle == null) fn__getCurrentPlaybackForVehicle = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getCurrentPlaybackForVehicle");
				var result = fn__getCurrentPlaybackForVehicle(_vehicle);
				return result;
			}
		}

		public void SkipToEndAndStopPlaybackRecordedVehicle(int _vehicle)
		{
			unsafe {
				if (fn__skipToEndAndStopPlaybackRecordedVehicle == null) fn__skipToEndAndStopPlaybackRecordedVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_skipToEndAndStopPlaybackRecordedVehicle");
				fn__skipToEndAndStopPlaybackRecordedVehicle(_vehicle);
			}
		}

		public void SetPlaybackSpeed(int _vehicle, float _speed)
		{
			unsafe {
				if (fn__setPlaybackSpeed == null) fn__setPlaybackSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlaybackSpeed");
				fn__setPlaybackSpeed(_vehicle, _speed);
			}
		}

		public void StartPlaybackRecordedVehicleUsingAi(int _vehicle, int _recording, string _script, float _speed, int _drivingStyle)
		{
			unsafe {
				if (fn__startPlaybackRecordedVehicleUsingAi == null) fn__startPlaybackRecordedVehicleUsingAi = (delegate* unmanaged[Cdecl]<int, int, nint, float, int, void>) NativeLibrary.GetExport(handle, "Native_startPlaybackRecordedVehicleUsingAi");
				var ptr_script = MemoryUtils.StringToHGlobalUtf8(_script);
				fn__startPlaybackRecordedVehicleUsingAi(_vehicle, _recording, ptr_script, _speed, _drivingStyle);
				Marshal.FreeHGlobal(ptr_script);
			}
		}

		public void SkipTimeInPlaybackRecordedVehicle(int _vehicle, float _time)
		{
			unsafe {
				if (fn__skipTimeInPlaybackRecordedVehicle == null) fn__skipTimeInPlaybackRecordedVehicle = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_skipTimeInPlaybackRecordedVehicle");
				fn__skipTimeInPlaybackRecordedVehicle(_vehicle, _time);
			}
		}

		public void SetPlaybackToUseAi(int _vehicle, int _drivingStyle)
		{
			unsafe {
				if (fn__setPlaybackToUseAi == null) fn__setPlaybackToUseAi = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPlaybackToUseAi");
				fn__setPlaybackToUseAi(_vehicle, _drivingStyle);
			}
		}

		public void SetPlaybackToUseAiTryToRevertBackLater(int _vehicle, int _time, int _drivingStyle, bool _p3)
		{
			unsafe {
				if (fn__setPlaybackToUseAiTryToRevertBackLater == null) fn__setPlaybackToUseAiTryToRevertBackLater = (delegate* unmanaged[Cdecl]<int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlaybackToUseAiTryToRevertBackLater");
				fn__setPlaybackToUseAiTryToRevertBackLater(_vehicle, _time, _drivingStyle, _p3);
			}
		}

		public void _0x5845066D8A1EA7F7(int _vehicle, float _x, float _y, float _z, int _p4)
		{
			unsafe {
				if (fn__0x5845066D8A1EA7F7 == null) fn__0x5845066D8A1EA7F7 = (delegate* unmanaged[Cdecl]<int, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native__0x5845066D8A1EA7F7");
				fn__0x5845066D8A1EA7F7(_vehicle, _x, _y, _z, _p4);
			}
		}

		public void _0x796A877E459B99EA(int _p0, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__0x796A877E459B99EA == null) fn__0x796A877E459B99EA = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0x796A877E459B99EA");
				fn__0x796A877E459B99EA(_p0, _p1, _p2, _p3);
			}
		}

		public void _0xFAF2A78061FD9EF4(int _p0, float _p1, float _p2, float _p3)
		{
			unsafe {
				if (fn__0xFAF2A78061FD9EF4 == null) fn__0xFAF2A78061FD9EF4 = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0xFAF2A78061FD9EF4");
				fn__0xFAF2A78061FD9EF4(_p0, _p1, _p2, _p3);
			}
		}

		public void _0x063AE2B2CC273588(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x063AE2B2CC273588 == null) fn__0x063AE2B2CC273588 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x063AE2B2CC273588");
				fn__0x063AE2B2CC273588(_vehicle, _p1);
			}
		}

		public void ExplodeVehicleInCutscene(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__explodeVehicleInCutscene == null) fn__explodeVehicleInCutscene = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_explodeVehicleInCutscene");
				fn__explodeVehicleInCutscene(_vehicle, _p1);
			}
		}

		public void AddVehicleStuckCheckWithWarp(int _p0, float _p1, int _p2, bool _p3, bool _p4, bool _p5, int _p6)
		{
			unsafe {
				if (fn__addVehicleStuckCheckWithWarp == null) fn__addVehicleStuckCheckWithWarp = (delegate* unmanaged[Cdecl]<int, float, int, bool, bool, bool, int, void>) NativeLibrary.GetExport(handle, "Native_addVehicleStuckCheckWithWarp");
				fn__addVehicleStuckCheckWithWarp(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
			}
		}

		public void SetVehicleModelIsSuppressed(int _model, bool _suppressed)
		{
			unsafe {
				if (fn__setVehicleModelIsSuppressed == null) fn__setVehicleModelIsSuppressed = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleModelIsSuppressed");
				fn__setVehicleModelIsSuppressed(_model, _suppressed);
			}
		}

		public int GetRandomVehicleInSphere(float _x, float _y, float _z, float _radius, int _modelHash, int _flags)
		{
			unsafe {
				if (fn__getRandomVehicleInSphere == null) fn__getRandomVehicleInSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int>) NativeLibrary.GetExport(handle, "Native_getRandomVehicleInSphere");
				var result = fn__getRandomVehicleInSphere(_x, _y, _z, _radius, _modelHash, _flags);
				return result;
			}
		}

		public int GetRandomVehicleFrontBumperInSphere(float _p0, float _p1, float _p2, float _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__getRandomVehicleFrontBumperInSphere == null) fn__getRandomVehicleFrontBumperInSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getRandomVehicleFrontBumperInSphere");
				var result = fn__getRandomVehicleFrontBumperInSphere(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
				return result;
			}
		}

		public int GetRandomVehicleBackBumperInSphere(float _p0, float _p1, float _p2, float _p3, int _p4, int _p5, int _p6)
		{
			unsafe {
				if (fn__getRandomVehicleBackBumperInSphere == null) fn__getRandomVehicleBackBumperInSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getRandomVehicleBackBumperInSphere");
				var result = fn__getRandomVehicleBackBumperInSphere(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
				return result;
			}
		}

		public int GetClosestVehicle(float _x, float _y, float _z, float _radius, int _modelHash, int _flags)
		{
			unsafe {
				if (fn__getClosestVehicle == null) fn__getClosestVehicle = (delegate* unmanaged[Cdecl]<float, float, float, float, int, int, int>) NativeLibrary.GetExport(handle, "Native_getClosestVehicle");
				var result = fn__getClosestVehicle(_x, _y, _z, _radius, _modelHash, _flags);
				return result;
			}
		}

		public int GetTrainCarriage(int _train, int _trailerNumber)
		{
			unsafe {
				if (fn__getTrainCarriage == null) fn__getTrainCarriage = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getTrainCarriage");
				var result = fn__getTrainCarriage(_train, _trailerNumber);
				return result;
			}
		}

		public bool IsMissionTrain(int _vehicle)
		{
			unsafe {
				if (fn__isMissionTrain == null) fn__isMissionTrain = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isMissionTrain");
				var result = fn__isMissionTrain(_vehicle);
				return result;
			}
		}

		public void DeleteMissionTrain(ref int _train)
		{
			unsafe {
				if (fn__deleteMissionTrain == null) fn__deleteMissionTrain = (delegate* unmanaged[Cdecl]<int*, void>) NativeLibrary.GetExport(handle, "Native_deleteMissionTrain");
				var ref_train = _train;
				fn__deleteMissionTrain(&ref_train);
				_train = ref_train;
			}
		}

		public void SetMissionTrainAsNoLongerNeeded(ref int _train, bool _p1)
		{
			unsafe {
				if (fn__setMissionTrainAsNoLongerNeeded == null) fn__setMissionTrainAsNoLongerNeeded = (delegate* unmanaged[Cdecl]<int*, bool, void>) NativeLibrary.GetExport(handle, "Native_setMissionTrainAsNoLongerNeeded");
				var ref_train = _train;
				fn__setMissionTrainAsNoLongerNeeded(&ref_train, _p1);
				_train = ref_train;
			}
		}

		public void SetMissionTrainCoords(int _train, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__setMissionTrainCoords == null) fn__setMissionTrainCoords = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setMissionTrainCoords");
				fn__setMissionTrainCoords(_train, _x, _y, _z);
			}
		}

		public bool IsThisModelABoat(int _model)
		{
			unsafe {
				if (fn__isThisModelABoat == null) fn__isThisModelABoat = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelABoat");
				var result = fn__isThisModelABoat(_model);
				return result;
			}
		}

		public bool IsThisModelAJetski(int _model)
		{
			unsafe {
				if (fn__isThisModelAJetski == null) fn__isThisModelAJetski = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelAJetski");
				var result = fn__isThisModelAJetski(_model);
				return result;
			}
		}

		public bool IsThisModelAPlane(int _model)
		{
			unsafe {
				if (fn__isThisModelAPlane == null) fn__isThisModelAPlane = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelAPlane");
				var result = fn__isThisModelAPlane(_model);
				return result;
			}
		}

		public bool IsThisModelAHeli(int _model)
		{
			unsafe {
				if (fn__isThisModelAHeli == null) fn__isThisModelAHeli = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelAHeli");
				var result = fn__isThisModelAHeli(_model);
				return result;
			}
		}

		public bool IsThisModelACar(int _model)
		{
			unsafe {
				if (fn__isThisModelACar == null) fn__isThisModelACar = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelACar");
				var result = fn__isThisModelACar(_model);
				return result;
			}
		}

		public bool IsThisModelATrain(int _model)
		{
			unsafe {
				if (fn__isThisModelATrain == null) fn__isThisModelATrain = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelATrain");
				var result = fn__isThisModelATrain(_model);
				return result;
			}
		}

		public bool IsThisModelABike(int _model)
		{
			unsafe {
				if (fn__isThisModelABike == null) fn__isThisModelABike = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelABike");
				var result = fn__isThisModelABike(_model);
				return result;
			}
		}

		public bool IsThisModelABicycle(int _model)
		{
			unsafe {
				if (fn__isThisModelABicycle == null) fn__isThisModelABicycle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelABicycle");
				var result = fn__isThisModelABicycle(_model);
				return result;
			}
		}

		public bool IsThisModelAQuadbike(int _model)
		{
			unsafe {
				if (fn__isThisModelAQuadbike == null) fn__isThisModelAQuadbike = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelAQuadbike");
				var result = fn__isThisModelAQuadbike(_model);
				return result;
			}
		}

		public bool IsThisModelAnAmphibiousCar(int _model)
		{
			unsafe {
				if (fn__isThisModelAnAmphibiousCar == null) fn__isThisModelAnAmphibiousCar = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelAnAmphibiousCar");
				var result = fn__isThisModelAnAmphibiousCar(_model);
				return result;
			}
		}

		public bool IsThisModelAnAmphibiousQuadbike(int _model)
		{
			unsafe {
				if (fn__isThisModelAnAmphibiousQuadbike == null) fn__isThisModelAnAmphibiousQuadbike = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isThisModelAnAmphibiousQuadbike");
				var result = fn__isThisModelAnAmphibiousQuadbike(_model);
				return result;
			}
		}

		public void SetHeliBladesFullSpeed(int _vehicle)
		{
			unsafe {
				if (fn__setHeliBladesFullSpeed == null) fn__setHeliBladesFullSpeed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setHeliBladesFullSpeed");
				fn__setHeliBladesFullSpeed(_vehicle);
			}
		}

		public void SetHeliBladesSpeed(int _vehicle, float _speed)
		{
			unsafe {
				if (fn__setHeliBladesSpeed == null) fn__setHeliBladesSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setHeliBladesSpeed");
				fn__setHeliBladesSpeed(_vehicle, _speed);
			}
		}

		public void _0x99CAD8E7AFDB60FA(int _vehicle, float _p1, float _p2)
		{
			unsafe {
				if (fn__0x99CAD8E7AFDB60FA == null) fn__0x99CAD8E7AFDB60FA = (delegate* unmanaged[Cdecl]<int, float, float, void>) NativeLibrary.GetExport(handle, "Native__0x99CAD8E7AFDB60FA");
				fn__0x99CAD8E7AFDB60FA(_vehicle, _p1, _p2);
			}
		}

		public void SetVehicleCanBeTargetted(int _vehicle, bool _state)
		{
			unsafe {
				if (fn__setVehicleCanBeTargetted == null) fn__setVehicleCanBeTargetted = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanBeTargetted");
				fn__setVehicleCanBeTargetted(_vehicle, _state);
			}
		}

		public void _0xDBC631F109350B8C(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0xDBC631F109350B8C == null) fn__0xDBC631F109350B8C = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xDBC631F109350B8C");
				fn__0xDBC631F109350B8C(_vehicle, _p1);
			}
		}

		public void SetVehicleCanBeVisiblyDamaged(int _vehicle, bool _state)
		{
			unsafe {
				if (fn__setVehicleCanBeVisiblyDamaged == null) fn__setVehicleCanBeVisiblyDamaged = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanBeVisiblyDamaged");
				fn__setVehicleCanBeVisiblyDamaged(_vehicle, _state);
			}
		}

		public void SetVehicleHasUnbreakableLights(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__setVehicleHasUnbreakableLights == null) fn__setVehicleHasUnbreakableLights = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHasUnbreakableLights");
				fn__setVehicleHasUnbreakableLights(_vehicle, _p1);
			}
		}

		public void _0x2311DD7159F00582(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x2311DD7159F00582 == null) fn__0x2311DD7159F00582 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x2311DD7159F00582");
				fn__0x2311DD7159F00582(_vehicle, _p1);
			}
		}

		public void _0x065D03A9D6B2C6B5(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x065D03A9D6B2C6B5 == null) fn__0x065D03A9D6B2C6B5 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x065D03A9D6B2C6B5");
				fn__0x065D03A9D6B2C6B5(_p0, _p1);
			}
		}

		public float GetVehicleDirtLevel(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleDirtLevel == null) fn__getVehicleDirtLevel = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleDirtLevel");
				var result = fn__getVehicleDirtLevel(_vehicle);
				return result;
			}
		}

		public void SetVehicleDirtLevel(int _vehicle, float _dirtLevel)
		{
			unsafe {
				if (fn__setVehicleDirtLevel == null) fn__setVehicleDirtLevel = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDirtLevel");
				fn__setVehicleDirtLevel(_vehicle, _dirtLevel);
			}
		}

		public bool IsVehicleDamaged(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleDamaged == null) fn__isVehicleDamaged = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleDamaged");
				var result = fn__isVehicleDamaged(_vehicle);
				return result;
			}
		}

		public bool IsVehicleDoorFullyOpen(int _vehicle, int _doorId)
		{
			unsafe {
				if (fn__isVehicleDoorFullyOpen == null) fn__isVehicleDoorFullyOpen = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleDoorFullyOpen");
				var result = fn__isVehicleDoorFullyOpen(_vehicle, _doorId);
				return result;
			}
		}

		public void SetVehicleEngineOn(int _vehicle, bool _value, bool _instantly, bool _disableAutoStart)
		{
			unsafe {
				if (fn__setVehicleEngineOn == null) fn__setVehicleEngineOn = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleEngineOn");
				fn__setVehicleEngineOn(_vehicle, _value, _instantly, _disableAutoStart);
			}
		}

		public void SetVehicleUndriveable(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleUndriveable == null) fn__setVehicleUndriveable = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleUndriveable");
				fn__setVehicleUndriveable(_vehicle, _toggle);
			}
		}

		public void SetVehicleProvidesCover(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleProvidesCover == null) fn__setVehicleProvidesCover = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleProvidesCover");
				fn__setVehicleProvidesCover(_vehicle, _toggle);
			}
		}

		public void SetVehicleDoorControl(int _vehicle, int _doorId, int _speed, float _angle)
		{
			unsafe {
				if (fn__setVehicleDoorControl == null) fn__setVehicleDoorControl = (delegate* unmanaged[Cdecl]<int, int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorControl");
				fn__setVehicleDoorControl(_vehicle, _doorId, _speed, _angle);
			}
		}

		public void SetVehicleDoorLatched(int _vehicle, int _doorId, bool _p2, bool _p3, bool _p4)
		{
			unsafe {
				if (fn__setVehicleDoorLatched == null) fn__setVehicleDoorLatched = (delegate* unmanaged[Cdecl]<int, int, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorLatched");
				fn__setVehicleDoorLatched(_vehicle, _doorId, _p2, _p3, _p4);
			}
		}

		public float GetVehicleDoorAngleRatio(int _vehicle, int _doorId)
		{
			unsafe {
				if (fn__getVehicleDoorAngleRatio == null) fn__getVehicleDoorAngleRatio = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleDoorAngleRatio");
				var result = fn__getVehicleDoorAngleRatio(_vehicle, _doorId);
				return result;
			}
		}

		public int GetPedUsingVehicleDoor(int _vehicle, int _doord)
		{
			unsafe {
				if (fn__getPedUsingVehicleDoor == null) fn__getPedUsingVehicleDoor = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedUsingVehicleDoor");
				var result = fn__getPedUsingVehicleDoor(_vehicle, _doord);
				return result;
			}
		}

		public void SetVehicleDoorShut(int _vehicle, int _doorId, bool _closeInstantly)
		{
			unsafe {
				if (fn__setVehicleDoorShut == null) fn__setVehicleDoorShut = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorShut");
				fn__setVehicleDoorShut(_vehicle, _doorId, _closeInstantly);
			}
		}

		public void SetVehicleDoorBroken(int _vehicle, int _doorId, bool _deleteDoor)
		{
			unsafe {
				if (fn__setVehicleDoorBroken == null) fn__setVehicleDoorBroken = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorBroken");
				fn__setVehicleDoorBroken(_vehicle, _doorId, _deleteDoor);
			}
		}

		public void SetVehicleCanBreak(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleCanBreak == null) fn__setVehicleCanBreak = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanBreak");
				fn__setVehicleCanBreak(_vehicle, _toggle);
			}
		}

		public bool DoesVehicleHaveRoof(int _vehicle)
		{
			unsafe {
				if (fn__doesVehicleHaveRoof == null) fn__doesVehicleHaveRoof = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesVehicleHaveRoof");
				var result = fn__doesVehicleHaveRoof(_vehicle);
				return result;
			}
		}

		public void _0xC4B3347BD68BD609(int _p0)
		{
			unsafe {
				if (fn__0xC4B3347BD68BD609 == null) fn__0xC4B3347BD68BD609 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xC4B3347BD68BD609");
				fn__0xC4B3347BD68BD609(_p0);
			}
		}

		public void _0xD3301660A57C9272(int _p0)
		{
			unsafe {
				if (fn__0xD3301660A57C9272 == null) fn__0xD3301660A57C9272 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xD3301660A57C9272");
				fn__0xD3301660A57C9272(_p0);
			}
		}

		public void _0xB9562064627FF9DB(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xB9562064627FF9DB == null) fn__0xB9562064627FF9DB = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xB9562064627FF9DB");
				fn__0xB9562064627FF9DB(_p0, _p1);
			}
		}

		public bool IsBigVehicle(int _vehicle)
		{
			unsafe {
				if (fn__isBigVehicle == null) fn__isBigVehicle = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isBigVehicle");
				var result = fn__isBigVehicle(_vehicle);
				return result;
			}
		}

		public int GetNumberOfVehicleColours(int _vehicle)
		{
			unsafe {
				if (fn__getNumberOfVehicleColours == null) fn__getNumberOfVehicleColours = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfVehicleColours");
				var result = fn__getNumberOfVehicleColours(_vehicle);
				return result;
			}
		}

		public void SetVehicleColourCombination(int _vehicle, int _colorCombination)
		{
			unsafe {
				if (fn__setVehicleColourCombination == null) fn__setVehicleColourCombination = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleColourCombination");
				fn__setVehicleColourCombination(_vehicle, _colorCombination);
			}
		}

		public int GetVehicleColourCombination(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleColourCombination == null) fn__getVehicleColourCombination = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleColourCombination");
				var result = fn__getVehicleColourCombination(_vehicle);
				return result;
			}
		}

		public void SetVehicleXenonLightsColor(int _vehicle, int _colorIndex)
		{
			unsafe {
				if (fn__setVehicleXenonLightsColor == null) fn__setVehicleXenonLightsColor = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleXenonLightsColor");
				fn__setVehicleXenonLightsColor(_vehicle, _colorIndex);
			}
		}

		public int GetVehicleXenonLightsColor(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleXenonLightsColor == null) fn__getVehicleXenonLightsColor = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleXenonLightsColor");
				var result = fn__getVehicleXenonLightsColor(_vehicle);
				return result;
			}
		}

		public void SetVehicleIsConsideredByPlayer(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleIsConsideredByPlayer == null) fn__setVehicleIsConsideredByPlayer = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleIsConsideredByPlayer");
				fn__setVehicleIsConsideredByPlayer(_vehicle, _toggle);
			}
		}

		public void _0xBE5C1255A1830FF5(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0xBE5C1255A1830FF5 == null) fn__0xBE5C1255A1830FF5 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xBE5C1255A1830FF5");
				fn__0xBE5C1255A1830FF5(_vehicle, _toggle);
			}
		}

		public void _0x9BECD4B9FEF3F8A6(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x9BECD4B9FEF3F8A6 == null) fn__0x9BECD4B9FEF3F8A6 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x9BECD4B9FEF3F8A6");
				fn__0x9BECD4B9FEF3F8A6(_vehicle, _p1);
			}
		}

		public void _0x88BC673CA9E0AE99(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x88BC673CA9E0AE99 == null) fn__0x88BC673CA9E0AE99 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x88BC673CA9E0AE99");
				fn__0x88BC673CA9E0AE99(_vehicle, _p1);
			}
		}

		public void _0xE851E480B814D4BA(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0xE851E480B814D4BA == null) fn__0xE851E480B814D4BA = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xE851E480B814D4BA");
				fn__0xE851E480B814D4BA(_vehicle, _p1);
			}
		}

		public void GetRandomVehicleModelInMemory(bool _p0, ref int _modelHash, ref int _successIndicator)
		{
			unsafe {
				if (fn__getRandomVehicleModelInMemory == null) fn__getRandomVehicleModelInMemory = (delegate* unmanaged[Cdecl]<bool, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getRandomVehicleModelInMemory");
				var ref_modelHash = _modelHash;
				var ref_successIndicator = _successIndicator;
				fn__getRandomVehicleModelInMemory(_p0, &ref_modelHash, &ref_successIndicator);
				_modelHash = ref_modelHash;
				_successIndicator = ref_successIndicator;
			}
		}

		public int GetVehicleDoorLockStatus(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleDoorLockStatus == null) fn__getVehicleDoorLockStatus = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleDoorLockStatus");
				var result = fn__getVehicleDoorLockStatus(_vehicle);
				return result;
			}
		}

		public int GetVehicleDoorDestroyType(int _vehicle, int _doorId)
		{
			unsafe {
				if (fn__getVehicleDoorDestroyType == null) fn__getVehicleDoorDestroyType = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleDoorDestroyType");
				var result = fn__getVehicleDoorDestroyType(_vehicle, _doorId);
				return result;
			}
		}

		public bool IsVehicleDoorDamaged(int _veh, int _doorID)
		{
			unsafe {
				if (fn__isVehicleDoorDamaged == null) fn__isVehicleDoorDamaged = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleDoorDamaged");
				var result = fn__isVehicleDoorDamaged(_veh, _doorID);
				return result;
			}
		}

		public void SetVehicleDoorCanBreak(int _vehicle, int _doorId, bool _isBreakable)
		{
			unsafe {
				if (fn__setVehicleDoorCanBreak == null) fn__setVehicleDoorCanBreak = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDoorCanBreak");
				fn__setVehicleDoorCanBreak(_vehicle, _doorId, _isBreakable);
			}
		}

		public bool IsVehicleBumperBouncing(int _vehicle, bool _frontBumper)
		{
			unsafe {
				if (fn__isVehicleBumperBouncing == null) fn__isVehicleBumperBouncing = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleBumperBouncing");
				var result = fn__isVehicleBumperBouncing(_vehicle, _frontBumper);
				return result;
			}
		}

		public bool IsVehicleBumperBrokenOff(int _vehicle, bool _front)
		{
			unsafe {
				if (fn__isVehicleBumperBrokenOff == null) fn__isVehicleBumperBrokenOff = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleBumperBrokenOff");
				var result = fn__isVehicleBumperBrokenOff(_vehicle, _front);
				return result;
			}
		}

		public bool IsCopVehicleInArea3d(float _x1, float _x2, float _y1, float _y2, float _z1, float _z2)
		{
			unsafe {
				if (fn__isCopVehicleInArea3d == null) fn__isCopVehicleInArea3d = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isCopVehicleInArea3d");
				var result = fn__isCopVehicleInArea3d(_x1, _x2, _y1, _y2, _z1, _z2);
				return result;
			}
		}

		public bool IsVehicleOnAllWheels(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleOnAllWheels == null) fn__isVehicleOnAllWheels = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleOnAllWheels");
				var result = fn__isVehicleOnAllWheels(_vehicle);
				return result;
			}
		}

		public int GetVehicleModelMonetaryValue(int _vehicleModel)
		{
			unsafe {
				if (fn__getVehicleModelMonetaryValue == null) fn__getVehicleModelMonetaryValue = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleModelMonetaryValue");
				var result = fn__getVehicleModelMonetaryValue(_vehicleModel);
				return result;
			}
		}

		public int GetVehicleLayoutHash(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleLayoutHash == null) fn__getVehicleLayoutHash = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleLayoutHash");
				var result = fn__getVehicleLayoutHash(_vehicle);
				return result;
			}
		}

		public int _0xA01BC64DD4BFBBAC(int _vehicle, int _p1)
		{
			unsafe {
				if (fn__0xA01BC64DD4BFBBAC == null) fn__0xA01BC64DD4BFBBAC = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0xA01BC64DD4BFBBAC");
				var result = fn__0xA01BC64DD4BFBBAC(_vehicle, _p1);
				return result;
			}
		}

		public void SetRenderTrainAsDerailed(int _train, bool _toggle)
		{
			unsafe {
				if (fn__setRenderTrainAsDerailed == null) fn__setRenderTrainAsDerailed = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setRenderTrainAsDerailed");
				fn__setRenderTrainAsDerailed(_train, _toggle);
			}
		}

		public void SetVehicleExtraColours(int _vehicle, int _pearlescentColor, int _wheelColor)
		{
			unsafe {
				if (fn__setVehicleExtraColours == null) fn__setVehicleExtraColours = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleExtraColours");
				fn__setVehicleExtraColours(_vehicle, _pearlescentColor, _wheelColor);
			}
		}

		public void GetVehicleExtraColours(int _vehicle, ref int _pearlescentColor, ref int _wheelColor)
		{
			unsafe {
				if (fn__getVehicleExtraColours == null) fn__getVehicleExtraColours = (delegate* unmanaged[Cdecl]<int, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleExtraColours");
				var ref_pearlescentColor = _pearlescentColor;
				var ref_wheelColor = _wheelColor;
				fn__getVehicleExtraColours(_vehicle, &ref_pearlescentColor, &ref_wheelColor);
				_pearlescentColor = ref_pearlescentColor;
				_wheelColor = ref_wheelColor;
			}
		}

		public void SetVehicleInteriorColor(int _vehicle, int _color)
		{
			unsafe {
				if (fn__setVehicleInteriorColor == null) fn__setVehicleInteriorColor = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleInteriorColor");
				fn__setVehicleInteriorColor(_vehicle, _color);
			}
		}

		public void GetVehicleInteriorColor(int _vehicle, ref int _color)
		{
			unsafe {
				if (fn__getVehicleInteriorColor == null) fn__getVehicleInteriorColor = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleInteriorColor");
				var ref_color = _color;
				fn__getVehicleInteriorColor(_vehicle, &ref_color);
				_color = ref_color;
			}
		}

		public void SetVehicleDashboardColor(int _vehicle, int _color)
		{
			unsafe {
				if (fn__setVehicleDashboardColor == null) fn__setVehicleDashboardColor = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDashboardColor");
				fn__setVehicleDashboardColor(_vehicle, _color);
			}
		}

		public void GetVehicleDashboardColor(int _vehicle, ref int _color)
		{
			unsafe {
				if (fn__getVehicleDashboardColor == null) fn__getVehicleDashboardColor = (delegate* unmanaged[Cdecl]<int, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleDashboardColor");
				var ref_color = _color;
				fn__getVehicleDashboardColor(_vehicle, &ref_color);
				_color = ref_color;
			}
		}

		public void StopAllGarageActivity()
		{
			unsafe {
				if (fn__stopAllGarageActivity == null) fn__stopAllGarageActivity = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_stopAllGarageActivity");
				fn__stopAllGarageActivity();
			}
		}

		public void SetVehicleFixed(int _vehicle)
		{
			unsafe {
				if (fn__setVehicleFixed == null) fn__setVehicleFixed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleFixed");
				fn__setVehicleFixed(_vehicle);
			}
		}

		public void SetVehicleDeformationFixed(int _vehicle)
		{
			unsafe {
				if (fn__setVehicleDeformationFixed == null) fn__setVehicleDeformationFixed = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDeformationFixed");
				fn__setVehicleDeformationFixed(_vehicle);
			}
		}

		public void SetVehicleCanEngineOperateOnFire(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleCanEngineOperateOnFire == null) fn__setVehicleCanEngineOperateOnFire = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanEngineOperateOnFire");
				fn__setVehicleCanEngineOperateOnFire(_vehicle, _toggle);
			}
		}

		public void SetVehicleCanLeakOil(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleCanLeakOil == null) fn__setVehicleCanLeakOil = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanLeakOil");
				fn__setVehicleCanLeakOil(_vehicle, _toggle);
			}
		}

		public void SetVehicleCanLeakPetrol(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleCanLeakPetrol == null) fn__setVehicleCanLeakPetrol = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanLeakPetrol");
				fn__setVehicleCanLeakPetrol(_vehicle, _toggle);
			}
		}

		public void SetDisableVehiclePetrolTankFires(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setDisableVehiclePetrolTankFires == null) fn__setDisableVehiclePetrolTankFires = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableVehiclePetrolTankFires");
				fn__setDisableVehiclePetrolTankFires(_vehicle, _toggle);
			}
		}

		public void SetDisableVehiclePetrolTankDamage(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setDisableVehiclePetrolTankDamage == null) fn__setDisableVehiclePetrolTankDamage = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableVehiclePetrolTankDamage");
				fn__setDisableVehiclePetrolTankDamage(_vehicle, _toggle);
			}
		}

		public void SetDisableVehicleEngineFires(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setDisableVehicleEngineFires == null) fn__setDisableVehicleEngineFires = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableVehicleEngineFires");
				fn__setDisableVehicleEngineFires(_vehicle, _toggle);
			}
		}

		public void _0xC50CE861B55EAB8B(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0xC50CE861B55EAB8B == null) fn__0xC50CE861B55EAB8B = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xC50CE861B55EAB8B");
				fn__0xC50CE861B55EAB8B(_vehicle, _p1);
			}
		}

		public void _0x6EBFB22D646FFC18(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x6EBFB22D646FFC18 == null) fn__0x6EBFB22D646FFC18 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x6EBFB22D646FFC18");
				fn__0x6EBFB22D646FFC18(_vehicle, _p1);
			}
		}

		public void SetDisablePretendOccupants(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setDisablePretendOccupants == null) fn__setDisablePretendOccupants = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisablePretendOccupants");
				fn__setDisablePretendOccupants(_vehicle, _toggle);
			}
		}

		public void RemoveVehiclesFromGeneratorsInArea(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, int _unk)
		{
			unsafe {
				if (fn__removeVehiclesFromGeneratorsInArea == null) fn__removeVehiclesFromGeneratorsInArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_removeVehiclesFromGeneratorsInArea");
				fn__removeVehiclesFromGeneratorsInArea(_x1, _y1, _z1, _x2, _y2, _z2, _unk);
			}
		}

		public void SetVehicleSteerBias(int _vehicle, float _value)
		{
			unsafe {
				if (fn__setVehicleSteerBias == null) fn__setVehicleSteerBias = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleSteerBias");
				fn__setVehicleSteerBias(_vehicle, _value);
			}
		}

		public bool IsVehicleExtraTurnedOn(int _vehicle, int _extraId)
		{
			unsafe {
				if (fn__isVehicleExtraTurnedOn == null) fn__isVehicleExtraTurnedOn = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleExtraTurnedOn");
				var result = fn__isVehicleExtraTurnedOn(_vehicle, _extraId);
				return result;
			}
		}

		public void SetVehicleExtra(int _vehicle, int _extraId, bool _disable)
		{
			unsafe {
				if (fn__setVehicleExtra == null) fn__setVehicleExtra = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleExtra");
				fn__setVehicleExtra(_vehicle, _extraId, _disable);
			}
		}

		public bool DoesExtraExist(int _vehicle, int _extraId)
		{
			unsafe {
				if (fn__doesExtraExist == null) fn__doesExtraExist = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_doesExtraExist");
				var result = fn__doesExtraExist(_vehicle, _extraId);
				return result;
			}
		}

		public bool DoesVehicleTyreExist(int _vehicle, int _tyreIndex)
		{
			unsafe {
				if (fn__doesVehicleTyreExist == null) fn__doesVehicleTyreExist = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_doesVehicleTyreExist");
				var result = fn__doesVehicleTyreExist(_vehicle, _tyreIndex);
				return result;
			}
		}

		public void SetConvertibleRoof(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__setConvertibleRoof == null) fn__setConvertibleRoof = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setConvertibleRoof");
				fn__setConvertibleRoof(_vehicle, _p1);
			}
		}

		public void LowerConvertibleRoof(int _vehicle, bool _instantlyLower)
		{
			unsafe {
				if (fn__lowerConvertibleRoof == null) fn__lowerConvertibleRoof = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_lowerConvertibleRoof");
				fn__lowerConvertibleRoof(_vehicle, _instantlyLower);
			}
		}

		public void RaiseConvertibleRoof(int _vehicle, bool _instantlyRaise)
		{
			unsafe {
				if (fn__raiseConvertibleRoof == null) fn__raiseConvertibleRoof = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_raiseConvertibleRoof");
				fn__raiseConvertibleRoof(_vehicle, _instantlyRaise);
			}
		}

		public int GetConvertibleRoofState(int _vehicle)
		{
			unsafe {
				if (fn__getConvertibleRoofState == null) fn__getConvertibleRoofState = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getConvertibleRoofState");
				var result = fn__getConvertibleRoofState(_vehicle);
				return result;
			}
		}

		public bool IsVehicleAConvertible(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__isVehicleAConvertible == null) fn__isVehicleAConvertible = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleAConvertible");
				var result = fn__isVehicleAConvertible(_vehicle, _p1);
				return result;
			}
		}

		public void TransformVehicleToSubmarine(int _vehicle, bool _noAnimation)
		{
			unsafe {
				if (fn__transformVehicleToSubmarine == null) fn__transformVehicleToSubmarine = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_transformVehicleToSubmarine");
				fn__transformVehicleToSubmarine(_vehicle, _noAnimation);
			}
		}

		public void TransformSubmarineToVehicle(int _vehicle, bool _noAnimation)
		{
			unsafe {
				if (fn__transformSubmarineToVehicle == null) fn__transformSubmarineToVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_transformSubmarineToVehicle");
				fn__transformSubmarineToVehicle(_vehicle, _noAnimation);
			}
		}

		public bool GetIsSubmarineVehicleTransformed(int _vehicle)
		{
			unsafe {
				if (fn__getIsSubmarineVehicleTransformed == null) fn__getIsSubmarineVehicleTransformed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getIsSubmarineVehicleTransformed");
				var result = fn__getIsSubmarineVehicleTransformed(_vehicle);
				return result;
			}
		}

		public bool IsVehicleStoppedAtTrafficLights(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleStoppedAtTrafficLights == null) fn__isVehicleStoppedAtTrafficLights = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleStoppedAtTrafficLights");
				var result = fn__isVehicleStoppedAtTrafficLights(_vehicle);
				return result;
			}
		}

		public void SetVehicleDamage(int _vehicle, float _xOffset, float _yOffset, float _zOffset, float _damage, float _radius, bool _focusOnModel)
		{
			unsafe {
				if (fn__setVehicleDamage == null) fn__setVehicleDamage = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDamage");
				fn__setVehicleDamage(_vehicle, _xOffset, _yOffset, _zOffset, _damage, _radius, _focusOnModel);
			}
		}

		public void _0x35BB21DE06784373(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x35BB21DE06784373 == null) fn__0x35BB21DE06784373 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x35BB21DE06784373");
				fn__0x35BB21DE06784373(_p0, _p1);
			}
		}

		public float GetVehicleEngineHealth(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleEngineHealth == null) fn__getVehicleEngineHealth = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleEngineHealth");
				var result = fn__getVehicleEngineHealth(_vehicle);
				return result;
			}
		}

		public void SetVehicleEngineHealth(int _vehicle, float _health)
		{
			unsafe {
				if (fn__setVehicleEngineHealth == null) fn__setVehicleEngineHealth = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleEngineHealth");
				fn__setVehicleEngineHealth(_vehicle, _health);
			}
		}

		public void SetPlaneEngineHealth(int _vehicle, float _health)
		{
			unsafe {
				if (fn__setPlaneEngineHealth == null) fn__setPlaneEngineHealth = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlaneEngineHealth");
				fn__setPlaneEngineHealth(_vehicle, _health);
			}
		}

		public float GetVehiclePetrolTankHealth(int _vehicle)
		{
			unsafe {
				if (fn__getVehiclePetrolTankHealth == null) fn__getVehiclePetrolTankHealth = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehiclePetrolTankHealth");
				var result = fn__getVehiclePetrolTankHealth(_vehicle);
				return result;
			}
		}

		public void SetVehiclePetrolTankHealth(int _vehicle, float _health)
		{
			unsafe {
				if (fn__setVehiclePetrolTankHealth == null) fn__setVehiclePetrolTankHealth = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehiclePetrolTankHealth");
				fn__setVehiclePetrolTankHealth(_vehicle, _health);
			}
		}

		public bool IsVehicleStuckTimerUp(int _vehicle, int _p1, int _p2)
		{
			unsafe {
				if (fn__isVehicleStuckTimerUp == null) fn__isVehicleStuckTimerUp = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleStuckTimerUp");
				var result = fn__isVehicleStuckTimerUp(_vehicle, _p1, _p2);
				return result;
			}
		}

		public void ResetVehicleStuckTimer(int _vehicle, int _nullAttributes)
		{
			unsafe {
				if (fn__resetVehicleStuckTimer == null) fn__resetVehicleStuckTimer = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_resetVehicleStuckTimer");
				fn__resetVehicleStuckTimer(_vehicle, _nullAttributes);
			}
		}

		public bool IsVehicleDriveable(int _vehicle, bool _isOnFireCheck)
		{
			unsafe {
				if (fn__isVehicleDriveable == null) fn__isVehicleDriveable = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleDriveable");
				var result = fn__isVehicleDriveable(_vehicle, _isOnFireCheck);
				return result;
			}
		}

		public void SetVehicleHasBeenOwnedByPlayer(int _vehicle, bool _owned)
		{
			unsafe {
				if (fn__setVehicleHasBeenOwnedByPlayer == null) fn__setVehicleHasBeenOwnedByPlayer = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHasBeenOwnedByPlayer");
				fn__setVehicleHasBeenOwnedByPlayer(_vehicle, _owned);
			}
		}

		public void SetVehicleNeedsToBeHotwired(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleNeedsToBeHotwired == null) fn__setVehicleNeedsToBeHotwired = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleNeedsToBeHotwired");
				fn__setVehicleNeedsToBeHotwired(_vehicle, _toggle);
			}
		}

		public void _0x9F3F689B814F2599(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x9F3F689B814F2599 == null) fn__0x9F3F689B814F2599 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x9F3F689B814F2599");
				fn__0x9F3F689B814F2599(_vehicle, _p1);
			}
		}

		public void _0x4E74E62E0A97E901(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x4E74E62E0A97E901 == null) fn__0x4E74E62E0A97E901 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x4E74E62E0A97E901");
				fn__0x4E74E62E0A97E901(_vehicle, _p1);
			}
		}

		public void StartVehicleHorn(int _vehicle, int _duration, int _mode, bool _forever)
		{
			unsafe {
				if (fn__startVehicleHorn == null) fn__startVehicleHorn = (delegate* unmanaged[Cdecl]<int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_startVehicleHorn");
				fn__startVehicleHorn(_vehicle, _duration, _mode, _forever);
			}
		}

		public void SetVehicleSilent(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleSilent == null) fn__setVehicleSilent = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleSilent");
				fn__setVehicleSilent(_vehicle, _toggle);
			}
		}

		public void SetVehicleHasStrongAxles(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleHasStrongAxles == null) fn__setVehicleHasStrongAxles = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHasStrongAxles");
				fn__setVehicleHasStrongAxles(_vehicle, _toggle);
			}
		}

		public string GetDisplayNameFromVehicleModel(int _modelHash)
		{
			unsafe {
				if (fn__getDisplayNameFromVehicleModel == null) fn__getDisplayNameFromVehicleModel = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getDisplayNameFromVehicleModel");
				var result = fn__getDisplayNameFromVehicleModel(_modelHash);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetMakeNameFromVehicleModel(int _modelHash)
		{
			unsafe {
				if (fn__getMakeNameFromVehicleModel == null) fn__getMakeNameFromVehicleModel = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getMakeNameFromVehicleModel");
				var result = fn__getMakeNameFromVehicleModel(_modelHash);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public Vector3 GetVehicleDeformationAtPos(int _vehicle, float _offsetX, float _offsetY, float _offsetZ)
		{
			unsafe {
				if (fn__getVehicleDeformationAtPos == null) fn__getVehicleDeformationAtPos = (delegate* unmanaged[Cdecl]<int, float, float, float, Vector3>) NativeLibrary.GetExport(handle, "Native_getVehicleDeformationAtPos");
				var result = fn__getVehicleDeformationAtPos(_vehicle, _offsetX, _offsetY, _offsetZ);
				return result;
			}
		}

		public void SetVehicleLivery(int _vehicle, int _livery)
		{
			unsafe {
				if (fn__setVehicleLivery == null) fn__setVehicleLivery = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleLivery");
				fn__setVehicleLivery(_vehicle, _livery);
			}
		}

		public int GetVehicleLivery(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleLivery == null) fn__getVehicleLivery = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleLivery");
				var result = fn__getVehicleLivery(_vehicle);
				return result;
			}
		}

		public int GetVehicleLiveryCount(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleLiveryCount == null) fn__getVehicleLiveryCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleLiveryCount");
				var result = fn__getVehicleLiveryCount(_vehicle);
				return result;
			}
		}

		public void SetVehicleRoofLivery(int _vehicle, int _livery)
		{
			unsafe {
				if (fn__setVehicleRoofLivery == null) fn__setVehicleRoofLivery = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRoofLivery");
				fn__setVehicleRoofLivery(_vehicle, _livery);
			}
		}

		public int GetVehicleRoofLivery(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleRoofLivery == null) fn__getVehicleRoofLivery = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleRoofLivery");
				var result = fn__getVehicleRoofLivery(_vehicle);
				return result;
			}
		}

		public int GetVehicleRoofLiveryCount(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleRoofLiveryCount == null) fn__getVehicleRoofLiveryCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleRoofLiveryCount");
				var result = fn__getVehicleRoofLiveryCount(_vehicle);
				return result;
			}
		}

		public bool IsVehicleWindowIntact(int _vehicle, int _windowIndex)
		{
			unsafe {
				if (fn__isVehicleWindowIntact == null) fn__isVehicleWindowIntact = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleWindowIntact");
				var result = fn__isVehicleWindowIntact(_vehicle, _windowIndex);
				return result;
			}
		}

		public bool AreAllVehicleWindowsIntact(int _vehicle)
		{
			unsafe {
				if (fn__areAllVehicleWindowsIntact == null) fn__areAllVehicleWindowsIntact = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_areAllVehicleWindowsIntact");
				var result = fn__areAllVehicleWindowsIntact(_vehicle);
				return result;
			}
		}

		public bool AreAnyVehicleSeatsFree(int _vehicle)
		{
			unsafe {
				if (fn__areAnyVehicleSeatsFree == null) fn__areAnyVehicleSeatsFree = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_areAnyVehicleSeatsFree");
				var result = fn__areAnyVehicleSeatsFree(_vehicle);
				return result;
			}
		}

		public void ResetVehicleWheels(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__resetVehicleWheels == null) fn__resetVehicleWheels = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_resetVehicleWheels");
				fn__resetVehicleWheels(_vehicle, _toggle);
			}
		}

		public bool IsHeliPartBroken(int _vehicle, bool _p1, bool _p2, bool _p3)
		{
			unsafe {
				if (fn__isHeliPartBroken == null) fn__isHeliPartBroken = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_isHeliPartBroken");
				var result = fn__isHeliPartBroken(_vehicle, _p1, _p2, _p3);
				return result;
			}
		}

		public float GetHeliMainRotorHealth(int _vehicle)
		{
			unsafe {
				if (fn__getHeliMainRotorHealth == null) fn__getHeliMainRotorHealth = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getHeliMainRotorHealth");
				var result = fn__getHeliMainRotorHealth(_vehicle);
				return result;
			}
		}

		public float GetHeliTailRotorHealth(int _vehicle)
		{
			unsafe {
				if (fn__getHeliTailRotorHealth == null) fn__getHeliTailRotorHealth = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getHeliTailRotorHealth");
				var result = fn__getHeliTailRotorHealth(_vehicle);
				return result;
			}
		}

		public float GetHeliTailBoomHealth(int _vehicle)
		{
			unsafe {
				if (fn__getHeliTailBoomHealth == null) fn__getHeliTailBoomHealth = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getHeliTailBoomHealth");
				var result = fn__getHeliTailBoomHealth(_vehicle);
				return result;
			}
		}

		public void SetHeliMainRotorHealth(int _vehicle, float _health)
		{
			unsafe {
				if (fn__setHeliMainRotorHealth == null) fn__setHeliMainRotorHealth = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setHeliMainRotorHealth");
				fn__setHeliMainRotorHealth(_vehicle, _health);
			}
		}

		public void SetHeliTailRotorHealth(int _vehicle, float _health)
		{
			unsafe {
				if (fn__setHeliTailRotorHealth == null) fn__setHeliTailRotorHealth = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setHeliTailRotorHealth");
				fn__setHeliTailRotorHealth(_vehicle, _health);
			}
		}

		public void SetHeliTailExplodeThrowDashboard(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__setHeliTailExplodeThrowDashboard == null) fn__setHeliTailExplodeThrowDashboard = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setHeliTailExplodeThrowDashboard");
				fn__setHeliTailExplodeThrowDashboard(_vehicle, _p1);
			}
		}

		public void SetVehicleNameDebug(int _vehicle, string _name)
		{
			unsafe {
				if (fn__setVehicleNameDebug == null) fn__setVehicleNameDebug = (delegate* unmanaged[Cdecl]<int, nint, void>) NativeLibrary.GetExport(handle, "Native_setVehicleNameDebug");
				var ptr_name = MemoryUtils.StringToHGlobalUtf8(_name);
				fn__setVehicleNameDebug(_vehicle, ptr_name);
				Marshal.FreeHGlobal(ptr_name);
			}
		}

		public void SetVehicleExplodesOnHighExplosionDamage(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleExplodesOnHighExplosionDamage == null) fn__setVehicleExplodesOnHighExplosionDamage = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleExplodesOnHighExplosionDamage");
				fn__setVehicleExplodesOnHighExplosionDamage(_vehicle, _toggle);
			}
		}

		public void _0xD565F438137F0E10(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xD565F438137F0E10 == null) fn__0xD565F438137F0E10 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xD565F438137F0E10");
				fn__0xD565F438137F0E10(_p0, _p1);
			}
		}

		public void _0x3441CAD2F2231923(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x3441CAD2F2231923 == null) fn__0x3441CAD2F2231923 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x3441CAD2F2231923");
				fn__0x3441CAD2F2231923(_vehicle, _p1);
			}
		}

		public void SetVehicleDisableTowing(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleDisableTowing == null) fn__setVehicleDisableTowing = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDisableTowing");
				fn__setVehicleDisableTowing(_vehicle, _toggle);
			}
		}

		public bool DoesVehicleHaveLandingGear(int _vehicle)
		{
			unsafe {
				if (fn__doesVehicleHaveLandingGear == null) fn__doesVehicleHaveLandingGear = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesVehicleHaveLandingGear");
				var result = fn__doesVehicleHaveLandingGear(_vehicle);
				return result;
			}
		}

		public void ControlLandingGear(int _vehicle, int _state)
		{
			unsafe {
				if (fn__controlLandingGear == null) fn__controlLandingGear = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_controlLandingGear");
				fn__controlLandingGear(_vehicle, _state);
			}
		}

		public int GetLandingGearState(int _vehicle)
		{
			unsafe {
				if (fn__getLandingGearState == null) fn__getLandingGearState = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getLandingGearState");
				var result = fn__getLandingGearState(_vehicle);
				return result;
			}
		}

		public bool IsAnyVehicleNearPoint(float _x, float _y, float _z, float _radius)
		{
			unsafe {
				if (fn__isAnyVehicleNearPoint == null) fn__isAnyVehicleNearPoint = (delegate* unmanaged[Cdecl]<float, float, float, float, bool>) NativeLibrary.GetExport(handle, "Native_isAnyVehicleNearPoint");
				var result = fn__isAnyVehicleNearPoint(_x, _y, _z, _radius);
				return result;
			}
		}

		public void RequestVehicleHighDetailModel(int _vehicle)
		{
			unsafe {
				if (fn__requestVehicleHighDetailModel == null) fn__requestVehicleHighDetailModel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestVehicleHighDetailModel");
				fn__requestVehicleHighDetailModel(_vehicle);
			}
		}

		public void RemoveVehicleHighDetailModel(int _vehicle)
		{
			unsafe {
				if (fn__removeVehicleHighDetailModel == null) fn__removeVehicleHighDetailModel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleHighDetailModel");
				fn__removeVehicleHighDetailModel(_vehicle);
			}
		}

		public bool IsVehicleHighDetail(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleHighDetail == null) fn__isVehicleHighDetail = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleHighDetail");
				var result = fn__isVehicleHighDetail(_vehicle);
				return result;
			}
		}

		public void RequestVehicleAsset(int _vehicleHash, int _vehicleAsset)
		{
			unsafe {
				if (fn__requestVehicleAsset == null) fn__requestVehicleAsset = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_requestVehicleAsset");
				fn__requestVehicleAsset(_vehicleHash, _vehicleAsset);
			}
		}

		public bool HasVehicleAssetLoaded(int _vehicleAsset)
		{
			unsafe {
				if (fn__hasVehicleAssetLoaded == null) fn__hasVehicleAssetLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasVehicleAssetLoaded");
				var result = fn__hasVehicleAssetLoaded(_vehicleAsset);
				return result;
			}
		}

		public void RemoveVehicleAsset(int _vehicleAsset)
		{
			unsafe {
				if (fn__removeVehicleAsset == null) fn__removeVehicleAsset = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleAsset");
				fn__removeVehicleAsset(_vehicleAsset);
			}
		}

		public void SetVehicleTowTruckArmPosition(int _vehicle, float _position)
		{
			unsafe {
				if (fn__setVehicleTowTruckArmPosition == null) fn__setVehicleTowTruckArmPosition = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleTowTruckArmPosition");
				fn__setVehicleTowTruckArmPosition(_vehicle, _position);
			}
		}

		public void AttachVehicleToTowTruck(int _towTruck, int _vehicle, bool _rear, float _hookOffsetX, float _hookOffsetY, float _hookOffsetZ)
		{
			unsafe {
				if (fn__attachVehicleToTowTruck == null) fn__attachVehicleToTowTruck = (delegate* unmanaged[Cdecl]<int, int, bool, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_attachVehicleToTowTruck");
				fn__attachVehicleToTowTruck(_towTruck, _vehicle, _rear, _hookOffsetX, _hookOffsetY, _hookOffsetZ);
			}
		}

		public void DetachVehicleFromTowTruck(int _towTruck, int _vehicle)
		{
			unsafe {
				if (fn__detachVehicleFromTowTruck == null) fn__detachVehicleFromTowTruck = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_detachVehicleFromTowTruck");
				fn__detachVehicleFromTowTruck(_towTruck, _vehicle);
			}
		}

		public bool DetachVehicleFromAnyTowTruck(int _vehicle)
		{
			unsafe {
				if (fn__detachVehicleFromAnyTowTruck == null) fn__detachVehicleFromAnyTowTruck = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_detachVehicleFromAnyTowTruck");
				var result = fn__detachVehicleFromAnyTowTruck(_vehicle);
				return result;
			}
		}

		public bool IsVehicleAttachedToTowTruck(int _towTruck, int _vehicle)
		{
			unsafe {
				if (fn__isVehicleAttachedToTowTruck == null) fn__isVehicleAttachedToTowTruck = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleAttachedToTowTruck");
				var result = fn__isVehicleAttachedToTowTruck(_towTruck, _vehicle);
				return result;
			}
		}

		public int GetEntityAttachedToTowTruck(int _towTruck)
		{
			unsafe {
				if (fn__getEntityAttachedToTowTruck == null) fn__getEntityAttachedToTowTruck = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityAttachedToTowTruck");
				var result = fn__getEntityAttachedToTowTruck(_towTruck);
				return result;
			}
		}

		public int SetVehicleAutomaticallyAttaches(int _vehicle, bool _p1, int _p2)
		{
			unsafe {
				if (fn__setVehicleAutomaticallyAttaches == null) fn__setVehicleAutomaticallyAttaches = (delegate* unmanaged[Cdecl]<int, bool, int, int>) NativeLibrary.GetExport(handle, "Native_setVehicleAutomaticallyAttaches");
				var result = fn__setVehicleAutomaticallyAttaches(_vehicle, _p1, _p2);
				return result;
			}
		}

		public void SetVehicleBulldozerArmPosition(int _vehicle, float _position, bool _p2)
		{
			unsafe {
				if (fn__setVehicleBulldozerArmPosition == null) fn__setVehicleBulldozerArmPosition = (delegate* unmanaged[Cdecl]<int, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleBulldozerArmPosition");
				fn__setVehicleBulldozerArmPosition(_vehicle, _position, _p2);
			}
		}

		public void SetVehicleTankTurretPosition(int _vehicle, float _position, bool _p2)
		{
			unsafe {
				if (fn__setVehicleTankTurretPosition == null) fn__setVehicleTankTurretPosition = (delegate* unmanaged[Cdecl]<int, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleTankTurretPosition");
				fn__setVehicleTankTurretPosition(_vehicle, _position, _p2);
			}
		}

		public void _0x0581730AB9380412(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__0x0581730AB9380412 == null) fn__0x0581730AB9380412 = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0581730AB9380412");
				fn__0x0581730AB9380412(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void _0x737E398138550FFF(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x737E398138550FFF == null) fn__0x737E398138550FFF = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x737E398138550FFF");
				fn__0x737E398138550FFF(_p0, _p1);
			}
		}

		public void SetVehicleTurretSpeedThisFrame(int _vehicle, float _speed)
		{
			unsafe {
				if (fn__setVehicleTurretSpeedThisFrame == null) fn__setVehicleTurretSpeedThisFrame = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleTurretSpeedThisFrame");
				fn__setVehicleTurretSpeedThisFrame(_vehicle, _speed);
			}
		}

		public void DisableVehicleTurretMovementThisFrame(int _vehicle)
		{
			unsafe {
				if (fn__disableVehicleTurretMovementThisFrame == null) fn__disableVehicleTurretMovementThisFrame = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableVehicleTurretMovementThisFrame");
				fn__disableVehicleTurretMovementThisFrame(_vehicle);
			}
		}

		public void SetVehicleFlightNozzlePosition(int _vehicle, float _angleRatio)
		{
			unsafe {
				if (fn__setVehicleFlightNozzlePosition == null) fn__setVehicleFlightNozzlePosition = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleFlightNozzlePosition");
				fn__setVehicleFlightNozzlePosition(_vehicle, _angleRatio);
			}
		}

		public void SetVehicleFlightNozzlePositionImmediate(int _vehicle, float _angle)
		{
			unsafe {
				if (fn__setVehicleFlightNozzlePositionImmediate == null) fn__setVehicleFlightNozzlePositionImmediate = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleFlightNozzlePositionImmediate");
				fn__setVehicleFlightNozzlePositionImmediate(_vehicle, _angle);
			}
		}

		public float GetVehicleFlightNozzlePosition(int _plane)
		{
			unsafe {
				if (fn__getVehicleFlightNozzlePosition == null) fn__getVehicleFlightNozzlePosition = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleFlightNozzlePosition");
				var result = fn__getVehicleFlightNozzlePosition(_plane);
				return result;
			}
		}

		public void SetDisableVehicleFlightNozzlePosition(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setDisableVehicleFlightNozzlePosition == null) fn__setDisableVehicleFlightNozzlePosition = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableVehicleFlightNozzlePosition");
				fn__setDisableVehicleFlightNozzlePosition(_vehicle, _toggle);
			}
		}

		public bool _0xA4822F1CF23F4810(ref Vector3 _outVec, int _p1, ref Vector3 _outVec1, int _p3, int _p4, int _p5, int _p6, int _p7, int _p8)
		{
			unsafe {
				if (fn__0xA4822F1CF23F4810 == null) fn__0xA4822F1CF23F4810 = (delegate* unmanaged[Cdecl]<Vector3*, int, Vector3*, int, int, int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native__0xA4822F1CF23F4810");
				var ref_outVec = _outVec;
				var ref_outVec1 = _outVec1;
				var result = fn__0xA4822F1CF23F4810(&ref_outVec, _p1, &ref_outVec1, _p3, _p4, _p5, _p6, _p7, _p8);
				_outVec = ref_outVec;
				_outVec1 = ref_outVec1;
				return result;
			}
		}

		public void SetVehicleBurnout(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleBurnout == null) fn__setVehicleBurnout = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleBurnout");
				fn__setVehicleBurnout(_vehicle, _toggle);
			}
		}

		public bool IsVehicleInBurnout(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleInBurnout == null) fn__isVehicleInBurnout = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleInBurnout");
				var result = fn__isVehicleInBurnout(_vehicle);
				return result;
			}
		}

		public void SetVehicleReduceGrip(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleReduceGrip == null) fn__setVehicleReduceGrip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleReduceGrip");
				fn__setVehicleReduceGrip(_vehicle, _toggle);
			}
		}

		public void SetVehicleReduceTraction(int _vehicle, int _val)
		{
			unsafe {
				if (fn__setVehicleReduceTraction == null) fn__setVehicleReduceTraction = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleReduceTraction");
				fn__setVehicleReduceTraction(_vehicle, _val);
			}
		}

		public void SetVehicleIndicatorLights(int _vehicle, int _turnSignal, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleIndicatorLights == null) fn__setVehicleIndicatorLights = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleIndicatorLights");
				fn__setVehicleIndicatorLights(_vehicle, _turnSignal, _toggle);
			}
		}

		public void SetVehicleBrakeLights(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleBrakeLights == null) fn__setVehicleBrakeLights = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleBrakeLights");
				fn__setVehicleBrakeLights(_vehicle, _toggle);
			}
		}

		public void SetVehicleHandbrake(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleHandbrake == null) fn__setVehicleHandbrake = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHandbrake");
				fn__setVehicleHandbrake(_vehicle, _toggle);
			}
		}

		public void SetVehicleBrake(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleBrake == null) fn__setVehicleBrake = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleBrake");
				fn__setVehicleBrake(_vehicle, _toggle);
			}
		}

		public void InstantlyFillVehiclePopulation()
		{
			unsafe {
				if (fn__instantlyFillVehiclePopulation == null) fn__instantlyFillVehiclePopulation = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_instantlyFillVehiclePopulation");
				fn__instantlyFillVehiclePopulation();
			}
		}

		public bool HasFilledVehiclePopulation()
		{
			unsafe {
				if (fn__hasFilledVehiclePopulation == null) fn__hasFilledVehiclePopulation = (delegate* unmanaged[Cdecl]<bool>) NativeLibrary.GetExport(handle, "Native_hasFilledVehiclePopulation");
				var result = fn__hasFilledVehiclePopulation();
				return result;
			}
		}

		public void _0x51DB102F4A3BA5E0(bool _toggle)
		{
			unsafe {
				if (fn__0x51DB102F4A3BA5E0 == null) fn__0x51DB102F4A3BA5E0 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x51DB102F4A3BA5E0");
				fn__0x51DB102F4A3BA5E0(_toggle);
			}
		}

		public void _0xA4A9A4C40E615885(int _p0)
		{
			unsafe {
				if (fn__0xA4A9A4C40E615885 == null) fn__0xA4A9A4C40E615885 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xA4A9A4C40E615885");
				fn__0xA4A9A4C40E615885(_p0);
			}
		}

		public bool GetVehicleTrailerVehicle(int _vehicle, ref int _trailer)
		{
			unsafe {
				if (fn__getVehicleTrailerVehicle == null) fn__getVehicleTrailerVehicle = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleTrailerVehicle");
				var ref_trailer = _trailer;
				var result = fn__getVehicleTrailerVehicle(_vehicle, &ref_trailer);
				_trailer = ref_trailer;
				return result;
			}
		}

		public void SetVehicleUsesLargeRearRamp(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleUsesLargeRearRamp == null) fn__setVehicleUsesLargeRearRamp = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleUsesLargeRearRamp");
				fn__setVehicleUsesLargeRearRamp(_vehicle, _toggle);
			}
		}

		public void SetVehicleRudderBroken(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleRudderBroken == null) fn__setVehicleRudderBroken = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRudderBroken");
				fn__setVehicleRudderBroken(_vehicle, _toggle);
			}
		}

		public void SetConvertibleRoofLatchState(int _vehicle, bool _state)
		{
			unsafe {
				if (fn__setConvertibleRoofLatchState == null) fn__setConvertibleRoofLatchState = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setConvertibleRoofLatchState");
				fn__setConvertibleRoofLatchState(_vehicle, _state);
			}
		}

		public float GetVehicleEstimatedMaxSpeed(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleEstimatedMaxSpeed == null) fn__getVehicleEstimatedMaxSpeed = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleEstimatedMaxSpeed");
				var result = fn__getVehicleEstimatedMaxSpeed(_vehicle);
				return result;
			}
		}

		public float GetVehicleMaxBraking(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleMaxBraking == null) fn__getVehicleMaxBraking = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleMaxBraking");
				var result = fn__getVehicleMaxBraking(_vehicle);
				return result;
			}
		}

		public float GetVehicleMaxTraction(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleMaxTraction == null) fn__getVehicleMaxTraction = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleMaxTraction");
				var result = fn__getVehicleMaxTraction(_vehicle);
				return result;
			}
		}

		public float GetVehicleAcceleration(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleAcceleration == null) fn__getVehicleAcceleration = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleAcceleration");
				var result = fn__getVehicleAcceleration(_vehicle);
				return result;
			}
		}

		public float GetVehicleModelEstimatedMaxSpeed(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleModelEstimatedMaxSpeed == null) fn__getVehicleModelEstimatedMaxSpeed = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleModelEstimatedMaxSpeed");
				var result = fn__getVehicleModelEstimatedMaxSpeed(_modelHash);
				return result;
			}
		}

		public float GetVehicleModelMaxBraking(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleModelMaxBraking == null) fn__getVehicleModelMaxBraking = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleModelMaxBraking");
				var result = fn__getVehicleModelMaxBraking(_modelHash);
				return result;
			}
		}

		public float GetVehicleModelMaxBrakingMaxMods(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleModelMaxBrakingMaxMods == null) fn__getVehicleModelMaxBrakingMaxMods = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleModelMaxBrakingMaxMods");
				var result = fn__getVehicleModelMaxBrakingMaxMods(_modelHash);
				return result;
			}
		}

		public float GetVehicleModelMaxTraction(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleModelMaxTraction == null) fn__getVehicleModelMaxTraction = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleModelMaxTraction");
				var result = fn__getVehicleModelMaxTraction(_modelHash);
				return result;
			}
		}

		public float GetVehicleModelAcceleration(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleModelAcceleration == null) fn__getVehicleModelAcceleration = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleModelAcceleration");
				var result = fn__getVehicleModelAcceleration(_modelHash);
				return result;
			}
		}

		public float GetVehicleModelEstimatedAgility(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleModelEstimatedAgility == null) fn__getVehicleModelEstimatedAgility = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleModelEstimatedAgility");
				var result = fn__getVehicleModelEstimatedAgility(_modelHash);
				return result;
			}
		}

		public float GetVehicleModelMaxKnots(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleModelMaxKnots == null) fn__getVehicleModelMaxKnots = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleModelMaxKnots");
				var result = fn__getVehicleModelMaxKnots(_modelHash);
				return result;
			}
		}

		public float GetVehicleModelMoveResistance(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleModelMoveResistance == null) fn__getVehicleModelMoveResistance = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleModelMoveResistance");
				var result = fn__getVehicleModelMoveResistance(_modelHash);
				return result;
			}
		}

		public float GetVehicleClassEstimatedMaxSpeed(int _vehicleClass)
		{
			unsafe {
				if (fn__getVehicleClassEstimatedMaxSpeed == null) fn__getVehicleClassEstimatedMaxSpeed = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleClassEstimatedMaxSpeed");
				var result = fn__getVehicleClassEstimatedMaxSpeed(_vehicleClass);
				return result;
			}
		}

		public float GetVehicleClassMaxTraction(int _vehicleClass)
		{
			unsafe {
				if (fn__getVehicleClassMaxTraction == null) fn__getVehicleClassMaxTraction = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleClassMaxTraction");
				var result = fn__getVehicleClassMaxTraction(_vehicleClass);
				return result;
			}
		}

		public float GetVehicleClassMaxAgility(int _vehicleClass)
		{
			unsafe {
				if (fn__getVehicleClassMaxAgility == null) fn__getVehicleClassMaxAgility = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleClassMaxAgility");
				var result = fn__getVehicleClassMaxAgility(_vehicleClass);
				return result;
			}
		}

		public float GetVehicleClassMaxAcceleration(int _vehicleClass)
		{
			unsafe {
				if (fn__getVehicleClassMaxAcceleration == null) fn__getVehicleClassMaxAcceleration = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleClassMaxAcceleration");
				var result = fn__getVehicleClassMaxAcceleration(_vehicleClass);
				return result;
			}
		}

		public float GetVehicleClassMaxBraking(int _vehicleClass)
		{
			unsafe {
				if (fn__getVehicleClassMaxBraking == null) fn__getVehicleClassMaxBraking = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleClassMaxBraking");
				var result = fn__getVehicleClassMaxBraking(_vehicleClass);
				return result;
			}
		}

		public int AddRoadNodeSpeedZone(float _x, float _y, float _z, float _radius, float _speed, bool _p5)
		{
			unsafe {
				if (fn__addRoadNodeSpeedZone == null) fn__addRoadNodeSpeedZone = (delegate* unmanaged[Cdecl]<float, float, float, float, float, bool, int>) NativeLibrary.GetExport(handle, "Native_addRoadNodeSpeedZone");
				var result = fn__addRoadNodeSpeedZone(_x, _y, _z, _radius, _speed, _p5);
				return result;
			}
		}

		public bool RemoveRoadNodeSpeedZone(int _speedzone)
		{
			unsafe {
				if (fn__removeRoadNodeSpeedZone == null) fn__removeRoadNodeSpeedZone = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_removeRoadNodeSpeedZone");
				var result = fn__removeRoadNodeSpeedZone(_speedzone);
				return result;
			}
		}

		public void OpenBombBayDoors(int _vehicle)
		{
			unsafe {
				if (fn__openBombBayDoors == null) fn__openBombBayDoors = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_openBombBayDoors");
				fn__openBombBayDoors(_vehicle);
			}
		}

		public void CloseBombBayDoors(int _vehicle)
		{
			unsafe {
				if (fn__closeBombBayDoors == null) fn__closeBombBayDoors = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_closeBombBayDoors");
				fn__closeBombBayDoors(_vehicle);
			}
		}

		public bool AreBombBayDoorsOpen(int _aircraft)
		{
			unsafe {
				if (fn__areBombBayDoorsOpen == null) fn__areBombBayDoorsOpen = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_areBombBayDoorsOpen");
				var result = fn__areBombBayDoorsOpen(_aircraft);
				return result;
			}
		}

		public bool IsVehicleSearchlightOn(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleSearchlightOn == null) fn__isVehicleSearchlightOn = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleSearchlightOn");
				var result = fn__isVehicleSearchlightOn(_vehicle);
				return result;
			}
		}

		public void SetVehicleSearchlight(int _heli, bool _toggle, bool _canBeUsedByAI)
		{
			unsafe {
				if (fn__setVehicleSearchlight == null) fn__setVehicleSearchlight = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleSearchlight");
				fn__setVehicleSearchlight(_heli, _toggle, _canBeUsedByAI);
			}
		}

		public bool DoesVehicleHaveSearchlight(int _vehicle)
		{
			unsafe {
				if (fn__doesVehicleHaveSearchlight == null) fn__doesVehicleHaveSearchlight = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesVehicleHaveSearchlight");
				var result = fn__doesVehicleHaveSearchlight(_vehicle);
				return result;
			}
		}

		public bool IsVehicleSeatAccessible(int _ped, int _vehicle, int _seatIndex, bool _side, bool _onEnter)
		{
			unsafe {
				if (fn__isVehicleSeatAccessible == null) fn__isVehicleSeatAccessible = (delegate* unmanaged[Cdecl]<int, int, int, bool, bool, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleSeatAccessible");
				var result = fn__isVehicleSeatAccessible(_ped, _vehicle, _seatIndex, _side, _onEnter);
				return result;
			}
		}

		public Vector3 GetEntryPositionOfDoor(int _vehicle, int _doorId)
		{
			unsafe {
				if (fn__getEntryPositionOfDoor == null) fn__getEntryPositionOfDoor = (delegate* unmanaged[Cdecl]<int, int, Vector3>) NativeLibrary.GetExport(handle, "Native_getEntryPositionOfDoor");
				var result = fn__getEntryPositionOfDoor(_vehicle, _doorId);
				return result;
			}
		}

		public bool CanShuffleSeat(int _vehicle, int _seatIndex)
		{
			unsafe {
				if (fn__canShuffleSeat == null) fn__canShuffleSeat = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_canShuffleSeat");
				var result = fn__canShuffleSeat(_vehicle, _seatIndex);
				return result;
			}
		}

		public int GetNumModKits(int _vehicle)
		{
			unsafe {
				if (fn__getNumModKits == null) fn__getNumModKits = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumModKits");
				var result = fn__getNumModKits(_vehicle);
				return result;
			}
		}

		public void SetVehicleModKit(int _vehicle, int _modKit)
		{
			unsafe {
				if (fn__setVehicleModKit == null) fn__setVehicleModKit = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleModKit");
				fn__setVehicleModKit(_vehicle, _modKit);
			}
		}

		public int GetVehicleModKit(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleModKit == null) fn__getVehicleModKit = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleModKit");
				var result = fn__getVehicleModKit(_vehicle);
				return result;
			}
		}

		public int GetVehicleModKitType(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleModKitType == null) fn__getVehicleModKitType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleModKitType");
				var result = fn__getVehicleModKitType(_vehicle);
				return result;
			}
		}

		public int GetVehicleWheelType(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleWheelType == null) fn__getVehicleWheelType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleWheelType");
				var result = fn__getVehicleWheelType(_vehicle);
				return result;
			}
		}

		public void SetVehicleWheelType(int _vehicle, int _WheelType)
		{
			unsafe {
				if (fn__setVehicleWheelType == null) fn__setVehicleWheelType = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleWheelType");
				fn__setVehicleWheelType(_vehicle, _WheelType);
			}
		}

		public int GetNumModColors(int _paintType, bool _p1)
		{
			unsafe {
				if (fn__getNumModColors == null) fn__getNumModColors = (delegate* unmanaged[Cdecl]<int, bool, int>) NativeLibrary.GetExport(handle, "Native_getNumModColors");
				var result = fn__getNumModColors(_paintType, _p1);
				return result;
			}
		}

		public void SetVehicleModColor1(int _vehicle, int _paintType, int _color, int _pearlescentColor)
		{
			unsafe {
				if (fn__setVehicleModColor1 == null) fn__setVehicleModColor1 = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleModColor1");
				fn__setVehicleModColor1(_vehicle, _paintType, _color, _pearlescentColor);
			}
		}

		public void SetVehicleModColor2(int _vehicle, int _paintType, int _color)
		{
			unsafe {
				if (fn__setVehicleModColor2 == null) fn__setVehicleModColor2 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleModColor2");
				fn__setVehicleModColor2(_vehicle, _paintType, _color);
			}
		}

		public void GetVehicleModColor1(int _vehicle, ref int _paintType, ref int _color, ref int _pearlescentColor)
		{
			unsafe {
				if (fn__getVehicleModColor1 == null) fn__getVehicleModColor1 = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleModColor1");
				var ref_paintType = _paintType;
				var ref_color = _color;
				var ref_pearlescentColor = _pearlescentColor;
				fn__getVehicleModColor1(_vehicle, &ref_paintType, &ref_color, &ref_pearlescentColor);
				_paintType = ref_paintType;
				_color = ref_color;
				_pearlescentColor = ref_pearlescentColor;
			}
		}

		public void GetVehicleModColor2(int _vehicle, ref int _paintType, ref int _color)
		{
			unsafe {
				if (fn__getVehicleModColor2 == null) fn__getVehicleModColor2 = (delegate* unmanaged[Cdecl]<int, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleModColor2");
				var ref_paintType = _paintType;
				var ref_color = _color;
				fn__getVehicleModColor2(_vehicle, &ref_paintType, &ref_color);
				_paintType = ref_paintType;
				_color = ref_color;
			}
		}

		public string GetVehicleModColor1Name(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__getVehicleModColor1Name == null) fn__getVehicleModColor1Name = (delegate* unmanaged[Cdecl]<int, bool, nint>) NativeLibrary.GetExport(handle, "Native_getVehicleModColor1Name");
				var result = fn__getVehicleModColor1Name(_vehicle, _p1);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetVehicleModColor2Name(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleModColor2Name == null) fn__getVehicleModColor2Name = (delegate* unmanaged[Cdecl]<int, nint>) NativeLibrary.GetExport(handle, "Native_getVehicleModColor2Name");
				var result = fn__getVehicleModColor2Name(_vehicle);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public bool HaveVehicleModsStreamedIn(int _vehicle)
		{
			unsafe {
				if (fn__haveVehicleModsStreamedIn == null) fn__haveVehicleModsStreamedIn = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_haveVehicleModsStreamedIn");
				var result = fn__haveVehicleModsStreamedIn(_vehicle);
				return result;
			}
		}

		public void SetVehicleMod(int _vehicle, int _modType, int _modIndex, bool _customTires)
		{
			unsafe {
				if (fn__setVehicleMod == null) fn__setVehicleMod = (delegate* unmanaged[Cdecl]<int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleMod");
				fn__setVehicleMod(_vehicle, _modType, _modIndex, _customTires);
			}
		}

		public int GetVehicleMod(int _vehicle, int _modType)
		{
			unsafe {
				if (fn__getVehicleMod == null) fn__getVehicleMod = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleMod");
				var result = fn__getVehicleMod(_vehicle, _modType);
				return result;
			}
		}

		public bool GetVehicleModVariation(int _vehicle, int _modType)
		{
			unsafe {
				if (fn__getVehicleModVariation == null) fn__getVehicleModVariation = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleModVariation");
				var result = fn__getVehicleModVariation(_vehicle, _modType);
				return result;
			}
		}

		public int GetNumVehicleMods(int _vehicle, int _modType)
		{
			unsafe {
				if (fn__getNumVehicleMods == null) fn__getNumVehicleMods = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getNumVehicleMods");
				var result = fn__getNumVehicleMods(_vehicle, _modType);
				return result;
			}
		}

		public void RemoveVehicleMod(int _vehicle, int _modType)
		{
			unsafe {
				if (fn__removeVehicleMod == null) fn__removeVehicleMod = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleMod");
				fn__removeVehicleMod(_vehicle, _modType);
			}
		}

		public void ToggleVehicleMod(int _vehicle, int _modType, bool _toggle)
		{
			unsafe {
				if (fn__toggleVehicleMod == null) fn__toggleVehicleMod = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_toggleVehicleMod");
				fn__toggleVehicleMod(_vehicle, _modType, _toggle);
			}
		}

		public bool IsToggleModOn(int _vehicle, int _modType)
		{
			unsafe {
				if (fn__isToggleModOn == null) fn__isToggleModOn = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isToggleModOn");
				var result = fn__isToggleModOn(_vehicle, _modType);
				return result;
			}
		}

		public string GetModTextLabel(int _vehicle, int _modType, int _modValue)
		{
			unsafe {
				if (fn__getModTextLabel == null) fn__getModTextLabel = (delegate* unmanaged[Cdecl]<int, int, int, nint>) NativeLibrary.GetExport(handle, "Native_getModTextLabel");
				var result = fn__getModTextLabel(_vehicle, _modType, _modValue);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetModSlotName(int _vehicle, int _modType)
		{
			unsafe {
				if (fn__getModSlotName == null) fn__getModSlotName = (delegate* unmanaged[Cdecl]<int, int, nint>) NativeLibrary.GetExport(handle, "Native_getModSlotName");
				var result = fn__getModSlotName(_vehicle, _modType);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public string GetLiveryName(int _vehicle, int _liveryIndex)
		{
			unsafe {
				if (fn__getLiveryName == null) fn__getLiveryName = (delegate* unmanaged[Cdecl]<int, int, nint>) NativeLibrary.GetExport(handle, "Native_getLiveryName");
				var result = fn__getLiveryName(_vehicle, _liveryIndex);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public int GetVehicleModModifierValue(int _vehicle, int _modType, int _modIndex)
		{
			unsafe {
				if (fn__getVehicleModModifierValue == null) fn__getVehicleModModifierValue = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleModModifierValue");
				var result = fn__getVehicleModModifierValue(_vehicle, _modType, _modIndex);
				return result;
			}
		}

		public int GetVehicleModIdentifierHash(int _vehicle, int _modType, int _modIndex)
		{
			unsafe {
				if (fn__getVehicleModIdentifierHash == null) fn__getVehicleModIdentifierHash = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleModIdentifierHash");
				var result = fn__getVehicleModIdentifierHash(_vehicle, _modType, _modIndex);
				return result;
			}
		}

		public void PreloadVehicleMod(int _p0, int _modType, int _p2)
		{
			unsafe {
				if (fn__preloadVehicleMod == null) fn__preloadVehicleMod = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_preloadVehicleMod");
				fn__preloadVehicleMod(_p0, _modType, _p2);
			}
		}

		public bool HasPreloadModsFinished(int _p0)
		{
			unsafe {
				if (fn__hasPreloadModsFinished == null) fn__hasPreloadModsFinished = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasPreloadModsFinished");
				var result = fn__hasPreloadModsFinished(_p0);
				return result;
			}
		}

		public void ReleasePreloadMods(int _vehicle)
		{
			unsafe {
				if (fn__releasePreloadMods == null) fn__releasePreloadMods = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_releasePreloadMods");
				fn__releasePreloadMods(_vehicle);
			}
		}

		public void SetVehicleTyreSmokeColor(int _vehicle, int _r, int _g, int _b)
		{
			unsafe {
				if (fn__setVehicleTyreSmokeColor == null) fn__setVehicleTyreSmokeColor = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleTyreSmokeColor");
				fn__setVehicleTyreSmokeColor(_vehicle, _r, _g, _b);
			}
		}

		public void GetVehicleTyreSmokeColor(int _vehicle, ref int _r, ref int _g, ref int _b)
		{
			unsafe {
				if (fn__getVehicleTyreSmokeColor == null) fn__getVehicleTyreSmokeColor = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleTyreSmokeColor");
				var ref_r = _r;
				var ref_g = _g;
				var ref_b = _b;
				fn__getVehicleTyreSmokeColor(_vehicle, &ref_r, &ref_g, &ref_b);
				_r = ref_r;
				_g = ref_g;
				_b = ref_b;
			}
		}

		public void SetVehicleWindowTint(int _vehicle, int _tint)
		{
			unsafe {
				if (fn__setVehicleWindowTint == null) fn__setVehicleWindowTint = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleWindowTint");
				fn__setVehicleWindowTint(_vehicle, _tint);
			}
		}

		public int GetVehicleWindowTint(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleWindowTint == null) fn__getVehicleWindowTint = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleWindowTint");
				var result = fn__getVehicleWindowTint(_vehicle);
				return result;
			}
		}

		public int GetNumVehicleWindowTints()
		{
			unsafe {
				if (fn__getNumVehicleWindowTints == null) fn__getNumVehicleWindowTints = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getNumVehicleWindowTints");
				var result = fn__getNumVehicleWindowTints();
				return result;
			}
		}

		public void GetVehicleColor(int _vehicle, ref int _r, ref int _g, ref int _b)
		{
			unsafe {
				if (fn__getVehicleColor == null) fn__getVehicleColor = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleColor");
				var ref_r = _r;
				var ref_g = _g;
				var ref_b = _b;
				fn__getVehicleColor(_vehicle, &ref_r, &ref_g, &ref_b);
				_r = ref_r;
				_g = ref_g;
				_b = ref_b;
			}
		}

		public int _0xEEBFC7A7EFDC35B4(int _vehicle)
		{
			unsafe {
				if (fn__0xEEBFC7A7EFDC35B4 == null) fn__0xEEBFC7A7EFDC35B4 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0xEEBFC7A7EFDC35B4");
				var result = fn__0xEEBFC7A7EFDC35B4(_vehicle);
				return result;
			}
		}

		public int GetVehicleCauseOfDestruction(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleCauseOfDestruction == null) fn__getVehicleCauseOfDestruction = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleCauseOfDestruction");
				var result = fn__getVehicleCauseOfDestruction(_vehicle);
				return result;
			}
		}

		public void _0x5EE5632F47AE9695(int _vehicle, float _health)
		{
			unsafe {
				if (fn__0x5EE5632F47AE9695 == null) fn__0x5EE5632F47AE9695 = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x5EE5632F47AE9695");
				fn__0x5EE5632F47AE9695(_vehicle, _health);
			}
		}

		public bool GetIsLeftVehicleHeadlightDamaged(int _vehicle)
		{
			unsafe {
				if (fn__getIsLeftVehicleHeadlightDamaged == null) fn__getIsLeftVehicleHeadlightDamaged = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getIsLeftVehicleHeadlightDamaged");
				var result = fn__getIsLeftVehicleHeadlightDamaged(_vehicle);
				return result;
			}
		}

		public bool GetIsRightVehicleHeadlightDamaged(int _vehicle)
		{
			unsafe {
				if (fn__getIsRightVehicleHeadlightDamaged == null) fn__getIsRightVehicleHeadlightDamaged = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getIsRightVehicleHeadlightDamaged");
				var result = fn__getIsRightVehicleHeadlightDamaged(_vehicle);
				return result;
			}
		}

		public bool IsVehicleEngineOnFire(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleEngineOnFire == null) fn__isVehicleEngineOnFire = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleEngineOnFire");
				var result = fn__isVehicleEngineOnFire(_vehicle);
				return result;
			}
		}

		public void ModifyVehicleTopSpeed(int _vehicle, float _value)
		{
			unsafe {
				if (fn__modifyVehicleTopSpeed == null) fn__modifyVehicleTopSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_modifyVehicleTopSpeed");
				fn__modifyVehicleTopSpeed(_vehicle, _value);
			}
		}

		public void SetVehicleMaxSpeed(int _vehicle, float _speed)
		{
			unsafe {
				if (fn__setVehicleMaxSpeed == null) fn__setVehicleMaxSpeed = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleMaxSpeed");
				fn__setVehicleMaxSpeed(_vehicle, _speed);
			}
		}

		public void _0x1CF38D529D7441D9(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0x1CF38D529D7441D9 == null) fn__0x1CF38D529D7441D9 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x1CF38D529D7441D9");
				fn__0x1CF38D529D7441D9(_vehicle, _toggle);
			}
		}

		public void _0x1F9FB66F3A3842D2(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x1F9FB66F3A3842D2 == null) fn__0x1F9FB66F3A3842D2 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x1F9FB66F3A3842D2");
				fn__0x1F9FB66F3A3842D2(_vehicle, _p1);
			}
		}

		public void _0x59C3757B3B7408E8(int _vehicle, bool _toggle, float _p2)
		{
			unsafe {
				if (fn__0x59C3757B3B7408E8 == null) fn__0x59C3757B3B7408E8 = (delegate* unmanaged[Cdecl]<int, bool, float, void>) NativeLibrary.GetExport(handle, "Native__0x59C3757B3B7408E8");
				fn__0x59C3757B3B7408E8(_vehicle, _toggle, _p2);
			}
		}

		public int AddVehicleCombatAngledAvoidanceArea(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6)
		{
			unsafe {
				if (fn__addVehicleCombatAngledAvoidanceArea == null) fn__addVehicleCombatAngledAvoidanceArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_addVehicleCombatAngledAvoidanceArea");
				var result = fn__addVehicleCombatAngledAvoidanceArea(_p0, _p1, _p2, _p3, _p4, _p5, _p6);
				return result;
			}
		}

		public void RemoveVehicleCombatAvoidanceArea(int _p0)
		{
			unsafe {
				if (fn__removeVehicleCombatAvoidanceArea == null) fn__removeVehicleCombatAvoidanceArea = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleCombatAvoidanceArea");
				fn__removeVehicleCombatAvoidanceArea(_p0);
			}
		}

		public bool IsAnyPedRappellingFromHeli(int _vehicle)
		{
			unsafe {
				if (fn__isAnyPedRappellingFromHeli == null) fn__isAnyPedRappellingFromHeli = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isAnyPedRappellingFromHeli");
				var result = fn__isAnyPedRappellingFromHeli(_vehicle);
				return result;
			}
		}

		public void SetVehicleCheatPowerIncrease(int _vehicle, float _value)
		{
			unsafe {
				if (fn__setVehicleCheatPowerIncrease == null) fn__setVehicleCheatPowerIncrease = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCheatPowerIncrease");
				fn__setVehicleCheatPowerIncrease(_vehicle, _value);
			}
		}

		public void _0x0AD9E8F87FF7C16F(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0x0AD9E8F87FF7C16F == null) fn__0x0AD9E8F87FF7C16F = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x0AD9E8F87FF7C16F");
				fn__0x0AD9E8F87FF7C16F(_p0, _p1);
			}
		}

		public void SetVehicleIsWanted(int _vehicle, bool _state)
		{
			unsafe {
				if (fn__setVehicleIsWanted == null) fn__setVehicleIsWanted = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleIsWanted");
				fn__setVehicleIsWanted(_vehicle, _state);
			}
		}

		public void SetBoatBoomPositionRatio(int _vehicle, float _ratio)
		{
			unsafe {
				if (fn__setBoatBoomPositionRatio == null) fn__setBoatBoomPositionRatio = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setBoatBoomPositionRatio");
				fn__setBoatBoomPositionRatio(_vehicle, _ratio);
			}
		}

		public void GetBoatBoomPositionRatio2(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__getBoatBoomPositionRatio2 == null) fn__getBoatBoomPositionRatio2 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_getBoatBoomPositionRatio2");
				fn__getBoatBoomPositionRatio2(_vehicle, _p1);
			}
		}

		public void GetBoatBoomPositionRatio3(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__getBoatBoomPositionRatio3 == null) fn__getBoatBoomPositionRatio3 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_getBoatBoomPositionRatio3");
				fn__getBoatBoomPositionRatio3(_vehicle, _p1);
			}
		}

		public float GetBoatBoomPositionRatio(int _vehicle)
		{
			unsafe {
				if (fn__getBoatBoomPositionRatio == null) fn__getBoatBoomPositionRatio = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getBoatBoomPositionRatio");
				var result = fn__getBoatBoomPositionRatio(_vehicle);
				return result;
			}
		}

		public void DisablePlaneAileron(int _vehicle, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__disablePlaneAileron == null) fn__disablePlaneAileron = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_disablePlaneAileron");
				fn__disablePlaneAileron(_vehicle, _p1, _p2);
			}
		}

		public bool GetIsVehicleEngineRunning(int _vehicle)
		{
			unsafe {
				if (fn__getIsVehicleEngineRunning == null) fn__getIsVehicleEngineRunning = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getIsVehicleEngineRunning");
				var result = fn__getIsVehicleEngineRunning(_vehicle);
				return result;
			}
		}

		public void SetVehicleUseAlternateHandling(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleUseAlternateHandling == null) fn__setVehicleUseAlternateHandling = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleUseAlternateHandling");
				fn__setVehicleUseAlternateHandling(_vehicle, _toggle);
			}
		}

		public void SetBikeOnStand(int _vehicle, float _x, float _y)
		{
			unsafe {
				if (fn__setBikeOnStand == null) fn__setBikeOnStand = (delegate* unmanaged[Cdecl]<int, float, float, void>) NativeLibrary.GetExport(handle, "Native_setBikeOnStand");
				fn__setBikeOnStand(_vehicle, _x, _y);
			}
		}

		public void _0xAB04325045427AAE(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0xAB04325045427AAE == null) fn__0xAB04325045427AAE = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xAB04325045427AAE");
				fn__0xAB04325045427AAE(_vehicle, _p1);
			}
		}

		public void _0xCFD778E7904C255E(int _vehicle)
		{
			unsafe {
				if (fn__0xCFD778E7904C255E == null) fn__0xCFD778E7904C255E = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xCFD778E7904C255E");
				fn__0xCFD778E7904C255E(_vehicle);
			}
		}

		public void SetLastDrivenVehicle(int _vehicle)
		{
			unsafe {
				if (fn__setLastDrivenVehicle == null) fn__setLastDrivenVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setLastDrivenVehicle");
				fn__setLastDrivenVehicle(_vehicle);
			}
		}

		public int GetLastDrivenVehicle()
		{
			unsafe {
				if (fn__getLastDrivenVehicle == null) fn__getLastDrivenVehicle = (delegate* unmanaged[Cdecl]<int>) NativeLibrary.GetExport(handle, "Native_getLastDrivenVehicle");
				var result = fn__getLastDrivenVehicle();
				return result;
			}
		}

		public void ClearLastDrivenVehicle()
		{
			unsafe {
				if (fn__clearLastDrivenVehicle == null) fn__clearLastDrivenVehicle = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_clearLastDrivenVehicle");
				fn__clearLastDrivenVehicle();
			}
		}

		public void SetVehicleHasBeenDrivenFlag(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleHasBeenDrivenFlag == null) fn__setVehicleHasBeenDrivenFlag = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHasBeenDrivenFlag");
				fn__setVehicleHasBeenDrivenFlag(_vehicle, _toggle);
			}
		}

		public void SetTaskVehicleGotoPlaneMinHeightAboveTerrain(int _plane, int _height)
		{
			unsafe {
				if (fn__setTaskVehicleGotoPlaneMinHeightAboveTerrain == null) fn__setTaskVehicleGotoPlaneMinHeightAboveTerrain = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setTaskVehicleGotoPlaneMinHeightAboveTerrain");
				fn__setTaskVehicleGotoPlaneMinHeightAboveTerrain(_plane, _height);
			}
		}

		public void SetVehicleLodMultiplier(int _vehicle, float _multiplier)
		{
			unsafe {
				if (fn__setVehicleLodMultiplier == null) fn__setVehicleLodMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleLodMultiplier");
				fn__setVehicleLodMultiplier(_vehicle, _multiplier);
			}
		}

		public void SetVehicleCanSaveInGarage(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleCanSaveInGarage == null) fn__setVehicleCanSaveInGarage = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanSaveInGarage");
				fn__setVehicleCanSaveInGarage(_vehicle, _toggle);
			}
		}

		public int GetVehicleNumberOfBrokenOffBones(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleNumberOfBrokenOffBones == null) fn__getVehicleNumberOfBrokenOffBones = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleNumberOfBrokenOffBones");
				var result = fn__getVehicleNumberOfBrokenOffBones(_vehicle);
				return result;
			}
		}

		public int GetVehicleNumberOfBrokenBones(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleNumberOfBrokenBones == null) fn__getVehicleNumberOfBrokenBones = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleNumberOfBrokenBones");
				var result = fn__getVehicleNumberOfBrokenBones(_vehicle);
				return result;
			}
		}

		public void _0x4D9D109F63FEE1D4(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0x4D9D109F63FEE1D4 == null) fn__0x4D9D109F63FEE1D4 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x4D9D109F63FEE1D4");
				fn__0x4D9D109F63FEE1D4(_p0, _p1);
			}
		}

		public void SetVehicleGeneratesEngineShockingEvents(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleGeneratesEngineShockingEvents == null) fn__setVehicleGeneratesEngineShockingEvents = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleGeneratesEngineShockingEvents");
				fn__setVehicleGeneratesEngineShockingEvents(_vehicle, _toggle);
			}
		}

		public void CopyVehicleDamages(int _sourceVehicle, int _targetVehicle)
		{
			unsafe {
				if (fn__copyVehicleDamages == null) fn__copyVehicleDamages = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_copyVehicleDamages");
				fn__copyVehicleDamages(_sourceVehicle, _targetVehicle);
			}
		}

		public void _0xF25E02CB9C5818F8()
		{
			unsafe {
				if (fn__0xF25E02CB9C5818F8 == null) fn__0xF25E02CB9C5818F8 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xF25E02CB9C5818F8");
				fn__0xF25E02CB9C5818F8();
			}
		}

		public void SetLightsCutoffDistanceTweak(float _distance)
		{
			unsafe {
				if (fn__setLightsCutoffDistanceTweak == null) fn__setLightsCutoffDistanceTweak = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setLightsCutoffDistanceTweak");
				fn__setLightsCutoffDistanceTweak(_distance);
			}
		}

		public void SetVehicleShootAtTarget(int _driver, int _entity, float _xTarget, float _yTarget, float _zTarget)
		{
			unsafe {
				if (fn__setVehicleShootAtTarget == null) fn__setVehicleShootAtTarget = (delegate* unmanaged[Cdecl]<int, int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleShootAtTarget");
				fn__setVehicleShootAtTarget(_driver, _entity, _xTarget, _yTarget, _zTarget);
			}
		}

		public bool GetVehicleLockOnTarget(int _vehicle, ref int _entity)
		{
			unsafe {
				if (fn__getVehicleLockOnTarget == null) fn__getVehicleLockOnTarget = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleLockOnTarget");
				var ref_entity = _entity;
				var result = fn__getVehicleLockOnTarget(_vehicle, &ref_entity);
				_entity = ref_entity;
				return result;
			}
		}

		public void SetForceHdVehicle(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setForceHdVehicle == null) fn__setForceHdVehicle = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setForceHdVehicle");
				fn__setForceHdVehicle(_vehicle, _toggle);
			}
		}

		public void _0x182F266C2D9E2BEB(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__0x182F266C2D9E2BEB == null) fn__0x182F266C2D9E2BEB = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x182F266C2D9E2BEB");
				fn__0x182F266C2D9E2BEB(_vehicle, _p1);
			}
		}

		public int GetVehiclePlateType(int _vehicle)
		{
			unsafe {
				if (fn__getVehiclePlateType == null) fn__getVehiclePlateType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehiclePlateType");
				var result = fn__getVehiclePlateType(_vehicle);
				return result;
			}
		}

		public void TrackVehicleVisibility(int _vehicle)
		{
			unsafe {
				if (fn__trackVehicleVisibility == null) fn__trackVehicleVisibility = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_trackVehicleVisibility");
				fn__trackVehicleVisibility(_vehicle);
			}
		}

		public bool IsVehicleVisible(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleVisible == null) fn__isVehicleVisible = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleVisible");
				var result = fn__isVehicleVisible(_vehicle);
				return result;
			}
		}

		public void SetVehicleGravity(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleGravity == null) fn__setVehicleGravity = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleGravity");
				fn__setVehicleGravity(_vehicle, _toggle);
			}
		}

		public void SetEnableVehicleSlipstreaming(bool _toggle)
		{
			unsafe {
				if (fn__setEnableVehicleSlipstreaming == null) fn__setEnableVehicleSlipstreaming = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setEnableVehicleSlipstreaming");
				fn__setEnableVehicleSlipstreaming(_toggle);
			}
		}

		public void _0xF051D9BFB6BA39C0(int _p0)
		{
			unsafe {
				if (fn__0xF051D9BFB6BA39C0 == null) fn__0xF051D9BFB6BA39C0 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xF051D9BFB6BA39C0");
				fn__0xF051D9BFB6BA39C0(_p0);
			}
		}

		public float GetVehicleCurrentSlipstreamDraft(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleCurrentSlipstreamDraft == null) fn__getVehicleCurrentSlipstreamDraft = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleCurrentSlipstreamDraft");
				var result = fn__getVehicleCurrentSlipstreamDraft(_vehicle);
				return result;
			}
		}

		public bool IsVehicleSlipstreamLeader(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleSlipstreamLeader == null) fn__isVehicleSlipstreamLeader = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleSlipstreamLeader");
				var result = fn__isVehicleSlipstreamLeader(_vehicle);
				return result;
			}
		}

		public void SetVehicleInactiveDuringPlayback(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleInactiveDuringPlayback == null) fn__setVehicleInactiveDuringPlayback = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleInactiveDuringPlayback");
				fn__setVehicleInactiveDuringPlayback(_vehicle, _toggle);
			}
		}

		public void SetVehicleActiveDuringPlayback(int _p0, bool _p1)
		{
			unsafe {
				if (fn__setVehicleActiveDuringPlayback == null) fn__setVehicleActiveDuringPlayback = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleActiveDuringPlayback");
				fn__setVehicleActiveDuringPlayback(_p0, _p1);
			}
		}

		public bool IsVehicleSprayable(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleSprayable == null) fn__isVehicleSprayable = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleSprayable");
				var result = fn__isVehicleSprayable(_vehicle);
				return result;
			}
		}

		public void SetVehicleEngineCanDegrade(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleEngineCanDegrade == null) fn__setVehicleEngineCanDegrade = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleEngineCanDegrade");
				fn__setVehicleEngineCanDegrade(_vehicle, _toggle);
			}
		}

		public void SetVehicleShadowEffect(int _vehicle, int _p1, int _p2)
		{
			unsafe {
				if (fn__setVehicleShadowEffect == null) fn__setVehicleShadowEffect = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleShadowEffect");
				fn__setVehicleShadowEffect(_vehicle, _p1, _p2);
			}
		}

		public void RemoveVehicleShadowEffect(int _vehicle)
		{
			unsafe {
				if (fn__removeVehicleShadowEffect == null) fn__removeVehicleShadowEffect = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeVehicleShadowEffect");
				fn__removeVehicleShadowEffect(_vehicle);
			}
		}

		public bool IsPlaneLandingGearIntact(int _plane)
		{
			unsafe {
				if (fn__isPlaneLandingGearIntact == null) fn__isPlaneLandingGearIntact = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPlaneLandingGearIntact");
				var result = fn__isPlaneLandingGearIntact(_plane);
				return result;
			}
		}

		public bool ArePlanePropellersIntact(int _plane)
		{
			unsafe {
				if (fn__arePlanePropellersIntact == null) fn__arePlanePropellersIntact = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_arePlanePropellersIntact");
				var result = fn__arePlanePropellersIntact(_plane);
				return result;
			}
		}

		public void SetPlanePropellersHealth(int _plane, float _health)
		{
			unsafe {
				if (fn__setPlanePropellersHealth == null) fn__setPlanePropellersHealth = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlanePropellersHealth");
				fn__setPlanePropellersHealth(_plane, _health);
			}
		}

		public void SetVehicleCanDeformWheels(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleCanDeformWheels == null) fn__setVehicleCanDeformWheels = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanDeformWheels");
				fn__setVehicleCanDeformWheels(_vehicle, _toggle);
			}
		}

		public bool IsVehicleStolen(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleStolen == null) fn__isVehicleStolen = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleStolen");
				var result = fn__isVehicleStolen(_vehicle);
				return result;
			}
		}

		public void SetVehicleIsStolen(int _vehicle, bool _isStolen)
		{
			unsafe {
				if (fn__setVehicleIsStolen == null) fn__setVehicleIsStolen = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleIsStolen");
				fn__setVehicleIsStolen(_vehicle, _isStolen);
			}
		}

		public void SetPlaneTurbulenceMultiplier(int _vehicle, float _multiplier)
		{
			unsafe {
				if (fn__setPlaneTurbulenceMultiplier == null) fn__setPlaneTurbulenceMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setPlaneTurbulenceMultiplier");
				fn__setPlaneTurbulenceMultiplier(_vehicle, _multiplier);
			}
		}

		public bool ArePlaneWingsIntact(int _plane)
		{
			unsafe {
				if (fn__arePlaneWingsIntact == null) fn__arePlaneWingsIntact = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_arePlaneWingsIntact");
				var result = fn__arePlaneWingsIntact(_plane);
				return result;
			}
		}

		public void _0xB264C4D2F2B0A78B(int _vehicle)
		{
			unsafe {
				if (fn__0xB264C4D2F2B0A78B == null) fn__0xB264C4D2F2B0A78B = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xB264C4D2F2B0A78B");
				fn__0xB264C4D2F2B0A78B(_vehicle);
			}
		}

		public void DetachVehicleFromCargobob(int _vehicle, int _cargobob)
		{
			unsafe {
				if (fn__detachVehicleFromCargobob == null) fn__detachVehicleFromCargobob = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_detachVehicleFromCargobob");
				fn__detachVehicleFromCargobob(_vehicle, _cargobob);
			}
		}

		public bool DetachVehicleFromAnyCargobob(int _vehicle)
		{
			unsafe {
				if (fn__detachVehicleFromAnyCargobob == null) fn__detachVehicleFromAnyCargobob = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_detachVehicleFromAnyCargobob");
				var result = fn__detachVehicleFromAnyCargobob(_vehicle);
				return result;
			}
		}

		public int DetachEntityFromCargobob(int _cargobob, int _entity)
		{
			unsafe {
				if (fn__detachEntityFromCargobob == null) fn__detachEntityFromCargobob = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_detachEntityFromCargobob");
				var result = fn__detachEntityFromCargobob(_cargobob, _entity);
				return result;
			}
		}

		public bool IsVehicleAttachedToCargobob(int _cargobob, int _vehicleAttached)
		{
			unsafe {
				if (fn__isVehicleAttachedToCargobob == null) fn__isVehicleAttachedToCargobob = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleAttachedToCargobob");
				var result = fn__isVehicleAttachedToCargobob(_cargobob, _vehicleAttached);
				return result;
			}
		}

		public int GetVehicleAttachedToCargobob(int _cargobob)
		{
			unsafe {
				if (fn__getVehicleAttachedToCargobob == null) fn__getVehicleAttachedToCargobob = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleAttachedToCargobob");
				var result = fn__getVehicleAttachedToCargobob(_cargobob);
				return result;
			}
		}

		public int GetEntityAttachedToCargobob(int _p0)
		{
			unsafe {
				if (fn__getEntityAttachedToCargobob == null) fn__getEntityAttachedToCargobob = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getEntityAttachedToCargobob");
				var result = fn__getEntityAttachedToCargobob(_p0);
				return result;
			}
		}

		public void AttachVehicleToCargobob(int _vehicle, int _cargobob, int _p2, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__attachVehicleToCargobob == null) fn__attachVehicleToCargobob = (delegate* unmanaged[Cdecl]<int, int, int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_attachVehicleToCargobob");
				fn__attachVehicleToCargobob(_vehicle, _cargobob, _p2, _x, _y, _z);
			}
		}

		public void AttachEntityToCargobob(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5)
		{
			unsafe {
				if (fn__attachEntityToCargobob == null) fn__attachEntityToCargobob = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_attachEntityToCargobob");
				fn__attachEntityToCargobob(_p0, _p1, _p2, _p3, _p4, _p5);
			}
		}

		public void SetCargobobHookCanDetach(int _cargobob, bool _toggle)
		{
			unsafe {
				if (fn__setCargobobHookCanDetach == null) fn__setCargobobHookCanDetach = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCargobobHookCanDetach");
				fn__setCargobobHookCanDetach(_cargobob, _toggle);
			}
		}

		public void _0x1F34B0626C594380(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x1F34B0626C594380 == null) fn__0x1F34B0626C594380 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1F34B0626C594380");
				fn__0x1F34B0626C594380(_p0, _p1);
			}
		}

		public int _0x2C1D8B3B19E517CC(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x2C1D8B3B19E517CC == null) fn__0x2C1D8B3B19E517CC = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x2C1D8B3B19E517CC");
				var result = fn__0x2C1D8B3B19E517CC(_p0, _p1);
				return result;
			}
		}

		public Vector3 GetCargobobHookPosition(int _cargobob)
		{
			unsafe {
				if (fn__getCargobobHookPosition == null) fn__getCargobobHookPosition = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_getCargobobHookPosition");
				var result = fn__getCargobobHookPosition(_cargobob);
				return result;
			}
		}

		public bool DoesCargobobHavePickUpRope(int _cargobob)
		{
			unsafe {
				if (fn__doesCargobobHavePickUpRope == null) fn__doesCargobobHavePickUpRope = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesCargobobHavePickUpRope");
				var result = fn__doesCargobobHavePickUpRope(_cargobob);
				return result;
			}
		}

		public void CreatePickUpRopeForCargobob(int _cargobob, int _state)
		{
			unsafe {
				if (fn__createPickUpRopeForCargobob == null) fn__createPickUpRopeForCargobob = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_createPickUpRopeForCargobob");
				fn__createPickUpRopeForCargobob(_cargobob, _state);
			}
		}

		public void RemovePickUpRopeForCargobob(int _cargobob)
		{
			unsafe {
				if (fn__removePickUpRopeForCargobob == null) fn__removePickUpRopeForCargobob = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removePickUpRopeForCargobob");
				fn__removePickUpRopeForCargobob(_cargobob);
			}
		}

		public void SetPickupRopeLengthForCargobob(int _cargobob, float _length1, float _length2, bool _p3)
		{
			unsafe {
				if (fn__setPickupRopeLengthForCargobob == null) fn__setPickupRopeLengthForCargobob = (delegate* unmanaged[Cdecl]<int, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setPickupRopeLengthForCargobob");
				fn__setPickupRopeLengthForCargobob(_cargobob, _length1, _length2, _p3);
			}
		}

		public void _0xC0ED6438E6D39BA8(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0xC0ED6438E6D39BA8 == null) fn__0xC0ED6438E6D39BA8 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0xC0ED6438E6D39BA8");
				fn__0xC0ED6438E6D39BA8(_p0, _p1, _p2);
			}
		}

		public void SetCargobobPickupRopeDampingMultiplier(int _p0, int _p1)
		{
			unsafe {
				if (fn__setCargobobPickupRopeDampingMultiplier == null) fn__setCargobobPickupRopeDampingMultiplier = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupRopeDampingMultiplier");
				fn__setCargobobPickupRopeDampingMultiplier(_p0, _p1);
			}
		}

		public void SetCargobobPickupRopeType(int _p0, int _p1)
		{
			unsafe {
				if (fn__setCargobobPickupRopeType == null) fn__setCargobobPickupRopeType = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupRopeType");
				fn__setCargobobPickupRopeType(_p0, _p1);
			}
		}

		public bool DoesCargobobHavePickupMagnet(int _cargobob)
		{
			unsafe {
				if (fn__doesCargobobHavePickupMagnet == null) fn__doesCargobobHavePickupMagnet = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesCargobobHavePickupMagnet");
				var result = fn__doesCargobobHavePickupMagnet(_cargobob);
				return result;
			}
		}

		public void SetCargobobPickupMagnetActive(int _cargobob, bool _isActive)
		{
			unsafe {
				if (fn__setCargobobPickupMagnetActive == null) fn__setCargobobPickupMagnetActive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupMagnetActive");
				fn__setCargobobPickupMagnetActive(_cargobob, _isActive);
			}
		}

		public void SetCargobobPickupMagnetStrength(int _cargobob, float _strength)
		{
			unsafe {
				if (fn__setCargobobPickupMagnetStrength == null) fn__setCargobobPickupMagnetStrength = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupMagnetStrength");
				fn__setCargobobPickupMagnetStrength(_cargobob, _strength);
			}
		}

		public void SetCargobobPickupMagnetEffectRadius(int _cargobob, float _p1)
		{
			unsafe {
				if (fn__setCargobobPickupMagnetEffectRadius == null) fn__setCargobobPickupMagnetEffectRadius = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupMagnetEffectRadius");
				fn__setCargobobPickupMagnetEffectRadius(_cargobob, _p1);
			}
		}

		public void SetCargobobPickupMagnetReducedFalloff(int _cargobob, float _p1)
		{
			unsafe {
				if (fn__setCargobobPickupMagnetReducedFalloff == null) fn__setCargobobPickupMagnetReducedFalloff = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupMagnetReducedFalloff");
				fn__setCargobobPickupMagnetReducedFalloff(_cargobob, _p1);
			}
		}

		public void SetCargobobPickupMagnetPullRopeLength(int _cargobob, float _p1)
		{
			unsafe {
				if (fn__setCargobobPickupMagnetPullRopeLength == null) fn__setCargobobPickupMagnetPullRopeLength = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupMagnetPullRopeLength");
				fn__setCargobobPickupMagnetPullRopeLength(_cargobob, _p1);
			}
		}

		public void SetCargobobPickupMagnetPullStrength(int _cargobob, float _p1)
		{
			unsafe {
				if (fn__setCargobobPickupMagnetPullStrength == null) fn__setCargobobPickupMagnetPullStrength = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupMagnetPullStrength");
				fn__setCargobobPickupMagnetPullStrength(_cargobob, _p1);
			}
		}

		public void SetCargobobPickupMagnetFalloff(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__setCargobobPickupMagnetFalloff == null) fn__setCargobobPickupMagnetFalloff = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupMagnetFalloff");
				fn__setCargobobPickupMagnetFalloff(_vehicle, _p1);
			}
		}

		public void SetCargobobPickupMagnetReducedStrength(int _vehicle, int _cargobob)
		{
			unsafe {
				if (fn__setCargobobPickupMagnetReducedStrength == null) fn__setCargobobPickupMagnetReducedStrength = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setCargobobPickupMagnetReducedStrength");
				fn__setCargobobPickupMagnetReducedStrength(_vehicle, _cargobob);
			}
		}

		public void _0x9BDDC73CC6A115D4(int _vehicle, bool _p1, bool _p2)
		{
			unsafe {
				if (fn__0x9BDDC73CC6A115D4 == null) fn__0x9BDDC73CC6A115D4 = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native__0x9BDDC73CC6A115D4");
				fn__0x9BDDC73CC6A115D4(_vehicle, _p1, _p2);
			}
		}

		public void _0x56EB5E94318D3FB6(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x56EB5E94318D3FB6 == null) fn__0x56EB5E94318D3FB6 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x56EB5E94318D3FB6");
				fn__0x56EB5E94318D3FB6(_vehicle, _p1);
			}
		}

		public bool DoesVehicleHaveWeapons(int _vehicle)
		{
			unsafe {
				if (fn__doesVehicleHaveWeapons == null) fn__doesVehicleHaveWeapons = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesVehicleHaveWeapons");
				var result = fn__doesVehicleHaveWeapons(_vehicle);
				return result;
			}
		}

		public void _0x2C4A1590ABF43E8B(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0x2C4A1590ABF43E8B == null) fn__0x2C4A1590ABF43E8B = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x2C4A1590ABF43E8B");
				fn__0x2C4A1590ABF43E8B(_vehicle, _p1);
			}
		}

		public void DisableVehicleWeapon(bool _disabled, int _weaponHash, int _vehicle, int _owner)
		{
			unsafe {
				if (fn__disableVehicleWeapon == null) fn__disableVehicleWeapon = (delegate* unmanaged[Cdecl]<bool, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_disableVehicleWeapon");
				fn__disableVehicleWeapon(_disabled, _weaponHash, _vehicle, _owner);
			}
		}

		public bool IsVehicleWeaponDisabled(int _weaponHash, int _vehicle, int _owner)
		{
			unsafe {
				if (fn__isVehicleWeaponDisabled == null) fn__isVehicleWeaponDisabled = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleWeaponDisabled");
				var result = fn__isVehicleWeaponDisabled(_weaponHash, _vehicle, _owner);
				return result;
			}
		}

		public void _0xE05DD0E9707003A3(int _p0, bool _p1)
		{
			unsafe {
				if (fn__0xE05DD0E9707003A3 == null) fn__0xE05DD0E9707003A3 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xE05DD0E9707003A3");
				fn__0xE05DD0E9707003A3(_p0, _p1);
			}
		}

		public void SetVehicleActiveForPedNavigation(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleActiveForPedNavigation == null) fn__setVehicleActiveForPedNavigation = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleActiveForPedNavigation");
				fn__setVehicleActiveForPedNavigation(_vehicle, _toggle);
			}
		}

		public int GetVehicleClass(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleClass == null) fn__getVehicleClass = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleClass");
				var result = fn__getVehicleClass(_vehicle);
				return result;
			}
		}

		public int GetVehicleClassFromName(int _modelHash)
		{
			unsafe {
				if (fn__getVehicleClassFromName == null) fn__getVehicleClassFromName = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleClassFromName");
				var result = fn__getVehicleClassFromName(_modelHash);
				return result;
			}
		}

		public void SetPlayersLastVehicle(int _vehicle)
		{
			unsafe {
				if (fn__setPlayersLastVehicle == null) fn__setPlayersLastVehicle = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPlayersLastVehicle");
				fn__setPlayersLastVehicle(_vehicle);
			}
		}

		public void SetVehicleCanBeUsedByFleeingPeds(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleCanBeUsedByFleeingPeds == null) fn__setVehicleCanBeUsedByFleeingPeds = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCanBeUsedByFleeingPeds");
				fn__setVehicleCanBeUsedByFleeingPeds(_vehicle, _toggle);
			}
		}

		public void _0xE5810AC70602F2F5(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__0xE5810AC70602F2F5 == null) fn__0xE5810AC70602F2F5 = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0xE5810AC70602F2F5");
				fn__0xE5810AC70602F2F5(_vehicle, _p1);
			}
		}

		public void SetVehicleDropsMoneyWhenBlownUp(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleDropsMoneyWhenBlownUp == null) fn__setVehicleDropsMoneyWhenBlownUp = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleDropsMoneyWhenBlownUp");
				fn__setVehicleDropsMoneyWhenBlownUp(_vehicle, _toggle);
			}
		}

		public void SetVehicleJetEngineOn(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleJetEngineOn == null) fn__setVehicleJetEngineOn = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleJetEngineOn");
				fn__setVehicleJetEngineOn(_vehicle, _toggle);
			}
		}

		public void _0x6A973569BA094650(int _vehicle, int _p1)
		{
			unsafe {
				if (fn__0x6A973569BA094650 == null) fn__0x6A973569BA094650 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x6A973569BA094650");
				fn__0x6A973569BA094650(_vehicle, _p1);
			}
		}

		public void SetVehicleHandlingHashForAi(int _vehicle, int _hash)
		{
			unsafe {
				if (fn__setVehicleHandlingHashForAi == null) fn__setVehicleHandlingHashForAi = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHandlingHashForAi");
				fn__setVehicleHandlingHashForAi(_vehicle, _hash);
			}
		}

		public void SetVehicleExtendedRemovalRange(int _vehicle, int _range)
		{
			unsafe {
				if (fn__setVehicleExtendedRemovalRange == null) fn__setVehicleExtendedRemovalRange = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleExtendedRemovalRange");
				fn__setVehicleExtendedRemovalRange(_vehicle, _range);
			}
		}

		public void SetVehicleSteeringBiasScalar(int _p0, float _p1)
		{
			unsafe {
				if (fn__setVehicleSteeringBiasScalar == null) fn__setVehicleSteeringBiasScalar = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleSteeringBiasScalar");
				fn__setVehicleSteeringBiasScalar(_p0, _p1);
			}
		}

		public void SetHelicopterRollPitchYawMult(int _helicopter, float _multiplier)
		{
			unsafe {
				if (fn__setHelicopterRollPitchYawMult == null) fn__setHelicopterRollPitchYawMult = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setHelicopterRollPitchYawMult");
				fn__setHelicopterRollPitchYawMult(_helicopter, _multiplier);
			}
		}

		public void SetVehicleFrictionOverride(int _vehicle, float _friction)
		{
			unsafe {
				if (fn__setVehicleFrictionOverride == null) fn__setVehicleFrictionOverride = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleFrictionOverride");
				fn__setVehicleFrictionOverride(_vehicle, _friction);
			}
		}

		public void SetVehicleWheelsCanBreakOffWhenBlowUp(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleWheelsCanBreakOffWhenBlowUp == null) fn__setVehicleWheelsCanBreakOffWhenBlowUp = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleWheelsCanBreakOffWhenBlowUp");
				fn__setVehicleWheelsCanBreakOffWhenBlowUp(_vehicle, _toggle);
			}
		}

		public bool _0xF78F94D60248C737(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0xF78F94D60248C737 == null) fn__0xF78F94D60248C737 = (delegate* unmanaged[Cdecl]<int, bool, bool>) NativeLibrary.GetExport(handle, "Native__0xF78F94D60248C737");
				var result = fn__0xF78F94D60248C737(_vehicle, _p1);
				return result;
			}
		}

		public void SetVehicleCeilingHeight(int _vehicle, float _height)
		{
			unsafe {
				if (fn__setVehicleCeilingHeight == null) fn__setVehicleCeilingHeight = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCeilingHeight");
				fn__setVehicleCeilingHeight(_vehicle, _height);
			}
		}

		public void _0x5E569EC46EC21CAE(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0x5E569EC46EC21CAE == null) fn__0x5E569EC46EC21CAE = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x5E569EC46EC21CAE");
				fn__0x5E569EC46EC21CAE(_vehicle, _toggle);
			}
		}

		public void ClearVehicleRouteHistory(int _vehicle)
		{
			unsafe {
				if (fn__clearVehicleRouteHistory == null) fn__clearVehicleRouteHistory = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearVehicleRouteHistory");
				fn__clearVehicleRouteHistory(_vehicle);
			}
		}

		public bool DoesVehicleExistWithDecorator(string _decorator)
		{
			unsafe {
				if (fn__doesVehicleExistWithDecorator == null) fn__doesVehicleExistWithDecorator = (delegate* unmanaged[Cdecl]<nint, bool>) NativeLibrary.GetExport(handle, "Native_doesVehicleExistWithDecorator");
				var ptr_decorator = MemoryUtils.StringToHGlobalUtf8(_decorator);
				var result = fn__doesVehicleExistWithDecorator(ptr_decorator);
				Marshal.FreeHGlobal(ptr_decorator);
				return result;
			}
		}

		public void _0x41062318F23ED854(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0x41062318F23ED854 == null) fn__0x41062318F23ED854 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x41062318F23ED854");
				fn__0x41062318F23ED854(_vehicle, _toggle);
			}
		}

		public void SetVehicleExclusiveDriver(int _vehicle, int _ped, int _index)
		{
			unsafe {
				if (fn__setVehicleExclusiveDriver == null) fn__setVehicleExclusiveDriver = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleExclusiveDriver");
				fn__setVehicleExclusiveDriver(_vehicle, _ped, _index);
			}
		}

		public bool IsPedExclusiveDriverOfVehicle(int _ped, int _vehicle, ref int _outIndex)
		{
			unsafe {
				if (fn__isPedExclusiveDriverOfVehicle == null) fn__isPedExclusiveDriverOfVehicle = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_isPedExclusiveDriverOfVehicle");
				var ref_outIndex = _outIndex;
				var result = fn__isPedExclusiveDriverOfVehicle(_ped, _vehicle, &ref_outIndex);
				_outIndex = ref_outIndex;
				return result;
			}
		}

		public void DisableIndividualPlanePropeller(int _vehicle, int _propeller)
		{
			unsafe {
				if (fn__disableIndividualPlanePropeller == null) fn__disableIndividualPlanePropeller = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_disableIndividualPlanePropeller");
				fn__disableIndividualPlanePropeller(_vehicle, _propeller);
			}
		}

		public void SetVehicleForceAfterburner(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleForceAfterburner == null) fn__setVehicleForceAfterburner = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleForceAfterburner");
				fn__setVehicleForceAfterburner(_vehicle, _toggle);
			}
		}

		public void SetDisableVehicleWindowCollisions(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setDisableVehicleWindowCollisions == null) fn__setDisableVehicleWindowCollisions = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableVehicleWindowCollisions");
				fn__setDisableVehicleWindowCollisions(_vehicle, _toggle);
			}
		}

		public void _0x4AD280EB48B2D8E6(int _vehicle, bool _togle)
		{
			unsafe {
				if (fn__0x4AD280EB48B2D8E6 == null) fn__0x4AD280EB48B2D8E6 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x4AD280EB48B2D8E6");
				fn__0x4AD280EB48B2D8E6(_vehicle, _togle);
			}
		}

		public void _0xB68CFAF83A02768D(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0xB68CFAF83A02768D == null) fn__0xB68CFAF83A02768D = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xB68CFAF83A02768D");
				fn__0xB68CFAF83A02768D(_vehicle, _toggle);
			}
		}

		public void _0x0205F5365292D2EB(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__0x0205F5365292D2EB == null) fn__0x0205F5365292D2EB = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x0205F5365292D2EB");
				fn__0x0205F5365292D2EB(_vehicle, _p1);
			}
		}

		public void _0xCF9159024555488C(int _p0)
		{
			unsafe {
				if (fn__0xCF9159024555488C == null) fn__0xCF9159024555488C = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xCF9159024555488C");
				fn__0xCF9159024555488C(_p0);
			}
		}

		public void SetDistantCarsEnabled(bool _toggle)
		{
			unsafe {
				if (fn__setDistantCarsEnabled == null) fn__setDistantCarsEnabled = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setDistantCarsEnabled");
				fn__setDistantCarsEnabled(_toggle);
			}
		}

		public void SetVehicleNeonLightsColour(int _vehicle, int _r, int _g, int _b)
		{
			unsafe {
				if (fn__setVehicleNeonLightsColour == null) fn__setVehicleNeonLightsColour = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleNeonLightsColour");
				fn__setVehicleNeonLightsColour(_vehicle, _r, _g, _b);
			}
		}

		public void _0xB93B2867F7B479D1(int _vehicle, int _index)
		{
			unsafe {
				if (fn__0xB93B2867F7B479D1 == null) fn__0xB93B2867F7B479D1 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xB93B2867F7B479D1");
				fn__0xB93B2867F7B479D1(_vehicle, _index);
			}
		}

		public void GetVehicleNeonLightsColour(int _vehicle, ref int _r, ref int _g, ref int _b)
		{
			unsafe {
				if (fn__getVehicleNeonLightsColour == null) fn__getVehicleNeonLightsColour = (delegate* unmanaged[Cdecl]<int, int*, int*, int*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleNeonLightsColour");
				var ref_r = _r;
				var ref_g = _g;
				var ref_b = _b;
				fn__getVehicleNeonLightsColour(_vehicle, &ref_r, &ref_g, &ref_b);
				_r = ref_r;
				_g = ref_g;
				_b = ref_b;
			}
		}

		public void SetVehicleNeonLightEnabled(int _vehicle, int _index, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleNeonLightEnabled == null) fn__setVehicleNeonLightEnabled = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleNeonLightEnabled");
				fn__setVehicleNeonLightEnabled(_vehicle, _index, _toggle);
			}
		}

		public bool IsVehicleNeonLightEnabled(int _vehicle, int _index)
		{
			unsafe {
				if (fn__isVehicleNeonLightEnabled == null) fn__isVehicleNeonLightEnabled = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleNeonLightEnabled");
				var result = fn__isVehicleNeonLightEnabled(_vehicle, _index);
				return result;
			}
		}

		public void _0x35E0654F4BAD7971(bool _p0)
		{
			unsafe {
				if (fn__0x35E0654F4BAD7971 == null) fn__0x35E0654F4BAD7971 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x35E0654F4BAD7971");
				fn__0x35E0654F4BAD7971(_p0);
			}
		}

		public void DisableVehicleNeonLights(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__disableVehicleNeonLights == null) fn__disableVehicleNeonLights = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_disableVehicleNeonLights");
				fn__disableVehicleNeonLights(_vehicle, _toggle);
			}
		}

		public void SetDisableSuperdummyMode(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__setDisableSuperdummyMode == null) fn__setDisableSuperdummyMode = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableSuperdummyMode");
				fn__setDisableSuperdummyMode(_vehicle, _p1);
			}
		}

		public void RequestVehicleDashboardScaleformMovie(int _vehicle)
		{
			unsafe {
				if (fn__requestVehicleDashboardScaleformMovie == null) fn__requestVehicleDashboardScaleformMovie = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestVehicleDashboardScaleformMovie");
				fn__requestVehicleDashboardScaleformMovie(_vehicle);
			}
		}

		public float GetVehicleBodyHealth(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleBodyHealth == null) fn__getVehicleBodyHealth = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleBodyHealth");
				var result = fn__getVehicleBodyHealth(_vehicle);
				return result;
			}
		}

		public void SetVehicleBodyHealth(int _vehicle, float _value)
		{
			unsafe {
				if (fn__setVehicleBodyHealth == null) fn__setVehicleBodyHealth = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleBodyHealth");
				fn__setVehicleBodyHealth(_vehicle, _value);
			}
		}

		public void GetVehicleSuspensionBounds(int _vehicle, ref Vector3 _out1, ref Vector3 _out2)
		{
			unsafe {
				if (fn__getVehicleSuspensionBounds == null) fn__getVehicleSuspensionBounds = (delegate* unmanaged[Cdecl]<int, Vector3*, Vector3*, void>) NativeLibrary.GetExport(handle, "Native_getVehicleSuspensionBounds");
				var ref_out1 = _out1;
				var ref_out2 = _out2;
				fn__getVehicleSuspensionBounds(_vehicle, &ref_out1, &ref_out2);
				_out1 = ref_out1;
				_out2 = ref_out2;
			}
		}

		public float GetVehicleSuspensionHeight(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleSuspensionHeight == null) fn__getVehicleSuspensionHeight = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getVehicleSuspensionHeight");
				var result = fn__getVehicleSuspensionHeight(_vehicle);
				return result;
			}
		}

		public void SetCarHighSpeedBumpSeverityMultiplier(float _multiplier)
		{
			unsafe {
				if (fn__setCarHighSpeedBumpSeverityMultiplier == null) fn__setCarHighSpeedBumpSeverityMultiplier = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setCarHighSpeedBumpSeverityMultiplier");
				fn__setCarHighSpeedBumpSeverityMultiplier(_multiplier);
			}
		}

		public int GetNumberOfVehicleDoors(int _vehicle)
		{
			unsafe {
				if (fn__getNumberOfVehicleDoors == null) fn__getNumberOfVehicleDoors = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getNumberOfVehicleDoors");
				var result = fn__getNumberOfVehicleDoors(_vehicle);
				return result;
			}
		}

		public void SetHydraulicRaised(int _p0, int _p1)
		{
			unsafe {
				if (fn__setHydraulicRaised == null) fn__setHydraulicRaised = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setHydraulicRaised");
				fn__setHydraulicRaised(_p0, _p1);
			}
		}

		public void _0xA7DCDF4DED40A8F4(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0xA7DCDF4DED40A8F4 == null) fn__0xA7DCDF4DED40A8F4 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xA7DCDF4DED40A8F4");
				fn__0xA7DCDF4DED40A8F4(_vehicle, _p1);
			}
		}

		public float GetVehicleBodyHealth2(int _vehicle, float _maxEngineHealth, float _maxPetrolTankHealth, float _maxBodyHealth, float _maxMainRotorHealth, float _maxTailRotorHealth, float _maxUnkHealth)
		{
			unsafe {
				if (fn__getVehicleBodyHealth2 == null) fn__getVehicleBodyHealth2 = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, float>) NativeLibrary.GetExport(handle, "Native_getVehicleBodyHealth2");
				var result = fn__getVehicleBodyHealth2(_vehicle, _maxEngineHealth, _maxPetrolTankHealth, _maxBodyHealth, _maxMainRotorHealth, _maxTailRotorHealth, _maxUnkHealth);
				return result;
			}
		}

		public bool _0xD4C4642CB7F50B5D(int _vehicle)
		{
			unsafe {
				if (fn__0xD4C4642CB7F50B5D == null) fn__0xD4C4642CB7F50B5D = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xD4C4642CB7F50B5D");
				var result = fn__0xD4C4642CB7F50B5D(_vehicle);
				return result;
			}
		}

		public void _0xC361AA040D6637A8(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0xC361AA040D6637A8 == null) fn__0xC361AA040D6637A8 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xC361AA040D6637A8");
				fn__0xC361AA040D6637A8(_vehicle, _p1);
			}
		}

		public void SetVehicleKersAllowed(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleKersAllowed == null) fn__setVehicleKersAllowed = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleKersAllowed");
				fn__setVehicleKersAllowed(_vehicle, _toggle);
			}
		}

		public bool GetVehicleHasKers(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleHasKers == null) fn__getVehicleHasKers = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleHasKers");
				var result = fn__getVehicleHasKers(_vehicle);
				return result;
			}
		}

		public void _0xE16142B94664DEFD(int _vehicle, bool _p1)
		{
			unsafe {
				if (fn__0xE16142B94664DEFD == null) fn__0xE16142B94664DEFD = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xE16142B94664DEFD");
				fn__0xE16142B94664DEFD(_vehicle, _p1);
			}
		}

		public void _0x26D99D5A82FD18E8(int _p0)
		{
			unsafe {
				if (fn__0x26D99D5A82FD18E8 == null) fn__0x26D99D5A82FD18E8 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x26D99D5A82FD18E8");
				fn__0x26D99D5A82FD18E8(_p0);
			}
		}

		public void SetHydraulicWheelValue(int _vehicle, int _wheelId, float _value)
		{
			unsafe {
				if (fn__setHydraulicWheelValue == null) fn__setHydraulicWheelValue = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setHydraulicWheelValue");
				fn__setHydraulicWheelValue(_vehicle, _wheelId, _value);
			}
		}

		public float GetHydraulicWheelValue(int _vehicle, int _wheelId)
		{
			unsafe {
				if (fn__getHydraulicWheelValue == null) fn__getHydraulicWheelValue = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getHydraulicWheelValue");
				var result = fn__getHydraulicWheelValue(_vehicle, _wheelId);
				return result;
			}
		}

		public void SetCamberedWheelsDisabled(int _p0, int _p1)
		{
			unsafe {
				if (fn__setCamberedWheelsDisabled == null) fn__setCamberedWheelsDisabled = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setCamberedWheelsDisabled");
				fn__setCamberedWheelsDisabled(_p0, _p1);
			}
		}

		public void SetHydraulicWheelState(int _p0, int _p1)
		{
			unsafe {
				if (fn__setHydraulicWheelState == null) fn__setHydraulicWheelState = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setHydraulicWheelState");
				fn__setHydraulicWheelState(_p0, _p1);
			}
		}

		public void SetHydraulicWheelStateTransition(int _vehicle, int _wheelId, int _state, float _value, int _p4)
		{
			unsafe {
				if (fn__setHydraulicWheelStateTransition == null) fn__setHydraulicWheelStateTransition = (delegate* unmanaged[Cdecl]<int, int, int, float, int, void>) NativeLibrary.GetExport(handle, "Native_setHydraulicWheelStateTransition");
				fn__setHydraulicWheelStateTransition(_vehicle, _wheelId, _state, _value, _p4);
			}
		}

		public int _0x5BA68A0840D546AC(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x5BA68A0840D546AC == null) fn__0x5BA68A0840D546AC = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x5BA68A0840D546AC");
				var result = fn__0x5BA68A0840D546AC(_p0, _p1);
				return result;
			}
		}

		public void _0x4419966C9936071A(int _vehicle)
		{
			unsafe {
				if (fn__0x4419966C9936071A == null) fn__0x4419966C9936071A = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x4419966C9936071A");
				fn__0x4419966C9936071A(_vehicle);
			}
		}

		public void _0x870B8B7A766615C8(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x870B8B7A766615C8 == null) fn__0x870B8B7A766615C8 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x870B8B7A766615C8");
				fn__0x870B8B7A766615C8(_p0, _p1, _p2);
			}
		}

		public int _0x8533CAFDE1F0F336(int _p0)
		{
			unsafe {
				if (fn__0x8533CAFDE1F0F336 == null) fn__0x8533CAFDE1F0F336 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x8533CAFDE1F0F336");
				var result = fn__0x8533CAFDE1F0F336(_p0);
				return result;
			}
		}

		public int SetVehicleDamageModifier(int _vehicle, float _p1)
		{
			unsafe {
				if (fn__setVehicleDamageModifier == null) fn__setVehicleDamageModifier = (delegate* unmanaged[Cdecl]<int, float, int>) NativeLibrary.GetExport(handle, "Native_setVehicleDamageModifier");
				var result = fn__setVehicleDamageModifier(_vehicle, _p1);
				return result;
			}
		}

		public void SetVehicleUnkDamageMultiplier(int _vehicle, float _multiplier)
		{
			unsafe {
				if (fn__setVehicleUnkDamageMultiplier == null) fn__setVehicleUnkDamageMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleUnkDamageMultiplier");
				fn__setVehicleUnkDamageMultiplier(_vehicle, _multiplier);
			}
		}

		public int _0xD4196117AF7BB974(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xD4196117AF7BB974 == null) fn__0xD4196117AF7BB974 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0xD4196117AF7BB974");
				var result = fn__0xD4196117AF7BB974(_p0, _p1);
				return result;
			}
		}

		public void _0xBB2333BB87DDD87F(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xBB2333BB87DDD87F == null) fn__0xBB2333BB87DDD87F = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xBB2333BB87DDD87F");
				fn__0xBB2333BB87DDD87F(_p0, _p1);
			}
		}

		public void _0x73561D4425A021A2(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x73561D4425A021A2 == null) fn__0x73561D4425A021A2 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x73561D4425A021A2");
				fn__0x73561D4425A021A2(_p0, _p1);
			}
		}

		public void SetVehicleControlsInverted(int _vehicle, bool _state)
		{
			unsafe {
				if (fn__setVehicleControlsInverted == null) fn__setVehicleControlsInverted = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleControlsInverted");
				fn__setVehicleControlsInverted(_vehicle, _state);
			}
		}

		public void _0x7BBE7FF626A591FE(int _p0)
		{
			unsafe {
				if (fn__0x7BBE7FF626A591FE == null) fn__0x7BBE7FF626A591FE = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x7BBE7FF626A591FE");
				fn__0x7BBE7FF626A591FE(_p0);
			}
		}

		public void _0x65B080555EA48149(int _p0)
		{
			unsafe {
				if (fn__0x65B080555EA48149 == null) fn__0x65B080555EA48149 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x65B080555EA48149");
				fn__0x65B080555EA48149(_p0);
			}
		}

		public void _0x428AD3E26C8D9EB0(int _vehicle, float _x, float _y, float _z, float _p4)
		{
			unsafe {
				if (fn__0x428AD3E26C8D9EB0 == null) fn__0x428AD3E26C8D9EB0 = (delegate* unmanaged[Cdecl]<int, float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0x428AD3E26C8D9EB0");
				fn__0x428AD3E26C8D9EB0(_vehicle, _x, _y, _z, _p4);
			}
		}

		public void _0xE2F53F172B45EDE1()
		{
			unsafe {
				if (fn__0xE2F53F172B45EDE1 == null) fn__0xE2F53F172B45EDE1 = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native__0xE2F53F172B45EDE1");
				fn__0xE2F53F172B45EDE1();
			}
		}

		public bool _0xBA91D045575699AD(int _vehicle)
		{
			unsafe {
				if (fn__0xBA91D045575699AD == null) fn__0xBA91D045575699AD = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xBA91D045575699AD");
				var result = fn__0xBA91D045575699AD(_vehicle);
				return result;
			}
		}

		public void _0x80E3357FDEF45C21(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x80E3357FDEF45C21 == null) fn__0x80E3357FDEF45C21 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x80E3357FDEF45C21");
				fn__0x80E3357FDEF45C21(_p0, _p1);
			}
		}

		public void SetVehicleRampLaunchModifier(int _p0, int _p1)
		{
			unsafe {
				if (fn__setVehicleRampLaunchModifier == null) fn__setVehicleRampLaunchModifier = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRampLaunchModifier");
				fn__setVehicleRampLaunchModifier(_p0, _p1);
			}
		}

		public bool GetIsDoorValid(int _vehicle, int _doorId)
		{
			unsafe {
				if (fn__getIsDoorValid == null) fn__getIsDoorValid = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_getIsDoorValid");
				var result = fn__getIsDoorValid(_vehicle, _doorId);
				return result;
			}
		}

		public void SetVehicleRocketBoostRefillTime(int _vehicle, float _seconds)
		{
			unsafe {
				if (fn__setVehicleRocketBoostRefillTime == null) fn__setVehicleRocketBoostRefillTime = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRocketBoostRefillTime");
				fn__setVehicleRocketBoostRefillTime(_vehicle, _seconds);
			}
		}

		public bool GetHasRocketBoost(int _vehicle)
		{
			unsafe {
				if (fn__getHasRocketBoost == null) fn__getHasRocketBoost = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getHasRocketBoost");
				var result = fn__getHasRocketBoost(_vehicle);
				return result;
			}
		}

		public bool IsVehicleRocketBoostActive(int _vehicle)
		{
			unsafe {
				if (fn__isVehicleRocketBoostActive == null) fn__isVehicleRocketBoostActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isVehicleRocketBoostActive");
				var result = fn__isVehicleRocketBoostActive(_vehicle);
				return result;
			}
		}

		public void SetVehicleRocketBoostActive(int _vehicle, bool _active)
		{
			unsafe {
				if (fn__setVehicleRocketBoostActive == null) fn__setVehicleRocketBoostActive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRocketBoostActive");
				fn__setVehicleRocketBoostActive(_vehicle, _active);
			}
		}

		public bool GetHasRetractableWheels(int _vehicle)
		{
			unsafe {
				if (fn__getHasRetractableWheels == null) fn__getHasRetractableWheels = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getHasRetractableWheels");
				var result = fn__getHasRetractableWheels(_vehicle);
				return result;
			}
		}

		public bool GetIsWheelsLoweredStateActive(int _vehicle)
		{
			unsafe {
				if (fn__getIsWheelsLoweredStateActive == null) fn__getIsWheelsLoweredStateActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getIsWheelsLoweredStateActive");
				var result = fn__getIsWheelsLoweredStateActive(_vehicle);
				return result;
			}
		}

		public void RaiseRetractableWheels(int _vehicle)
		{
			unsafe {
				if (fn__raiseRetractableWheels == null) fn__raiseRetractableWheels = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_raiseRetractableWheels");
				fn__raiseRetractableWheels(_vehicle);
			}
		}

		public void LowerRetractableWheels(int _vehicle)
		{
			unsafe {
				if (fn__lowerRetractableWheels == null) fn__lowerRetractableWheels = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_lowerRetractableWheels");
				fn__lowerRetractableWheels(_vehicle);
			}
		}

		public bool GetCanVehicleJump(int _vehicle)
		{
			unsafe {
				if (fn__getCanVehicleJump == null) fn__getCanVehicleJump = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getCanVehicleJump");
				var result = fn__getCanVehicleJump(_vehicle);
				return result;
			}
		}

		public void SetUseHigherVehicleJumpForce(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setUseHigherVehicleJumpForce == null) fn__setUseHigherVehicleJumpForce = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setUseHigherVehicleJumpForce");
				fn__setUseHigherVehicleJumpForce(_vehicle, _toggle);
			}
		}

		public void _0xB2E0C0D6922D31F2(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0xB2E0C0D6922D31F2 == null) fn__0xB2E0C0D6922D31F2 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xB2E0C0D6922D31F2");
				fn__0xB2E0C0D6922D31F2(_vehicle, _toggle);
			}
		}

		public void SetVehicleWeaponCapacity(int _vehicle, int _weaponIndex, int _capacity)
		{
			unsafe {
				if (fn__setVehicleWeaponCapacity == null) fn__setVehicleWeaponCapacity = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleWeaponCapacity");
				fn__setVehicleWeaponCapacity(_vehicle, _weaponIndex, _capacity);
			}
		}

		public int GetVehicleWeaponCapacity(int _vehicle, int _weaponIndex)
		{
			unsafe {
				if (fn__getVehicleWeaponCapacity == null) fn__getVehicleWeaponCapacity = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleWeaponCapacity");
				var result = fn__getVehicleWeaponCapacity(_vehicle, _weaponIndex);
				return result;
			}
		}

		public bool GetVehicleHasParachute(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleHasParachute == null) fn__getVehicleHasParachute = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleHasParachute");
				var result = fn__getVehicleHasParachute(_vehicle);
				return result;
			}
		}

		public bool GetVehicleCanActivateParachute(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleCanActivateParachute == null) fn__getVehicleCanActivateParachute = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getVehicleCanActivateParachute");
				var result = fn__getVehicleCanActivateParachute(_vehicle);
				return result;
			}
		}

		public void SetVehicleParachuteActive(int _vehicle, bool _active)
		{
			unsafe {
				if (fn__setVehicleParachuteActive == null) fn__setVehicleParachuteActive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleParachuteActive");
				fn__setVehicleParachuteActive(_vehicle, _active);
			}
		}

		public int _0x3DE51E9C80B116CF(int _p0)
		{
			unsafe {
				if (fn__0x3DE51E9C80B116CF == null) fn__0x3DE51E9C80B116CF = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x3DE51E9C80B116CF");
				var result = fn__0x3DE51E9C80B116CF(_p0);
				return result;
			}
		}

		public void SetVehicleReceivesRampDamage(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleReceivesRampDamage == null) fn__setVehicleReceivesRampDamage = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleReceivesRampDamage");
				fn__setVehicleReceivesRampDamage(_vehicle, _toggle);
			}
		}

		public void SetVehicleRampSidewaysLaunchMotion(int _p0, int _p1)
		{
			unsafe {
				if (fn__setVehicleRampSidewaysLaunchMotion == null) fn__setVehicleRampSidewaysLaunchMotion = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRampSidewaysLaunchMotion");
				fn__setVehicleRampSidewaysLaunchMotion(_p0, _p1);
			}
		}

		public void SetVehicleRampUpwardsLaunchMotion(int _p0, int _p1)
		{
			unsafe {
				if (fn__setVehicleRampUpwardsLaunchMotion == null) fn__setVehicleRampUpwardsLaunchMotion = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRampUpwardsLaunchMotion");
				fn__setVehicleRampUpwardsLaunchMotion(_p0, _p1);
			}
		}

		public void _0x9D30687C57BAA0BB(int _p0)
		{
			unsafe {
				if (fn__0x9D30687C57BAA0BB == null) fn__0x9D30687C57BAA0BB = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x9D30687C57BAA0BB");
				fn__0x9D30687C57BAA0BB(_p0);
			}
		}

		public void SetVehicleWeaponsDisabled(int _p0, int _p1)
		{
			unsafe {
				if (fn__setVehicleWeaponsDisabled == null) fn__setVehicleWeaponsDisabled = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleWeaponsDisabled");
				fn__setVehicleWeaponsDisabled(_p0, _p1);
			}
		}

		public void _0x41290B40FA63E6DA(int _p0)
		{
			unsafe {
				if (fn__0x41290B40FA63E6DA == null) fn__0x41290B40FA63E6DA = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x41290B40FA63E6DA");
				fn__0x41290B40FA63E6DA(_p0);
			}
		}

		public void SetVehicleParachuteModel(int _vehicle, int _modelHash)
		{
			unsafe {
				if (fn__setVehicleParachuteModel == null) fn__setVehicleParachuteModel = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleParachuteModel");
				fn__setVehicleParachuteModel(_vehicle, _modelHash);
			}
		}

		public void SetVehicleParachuteTextureVariation(int _vehicle, int _textureVariation)
		{
			unsafe {
				if (fn__setVehicleParachuteTextureVariation == null) fn__setVehicleParachuteTextureVariation = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleParachuteTextureVariation");
				fn__setVehicleParachuteTextureVariation(_vehicle, _textureVariation);
			}
		}

		public int _0x0419B167EE128F33(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x0419B167EE128F33 == null) fn__0x0419B167EE128F33 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0x0419B167EE128F33");
				var result = fn__0x0419B167EE128F33(_p0, _p1);
				return result;
			}
		}

		public int _0xF3B0E0AED097A3F5(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xF3B0E0AED097A3F5 == null) fn__0xF3B0E0AED097A3F5 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0xF3B0E0AED097A3F5");
				var result = fn__0xF3B0E0AED097A3F5(_p0, _p1);
				return result;
			}
		}

		public int _0xD3E51C0AB8C26EEE(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xD3E51C0AB8C26EEE == null) fn__0xD3E51C0AB8C26EEE = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0xD3E51C0AB8C26EEE");
				var result = fn__0xD3E51C0AB8C26EEE(_p0, _p1);
				return result;
			}
		}

		public int GetAllVehicles(ref int _vehsStruct)
		{
			unsafe {
				if (fn__getAllVehicles == null) fn__getAllVehicles = (delegate* unmanaged[Cdecl]<int*, int>) NativeLibrary.GetExport(handle, "Native_getAllVehicles");
				var ref_vehsStruct = _vehsStruct;
				var result = fn__getAllVehicles(&ref_vehsStruct);
				_vehsStruct = ref_vehsStruct;
				return result;
			}
		}

		public void _0x72BECCF4B829522E(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x72BECCF4B829522E == null) fn__0x72BECCF4B829522E = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x72BECCF4B829522E");
				fn__0x72BECCF4B829522E(_p0, _p1);
			}
		}

		public void _0x66E3AAFACE2D1EB8(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x66E3AAFACE2D1EB8 == null) fn__0x66E3AAFACE2D1EB8 = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x66E3AAFACE2D1EB8");
				fn__0x66E3AAFACE2D1EB8(_p0, _p1, _p2);
			}
		}

		public void _0x1312DDD8385AEE4E(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x1312DDD8385AEE4E == null) fn__0x1312DDD8385AEE4E = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x1312DDD8385AEE4E");
				fn__0x1312DDD8385AEE4E(_p0, _p1);
			}
		}

		public void _0xEDBC8405B3895CC9(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xEDBC8405B3895CC9 == null) fn__0xEDBC8405B3895CC9 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xEDBC8405B3895CC9");
				fn__0xEDBC8405B3895CC9(_p0, _p1);
			}
		}

		public void _0x26E13D440E7F6064(int _vehicle, float _value)
		{
			unsafe {
				if (fn__0x26E13D440E7F6064 == null) fn__0x26E13D440E7F6064 = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native__0x26E13D440E7F6064");
				fn__0x26E13D440E7F6064(_vehicle, _value);
			}
		}

		public void _0x2FA2494B47FDD009(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x2FA2494B47FDD009 == null) fn__0x2FA2494B47FDD009 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x2FA2494B47FDD009");
				fn__0x2FA2494B47FDD009(_p0, _p1);
			}
		}

		public void SetVehicleRocketBoostPercentage(int _vehicle, float _percentage)
		{
			unsafe {
				if (fn__setVehicleRocketBoostPercentage == null) fn__setVehicleRocketBoostPercentage = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleRocketBoostPercentage");
				fn__setVehicleRocketBoostPercentage(_vehicle, _percentage);
			}
		}

		public void SetOppressorTransformState(int _vehicle, bool _state)
		{
			unsafe {
				if (fn__setOppressorTransformState == null) fn__setOppressorTransformState = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setOppressorTransformState");
				fn__setOppressorTransformState(_vehicle, _state);
			}
		}

		public void _0x78CEEE41F49F421F(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x78CEEE41F49F421F == null) fn__0x78CEEE41F49F421F = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x78CEEE41F49F421F");
				fn__0x78CEEE41F49F421F(_p0, _p1);
			}
		}

		public void _0xAF60E6A2936F982A(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xAF60E6A2936F982A == null) fn__0xAF60E6A2936F982A = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xAF60E6A2936F982A");
				fn__0xAF60E6A2936F982A(_p0, _p1);
			}
		}

		public void _0x430A7631A84C9BE7(int _p0)
		{
			unsafe {
				if (fn__0x430A7631A84C9BE7 == null) fn__0x430A7631A84C9BE7 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x430A7631A84C9BE7");
				fn__0x430A7631A84C9BE7(_p0);
			}
		}

		public void DisableVehicleWorldCollision(int _vehicle)
		{
			unsafe {
				if (fn__disableVehicleWorldCollision == null) fn__disableVehicleWorldCollision = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_disableVehicleWorldCollision");
				fn__disableVehicleWorldCollision(_vehicle);
			}
		}

		public void _0x8235F1BEAD557629(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0x8235F1BEAD557629 == null) fn__0x8235F1BEAD557629 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x8235F1BEAD557629");
				fn__0x8235F1BEAD557629(_vehicle, _toggle);
			}
		}

		public void _0x9640E30A7F395E4B(int _vehicle, int _p1, int _p2, int _p3, int _p4)
		{
			unsafe {
				if (fn__0x9640E30A7F395E4B == null) fn__0x9640E30A7F395E4B = (delegate* unmanaged[Cdecl]<int, int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x9640E30A7F395E4B");
				fn__0x9640E30A7F395E4B(_vehicle, _p1, _p2, _p3, _p4);
			}
		}

		public void _0x0BBB9A7A8FFE931B(int _p0, int _p1, int _p2)
		{
			unsafe {
				if (fn__0x0BBB9A7A8FFE931B == null) fn__0x0BBB9A7A8FFE931B = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native__0x0BBB9A7A8FFE931B");
				fn__0x0BBB9A7A8FFE931B(_p0, _p1, _p2);
			}
		}

		public void SetCargobobHookCanAttach(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setCargobobHookCanAttach == null) fn__setCargobobHookCanAttach = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCargobobHookCanAttach");
				fn__setCargobobHookCanAttach(_vehicle, _toggle);
			}
		}

		public void SetVehicleBombCount(int _vehicle, int _bombCount)
		{
			unsafe {
				if (fn__setVehicleBombCount == null) fn__setVehicleBombCount = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleBombCount");
				fn__setVehicleBombCount(_vehicle, _bombCount);
			}
		}

		public int GetVehicleBombCount(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleBombCount == null) fn__getVehicleBombCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleBombCount");
				var result = fn__getVehicleBombCount(_vehicle);
				return result;
			}
		}

		public void SetVehicleCountermeasureCount(int _vehicle, int _counterMeasureCount)
		{
			unsafe {
				if (fn__setVehicleCountermeasureCount == null) fn__setVehicleCountermeasureCount = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setVehicleCountermeasureCount");
				fn__setVehicleCountermeasureCount(_vehicle, _counterMeasureCount);
			}
		}

		public int GetVehicleCountermeasureCount(int _vehicle)
		{
			unsafe {
				if (fn__getVehicleCountermeasureCount == null) fn__getVehicleCountermeasureCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getVehicleCountermeasureCount");
				var result = fn__getVehicleCountermeasureCount(_vehicle);
				return result;
			}
		}

		public void _0x0A3F820A9A9A9AC5(int _vehicle, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__0x0A3F820A9A9A9AC5 == null) fn__0x0A3F820A9A9A9AC5 = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native__0x0A3F820A9A9A9AC5");
				fn__0x0A3F820A9A9A9AC5(_vehicle, _x, _y, _z);
			}
		}

		public bool _0x51F30DB60626A20E(int _vehicle, float _x, float _y, float _z, float _rotX, float _rotY, float _rotZ, int _p7, int _p8)
		{
			unsafe {
				if (fn__0x51F30DB60626A20E == null) fn__0x51F30DB60626A20E = (delegate* unmanaged[Cdecl]<int, float, float, float, float, float, float, int, int, bool>) NativeLibrary.GetExport(handle, "Native__0x51F30DB60626A20E");
				var result = fn__0x51F30DB60626A20E(_vehicle, _x, _y, _z, _rotX, _rotY, _rotZ, _p7, _p8);
				return result;
			}
		}

		public void _0x97841634EF7DF1D6(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0x97841634EF7DF1D6 == null) fn__0x97841634EF7DF1D6 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0x97841634EF7DF1D6");
				fn__0x97841634EF7DF1D6(_vehicle, _toggle);
			}
		}

		public void SetVehicleHoverTransformRatio(int _vehicle, float _ratio)
		{
			unsafe {
				if (fn__setVehicleHoverTransformRatio == null) fn__setVehicleHoverTransformRatio = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHoverTransformRatio");
				fn__setVehicleHoverTransformRatio(_vehicle, _ratio);
			}
		}

		public void SetVehicleHoverTransformPercentage(int _vehicle, float _percentage)
		{
			unsafe {
				if (fn__setVehicleHoverTransformPercentage == null) fn__setVehicleHoverTransformPercentage = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHoverTransformPercentage");
				fn__setVehicleHoverTransformPercentage(_vehicle, _percentage);
			}
		}

		public void SetVehicleHoverTransformEnabled(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleHoverTransformEnabled == null) fn__setVehicleHoverTransformEnabled = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHoverTransformEnabled");
				fn__setVehicleHoverTransformEnabled(_vehicle, _toggle);
			}
		}

		public void SetVehicleHoverTransformActive(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleHoverTransformActive == null) fn__setVehicleHoverTransformActive = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleHoverTransformActive");
				fn__setVehicleHoverTransformActive(_vehicle, _toggle);
			}
		}

		public int _0x3A9128352EAC9E85(int _p0)
		{
			unsafe {
				if (fn__0x3A9128352EAC9E85 == null) fn__0x3A9128352EAC9E85 = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native__0x3A9128352EAC9E85");
				var result = fn__0x3A9128352EAC9E85(_p0);
				return result;
			}
		}

		public Vector3 FindRandomPointInSpace(int _ped)
		{
			unsafe {
				if (fn__findRandomPointInSpace == null) fn__findRandomPointInSpace = (delegate* unmanaged[Cdecl]<int, Vector3>) NativeLibrary.GetExport(handle, "Native_findRandomPointInSpace");
				var result = fn__findRandomPointInSpace(_ped);
				return result;
			}
		}

		public void SetDeployHeliStubWings(int _vehicle, bool _deploy, bool _p2)
		{
			unsafe {
				if (fn__setDeployHeliStubWings == null) fn__setDeployHeliStubWings = (delegate* unmanaged[Cdecl]<int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setDeployHeliStubWings");
				fn__setDeployHeliStubWings(_vehicle, _deploy, _p2);
			}
		}

		public bool AreHeliStubWingsDeployed(int _vehicle)
		{
			unsafe {
				if (fn__areHeliStubWingsDeployed == null) fn__areHeliStubWingsDeployed = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_areHeliStubWingsDeployed");
				var result = fn__areHeliStubWingsDeployed(_vehicle);
				return result;
			}
		}

		public void _0xAA653AE61924B0A0(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__0xAA653AE61924B0A0 == null) fn__0xAA653AE61924B0A0 = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native__0xAA653AE61924B0A0");
				fn__0xAA653AE61924B0A0(_vehicle, _toggle);
			}
		}

		public void SetVehicleTurretUnk(int _vehicle, int _index, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleTurretUnk == null) fn__setVehicleTurretUnk = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleTurretUnk");
				fn__setVehicleTurretUnk(_vehicle, _index, _toggle);
			}
		}

		public void SetSpecialflightWingRatio(int _vehicle, float _ratio)
		{
			unsafe {
				if (fn__setSpecialflightWingRatio == null) fn__setSpecialflightWingRatio = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setSpecialflightWingRatio");
				fn__setSpecialflightWingRatio(_vehicle, _ratio);
			}
		}

		public void SetDisableTurretMovementThisFrame(int _vehicle, int _turretId)
		{
			unsafe {
				if (fn__setDisableTurretMovementThisFrame == null) fn__setDisableTurretMovementThisFrame = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setDisableTurretMovementThisFrame");
				fn__setDisableTurretMovementThisFrame(_vehicle, _turretId);
			}
		}

		public void _0x887FA38787DE8C72(int _vehicle)
		{
			unsafe {
				if (fn__0x887FA38787DE8C72 == null) fn__0x887FA38787DE8C72 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x887FA38787DE8C72");
				fn__0x887FA38787DE8C72(_vehicle);
			}
		}

		public void SetUnkFloat0x104ForSubmarineVehicleTask(int _vehicle, float _value)
		{
			unsafe {
				if (fn__setUnkFloat0x104ForSubmarineVehicleTask == null) fn__setUnkFloat0x104ForSubmarineVehicleTask = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setUnkFloat0x104ForSubmarineVehicleTask");
				fn__setUnkFloat0x104ForSubmarineVehicleTask(_vehicle, _value);
			}
		}

		public void SetUnkBool0x102ForSubmarineVehicleTask(int _vehicle, bool _value)
		{
			unsafe {
				if (fn__setUnkBool0x102ForSubmarineVehicleTask == null) fn__setUnkBool0x102ForSubmarineVehicleTask = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setUnkBool0x102ForSubmarineVehicleTask");
				fn__setUnkBool0x102ForSubmarineVehicleTask(_vehicle, _value);
			}
		}

		public void _0x36DE109527A2C0C4(bool _toggle)
		{
			unsafe {
				if (fn__0x36DE109527A2C0C4 == null) fn__0x36DE109527A2C0C4 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x36DE109527A2C0C4");
				fn__0x36DE109527A2C0C4(_toggle);
			}
		}

		public void _0x82E0AC411E41A5B4(bool _toggle)
		{
			unsafe {
				if (fn__0x82E0AC411E41A5B4 == null) fn__0x82E0AC411E41A5B4 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x82E0AC411E41A5B4");
				fn__0x82E0AC411E41A5B4(_toggle);
			}
		}

		public void _0x99A05839C46CE316(bool _toggle)
		{
			unsafe {
				if (fn__0x99A05839C46CE316 == null) fn__0x99A05839C46CE316 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x99A05839C46CE316");
				fn__0x99A05839C46CE316(_toggle);
			}
		}

		public bool GetIsVehicleShuntBoostActive(int _vehicle)
		{
			unsafe {
				if (fn__getIsVehicleShuntBoostActive == null) fn__getIsVehicleShuntBoostActive = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getIsVehicleShuntBoostActive");
				var result = fn__getIsVehicleShuntBoostActive(_vehicle);
				return result;
			}
		}

		public bool _0xE8718FAF591FD224(int _vehicle)
		{
			unsafe {
				if (fn__0xE8718FAF591FD224 == null) fn__0xE8718FAF591FD224 = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native__0xE8718FAF591FD224");
				var result = fn__0xE8718FAF591FD224(_vehicle);
				return result;
			}
		}

		public int GetLastRammedVehicle(int _vehicle)
		{
			unsafe {
				if (fn__getLastRammedVehicle == null) fn__getLastRammedVehicle = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getLastRammedVehicle");
				var result = fn__getLastRammedVehicle(_vehicle);
				return result;
			}
		}

		public void SetDisableVehicleUnk(bool _toggle)
		{
			unsafe {
				if (fn__setDisableVehicleUnk == null) fn__setDisableVehicleUnk = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableVehicleUnk");
				fn__setDisableVehicleUnk(_toggle);
			}
		}

		public void SetVehicleNitroEnabled(int _vehicle, bool _toggle, float _level, float _power, float _rechargeTime, bool _disableSound)
		{
			unsafe {
				if (fn__setVehicleNitroEnabled == null) fn__setVehicleNitroEnabled = (delegate* unmanaged[Cdecl]<int, bool, float, float, float, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleNitroEnabled");
				fn__setVehicleNitroEnabled(_vehicle, _toggle, _level, _power, _rechargeTime, _disableSound);
			}
		}

		public void SetVehicleWheelsDealDamage(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setVehicleWheelsDealDamage == null) fn__setVehicleWheelsDealDamage = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setVehicleWheelsDealDamage");
				fn__setVehicleWheelsDealDamage(_vehicle, _toggle);
			}
		}

		public void SetDisableVehicleUnk2(bool _toggle)
		{
			unsafe {
				if (fn__setDisableVehicleUnk2 == null) fn__setDisableVehicleUnk2 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_setDisableVehicleUnk2");
				fn__setDisableVehicleUnk2(_toggle);
			}
		}

		public void _0x5BBCF35BF6E456F7(bool _toggle)
		{
			unsafe {
				if (fn__0x5BBCF35BF6E456F7 == null) fn__0x5BBCF35BF6E456F7 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x5BBCF35BF6E456F7");
				fn__0x5BBCF35BF6E456F7(_toggle);
			}
		}

		public bool GetDoesVehicleHaveTombstone(int _vehicle)
		{
			unsafe {
				if (fn__getDoesVehicleHaveTombstone == null) fn__getDoesVehicleHaveTombstone = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getDoesVehicleHaveTombstone");
				var result = fn__getDoesVehicleHaveTombstone(_vehicle);
				return result;
			}
		}

		public void HideVehicleTombstone(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__hideVehicleTombstone == null) fn__hideVehicleTombstone = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_hideVehicleTombstone");
				fn__hideVehicleTombstone(_vehicle, _toggle);
			}
		}

		public bool GetIsVehicleEmpDisabled(int _vehicle)
		{
			unsafe {
				if (fn__getIsVehicleEmpDisabled == null) fn__getIsVehicleEmpDisabled = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getIsVehicleEmpDisabled");
				var result = fn__getIsVehicleEmpDisabled(_vehicle);
				return result;
			}
		}

		public void _0x8F0D5BA1C2CC91D7(bool _toggle)
		{
			unsafe {
				if (fn__0x8F0D5BA1C2CC91D7 == null) fn__0x8F0D5BA1C2CC91D7 = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native__0x8F0D5BA1C2CC91D7");
				fn__0x8F0D5BA1C2CC91D7(_toggle);
			}
		}

		public float GetTyreHealth(int _vehicle, int _wheelIndex)
		{
			unsafe {
				if (fn__getTyreHealth == null) fn__getTyreHealth = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getTyreHealth");
				var result = fn__getTyreHealth(_vehicle, _wheelIndex);
				return result;
			}
		}

		public void SetTyreHealth(int _vehicle, int _wheelIndex, float _health)
		{
			unsafe {
				if (fn__setTyreHealth == null) fn__setTyreHealth = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setTyreHealth");
				fn__setTyreHealth(_vehicle, _wheelIndex, _health);
			}
		}

		public float GetTyreWearMultiplier(int _vehicle, int _wheelIndex)
		{
			unsafe {
				if (fn__getTyreWearMultiplier == null) fn__getTyreWearMultiplier = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getTyreWearMultiplier");
				var result = fn__getTyreWearMultiplier(_vehicle, _wheelIndex);
				return result;
			}
		}

		public void SetTyreWearMultiplier(int _vehicle, int _wheelIndex, float _multiplier)
		{
			unsafe {
				if (fn__setTyreWearMultiplier == null) fn__setTyreWearMultiplier = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setTyreWearMultiplier");
				fn__setTyreWearMultiplier(_vehicle, _wheelIndex, _multiplier);
			}
		}

		public void SetTyreTractionLossMultiplier(int _vehicle, int _wheelIndex, float _multiplier)
		{
			unsafe {
				if (fn__setTyreTractionLossMultiplier == null) fn__setTyreTractionLossMultiplier = (delegate* unmanaged[Cdecl]<int, int, float, void>) NativeLibrary.GetExport(handle, "Native_setTyreTractionLossMultiplier");
				fn__setTyreTractionLossMultiplier(_vehicle, _wheelIndex, _multiplier);
			}
		}

		public void _0xF8B49F5BA7F850E7(int _vehicle, int _p1)
		{
			unsafe {
				if (fn__0xF8B49F5BA7F850E7 == null) fn__0xF8B49F5BA7F850E7 = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xF8B49F5BA7F850E7");
				fn__0xF8B49F5BA7F850E7(_vehicle, _p1);
			}
		}

		public void SetReduceDriftVehicleSuspension(int _vehicle, bool _enable)
		{
			unsafe {
				if (fn__setReduceDriftVehicleSuspension == null) fn__setReduceDriftVehicleSuspension = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setReduceDriftVehicleSuspension");
				fn__setReduceDriftVehicleSuspension(_vehicle, _enable);
			}
		}

		public void SetDriftTyresEnabled(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__setDriftTyresEnabled == null) fn__setDriftTyresEnabled = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setDriftTyresEnabled");
				fn__setDriftTyresEnabled(_vehicle, _toggle);
			}
		}

		public bool GetDriftTyresEnabled(int _vehicle)
		{
			unsafe {
				if (fn__getDriftTyresEnabled == null) fn__getDriftTyresEnabled = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_getDriftTyresEnabled");
				var result = fn__getDriftTyresEnabled(_vehicle);
				return result;
			}
		}

		public void NetworkUseHighPrecisionVehicleBlending(int _vehicle, bool _toggle)
		{
			unsafe {
				if (fn__networkUseHighPrecisionVehicleBlending == null) fn__networkUseHighPrecisionVehicleBlending = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_networkUseHighPrecisionVehicleBlending");
				fn__networkUseHighPrecisionVehicleBlending(_vehicle, _toggle);
			}
		}

		public bool GetWaterHeight(float _x, float _y, float _z, ref float _height)
		{
			unsafe {
				if (fn__getWaterHeight == null) fn__getWaterHeight = (delegate* unmanaged[Cdecl]<float, float, float, float*, bool>) NativeLibrary.GetExport(handle, "Native_getWaterHeight");
				var ref_height = _height;
				var result = fn__getWaterHeight(_x, _y, _z, &ref_height);
				_height = ref_height;
				return result;
			}
		}

		public bool GetWaterHeightNoWaves(float _x, float _y, float _z, ref float _height)
		{
			unsafe {
				if (fn__getWaterHeightNoWaves == null) fn__getWaterHeightNoWaves = (delegate* unmanaged[Cdecl]<float, float, float, float*, bool>) NativeLibrary.GetExport(handle, "Native_getWaterHeightNoWaves");
				var ref_height = _height;
				var result = fn__getWaterHeightNoWaves(_x, _y, _z, &ref_height);
				_height = ref_height;
				return result;
			}
		}

		public bool TestProbeAgainstWater(float _x1, float _y1, float _z1, float _x2, float _y2, float _z2, ref Vector3 _result)
		{
			unsafe {
				if (fn__testProbeAgainstWater == null) fn__testProbeAgainstWater = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, Vector3*, bool>) NativeLibrary.GetExport(handle, "Native_testProbeAgainstWater");
				var ref_result = _result;
				var result = fn__testProbeAgainstWater(_x1, _y1, _z1, _x2, _y2, _z2, &ref_result);
				_result = ref_result;
				return result;
			}
		}

		public bool TestProbeAgainstAllWater(int _p0, int _p1, int _p2, int _p3, int _p4, int _p5, int _p6, int _p7)
		{
			unsafe {
				if (fn__testProbeAgainstAllWater == null) fn__testProbeAgainstAllWater = (delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_testProbeAgainstAllWater");
				var result = fn__testProbeAgainstAllWater(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7);
				return result;
			}
		}

		public bool TestVerticalProbeAgainstAllWater(float _x, float _y, float _z, int _p3, ref float _height)
		{
			unsafe {
				if (fn__testVerticalProbeAgainstAllWater == null) fn__testVerticalProbeAgainstAllWater = (delegate* unmanaged[Cdecl]<float, float, float, int, float*, bool>) NativeLibrary.GetExport(handle, "Native_testVerticalProbeAgainstAllWater");
				var ref_height = _height;
				var result = fn__testVerticalProbeAgainstAllWater(_x, _y, _z, _p3, &ref_height);
				_height = ref_height;
				return result;
			}
		}

		public void ModifyWater(float _x, float _y, float _radius, float _height)
		{
			unsafe {
				if (fn__modifyWater == null) fn__modifyWater = (delegate* unmanaged[Cdecl]<float, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_modifyWater");
				fn__modifyWater(_x, _y, _radius, _height);
			}
		}

		public int AddCurrentRise(float _xLow, float _yLow, float _xHigh, float _yHigh, float _height)
		{
			unsafe {
				if (fn__addCurrentRise == null) fn__addCurrentRise = (delegate* unmanaged[Cdecl]<float, float, float, float, float, int>) NativeLibrary.GetExport(handle, "Native_addCurrentRise");
				var result = fn__addCurrentRise(_xLow, _yLow, _xHigh, _yHigh, _height);
				return result;
			}
		}

		public void RemoveCurrentRise(int _p0)
		{
			unsafe {
				if (fn__removeCurrentRise == null) fn__removeCurrentRise = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeCurrentRise");
				fn__removeCurrentRise(_p0);
			}
		}

		public void SetDeepOceanScaler(float _intensity)
		{
			unsafe {
				if (fn__setDeepOceanScaler == null) fn__setDeepOceanScaler = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setDeepOceanScaler");
				fn__setDeepOceanScaler(_intensity);
			}
		}

		public float GetDeepOceanScaler()
		{
			unsafe {
				if (fn__getDeepOceanScaler == null) fn__getDeepOceanScaler = (delegate* unmanaged[Cdecl]<float>) NativeLibrary.GetExport(handle, "Native_getDeepOceanScaler");
				var result = fn__getDeepOceanScaler();
				return result;
			}
		}

		public void _0x547237AA71AB44DE(float _p0)
		{
			unsafe {
				if (fn__0x547237AA71AB44DE == null) fn__0x547237AA71AB44DE = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native__0x547237AA71AB44DE");
				fn__0x547237AA71AB44DE(_p0);
			}
		}

		public void ResetDeepOceanScaler()
		{
			unsafe {
				if (fn__resetDeepOceanScaler == null) fn__resetDeepOceanScaler = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_resetDeepOceanScaler");
				fn__resetDeepOceanScaler();
			}
		}

		public void EnableLaserSightRendering(bool _toggle)
		{
			unsafe {
				if (fn__enableLaserSightRendering == null) fn__enableLaserSightRendering = (delegate* unmanaged[Cdecl]<bool, void>) NativeLibrary.GetExport(handle, "Native_enableLaserSightRendering");
				fn__enableLaserSightRendering(_toggle);
			}
		}

		public int GetWeaponComponentTypeModel(int _componentHash)
		{
			unsafe {
				if (fn__getWeaponComponentTypeModel == null) fn__getWeaponComponentTypeModel = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeaponComponentTypeModel");
				var result = fn__getWeaponComponentTypeModel(_componentHash);
				return result;
			}
		}

		public int GetWeapontypeModel(int _weaponHash)
		{
			unsafe {
				if (fn__getWeapontypeModel == null) fn__getWeapontypeModel = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeapontypeModel");
				var result = fn__getWeapontypeModel(_weaponHash);
				return result;
			}
		}

		public int GetWeapontypeSlot(int _weaponHash)
		{
			unsafe {
				if (fn__getWeapontypeSlot == null) fn__getWeapontypeSlot = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeapontypeSlot");
				var result = fn__getWeapontypeSlot(_weaponHash);
				return result;
			}
		}

		public int GetWeapontypeGroup(int _weaponHash)
		{
			unsafe {
				if (fn__getWeapontypeGroup == null) fn__getWeapontypeGroup = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeapontypeGroup");
				var result = fn__getWeapontypeGroup(_weaponHash);
				return result;
			}
		}

		public int GetWeaponComponentVariantExtraComponentCount(int _componentHash)
		{
			unsafe {
				if (fn__getWeaponComponentVariantExtraComponentCount == null) fn__getWeaponComponentVariantExtraComponentCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeaponComponentVariantExtraComponentCount");
				var result = fn__getWeaponComponentVariantExtraComponentCount(_componentHash);
				return result;
			}
		}

		public int GetWeaponComponentVariantExtraComponentModel(int _componentHash, int _extraComponentIndex)
		{
			unsafe {
				if (fn__getWeaponComponentVariantExtraComponentModel == null) fn__getWeaponComponentVariantExtraComponentModel = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getWeaponComponentVariantExtraComponentModel");
				var result = fn__getWeaponComponentVariantExtraComponentModel(_componentHash, _extraComponentIndex);
				return result;
			}
		}

		public void SetCurrentPedWeapon(int _ped, int _weaponHash, bool _bForceInHand)
		{
			unsafe {
				if (fn__setCurrentPedWeapon == null) fn__setCurrentPedWeapon = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCurrentPedWeapon");
				fn__setCurrentPedWeapon(_ped, _weaponHash, _bForceInHand);
			}
		}

		public bool GetCurrentPedWeapon(int _ped, ref int _weaponHash, bool _p2)
		{
			unsafe {
				if (fn__getCurrentPedWeapon == null) fn__getCurrentPedWeapon = (delegate* unmanaged[Cdecl]<int, int*, bool, bool>) NativeLibrary.GetExport(handle, "Native_getCurrentPedWeapon");
				var ref_weaponHash = _weaponHash;
				var result = fn__getCurrentPedWeapon(_ped, &ref_weaponHash, _p2);
				_weaponHash = ref_weaponHash;
				return result;
			}
		}

		public int GetCurrentPedWeaponEntityIndex(int _ped, int _p1)
		{
			unsafe {
				if (fn__getCurrentPedWeaponEntityIndex == null) fn__getCurrentPedWeaponEntityIndex = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getCurrentPedWeaponEntityIndex");
				var result = fn__getCurrentPedWeaponEntityIndex(_ped, _p1);
				return result;
			}
		}

		public int GetBestPedWeapon(int _ped, bool _p1)
		{
			unsafe {
				if (fn__getBestPedWeapon == null) fn__getBestPedWeapon = (delegate* unmanaged[Cdecl]<int, bool, int>) NativeLibrary.GetExport(handle, "Native_getBestPedWeapon");
				var result = fn__getBestPedWeapon(_ped, _p1);
				return result;
			}
		}

		public bool SetCurrentPedVehicleWeapon(int _ped, int _weaponHash)
		{
			unsafe {
				if (fn__setCurrentPedVehicleWeapon == null) fn__setCurrentPedVehicleWeapon = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_setCurrentPedVehicleWeapon");
				var result = fn__setCurrentPedVehicleWeapon(_ped, _weaponHash);
				return result;
			}
		}

		public bool GetCurrentPedVehicleWeapon(int _ped, ref int _weaponHash)
		{
			unsafe {
				if (fn__getCurrentPedVehicleWeapon == null) fn__getCurrentPedVehicleWeapon = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getCurrentPedVehicleWeapon");
				var ref_weaponHash = _weaponHash;
				var result = fn__getCurrentPedVehicleWeapon(_ped, &ref_weaponHash);
				_weaponHash = ref_weaponHash;
				return result;
			}
		}

		public void _0x50276EF8172F5F12(int _ped)
		{
			unsafe {
				if (fn__0x50276EF8172F5F12 == null) fn__0x50276EF8172F5F12 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0x50276EF8172F5F12");
				fn__0x50276EF8172F5F12(_ped);
			}
		}

		public bool IsPedArmed(int _ped, int _typeFlags)
		{
			unsafe {
				if (fn__isPedArmed == null) fn__isPedArmed = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedArmed");
				var result = fn__isPedArmed(_ped, _typeFlags);
				return result;
			}
		}

		public bool IsWeaponValid(int _weaponHash)
		{
			unsafe {
				if (fn__isWeaponValid == null) fn__isWeaponValid = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isWeaponValid");
				var result = fn__isWeaponValid(_weaponHash);
				return result;
			}
		}

		public bool HasPedGotWeapon(int _ped, int _weaponHash, bool _p2)
		{
			unsafe {
				if (fn__hasPedGotWeapon == null) fn__hasPedGotWeapon = (delegate* unmanaged[Cdecl]<int, int, bool, bool>) NativeLibrary.GetExport(handle, "Native_hasPedGotWeapon");
				var result = fn__hasPedGotWeapon(_ped, _weaponHash, _p2);
				return result;
			}
		}

		public bool IsPedWeaponReadyToShoot(int _ped)
		{
			unsafe {
				if (fn__isPedWeaponReadyToShoot == null) fn__isPedWeaponReadyToShoot = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedWeaponReadyToShoot");
				var result = fn__isPedWeaponReadyToShoot(_ped);
				return result;
			}
		}

		public int GetPedWeapontypeInSlot(int _ped, int _weaponSlot)
		{
			unsafe {
				if (fn__getPedWeapontypeInSlot == null) fn__getPedWeapontypeInSlot = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedWeapontypeInSlot");
				var result = fn__getPedWeapontypeInSlot(_ped, _weaponSlot);
				return result;
			}
		}

		public int GetAmmoInPedWeapon(int _ped, int _weaponhash)
		{
			unsafe {
				if (fn__getAmmoInPedWeapon == null) fn__getAmmoInPedWeapon = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getAmmoInPedWeapon");
				var result = fn__getAmmoInPedWeapon(_ped, _weaponhash);
				return result;
			}
		}

		public void AddAmmoToPed(int _ped, int _weaponHash, int _ammo)
		{
			unsafe {
				if (fn__addAmmoToPed == null) fn__addAmmoToPed = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_addAmmoToPed");
				fn__addAmmoToPed(_ped, _weaponHash, _ammo);
			}
		}

		public void SetPedAmmo(int _ped, int _weaponHash, int _ammo, bool _p3)
		{
			unsafe {
				if (fn__setPedAmmo == null) fn__setPedAmmo = (delegate* unmanaged[Cdecl]<int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedAmmo");
				fn__setPedAmmo(_ped, _weaponHash, _ammo, _p3);
			}
		}

		public void SetPedInfiniteAmmo(int _ped, bool _toggle, int _weaponHash)
		{
			unsafe {
				if (fn__setPedInfiniteAmmo == null) fn__setPedInfiniteAmmo = (delegate* unmanaged[Cdecl]<int, bool, int, void>) NativeLibrary.GetExport(handle, "Native_setPedInfiniteAmmo");
				fn__setPedInfiniteAmmo(_ped, _toggle, _weaponHash);
			}
		}

		public void SetPedInfiniteAmmoClip(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedInfiniteAmmoClip == null) fn__setPedInfiniteAmmoClip = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedInfiniteAmmoClip");
				fn__setPedInfiniteAmmoClip(_ped, _toggle);
			}
		}

		public void _0x24C024BA8379A70A(int _p0, int _p1)
		{
			unsafe {
				if (fn__0x24C024BA8379A70A == null) fn__0x24C024BA8379A70A = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x24C024BA8379A70A");
				fn__0x24C024BA8379A70A(_p0, _p1);
			}
		}

		public void GiveWeaponToPed(int _ped, int _weaponHash, int _ammoCount, bool _isHidden, bool _bForceInHand)
		{
			unsafe {
				if (fn__giveWeaponToPed == null) fn__giveWeaponToPed = (delegate* unmanaged[Cdecl]<int, int, int, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_giveWeaponToPed");
				fn__giveWeaponToPed(_ped, _weaponHash, _ammoCount, _isHidden, _bForceInHand);
			}
		}

		public void GiveDelayedWeaponToPed(int _ped, int _weaponHash, int _ammoCount, bool _bForceInHand)
		{
			unsafe {
				if (fn__giveDelayedWeaponToPed == null) fn__giveDelayedWeaponToPed = (delegate* unmanaged[Cdecl]<int, int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_giveDelayedWeaponToPed");
				fn__giveDelayedWeaponToPed(_ped, _weaponHash, _ammoCount, _bForceInHand);
			}
		}

		public void RemoveAllPedWeapons(int _ped, bool _p1)
		{
			unsafe {
				if (fn__removeAllPedWeapons == null) fn__removeAllPedWeapons = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removeAllPedWeapons");
				fn__removeAllPedWeapons(_ped, _p1);
			}
		}

		public void RemoveWeaponFromPed(int _ped, int _weaponHash)
		{
			unsafe {
				if (fn__removeWeaponFromPed == null) fn__removeWeaponFromPed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_removeWeaponFromPed");
				fn__removeWeaponFromPed(_ped, _weaponHash);
			}
		}

		public void HidePedWeaponForScriptedCutscene(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__hidePedWeaponForScriptedCutscene == null) fn__hidePedWeaponForScriptedCutscene = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_hidePedWeaponForScriptedCutscene");
				fn__hidePedWeaponForScriptedCutscene(_ped, _toggle);
			}
		}

		public void SetPedCurrentWeaponVisible(int _ped, bool _visible, bool _deselectWeapon, bool _p3, bool _p4)
		{
			unsafe {
				if (fn__setPedCurrentWeaponVisible == null) fn__setPedCurrentWeaponVisible = (delegate* unmanaged[Cdecl]<int, bool, bool, bool, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedCurrentWeaponVisible");
				fn__setPedCurrentWeaponVisible(_ped, _visible, _deselectWeapon, _p3, _p4);
			}
		}

		public void SetPedDropsWeaponsWhenDead(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setPedDropsWeaponsWhenDead == null) fn__setPedDropsWeaponsWhenDead = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedDropsWeaponsWhenDead");
				fn__setPedDropsWeaponsWhenDead(_ped, _toggle);
			}
		}

		public bool HasPedBeenDamagedByWeapon(int _ped, int _weaponHash, int _weaponType)
		{
			unsafe {
				if (fn__hasPedBeenDamagedByWeapon == null) fn__hasPedBeenDamagedByWeapon = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasPedBeenDamagedByWeapon");
				var result = fn__hasPedBeenDamagedByWeapon(_ped, _weaponHash, _weaponType);
				return result;
			}
		}

		public void ClearPedLastWeaponDamage(int _ped)
		{
			unsafe {
				if (fn__clearPedLastWeaponDamage == null) fn__clearPedLastWeaponDamage = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPedLastWeaponDamage");
				fn__clearPedLastWeaponDamage(_ped);
			}
		}

		public bool HasEntityBeenDamagedByWeapon(int _entity, int _weaponHash, int _weaponType)
		{
			unsafe {
				if (fn__hasEntityBeenDamagedByWeapon == null) fn__hasEntityBeenDamagedByWeapon = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasEntityBeenDamagedByWeapon");
				var result = fn__hasEntityBeenDamagedByWeapon(_entity, _weaponHash, _weaponType);
				return result;
			}
		}

		public void ClearEntityLastWeaponDamage(int _entity)
		{
			unsafe {
				if (fn__clearEntityLastWeaponDamage == null) fn__clearEntityLastWeaponDamage = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearEntityLastWeaponDamage");
				fn__clearEntityLastWeaponDamage(_entity);
			}
		}

		public void SetPedDropsWeapon(int _ped)
		{
			unsafe {
				if (fn__setPedDropsWeapon == null) fn__setPedDropsWeapon = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_setPedDropsWeapon");
				fn__setPedDropsWeapon(_ped);
			}
		}

		public void SetPedDropsInventoryWeapon(int _ped, int _weaponHash, float _xOffset, float _yOffset, float _zOffset, int _ammoCount)
		{
			unsafe {
				if (fn__setPedDropsInventoryWeapon == null) fn__setPedDropsInventoryWeapon = (delegate* unmanaged[Cdecl]<int, int, float, float, float, int, void>) NativeLibrary.GetExport(handle, "Native_setPedDropsInventoryWeapon");
				fn__setPedDropsInventoryWeapon(_ped, _weaponHash, _xOffset, _yOffset, _zOffset, _ammoCount);
			}
		}

		public int GetMaxAmmoInClip(int _ped, int _weaponHash, bool _p2)
		{
			unsafe {
				if (fn__getMaxAmmoInClip == null) fn__getMaxAmmoInClip = (delegate* unmanaged[Cdecl]<int, int, bool, int>) NativeLibrary.GetExport(handle, "Native_getMaxAmmoInClip");
				var result = fn__getMaxAmmoInClip(_ped, _weaponHash, _p2);
				return result;
			}
		}

		public bool GetAmmoInClip(int _ped, int _weaponHash, ref int _ammo)
		{
			unsafe {
				if (fn__getAmmoInClip == null) fn__getAmmoInClip = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getAmmoInClip");
				var ref_ammo = _ammo;
				var result = fn__getAmmoInClip(_ped, _weaponHash, &ref_ammo);
				_ammo = ref_ammo;
				return result;
			}
		}

		public bool SetAmmoInClip(int _ped, int _weaponHash, int _ammo)
		{
			unsafe {
				if (fn__setAmmoInClip == null) fn__setAmmoInClip = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_setAmmoInClip");
				var result = fn__setAmmoInClip(_ped, _weaponHash, _ammo);
				return result;
			}
		}

		public bool GetMaxAmmo(int _ped, int _weaponHash, ref int _ammo)
		{
			unsafe {
				if (fn__getMaxAmmo == null) fn__getMaxAmmo = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getMaxAmmo");
				var ref_ammo = _ammo;
				var result = fn__getMaxAmmo(_ped, _weaponHash, &ref_ammo);
				_ammo = ref_ammo;
				return result;
			}
		}

		public bool GetMaxAmmoByType(int _ped, int _ammoTypeHash, ref int _ammo)
		{
			unsafe {
				if (fn__getMaxAmmoByType == null) fn__getMaxAmmoByType = (delegate* unmanaged[Cdecl]<int, int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getMaxAmmoByType");
				var ref_ammo = _ammo;
				var result = fn__getMaxAmmoByType(_ped, _ammoTypeHash, &ref_ammo);
				_ammo = ref_ammo;
				return result;
			}
		}

		public void AddAmmoToPedByType(int _ped, int _ammoTypeHash, int _ammo)
		{
			unsafe {
				if (fn__addAmmoToPedByType == null) fn__addAmmoToPedByType = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_addAmmoToPedByType");
				fn__addAmmoToPedByType(_ped, _ammoTypeHash, _ammo);
			}
		}

		public void SetPedAmmoByType(int _ped, int _ammoTypeHash, int _ammo)
		{
			unsafe {
				if (fn__setPedAmmoByType == null) fn__setPedAmmoByType = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedAmmoByType");
				fn__setPedAmmoByType(_ped, _ammoTypeHash, _ammo);
			}
		}

		public int GetPedAmmoByType(int _ped, int _ammoTypeHash)
		{
			unsafe {
				if (fn__getPedAmmoByType == null) fn__getPedAmmoByType = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedAmmoByType");
				var result = fn__getPedAmmoByType(_ped, _ammoTypeHash);
				return result;
			}
		}

		public void SetPedAmmoToDrop(int _ped, int _p1)
		{
			unsafe {
				if (fn__setPedAmmoToDrop == null) fn__setPedAmmoToDrop = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedAmmoToDrop");
				fn__setPedAmmoToDrop(_ped, _p1);
			}
		}

		public void SetPickupAmmoAmountScaler(float _p0)
		{
			unsafe {
				if (fn__setPickupAmmoAmountScaler == null) fn__setPickupAmmoAmountScaler = (delegate* unmanaged[Cdecl]<float, void>) NativeLibrary.GetExport(handle, "Native_setPickupAmmoAmountScaler");
				fn__setPickupAmmoAmountScaler(_p0);
			}
		}

		public int GetPedAmmoTypeFromWeapon(int _ped, int _weaponHash)
		{
			unsafe {
				if (fn__getPedAmmoTypeFromWeapon == null) fn__getPedAmmoTypeFromWeapon = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedAmmoTypeFromWeapon");
				var result = fn__getPedAmmoTypeFromWeapon(_ped, _weaponHash);
				return result;
			}
		}

		public int GetPedAmmoTypeFromWeapon2(int _ped, int _weaponHash)
		{
			unsafe {
				if (fn__getPedAmmoTypeFromWeapon2 == null) fn__getPedAmmoTypeFromWeapon2 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedAmmoTypeFromWeapon2");
				var result = fn__getPedAmmoTypeFromWeapon2(_ped, _weaponHash);
				return result;
			}
		}

		public bool GetPedLastWeaponImpactCoord(int _ped, ref Vector3 _coords)
		{
			unsafe {
				if (fn__getPedLastWeaponImpactCoord == null) fn__getPedLastWeaponImpactCoord = (delegate* unmanaged[Cdecl]<int, Vector3*, bool>) NativeLibrary.GetExport(handle, "Native_getPedLastWeaponImpactCoord");
				var ref_coords = _coords;
				var result = fn__getPedLastWeaponImpactCoord(_ped, &ref_coords);
				_coords = ref_coords;
				return result;
			}
		}

		public void SetPedGadget(int _ped, int _gadgetHash, bool _p2)
		{
			unsafe {
				if (fn__setPedGadget == null) fn__setPedGadget = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPedGadget");
				fn__setPedGadget(_ped, _gadgetHash, _p2);
			}
		}

		public bool GetIsPedGadgetEquipped(int _ped, int _gadgetHash)
		{
			unsafe {
				if (fn__getIsPedGadgetEquipped == null) fn__getIsPedGadgetEquipped = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_getIsPedGadgetEquipped");
				var result = fn__getIsPedGadgetEquipped(_ped, _gadgetHash);
				return result;
			}
		}

		public int GetSelectedPedWeapon(int _ped)
		{
			unsafe {
				if (fn__getSelectedPedWeapon == null) fn__getSelectedPedWeapon = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getSelectedPedWeapon");
				var result = fn__getSelectedPedWeapon(_ped);
				return result;
			}
		}

		public void ExplodeProjectiles(int _ped, int _weaponHash, bool _p2)
		{
			unsafe {
				if (fn__explodeProjectiles == null) fn__explodeProjectiles = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_explodeProjectiles");
				fn__explodeProjectiles(_ped, _weaponHash, _p2);
			}
		}

		public void RemoveAllProjectilesOfType(int _weaponHash, bool _explode)
		{
			unsafe {
				if (fn__removeAllProjectilesOfType == null) fn__removeAllProjectilesOfType = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_removeAllProjectilesOfType");
				fn__removeAllProjectilesOfType(_weaponHash, _explode);
			}
		}

		public float GetLockonDistanceOfCurrentPedWeapon(int _ped)
		{
			unsafe {
				if (fn__getLockonDistanceOfCurrentPedWeapon == null) fn__getLockonDistanceOfCurrentPedWeapon = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getLockonDistanceOfCurrentPedWeapon");
				var result = fn__getLockonDistanceOfCurrentPedWeapon(_ped);
				return result;
			}
		}

		public float GetMaxRangeOfCurrentPedWeapon(int _ped)
		{
			unsafe {
				if (fn__getMaxRangeOfCurrentPedWeapon == null) fn__getMaxRangeOfCurrentPedWeapon = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getMaxRangeOfCurrentPedWeapon");
				var result = fn__getMaxRangeOfCurrentPedWeapon(_ped);
				return result;
			}
		}

		public bool HasVehicleGotProjectileAttached(int _driver, int _vehicle, int _weaponHash, int _p3)
		{
			unsafe {
				if (fn__hasVehicleGotProjectileAttached == null) fn__hasVehicleGotProjectileAttached = (delegate* unmanaged[Cdecl]<int, int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasVehicleGotProjectileAttached");
				var result = fn__hasVehicleGotProjectileAttached(_driver, _vehicle, _weaponHash, _p3);
				return result;
			}
		}

		public void GiveWeaponComponentToPed(int _ped, int _weaponHash, int _componentHash)
		{
			unsafe {
				if (fn__giveWeaponComponentToPed == null) fn__giveWeaponComponentToPed = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_giveWeaponComponentToPed");
				fn__giveWeaponComponentToPed(_ped, _weaponHash, _componentHash);
			}
		}

		public void RemoveWeaponComponentFromPed(int _ped, int _weaponHash, int _componentHash)
		{
			unsafe {
				if (fn__removeWeaponComponentFromPed == null) fn__removeWeaponComponentFromPed = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_removeWeaponComponentFromPed");
				fn__removeWeaponComponentFromPed(_ped, _weaponHash, _componentHash);
			}
		}

		public bool HasPedGotWeaponComponent(int _ped, int _weaponHash, int _componentHash)
		{
			unsafe {
				if (fn__hasPedGotWeaponComponent == null) fn__hasPedGotWeaponComponent = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasPedGotWeaponComponent");
				var result = fn__hasPedGotWeaponComponent(_ped, _weaponHash, _componentHash);
				return result;
			}
		}

		public bool IsPedWeaponComponentActive(int _ped, int _weaponHash, int _componentHash)
		{
			unsafe {
				if (fn__isPedWeaponComponentActive == null) fn__isPedWeaponComponentActive = (delegate* unmanaged[Cdecl]<int, int, int, bool>) NativeLibrary.GetExport(handle, "Native_isPedWeaponComponentActive");
				var result = fn__isPedWeaponComponentActive(_ped, _weaponHash, _componentHash);
				return result;
			}
		}

		public bool RefillAmmoInstantly(int _ped)
		{
			unsafe {
				if (fn__refillAmmoInstantly == null) fn__refillAmmoInstantly = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_refillAmmoInstantly");
				var result = fn__refillAmmoInstantly(_ped);
				return result;
			}
		}

		public bool MakePedReload(int _ped)
		{
			unsafe {
				if (fn__makePedReload == null) fn__makePedReload = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_makePedReload");
				var result = fn__makePedReload(_ped);
				return result;
			}
		}

		public void RequestWeaponAsset(int _weaponHash, int _p1, int _p2)
		{
			unsafe {
				if (fn__requestWeaponAsset == null) fn__requestWeaponAsset = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_requestWeaponAsset");
				fn__requestWeaponAsset(_weaponHash, _p1, _p2);
			}
		}

		public bool HasWeaponAssetLoaded(int _weaponHash)
		{
			unsafe {
				if (fn__hasWeaponAssetLoaded == null) fn__hasWeaponAssetLoaded = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_hasWeaponAssetLoaded");
				var result = fn__hasWeaponAssetLoaded(_weaponHash);
				return result;
			}
		}

		public void RemoveWeaponAsset(int _weaponHash)
		{
			unsafe {
				if (fn__removeWeaponAsset == null) fn__removeWeaponAsset = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_removeWeaponAsset");
				fn__removeWeaponAsset(_weaponHash);
			}
		}

		public int CreateWeaponObject(int _weaponHash, int _ammoCount, float _x, float _y, float _z, bool _showWorldModel, float _scale, int _p7, int _p8, int _p9)
		{
			unsafe {
				if (fn__createWeaponObject == null) fn__createWeaponObject = (delegate* unmanaged[Cdecl]<int, int, float, float, float, bool, float, int, int, int, int>) NativeLibrary.GetExport(handle, "Native_createWeaponObject");
				var result = fn__createWeaponObject(_weaponHash, _ammoCount, _x, _y, _z, _showWorldModel, _scale, _p7, _p8, _p9);
				return result;
			}
		}

		public void GiveWeaponComponentToWeaponObject(int _weaponObject, int _addonHash)
		{
			unsafe {
				if (fn__giveWeaponComponentToWeaponObject == null) fn__giveWeaponComponentToWeaponObject = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_giveWeaponComponentToWeaponObject");
				fn__giveWeaponComponentToWeaponObject(_weaponObject, _addonHash);
			}
		}

		public void RemoveWeaponComponentFromWeaponObject(int _p0, int _p1)
		{
			unsafe {
				if (fn__removeWeaponComponentFromWeaponObject == null) fn__removeWeaponComponentFromWeaponObject = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_removeWeaponComponentFromWeaponObject");
				fn__removeWeaponComponentFromWeaponObject(_p0, _p1);
			}
		}

		public bool HasWeaponGotWeaponComponent(int _weapon, int _addonHash)
		{
			unsafe {
				if (fn__hasWeaponGotWeaponComponent == null) fn__hasWeaponGotWeaponComponent = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_hasWeaponGotWeaponComponent");
				var result = fn__hasWeaponGotWeaponComponent(_weapon, _addonHash);
				return result;
			}
		}

		public void GiveWeaponObjectToPed(int _weaponObject, int _ped)
		{
			unsafe {
				if (fn__giveWeaponObjectToPed == null) fn__giveWeaponObjectToPed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_giveWeaponObjectToPed");
				fn__giveWeaponObjectToPed(_weaponObject, _ped);
			}
		}

		public bool DoesWeaponTakeWeaponComponent(int _weaponHash, int _componentHash)
		{
			unsafe {
				if (fn__doesWeaponTakeWeaponComponent == null) fn__doesWeaponTakeWeaponComponent = (delegate* unmanaged[Cdecl]<int, int, bool>) NativeLibrary.GetExport(handle, "Native_doesWeaponTakeWeaponComponent");
				var result = fn__doesWeaponTakeWeaponComponent(_weaponHash, _componentHash);
				return result;
			}
		}

		public int GetWeaponObjectFromPed(int _ped, bool _p1)
		{
			unsafe {
				if (fn__getWeaponObjectFromPed == null) fn__getWeaponObjectFromPed = (delegate* unmanaged[Cdecl]<int, bool, int>) NativeLibrary.GetExport(handle, "Native_getWeaponObjectFromPed");
				var result = fn__getWeaponObjectFromPed(_ped, _p1);
				return result;
			}
		}

		public void GiveLoadoutToPed(int _ped, int _loadoutHash)
		{
			unsafe {
				if (fn__giveLoadoutToPed == null) fn__giveLoadoutToPed = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_giveLoadoutToPed");
				fn__giveLoadoutToPed(_ped, _loadoutHash);
			}
		}

		public void SetPedWeaponTintIndex(int _ped, int _weaponHash, int _tintIndex)
		{
			unsafe {
				if (fn__setPedWeaponTintIndex == null) fn__setPedWeaponTintIndex = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedWeaponTintIndex");
				fn__setPedWeaponTintIndex(_ped, _weaponHash, _tintIndex);
			}
		}

		public int GetPedWeaponTintIndex(int _ped, int _weaponHash)
		{
			unsafe {
				if (fn__getPedWeaponTintIndex == null) fn__getPedWeaponTintIndex = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedWeaponTintIndex");
				var result = fn__getPedWeaponTintIndex(_ped, _weaponHash);
				return result;
			}
		}

		public void SetWeaponObjectTintIndex(int _weapon, int _tintIndex)
		{
			unsafe {
				if (fn__setWeaponObjectTintIndex == null) fn__setWeaponObjectTintIndex = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setWeaponObjectTintIndex");
				fn__setWeaponObjectTintIndex(_weapon, _tintIndex);
			}
		}

		public int GetWeaponObjectTintIndex(int _weapon)
		{
			unsafe {
				if (fn__getWeaponObjectTintIndex == null) fn__getWeaponObjectTintIndex = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeaponObjectTintIndex");
				var result = fn__getWeaponObjectTintIndex(_weapon);
				return result;
			}
		}

		public int GetWeaponTintCount(int _weaponHash)
		{
			unsafe {
				if (fn__getWeaponTintCount == null) fn__getWeaponTintCount = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeaponTintCount");
				var result = fn__getWeaponTintCount(_weaponHash);
				return result;
			}
		}

		public void SetPedWeaponLiveryColor(int _ped, int _weaponHash, int _camoComponentHash, int _colorIndex)
		{
			unsafe {
				if (fn__setPedWeaponLiveryColor == null) fn__setPedWeaponLiveryColor = (delegate* unmanaged[Cdecl]<int, int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setPedWeaponLiveryColor");
				fn__setPedWeaponLiveryColor(_ped, _weaponHash, _camoComponentHash, _colorIndex);
			}
		}

		public int GetPedWeaponLiveryColor(int _ped, int _weaponHash, int _camoComponentHash)
		{
			unsafe {
				if (fn__getPedWeaponLiveryColor == null) fn__getPedWeaponLiveryColor = (delegate* unmanaged[Cdecl]<int, int, int, int>) NativeLibrary.GetExport(handle, "Native_getPedWeaponLiveryColor");
				var result = fn__getPedWeaponLiveryColor(_ped, _weaponHash, _camoComponentHash);
				return result;
			}
		}

		public void SetWeaponObjectLiveryColor(int _weaponObject, int _camoComponentHash, int _colorIndex)
		{
			unsafe {
				if (fn__setWeaponObjectLiveryColor == null) fn__setWeaponObjectLiveryColor = (delegate* unmanaged[Cdecl]<int, int, int, void>) NativeLibrary.GetExport(handle, "Native_setWeaponObjectLiveryColor");
				fn__setWeaponObjectLiveryColor(_weaponObject, _camoComponentHash, _colorIndex);
			}
		}

		public int GetWeaponObjectLiveryColor(int _weaponObject, int _camoComponentHash)
		{
			unsafe {
				if (fn__getWeaponObjectLiveryColor == null) fn__getWeaponObjectLiveryColor = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native_getWeaponObjectLiveryColor");
				var result = fn__getWeaponObjectLiveryColor(_weaponObject, _camoComponentHash);
				return result;
			}
		}

		public int _0xA2C9AC24B4061285(int _ped, int _weaponHash)
		{
			unsafe {
				if (fn__0xA2C9AC24B4061285 == null) fn__0xA2C9AC24B4061285 = (delegate* unmanaged[Cdecl]<int, int, int>) NativeLibrary.GetExport(handle, "Native__0xA2C9AC24B4061285");
				var result = fn__0xA2C9AC24B4061285(_ped, _weaponHash);
				return result;
			}
		}

		public void _0x977CA98939E82E4B(int _weaponObject, int _p1)
		{
			unsafe {
				if (fn__0x977CA98939E82E4B == null) fn__0x977CA98939E82E4B = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0x977CA98939E82E4B");
				fn__0x977CA98939E82E4B(_weaponObject, _p1);
			}
		}

		public bool GetWeaponHudStats(int _weaponHash, ref int _outData)
		{
			unsafe {
				if (fn__getWeaponHudStats == null) fn__getWeaponHudStats = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getWeaponHudStats");
				var ref_outData = _outData;
				var result = fn__getWeaponHudStats(_weaponHash, &ref_outData);
				_outData = ref_outData;
				return result;
			}
		}

		public bool GetWeaponComponentHudStats(int _componentHash, ref int _outData)
		{
			unsafe {
				if (fn__getWeaponComponentHudStats == null) fn__getWeaponComponentHudStats = (delegate* unmanaged[Cdecl]<int, int*, bool>) NativeLibrary.GetExport(handle, "Native_getWeaponComponentHudStats");
				var ref_outData = _outData;
				var result = fn__getWeaponComponentHudStats(_componentHash, &ref_outData);
				_outData = ref_outData;
				return result;
			}
		}

		public float GetWeaponDamage(int _weaponHash, int _componentHash)
		{
			unsafe {
				if (fn__getWeaponDamage == null) fn__getWeaponDamage = (delegate* unmanaged[Cdecl]<int, int, float>) NativeLibrary.GetExport(handle, "Native_getWeaponDamage");
				var result = fn__getWeaponDamage(_weaponHash, _componentHash);
				return result;
			}
		}

		public int GetWeaponClipSize(int _weaponHash)
		{
			unsafe {
				if (fn__getWeaponClipSize == null) fn__getWeaponClipSize = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeaponClipSize");
				var result = fn__getWeaponClipSize(_weaponHash);
				return result;
			}
		}

		public float GetWeaponTimeBetweenShots(int _weaponHash)
		{
			unsafe {
				if (fn__getWeaponTimeBetweenShots == null) fn__getWeaponTimeBetweenShots = (delegate* unmanaged[Cdecl]<int, float>) NativeLibrary.GetExport(handle, "Native_getWeaponTimeBetweenShots");
				var result = fn__getWeaponTimeBetweenShots(_weaponHash);
				return result;
			}
		}

		public void SetPedChanceOfFiringBlanks(int _ped, float _xBias, float _yBias)
		{
			unsafe {
				if (fn__setPedChanceOfFiringBlanks == null) fn__setPedChanceOfFiringBlanks = (delegate* unmanaged[Cdecl]<int, float, float, void>) NativeLibrary.GetExport(handle, "Native_setPedChanceOfFiringBlanks");
				fn__setPedChanceOfFiringBlanks(_ped, _xBias, _yBias);
			}
		}

		public int SetPedShootOrdnanceWeapon(int _ped, float _p1)
		{
			unsafe {
				if (fn__setPedShootOrdnanceWeapon == null) fn__setPedShootOrdnanceWeapon = (delegate* unmanaged[Cdecl]<int, float, int>) NativeLibrary.GetExport(handle, "Native_setPedShootOrdnanceWeapon");
				var result = fn__setPedShootOrdnanceWeapon(_ped, _p1);
				return result;
			}
		}

		public void RequestWeaponHighDetailModel(int _weaponObject)
		{
			unsafe {
				if (fn__requestWeaponHighDetailModel == null) fn__requestWeaponHighDetailModel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_requestWeaponHighDetailModel");
				fn__requestWeaponHighDetailModel(_weaponObject);
			}
		}

		public void SetWeaponDamageModifierThisFrame(int _weaponHash, float _damageMultiplier)
		{
			unsafe {
				if (fn__setWeaponDamageModifierThisFrame == null) fn__setWeaponDamageModifierThisFrame = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setWeaponDamageModifierThisFrame");
				fn__setWeaponDamageModifierThisFrame(_weaponHash, _damageMultiplier);
			}
		}

		public void SetWeaponExplosionRadiusMultiplier(int _weaponHash, float _multiplier)
		{
			unsafe {
				if (fn__setWeaponExplosionRadiusMultiplier == null) fn__setWeaponExplosionRadiusMultiplier = (delegate* unmanaged[Cdecl]<int, float, void>) NativeLibrary.GetExport(handle, "Native_setWeaponExplosionRadiusMultiplier");
				fn__setWeaponExplosionRadiusMultiplier(_weaponHash, _multiplier);
			}
		}

		public void _0xE6D2CEDD370FF98E(int _p0, int _p1)
		{
			unsafe {
				if (fn__0xE6D2CEDD370FF98E == null) fn__0xE6D2CEDD370FF98E = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native__0xE6D2CEDD370FF98E");
				fn__0xE6D2CEDD370FF98E(_p0, _p1);
			}
		}

		public bool IsPedCurrentWeaponSilenced(int _ped)
		{
			unsafe {
				if (fn__isPedCurrentWeaponSilenced == null) fn__isPedCurrentWeaponSilenced = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isPedCurrentWeaponSilenced");
				var result = fn__isPedCurrentWeaponSilenced(_ped);
				return result;
			}
		}

		public bool IsFlashLightOn(int _ped)
		{
			unsafe {
				if (fn__isFlashLightOn == null) fn__isFlashLightOn = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_isFlashLightOn");
				var result = fn__isFlashLightOn(_ped);
				return result;
			}
		}

		public int SetFlashLightFadeDistance(float _distance)
		{
			unsafe {
				if (fn__setFlashLightFadeDistance == null) fn__setFlashLightFadeDistance = (delegate* unmanaged[Cdecl]<float, int>) NativeLibrary.GetExport(handle, "Native_setFlashLightFadeDistance");
				var result = fn__setFlashLightFadeDistance(_distance);
				return result;
			}
		}

		public void SetFlashLightEnabled(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setFlashLightEnabled == null) fn__setFlashLightEnabled = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setFlashLightEnabled");
				fn__setFlashLightEnabled(_ped, _toggle);
			}
		}

		public void SetWeaponAnimationOverride(int _ped, int _animStyle)
		{
			unsafe {
				if (fn__setWeaponAnimationOverride == null) fn__setWeaponAnimationOverride = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_setWeaponAnimationOverride");
				fn__setWeaponAnimationOverride(_ped, _animStyle);
			}
		}

		public int GetWeaponDamageType(int _weaponHash)
		{
			unsafe {
				if (fn__getWeaponDamageType == null) fn__getWeaponDamageType = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getWeaponDamageType");
				var result = fn__getWeaponDamageType(_weaponHash);
				return result;
			}
		}

		public void _0xE4DCEC7FD5B739A5(int _ped)
		{
			unsafe {
				if (fn__0xE4DCEC7FD5B739A5 == null) fn__0xE4DCEC7FD5B739A5 = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native__0xE4DCEC7FD5B739A5");
				fn__0xE4DCEC7FD5B739A5(_ped);
			}
		}

		public bool CanUseWeaponOnParachute(int _weaponHash)
		{
			unsafe {
				if (fn__canUseWeaponOnParachute == null) fn__canUseWeaponOnParachute = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_canUseWeaponOnParachute");
				var result = fn__canUseWeaponOnParachute(_weaponHash);
				return result;
			}
		}

		public int CreateAirDefenseSphere(float _x, float _y, float _z, float _radius, float _p4, float _p5, float _p6, int _weaponHash)
		{
			unsafe {
				if (fn__createAirDefenseSphere == null) fn__createAirDefenseSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, int, int>) NativeLibrary.GetExport(handle, "Native_createAirDefenseSphere");
				var result = fn__createAirDefenseSphere(_x, _y, _z, _radius, _p4, _p5, _p6, _weaponHash);
				return result;
			}
		}

		public int CreateAirDefenseArea(float _p0, float _p1, float _p2, float _p3, float _p4, float _p5, float _p6, float _p7, float _p8, float _p9, int _weaponHash)
		{
			unsafe {
				if (fn__createAirDefenseArea == null) fn__createAirDefenseArea = (delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, float, float, int, int>) NativeLibrary.GetExport(handle, "Native_createAirDefenseArea");
				var result = fn__createAirDefenseArea(_p0, _p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9, _weaponHash);
				return result;
			}
		}

		public bool RemoveAirDefenseZone(int _zoneId)
		{
			unsafe {
				if (fn__removeAirDefenseZone == null) fn__removeAirDefenseZone = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_removeAirDefenseZone");
				var result = fn__removeAirDefenseZone(_zoneId);
				return result;
			}
		}

		public void RemoveAllAirDefenseZones()
		{
			unsafe {
				if (fn__removeAllAirDefenseZones == null) fn__removeAllAirDefenseZones = (delegate* unmanaged[Cdecl]<void>) NativeLibrary.GetExport(handle, "Native_removeAllAirDefenseZones");
				fn__removeAllAirDefenseZones();
			}
		}

		public void SetPlayerAirDefenseZoneFlag(int _player, int _zoneId, bool _enable)
		{
			unsafe {
				if (fn__setPlayerAirDefenseZoneFlag == null) fn__setPlayerAirDefenseZoneFlag = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setPlayerAirDefenseZoneFlag");
				fn__setPlayerAirDefenseZoneFlag(_player, _zoneId, _enable);
			}
		}

		public bool IsAnyAirDefenseZoneInsideSphere(float _x, float _y, float _z, float _radius, ref int _outZoneId)
		{
			unsafe {
				if (fn__isAnyAirDefenseZoneInsideSphere == null) fn__isAnyAirDefenseZoneInsideSphere = (delegate* unmanaged[Cdecl]<float, float, float, float, int*, bool>) NativeLibrary.GetExport(handle, "Native_isAnyAirDefenseZoneInsideSphere");
				var ref_outZoneId = _outZoneId;
				var result = fn__isAnyAirDefenseZoneInsideSphere(_x, _y, _z, _radius, &ref_outZoneId);
				_outZoneId = ref_outZoneId;
				return result;
			}
		}

		public void FireAirDefenseWeapon(int _zoneId, float _x, float _y, float _z)
		{
			unsafe {
				if (fn__fireAirDefenseWeapon == null) fn__fireAirDefenseWeapon = (delegate* unmanaged[Cdecl]<int, float, float, float, void>) NativeLibrary.GetExport(handle, "Native_fireAirDefenseWeapon");
				fn__fireAirDefenseWeapon(_zoneId, _x, _y, _z);
			}
		}

		public bool DoesAirDefenseZoneExist(int _zoneId)
		{
			unsafe {
				if (fn__doesAirDefenseZoneExist == null) fn__doesAirDefenseZoneExist = (delegate* unmanaged[Cdecl]<int, bool>) NativeLibrary.GetExport(handle, "Native_doesAirDefenseZoneExist");
				var result = fn__doesAirDefenseZoneExist(_zoneId);
				return result;
			}
		}

		public void SetCanPedEquipWeapon(int _ped, int _weaponHash, bool _toggle)
		{
			unsafe {
				if (fn__setCanPedEquipWeapon == null) fn__setCanPedEquipWeapon = (delegate* unmanaged[Cdecl]<int, int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCanPedEquipWeapon");
				fn__setCanPedEquipWeapon(_ped, _weaponHash, _toggle);
			}
		}

		public void SetCanPedEquipAllWeapons(int _ped, bool _toggle)
		{
			unsafe {
				if (fn__setCanPedEquipAllWeapons == null) fn__setCanPedEquipAllWeapons = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setCanPedEquipAllWeapons");
				fn__setCanPedEquipAllWeapons(_ped, _toggle);
			}
		}

		public int GetZoneAtCoords(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__getZoneAtCoords == null) fn__getZoneAtCoords = (delegate* unmanaged[Cdecl]<float, float, float, int>) NativeLibrary.GetExport(handle, "Native_getZoneAtCoords");
				var result = fn__getZoneAtCoords(_x, _y, _z);
				return result;
			}
		}

		public int GetZoneFromNameId(string _zoneName)
		{
			unsafe {
				if (fn__getZoneFromNameId == null) fn__getZoneFromNameId = (delegate* unmanaged[Cdecl]<nint, int>) NativeLibrary.GetExport(handle, "Native_getZoneFromNameId");
				var ptr_zoneName = MemoryUtils.StringToHGlobalUtf8(_zoneName);
				var result = fn__getZoneFromNameId(ptr_zoneName);
				Marshal.FreeHGlobal(ptr_zoneName);
				return result;
			}
		}

		public int GetZonePopschedule(int _zoneId)
		{
			unsafe {
				if (fn__getZonePopschedule == null) fn__getZonePopschedule = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getZonePopschedule");
				var result = fn__getZonePopschedule(_zoneId);
				return result;
			}
		}

		public string GetNameOfZone(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__getNameOfZone == null) fn__getNameOfZone = (delegate* unmanaged[Cdecl]<float, float, float, nint>) NativeLibrary.GetExport(handle, "Native_getNameOfZone");
				var result = fn__getNameOfZone(_x, _y, _z);
				return Marshal.PtrToStringUTF8(result);
			}
		}

		public void SetZoneEnabled(int _zoneId, bool _toggle)
		{
			unsafe {
				if (fn__setZoneEnabled == null) fn__setZoneEnabled = (delegate* unmanaged[Cdecl]<int, bool, void>) NativeLibrary.GetExport(handle, "Native_setZoneEnabled");
				fn__setZoneEnabled(_zoneId, _toggle);
			}
		}

		public int GetZoneScumminess(int _zoneId)
		{
			unsafe {
				if (fn__getZoneScumminess == null) fn__getZoneScumminess = (delegate* unmanaged[Cdecl]<int, int>) NativeLibrary.GetExport(handle, "Native_getZoneScumminess");
				var result = fn__getZoneScumminess(_zoneId);
				return result;
			}
		}

		public void OverridePopscheduleVehicleModel(int _scheduleId, int _vehicleHash)
		{
			unsafe {
				if (fn__overridePopscheduleVehicleModel == null) fn__overridePopscheduleVehicleModel = (delegate* unmanaged[Cdecl]<int, int, void>) NativeLibrary.GetExport(handle, "Native_overridePopscheduleVehicleModel");
				fn__overridePopscheduleVehicleModel(_scheduleId, _vehicleHash);
			}
		}

		public void ClearPopscheduleOverrideVehicleModel(int _scheduleId)
		{
			unsafe {
				if (fn__clearPopscheduleOverrideVehicleModel == null) fn__clearPopscheduleOverrideVehicleModel = (delegate* unmanaged[Cdecl]<int, void>) NativeLibrary.GetExport(handle, "Native_clearPopscheduleOverrideVehicleModel");
				fn__clearPopscheduleOverrideVehicleModel(_scheduleId);
			}
		}

		public int GetHashOfMapAreaAtCoords(float _x, float _y, float _z)
		{
			unsafe {
				if (fn__getHashOfMapAreaAtCoords == null) fn__getHashOfMapAreaAtCoords = (delegate* unmanaged[Cdecl]<float, float, float, int>) NativeLibrary.GetExport(handle, "Native_getHashOfMapAreaAtCoords");
				var result = fn__getHashOfMapAreaAtCoords(_x, _y, _z);
				return result;
			}
		}

	}
}
